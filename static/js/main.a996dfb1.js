/*! For license information please see main.a996dfb1.js.LICENSE.txt */
( () => {
    var __webpack_modules__ = {
        8603: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => ie
            });
            var r = function() {
                function e(e) {
                    var t = this;
                    this._insertTag = function(e) {
                        var n;
                        n = 0 === t.tags.length ? t.insertionPoint ? t.insertionPoint.nextSibling : t.prepend ? t.container.firstChild : t.before : t.tags[t.tags.length - 1].nextSibling,
                        t.container.insertBefore(e, n),
                        t.tags.push(e)
                    }
                    ,
                    this.isSpeedy = void 0 === e.speedy || e.speedy,
                    this.tags = [],
                    this.ctr = 0,
                    this.nonce = e.nonce,
                    this.key = e.key,
                    this.container = e.container,
                    this.prepend = e.prepend,
                    this.insertionPoint = e.insertionPoint,
                    this.before = null
                }
                var t = e.prototype;
                return t.hydrate = function(e) {
                    e.forEach(this._insertTag)
                }
                ,
                t.insert = function(e) {
                    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(function(e) {
                        var t = document.createElement("style");
                        return t.setAttribute("data-emotion", e.key),
                        void 0 !== e.nonce && t.setAttribute("nonce", e.nonce),
                        t.appendChild(document.createTextNode("")),
                        t.setAttribute("data-s", ""),
                        t
                    }(this));
                    var t = this.tags[this.tags.length - 1];
                    if (this.isSpeedy) {
                        var n = function(e) {
                            if (e.sheet)
                                return e.sheet;
                            for (var t = 0; t < document.styleSheets.length; t++)
                                if (document.styleSheets[t].ownerNode === e)
                                    return document.styleSheets[t]
                        }(t);
                        try {
                            n.insertRule(e, n.cssRules.length)
                        } catch (r) {}
                    } else
                        t.appendChild(document.createTextNode(e));
                    this.ctr++
                }
                ,
                t.flush = function() {
                    this.tags.forEach((function(e) {
                        var t;
                        return null == (t = e.parentNode) ? void 0 : t.removeChild(e)
                    }
                    )),
                    this.tags = [],
                    this.ctr = 0
                }
                ,
                e
            }()
              , i = Math.abs
              , o = String.fromCharCode
              , a = Object.assign;
            function s(e) {
                return e.trim()
            }
            function l(e, t, n) {
                return e.replace(t, n)
            }
            function c(e, t) {
                return e.indexOf(t)
            }
            function u(e, t) {
                return 0 | e.charCodeAt(t)
            }
            function d(e, t, n) {
                return e.slice(t, n)
            }
            function h(e) {
                return e.length
            }
            function p(e) {
                return e.length
            }
            function f(e, t) {
                return t.push(e),
                e
            }
            var m = 1
              , g = 1
              , v = 0
              , y = 0
              , b = 0
              , _ = "";
            function A(e, t, n, r, i, o, a) {
                return {
                    value: e,
                    root: t,
                    parent: n,
                    type: r,
                    props: i,
                    children: o,
                    line: m,
                    column: g,
                    length: a,
                    return: ""
                }
            }
            function x(e, t) {
                return a(A("", null, null, "", null, null, 0), e, {
                    length: -e.length
                }, t)
            }
            function S() {
                return b = y > 0 ? u(_, --y) : 0,
                g--,
                10 === b && (g = 1,
                m--),
                b
            }
            function w() {
                return b = y < v ? u(_, y++) : 0,
                g++,
                10 === b && (g = 1,
                m++),
                b
            }
            function E() {
                return u(_, y)
            }
            function M() {
                return y
            }
            function C(e, t) {
                return d(_, e, t)
            }
            function T(e) {
                switch (e) {
                case 0:
                case 9:
                case 10:
                case 13:
                case 32:
                    return 5;
                case 33:
                case 43:
                case 44:
                case 47:
                case 62:
                case 64:
                case 126:
                case 59:
                case 123:
                case 125:
                    return 4;
                case 58:
                    return 3;
                case 34:
                case 39:
                case 40:
                case 91:
                    return 2;
                case 41:
                case 93:
                    return 1
                }
                return 0
            }
            function R(e) {
                return m = g = 1,
                v = h(_ = e),
                y = 0,
                []
            }
            function P(e) {
                return _ = "",
                e
            }
            function B(e) {
                return s(C(y - 1, k(91 === e ? e + 2 : 40 === e ? e + 1 : e)))
            }
            function I(e) {
                for (; (b = E()) && b < 33; )
                    w();
                return T(e) > 2 || T(b) > 3 ? "" : " "
            }
            function L(e, t) {
                for (; --t && w() && !(b < 48 || b > 102 || b > 57 && b < 65 || b > 70 && b < 97); )
                    ;
                return C(e, M() + (t < 6 && 32 == E() && 32 == w()))
            }
            function k(e) {
                for (; w(); )
                    switch (b) {
                    case e:
                        return y;
                    case 34:
                    case 39:
                        34 !== e && 39 !== e && k(b);
                        break;
                    case 40:
                        41 === e && k(e);
                        break;
                    case 92:
                        w()
                    }
                return y
            }
            function D(e, t) {
                for (; w() && e + b !== 57 && (e + b !== 84 || 47 !== E()); )
                    ;
                return "/*" + C(t, y - 1) + "*" + o(47 === e ? e : w())
            }
            function O(e) {
                for (; !T(E()); )
                    w();
                return C(e, y)
            }
            var N = "-ms-"
              , F = "-moz-"
              , U = "-webkit-"
              , z = "comm"
              , G = "rule"
              , H = "decl"
              , j = "@keyframes";
            function W(e, t) {
                for (var n = "", r = p(e), i = 0; i < r; i++)
                    n += t(e[i], i, e, t) || "";
                return n
            }
            function V(e, t, n, r) {
                switch (e.type) {
                case "@layer":
                    if (e.children.length)
                        break;
                case "@import":
                case H:
                    return e.return = e.return || e.value;
                case z:
                    return "";
                case j:
                    return e.return = e.value + "{" + W(e.children, r) + "}";
                case G:
                    e.value = e.props.join(",")
                }
                return h(n = W(e.children, r)) ? e.return = e.value + "{" + n + "}" : ""
            }
            function X(e) {
                return P(J("", null, null, null, [""], e = R(e), 0, [0], e))
            }
            function J(e, t, n, r, i, a, s, d, p) {
                for (var m = 0, g = 0, v = s, y = 0, b = 0, _ = 0, A = 1, x = 1, C = 1, T = 0, R = "", P = i, k = a, N = r, F = R; x; )
                    switch (_ = T,
                    T = w()) {
                    case 40:
                        if (108 != _ && 58 == u(F, v - 1)) {
                            -1 != c(F += l(B(T), "&", "&\f"), "&\f") && (C = -1);
                            break
                        }
                    case 34:
                    case 39:
                    case 91:
                        F += B(T);
                        break;
                    case 9:
                    case 10:
                    case 13:
                    case 32:
                        F += I(_);
                        break;
                    case 92:
                        F += L(M() - 1, 7);
                        continue;
                    case 47:
                        switch (E()) {
                        case 42:
                        case 47:
                            f(q(D(w(), M()), t, n), p);
                            break;
                        default:
                            F += "/"
                        }
                        break;
                    case 123 * A:
                        d[m++] = h(F) * C;
                    case 125 * A:
                    case 59:
                    case 0:
                        switch (T) {
                        case 0:
                        case 125:
                            x = 0;
                        case 59 + g:
                            -1 == C && (F = l(F, /\f/g, "")),
                            b > 0 && h(F) - v && f(b > 32 ? Y(F + ";", r, n, v - 1) : Y(l(F, " ", "") + ";", r, n, v - 2), p);
                            break;
                        case 59:
                            F += ";";
                        default:
                            if (f(N = K(F, t, n, m, g, i, d, R, P = [], k = [], v), a),
                            123 === T)
                                if (0 === g)
                                    J(F, t, N, N, P, a, v, d, k);
                                else
                                    switch (99 === y && 110 === u(F, 3) ? 100 : y) {
                                    case 100:
                                    case 108:
                                    case 109:
                                    case 115:
                                        J(e, N, N, r && f(K(e, N, N, 0, 0, i, d, R, i, P = [], v), k), i, k, v, d, r ? P : k);
                                        break;
                                    default:
                                        J(F, N, N, N, [""], k, 0, d, k)
                                    }
                        }
                        m = g = b = 0,
                        A = C = 1,
                        R = F = "",
                        v = s;
                        break;
                    case 58:
                        v = 1 + h(F),
                        b = _;
                    default:
                        if (A < 1)
                            if (123 == T)
                                --A;
                            else if (125 == T && 0 == A++ && 125 == S())
                                continue;
                        switch (F += o(T),
                        T * A) {
                        case 38:
                            C = g > 0 ? 1 : (F += "\f",
                            -1);
                            break;
                        case 44:
                            d[m++] = (h(F) - 1) * C,
                            C = 1;
                            break;
                        case 64:
                            45 === E() && (F += B(w())),
                            y = E(),
                            g = v = h(R = F += O(M())),
                            T++;
                            break;
                        case 45:
                            45 === _ && 2 == h(F) && (A = 0)
                        }
                    }
                return a
            }
            function K(e, t, n, r, o, a, c, u, h, f, m) {
                for (var g = o - 1, v = 0 === o ? a : [""], y = p(v), b = 0, _ = 0, x = 0; b < r; ++b)
                    for (var S = 0, w = d(e, g + 1, g = i(_ = c[b])), E = e; S < y; ++S)
                        (E = s(_ > 0 ? v[S] + " " + w : l(w, /&\f/g, v[S]))) && (h[x++] = E);
                return A(e, t, n, 0 === o ? G : u, h, f, m)
            }
            function q(e, t, n) {
                return A(e, t, n, z, o(b), d(e, 2, -2), 0)
            }
            function Y(e, t, n, r) {
                return A(e, t, n, H, d(e, 0, r), d(e, r + 1, -1), r)
            }
            var Q = function(e, t, n) {
                for (var r = 0, i = 0; r = i,
                i = E(),
                38 === r && 12 === i && (t[n] = 1),
                !T(i); )
                    w();
                return C(e, y)
            }
              , Z = function(e, t) {
                return P(function(e, t) {
                    var n = -1
                      , r = 44;
                    do {
                        switch (T(r)) {
                        case 0:
                            38 === r && 12 === E() && (t[n] = 1),
                            e[n] += Q(y - 1, t, n);
                            break;
                        case 2:
                            e[n] += B(r);
                            break;
                        case 4:
                            if (44 === r) {
                                e[++n] = 58 === E() ? "&\f" : "",
                                t[n] = e[n].length;
                                break
                            }
                        default:
                            e[n] += o(r)
                        }
                    } while (r = w());
                    return e
                }(R(e), t))
            }
              , $ = new WeakMap
              , ee = function(e) {
                if ("rule" === e.type && e.parent && !(e.length < 1)) {
                    for (var t = e.value, n = e.parent, r = e.column === n.column && e.line === n.line; "rule" !== n.type; )
                        if (!(n = n.parent))
                            return;
                    if ((1 !== e.props.length || 58 === t.charCodeAt(0) || $.get(n)) && !r) {
                        $.set(e, !0);
                        for (var i = [], o = Z(t, i), a = n.props, s = 0, l = 0; s < o.length; s++)
                            for (var c = 0; c < a.length; c++,
                            l++)
                                e.props[l] = i[s] ? o[s].replace(/&\f/g, a[c]) : a[c] + " " + o[s]
                    }
                }
            }
              , te = function(e) {
                if ("decl" === e.type) {
                    var t = e.value;
                    108 === t.charCodeAt(0) && 98 === t.charCodeAt(2) && (e.return = "",
                    e.value = "")
                }
            };
            function ne(e, t) {
                switch (function(e, t) {
                    return 45 ^ u(e, 0) ? (((t << 2 ^ u(e, 0)) << 2 ^ u(e, 1)) << 2 ^ u(e, 2)) << 2 ^ u(e, 3) : 0
                }(e, t)) {
                case 5103:
                    return U + "print-" + e + e;
                case 5737:
                case 4201:
                case 3177:
                case 3433:
                case 1641:
                case 4457:
                case 2921:
                case 5572:
                case 6356:
                case 5844:
                case 3191:
                case 6645:
                case 3005:
                case 6391:
                case 5879:
                case 5623:
                case 6135:
                case 4599:
                case 4855:
                case 4215:
                case 6389:
                case 5109:
                case 5365:
                case 5621:
                case 3829:
                    return U + e + e;
                case 5349:
                case 4246:
                case 4810:
                case 6968:
                case 2756:
                    return U + e + F + e + N + e + e;
                case 6828:
                case 4268:
                    return U + e + N + e + e;
                case 6165:
                    return U + e + N + "flex-" + e + e;
                case 5187:
                    return U + e + l(e, /(\w+).+(:[^]+)/, U + "box-$1$2" + N + "flex-$1$2") + e;
                case 5443:
                    return U + e + N + "flex-item-" + l(e, /flex-|-self/, "") + e;
                case 4675:
                    return U + e + N + "flex-line-pack" + l(e, /align-content|flex-|-self/, "") + e;
                case 5548:
                    return U + e + N + l(e, "shrink", "negative") + e;
                case 5292:
                    return U + e + N + l(e, "basis", "preferred-size") + e;
                case 6060:
                    return U + "box-" + l(e, "-grow", "") + U + e + N + l(e, "grow", "positive") + e;
                case 4554:
                    return U + l(e, /([^-])(transform)/g, "$1" + U + "$2") + e;
                case 6187:
                    return l(l(l(e, /(zoom-|grab)/, U + "$1"), /(image-set)/, U + "$1"), e, "") + e;
                case 5495:
                case 3959:
                    return l(e, /(image-set\([^]*)/, U + "$1$`$1");
                case 4968:
                    return l(l(e, /(.+:)(flex-)?(.*)/, U + "box-pack:$3" + N + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + U + e + e;
                case 4095:
                case 3583:
                case 4068:
                case 2532:
                    return l(e, /(.+)-inline(.+)/, U + "$1$2") + e;
                case 8116:
                case 7059:
                case 5753:
                case 5535:
                case 5445:
                case 5701:
                case 4933:
                case 4677:
                case 5533:
                case 5789:
                case 5021:
                case 4765:
                    if (h(e) - 1 - t > 6)
                        switch (u(e, t + 1)) {
                        case 109:
                            if (45 !== u(e, t + 4))
                                break;
                        case 102:
                            return l(e, /(.+:)(.+)-([^]+)/, "$1" + U + "$2-$3$1" + F + (108 == u(e, t + 3) ? "$3" : "$2-$3")) + e;
                        case 115:
                            return ~c(e, "stretch") ? ne(l(e, "stretch", "fill-available"), t) + e : e
                        }
                    break;
                case 4949:
                    if (115 !== u(e, t + 1))
                        break;
                case 6444:
                    switch (u(e, h(e) - 3 - (~c(e, "!important") && 10))) {
                    case 107:
                        return l(e, ":", ":" + U) + e;
                    case 101:
                        return l(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + U + (45 === u(e, 14) ? "inline-" : "") + "box$3$1" + U + "$2$3$1" + N + "$2box$3") + e
                    }
                    break;
                case 5936:
                    switch (u(e, t + 11)) {
                    case 114:
                        return U + e + N + l(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
                    case 108:
                        return U + e + N + l(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
                    case 45:
                        return U + e + N + l(e, /[svh]\w+-[tblr]{2}/, "lr") + e
                    }
                    return U + e + N + e + e
                }
                return e
            }
            var re = [function(e, t, n, r) {
                if (e.length > -1 && !e.return)
                    switch (e.type) {
                    case H:
                        e.return = ne(e.value, e.length);
                        break;
                    case j:
                        return W([x(e, {
                            value: l(e.value, "@", "@" + U)
                        })], r);
                    case G:
                        if (e.length)
                            return function(e, t) {
                                return e.map(t).join("")
                            }(e.props, (function(t) {
                                switch (function(e, t) {
                                    return (e = t.exec(e)) ? e[0] : e
                                }(t, /(::plac\w+|:read-\w+)/)) {
                                case ":read-only":
                                case ":read-write":
                                    return W([x(e, {
                                        props: [l(t, /:(read-\w+)/, ":-moz-$1")]
                                    })], r);
                                case "::placeholder":
                                    return W([x(e, {
                                        props: [l(t, /:(plac\w+)/, ":" + U + "input-$1")]
                                    }), x(e, {
                                        props: [l(t, /:(plac\w+)/, ":-moz-$1")]
                                    }), x(e, {
                                        props: [l(t, /:(plac\w+)/, N + "input-$1")]
                                    })], r)
                                }
                                return ""
                            }
                            ))
                    }
            }
            ]
              , ie = function(e) {
                var t = e.key;
                if ("css" === t) {
                    var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
                    Array.prototype.forEach.call(n, (function(e) {
                        -1 !== e.getAttribute("data-emotion").indexOf(" ") && (document.head.appendChild(e),
                        e.setAttribute("data-s", ""))
                    }
                    ))
                }
                var i, o, a = e.stylisPlugins || re, s = {}, l = [];
                i = e.container || document.head,
                Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + t + ' "]'), (function(e) {
                    for (var t = e.getAttribute("data-emotion").split(" "), n = 1; n < t.length; n++)
                        s[t[n]] = !0;
                    l.push(e)
                }
                ));
                var c, u, d = [V, (u = function(e) {
                    c.insert(e)
                }
                ,
                function(e) {
                    e.root || (e = e.return) && u(e)
                }
                )], h = function(e) {
                    var t = p(e);
                    return function(n, r, i, o) {
                        for (var a = "", s = 0; s < t; s++)
                            a += e[s](n, r, i, o) || "";
                        return a
                    }
                }([ee, te].concat(a, d));
                o = function(e, t, n, r) {
                    c = n,
                    W(X(e ? e + "{" + t.styles + "}" : t.styles), h),
                    r && (f.inserted[t.name] = !0)
                }
                ;
                var f = {
                    key: t,
                    sheet: new r({
                        key: t,
                        container: i,
                        nonce: e.nonce,
                        speedy: e.speedy,
                        prepend: e.prepend,
                        insertionPoint: e.insertionPoint
                    }),
                    nonce: e.nonce,
                    inserted: s,
                    registered: {},
                    insert: o
                };
                return f.sheet.hydrate(l),
                f
            }
        }
        ,
        7923: (e, t, n) => {
            "use strict";
            function r(e) {
                var t = Object.create(null);
                return function(n) {
                    return void 0 === t[n] && (t[n] = e(n)),
                    t[n]
                }
            }
            n.d(t, {
                A: () => r
            })
        }
        ,
        7576: (e, t, n) => {
            "use strict";
            n.d(t, {
                C: () => a,
                T: () => l,
                w: () => s
            });
            var r = n(9950)
              , i = n(8603)
              , o = (n(9015),
            n(6477),
            r.createContext("undefined" !== typeof HTMLElement ? (0,
            i.A)({
                key: "css"
            }) : null))
              , a = o.Provider
              , s = function(e) {
                return (0,
                r.forwardRef)((function(t, n) {
                    var i = (0,
                    r.useContext)(o);
                    return e(t, i, n)
                }
                ))
            }
              , l = r.createContext({})
        }
        ,
        8283: (e, t, n) => {
            "use strict";
            n.d(t, {
                AH: () => c,
                i7: () => u,
                mL: () => l
            });
            var r = n(7576)
              , i = n(9950)
              , o = n(1783)
              , a = n(6477)
              , s = n(9015)
              , l = (n(8603),
            n(3876),
            (0,
            r.w)((function(e, t) {
                var n = e.styles
                  , l = (0,
                s.J)([n], void 0, i.useContext(r.T))
                  , c = i.useRef();
                return (0,
                a.i)((function() {
                    var e = t.key + "-global"
                      , n = new t.sheet.constructor({
                        key: e,
                        nonce: t.sheet.nonce,
                        container: t.sheet.container,
                        speedy: t.sheet.isSpeedy
                    })
                      , r = !1
                      , i = document.querySelector('style[data-emotion="' + e + " " + l.name + '"]');
                    return t.sheet.tags.length && (n.before = t.sheet.tags[0]),
                    null !== i && (r = !0,
                    i.setAttribute("data-emotion", e),
                    n.hydrate([i])),
                    c.current = [n, r],
                    function() {
                        n.flush()
                    }
                }
                ), [t]),
                (0,
                a.i)((function() {
                    var e = c.current
                      , n = e[0];
                    if (e[1])
                        e[1] = !1;
                    else {
                        if (void 0 !== l.next && (0,
                        o.sk)(t, l.next, !0),
                        n.tags.length) {
                            var r = n.tags[n.tags.length - 1].nextElementSibling;
                            n.before = r,
                            n.flush()
                        }
                        t.insert("", l, n, !1)
                    }
                }
                ), [t, l.name]),
                null
            }
            )));
            function c() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                return (0,
                s.J)(t)
            }
            var u = function() {
                var e = c.apply(void 0, arguments)
                  , t = "animation-" + e.name;
                return {
                    name: t,
                    styles: "@keyframes " + t + "{" + e.styles + "}",
                    anim: 1,
                    toString: function() {
                        return "_EMO_" + this.name + "_" + this.styles + "_EMO_"
                    }
                }
            }
        }
        ,
        9015: (e, t, n) => {
            "use strict";
            n.d(t, {
                J: () => g
            });
            var r = {
                animationIterationCount: 1,
                aspectRatio: 1,
                borderImageOutset: 1,
                borderImageSlice: 1,
                borderImageWidth: 1,
                boxFlex: 1,
                boxFlexGroup: 1,
                boxOrdinalGroup: 1,
                columnCount: 1,
                columns: 1,
                flex: 1,
                flexGrow: 1,
                flexPositive: 1,
                flexShrink: 1,
                flexNegative: 1,
                flexOrder: 1,
                gridRow: 1,
                gridRowEnd: 1,
                gridRowSpan: 1,
                gridRowStart: 1,
                gridColumn: 1,
                gridColumnEnd: 1,
                gridColumnSpan: 1,
                gridColumnStart: 1,
                msGridRow: 1,
                msGridRowSpan: 1,
                msGridColumn: 1,
                msGridColumnSpan: 1,
                fontWeight: 1,
                lineHeight: 1,
                opacity: 1,
                order: 1,
                orphans: 1,
                scale: 1,
                tabSize: 1,
                widows: 1,
                zIndex: 1,
                zoom: 1,
                WebkitLineClamp: 1,
                fillOpacity: 1,
                floodOpacity: 1,
                stopOpacity: 1,
                strokeDasharray: 1,
                strokeDashoffset: 1,
                strokeMiterlimit: 1,
                strokeOpacity: 1,
                strokeWidth: 1
            }
              , i = n(7923)
              , o = !1
              , a = /[A-Z]|^ms/g
              , s = /_EMO_([^_]+?)_([^]*?)_EMO_/g
              , l = function(e) {
                return 45 === e.charCodeAt(1)
            }
              , c = function(e) {
                return null != e && "boolean" !== typeof e
            }
              , u = (0,
            i.A)((function(e) {
                return l(e) ? e : e.replace(a, "-$&").toLowerCase()
            }
            ))
              , d = function(e, t) {
                switch (e) {
                case "animation":
                case "animationName":
                    if ("string" === typeof t)
                        return t.replace(s, (function(e, t, n) {
                            return f = {
                                name: t,
                                styles: n,
                                next: f
                            },
                            t
                        }
                        ))
                }
                return 1 === r[e] || l(e) || "number" !== typeof t || 0 === t ? t : t + "px"
            }
              , h = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
            function p(e, t, n) {
                if (null == n)
                    return "";
                var r = n;
                if (void 0 !== r.__emotion_styles)
                    return r;
                switch (typeof n) {
                case "boolean":
                    return "";
                case "object":
                    var i = n;
                    if (1 === i.anim)
                        return f = {
                            name: i.name,
                            styles: i.styles,
                            next: f
                        },
                        i.name;
                    var a = n;
                    if (void 0 !== a.styles) {
                        var s = a.next;
                        if (void 0 !== s)
                            for (; void 0 !== s; )
                                f = {
                                    name: s.name,
                                    styles: s.styles,
                                    next: f
                                },
                                s = s.next;
                        return a.styles + ";"
                    }
                    return function(e, t, n) {
                        var r = "";
                        if (Array.isArray(n))
                            for (var i = 0; i < n.length; i++)
                                r += p(e, t, n[i]) + ";";
                        else
                            for (var a in n) {
                                var s = n[a];
                                if ("object" !== typeof s) {
                                    var l = s;
                                    null != t && void 0 !== t[l] ? r += a + "{" + t[l] + "}" : c(l) && (r += u(a) + ":" + d(a, l) + ";")
                                } else {
                                    if ("NO_COMPONENT_SELECTOR" === a && o)
                                        throw new Error(h);
                                    if (!Array.isArray(s) || "string" !== typeof s[0] || null != t && void 0 !== t[s[0]]) {
                                        var f = p(e, t, s);
                                        switch (a) {
                                        case "animation":
                                        case "animationName":
                                            r += u(a) + ":" + f + ";";
                                            break;
                                        default:
                                            r += a + "{" + f + "}"
                                        }
                                    } else
                                        for (var m = 0; m < s.length; m++)
                                            c(s[m]) && (r += u(a) + ":" + d(a, s[m]) + ";")
                                }
                            }
                        return r
                    }(e, t, n);
                case "function":
                    if (void 0 !== e) {
                        var l = f
                          , m = n(e);
                        return f = l,
                        p(e, t, m)
                    }
                }
                var g = n;
                if (null == t)
                    return g;
                var v = t[g];
                return void 0 !== v ? v : g
            }
            var f, m = /label:\s*([^\s;{]+)\s*(;|$)/g;
            function g(e, t, n) {
                if (1 === e.length && "object" === typeof e[0] && null !== e[0] && void 0 !== e[0].styles)
                    return e[0];
                var r = !0
                  , i = "";
                f = void 0;
                var o = e[0];
                null == o || void 0 === o.raw ? (r = !1,
                i += p(n, t, o)) : i += o[0];
                for (var a = 1; a < e.length; a++) {
                    if (i += p(n, t, e[a]),
                    r)
                        i += o[a]
                }
                m.lastIndex = 0;
                for (var s, l = ""; null !== (s = m.exec(i)); )
                    l += "-" + s[1];
                var c = function(e) {
                    for (var t, n = 0, r = 0, i = e.length; i >= 4; ++r,
                    i -= 4)
                        t = 1540483477 * (65535 & (t = 255 & e.charCodeAt(r) | (255 & e.charCodeAt(++r)) << 8 | (255 & e.charCodeAt(++r)) << 16 | (255 & e.charCodeAt(++r)) << 24)) + (59797 * (t >>> 16) << 16),
                        n = 1540483477 * (65535 & (t ^= t >>> 24)) + (59797 * (t >>> 16) << 16) ^ 1540483477 * (65535 & n) + (59797 * (n >>> 16) << 16);
                    switch (i) {
                    case 3:
                        n ^= (255 & e.charCodeAt(r + 2)) << 16;
                    case 2:
                        n ^= (255 & e.charCodeAt(r + 1)) << 8;
                    case 1:
                        n = 1540483477 * (65535 & (n ^= 255 & e.charCodeAt(r))) + (59797 * (n >>> 16) << 16)
                    }
                    return (((n = 1540483477 * (65535 & (n ^= n >>> 13)) + (59797 * (n >>> 16) << 16)) ^ n >>> 15) >>> 0).toString(36)
                }(i) + l;
                return {
                    name: c,
                    styles: i,
                    next: f
                }
            }
        }
        ,
        6477: (e, t, n) => {
            "use strict";
            var r;
            n.d(t, {
                i: () => s,
                s: () => a
            });
            var i = n(9950)
              , o = !!(r || (r = n.t(i, 2))).useInsertionEffect && (r || (r = n.t(i, 2))).useInsertionEffect
              , a = o || function(e) {
                return e()
            }
              , s = o || i.useLayoutEffect
        }
        ,
        1783: (e, t, n) => {
            "use strict";
            n.d(t, {
                Rk: () => r,
                SF: () => i,
                sk: () => o
            });
            function r(e, t, n) {
                var r = "";
                return n.split(" ").forEach((function(n) {
                    void 0 !== e[n] ? t.push(e[n] + ";") : n && (r += n + " ")
                }
                )),
                r
            }
            var i = function(e, t, n) {
                var r = e.key + "-" + t.name;
                !1 === n && void 0 === e.registered[r] && (e.registered[r] = t.styles)
            }
              , o = function(e, t, n) {
                i(e, t, n);
                var r = e.key + "-" + t.name;
                if (void 0 === e.inserted[t.name]) {
                    var o = t;
                    do {
                        e.insert(t === o ? "." + r : "", o, e.sheet, !0),
                        o = o.next
                    } while (void 0 !== o)
                }
            }
        }
        ,
        3189: (e, t, n) => {
            "use strict";
            var r = n(4994);
            t.A = void 0;
            var i = r(n(9526))
              , o = n(4414);
            t.A = (0,
            i.default)((0,
            o.jsx)("path", {
                d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20z"
            }), "ArrowBack")
        }
        ,
        9526: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            Object.defineProperty(t, "default", {
                enumerable: !0,
                get: function() {
                    return r.createSvgIcon
                }
            });
            var r = n(1572)
        }
        ,
        8463: (e, t, n) => {
            "use strict";
            n.d(t, {
                b: () => i
            });
            n(9950);
            var r = n(6171);
            n(4414);
            function i(e) {
                return (0,
                r.b)(e)
            }
        }
        ,
        7775: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => U
            });
            var r = n(8168)
              , i = n(8587)
              , o = n(8099)
              , a = n(7483)
              , s = n(8076)
              , l = n(505)
              , c = n(2860);
            var u = n(9269);
            const d = {
                black: "#000",
                white: "#fff"
            }
              , h = {
                50: "#fafafa",
                100: "#f5f5f5",
                200: "#eeeeee",
                300: "#e0e0e0",
                400: "#bdbdbd",
                500: "#9e9e9e",
                600: "#757575",
                700: "#616161",
                800: "#424242",
                900: "#212121",
                A100: "#f5f5f5",
                A200: "#eeeeee",
                A400: "#bdbdbd",
                A700: "#616161"
            }
              , p = {
                50: "#f3e5f5",
                100: "#e1bee7",
                200: "#ce93d8",
                300: "#ba68c8",
                400: "#ab47bc",
                500: "#9c27b0",
                600: "#8e24aa",
                700: "#7b1fa2",
                800: "#6a1b9a",
                900: "#4a148c",
                A100: "#ea80fc",
                A200: "#e040fb",
                A400: "#d500f9",
                A700: "#aa00ff"
            }
              , f = {
                50: "#ffebee",
                100: "#ffcdd2",
                200: "#ef9a9a",
                300: "#e57373",
                400: "#ef5350",
                500: "#f44336",
                600: "#e53935",
                700: "#d32f2f",
                800: "#c62828",
                900: "#b71c1c",
                A100: "#ff8a80",
                A200: "#ff5252",
                A400: "#ff1744",
                A700: "#d50000"
            }
              , m = {
                50: "#fff3e0",
                100: "#ffe0b2",
                200: "#ffcc80",
                300: "#ffb74d",
                400: "#ffa726",
                500: "#ff9800",
                600: "#fb8c00",
                700: "#f57c00",
                800: "#ef6c00",
                900: "#e65100",
                A100: "#ffd180",
                A200: "#ffab40",
                A400: "#ff9100",
                A700: "#ff6d00"
            }
              , g = {
                50: "#e3f2fd",
                100: "#bbdefb",
                200: "#90caf9",
                300: "#64b5f6",
                400: "#42a5f5",
                500: "#2196f3",
                600: "#1e88e5",
                700: "#1976d2",
                800: "#1565c0",
                900: "#0d47a1",
                A100: "#82b1ff",
                A200: "#448aff",
                A400: "#2979ff",
                A700: "#2962ff"
            }
              , v = {
                50: "#e1f5fe",
                100: "#b3e5fc",
                200: "#81d4fa",
                300: "#4fc3f7",
                400: "#29b6f6",
                500: "#03a9f4",
                600: "#039be5",
                700: "#0288d1",
                800: "#0277bd",
                900: "#01579b",
                A100: "#80d8ff",
                A200: "#40c4ff",
                A400: "#00b0ff",
                A700: "#0091ea"
            }
              , y = {
                50: "#e8f5e9",
                100: "#c8e6c9",
                200: "#a5d6a7",
                300: "#81c784",
                400: "#66bb6a",
                500: "#4caf50",
                600: "#43a047",
                700: "#388e3c",
                800: "#2e7d32",
                900: "#1b5e20",
                A100: "#b9f6ca",
                A200: "#69f0ae",
                A400: "#00e676",
                A700: "#00c853"
            }
              , b = ["mode", "contrastThreshold", "tonalOffset"]
              , _ = {
                text: {
                    primary: "rgba(0, 0, 0, 0.87)",
                    secondary: "rgba(0, 0, 0, 0.6)",
                    disabled: "rgba(0, 0, 0, 0.38)"
                },
                divider: "rgba(0, 0, 0, 0.12)",
                background: {
                    paper: d.white,
                    default: d.white
                },
                action: {
                    active: "rgba(0, 0, 0, 0.54)",
                    hover: "rgba(0, 0, 0, 0.04)",
                    hoverOpacity: .04,
                    selected: "rgba(0, 0, 0, 0.08)",
                    selectedOpacity: .08,
                    disabled: "rgba(0, 0, 0, 0.26)",
                    disabledBackground: "rgba(0, 0, 0, 0.12)",
                    disabledOpacity: .38,
                    focus: "rgba(0, 0, 0, 0.12)",
                    focusOpacity: .12,
                    activatedOpacity: .12
                }
            }
              , A = {
                text: {
                    primary: d.white,
                    secondary: "rgba(255, 255, 255, 0.7)",
                    disabled: "rgba(255, 255, 255, 0.5)",
                    icon: "rgba(255, 255, 255, 0.5)"
                },
                divider: "rgba(255, 255, 255, 0.12)",
                background: {
                    paper: "#121212",
                    default: "#121212"
                },
                action: {
                    active: d.white,
                    hover: "rgba(255, 255, 255, 0.08)",
                    hoverOpacity: .08,
                    selected: "rgba(255, 255, 255, 0.16)",
                    selectedOpacity: .16,
                    disabled: "rgba(255, 255, 255, 0.3)",
                    disabledBackground: "rgba(255, 255, 255, 0.12)",
                    disabledOpacity: .38,
                    focus: "rgba(255, 255, 255, 0.12)",
                    focusOpacity: .12,
                    activatedOpacity: .24
                }
            };
            function x(e, t, n, r) {
                const i = r.light || r
                  , o = r.dark || 1.5 * r;
                e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : "light" === t ? e.light = (0,
                u.a)(e.main, i) : "dark" === t && (e.dark = (0,
                u.e$)(e.main, o)))
            }
            function S(e) {
                const {mode: t="light", contrastThreshold: n=3, tonalOffset: s=.2} = e
                  , l = (0,
                i.A)(e, b)
                  , c = e.primary || function() {
                    return "dark" === (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "light") ? {
                        main: g[200],
                        light: g[50],
                        dark: g[400]
                    } : {
                        main: g[700],
                        light: g[400],
                        dark: g[800]
                    }
                }(t)
                  , S = e.secondary || function() {
                    return "dark" === (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "light") ? {
                        main: p[200],
                        light: p[50],
                        dark: p[400]
                    } : {
                        main: p[500],
                        light: p[300],
                        dark: p[700]
                    }
                }(t)
                  , w = e.error || function() {
                    return "dark" === (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "light") ? {
                        main: f[500],
                        light: f[300],
                        dark: f[700]
                    } : {
                        main: f[700],
                        light: f[400],
                        dark: f[800]
                    }
                }(t)
                  , E = e.info || function() {
                    return "dark" === (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "light") ? {
                        main: v[400],
                        light: v[300],
                        dark: v[700]
                    } : {
                        main: v[700],
                        light: v[500],
                        dark: v[900]
                    }
                }(t)
                  , M = e.success || function() {
                    return "dark" === (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "light") ? {
                        main: y[400],
                        light: y[300],
                        dark: y[700]
                    } : {
                        main: y[800],
                        light: y[500],
                        dark: y[900]
                    }
                }(t)
                  , C = e.warning || function() {
                    return "dark" === (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "light") ? {
                        main: m[400],
                        light: m[300],
                        dark: m[700]
                    } : {
                        main: "#ed6c02",
                        light: m[500],
                        dark: m[900]
                    }
                }(t);
                function T(e) {
                    return (0,
                    u.eM)(e, A.text.primary) >= n ? A.text.primary : _.text.primary
                }
                const R = e => {
                    let {color: t, name: n, mainShade: i=500, lightShade: a=300, darkShade: l=700} = e;
                    if (t = (0,
                    r.A)({}, t),
                    !t.main && t[i] && (t.main = t[i]),
                    !t.hasOwnProperty("main"))
                        throw new Error((0,
                        o.A)(11, n ? ` (${n})` : "", i));
                    if ("string" !== typeof t.main)
                        throw new Error((0,
                        o.A)(12, n ? ` (${n})` : "", JSON.stringify(t.main)));
                    return x(t, "light", a, s),
                    x(t, "dark", l, s),
                    t.contrastText || (t.contrastText = T(t.main)),
                    t
                }
                  , P = {
                    dark: A,
                    light: _
                };
                return (0,
                a.A)((0,
                r.A)({
                    common: (0,
                    r.A)({}, d),
                    mode: t,
                    primary: R({
                        color: c,
                        name: "primary"
                    }),
                    secondary: R({
                        color: S,
                        name: "secondary",
                        mainShade: "A400",
                        lightShade: "A200",
                        darkShade: "A700"
                    }),
                    error: R({
                        color: w,
                        name: "error"
                    }),
                    warning: R({
                        color: C,
                        name: "warning"
                    }),
                    info: R({
                        color: E,
                        name: "info"
                    }),
                    success: R({
                        color: M,
                        name: "success"
                    }),
                    grey: h,
                    contrastThreshold: n,
                    getContrastText: T,
                    augmentColor: R,
                    tonalOffset: s
                }, P[t]), l)
            }
            const w = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
            const E = {
                textTransform: "uppercase"
            }
              , M = '"Roboto", "Helvetica", "Arial", sans-serif';
            function C(e, t) {
                const n = "function" === typeof t ? t(e) : t
                  , {fontFamily: o=M, fontSize: s=14, fontWeightLight: l=300, fontWeightRegular: c=400, fontWeightMedium: u=500, fontWeightBold: d=700, htmlFontSize: h=16, allVariants: p, pxToRem: f} = n
                  , m = (0,
                i.A)(n, w);
                const g = s / 14
                  , v = f || (e => e / h * g + "rem")
                  , y = (e, t, n, i, a) => {
                    return (0,
                    r.A)({
                        fontFamily: o,
                        fontWeight: e,
                        fontSize: v(t),
                        lineHeight: n
                    }, o === M ? {
                        letterSpacing: (s = i / t,
                        Math.round(1e5 * s) / 1e5) + "em"
                    } : {}, a, p);
                    var s
                }
                  , b = {
                    h1: y(l, 96, 1.167, -1.5),
                    h2: y(l, 60, 1.2, -.5),
                    h3: y(c, 48, 1.167, 0),
                    h4: y(c, 34, 1.235, .25),
                    h5: y(c, 24, 1.334, 0),
                    h6: y(u, 20, 1.6, .15),
                    subtitle1: y(c, 16, 1.75, .15),
                    subtitle2: y(u, 14, 1.57, .1),
                    body1: y(c, 16, 1.5, .15),
                    body2: y(c, 14, 1.43, .15),
                    button: y(u, 14, 1.75, .4, E),
                    caption: y(c, 12, 1.66, .4),
                    overline: y(c, 12, 2.66, 1, E),
                    inherit: {
                        fontFamily: "inherit",
                        fontWeight: "inherit",
                        fontSize: "inherit",
                        lineHeight: "inherit",
                        letterSpacing: "inherit"
                    }
                };
                return (0,
                a.A)((0,
                r.A)({
                    htmlFontSize: h,
                    pxToRem: v,
                    fontFamily: o,
                    fontSize: s,
                    fontWeightLight: l,
                    fontWeightRegular: c,
                    fontWeightMedium: u,
                    fontWeightBold: d
                }, b), m, {
                    clone: !1
                })
            }
            function T() {
                return [`${arguments.length <= 0 ? void 0 : arguments[0]}px ${arguments.length <= 1 ? void 0 : arguments[1]}px ${arguments.length <= 2 ? void 0 : arguments[2]}px ${arguments.length <= 3 ? void 0 : arguments[3]}px rgba(0,0,0,0.2)`, `${arguments.length <= 4 ? void 0 : arguments[4]}px ${arguments.length <= 5 ? void 0 : arguments[5]}px ${arguments.length <= 6 ? void 0 : arguments[6]}px ${arguments.length <= 7 ? void 0 : arguments[7]}px rgba(0,0,0,0.14)`, `${arguments.length <= 8 ? void 0 : arguments[8]}px ${arguments.length <= 9 ? void 0 : arguments[9]}px ${arguments.length <= 10 ? void 0 : arguments[10]}px ${arguments.length <= 11 ? void 0 : arguments[11]}px rgba(0,0,0,0.12)`].join(",")
            }
            const R = ["none", T(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), T(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), T(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), T(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), T(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), T(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), T(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), T(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), T(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), T(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), T(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), T(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), T(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), T(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), T(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), T(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), T(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), T(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), T(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), T(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), T(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), T(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), T(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), T(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)]
              , P = ["duration", "easing", "delay"]
              , B = {
                easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
                easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
                easeIn: "cubic-bezier(0.4, 0, 1, 1)",
                sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
            }
              , I = {
                shortest: 150,
                shorter: 200,
                short: 250,
                standard: 300,
                complex: 375,
                enteringScreen: 225,
                leavingScreen: 195
            };
            function L(e) {
                return `${Math.round(e)}ms`
            }
            function k(e) {
                if (!e)
                    return 0;
                const t = e / 36;
                return Math.round(10 * (4 + 15 * t ** .25 + t / 5))
            }
            function D(e) {
                const t = (0,
                r.A)({}, B, e.easing)
                  , n = (0,
                r.A)({}, I, e.duration);
                return (0,
                r.A)({
                    getAutoHeightDuration: k,
                    create: function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ["all"]
                          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        const {duration: o=n.standard, easing: a=t.easeInOut, delay: s=0} = r;
                        (0,
                        i.A)(r, P);
                        return (Array.isArray(e) ? e : [e]).map((e => `${e} ${"string" === typeof o ? o : L(o)} ${a} ${"string" === typeof s ? s : L(s)}`)).join(",")
                    }
                }, e, {
                    easing: t,
                    duration: n
                })
            }
            const O = {
                mobileStepper: 1e3,
                fab: 1050,
                speedDial: 1050,
                appBar: 1100,
                drawer: 1200,
                modal: 1300,
                snackbar: 1400,
                tooltip: 1500
            }
              , N = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
            function F() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const {mixins: t={}, palette: n={}, transitions: u={}, typography: d={}} = e
                  , h = (0,
                i.A)(e, N);
                if (e.vars)
                    throw new Error((0,
                    o.A)(18));
                const p = S(n)
                  , f = (0,
                c.A)(e);
                let m = (0,
                a.A)(f, {
                    mixins: (g = f.breakpoints,
                    v = t,
                    (0,
                    r.A)({
                        toolbar: {
                            minHeight: 56,
                            [g.up("xs")]: {
                                "@media (orientation: landscape)": {
                                    minHeight: 48
                                }
                            },
                            [g.up("sm")]: {
                                minHeight: 64
                            }
                        }
                    }, v)),
                    palette: p,
                    shadows: R.slice(),
                    typography: C(p, d),
                    transitions: D(u),
                    zIndex: (0,
                    r.A)({}, O)
                });
                var g, v;
                m = (0,
                a.A)(m, h);
                for (var y = arguments.length, b = new Array(y > 1 ? y - 1 : 0), _ = 1; _ < y; _++)
                    b[_ - 1] = arguments[_];
                return m = b.reduce(( (e, t) => (0,
                a.A)(e, t)), m),
                m.unstable_sxConfig = (0,
                r.A)({}, s.A, null == h ? void 0 : h.unstable_sxConfig),
                m.unstable_sx = function(e) {
                    return (0,
                    l.A)({
                        sx: e,
                        theme: this
                    })
                }
                ,
                m
            }
            const U = F
        }
        ,
        195: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => r
            });
            const r = (0,
            n(7775).A)()
        }
        ,
        7550: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => r
            });
            const r = "$$material"
        }
        ,
        741: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => i
            });
            const r = function(e) {
                return "ownerState" !== e && "theme" !== e && "sx" !== e && "as" !== e
            }
              , i = e => r(e) && "classes" !== e
        }
        ,
        9254: (e, t, n) => {
            "use strict";
            n.d(t, {
                Ay: () => s
            });
            var r = n(7295)
              , i = n(195)
              , o = n(7550)
              , a = n(741);
            const s = (0,
            r.Ay)({
                themeId: o.A,
                defaultTheme: i.A,
                rootShouldForwardProp: a.A
            })
        }
        ,
        1676: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => r
            });
            const r = n(5501).A
        }
        ,
        3235: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => b
            });
            var r = n(8168)
              , i = n(9950)
              , o = n(8587)
              , a = n(533)
              , s = n(8465)
              , l = n(1676)
              , c = n(8463)
              , u = n(9254)
              , d = n(1763)
              , h = n(423);
            function p(e) {
                return (0,
                h.Ay)("MuiSvgIcon", e)
            }
            (0,
            d.A)("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
            var f = n(4414);
            const m = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"]
              , g = (0,
            u.Ay)("svg", {
                name: "MuiSvgIcon",
                slot: "Root",
                overridesResolver: (e, t) => {
                    const {ownerState: n} = e;
                    return [t.root, "inherit" !== n.color && t[`color${(0,
                    l.A)(n.color)}`], t[`fontSize${(0,
                    l.A)(n.fontSize)}`]]
                }
            })((e => {
                let {theme: t, ownerState: n} = e;
                var r, i, o, a, s, l, c, u, d, h, p, f, m;
                return {
                    userSelect: "none",
                    width: "1em",
                    height: "1em",
                    display: "inline-block",
                    fill: n.hasSvgAsChild ? void 0 : "currentColor",
                    flexShrink: 0,
                    transition: null == (r = t.transitions) || null == (i = r.create) ? void 0 : i.call(r, "fill", {
                        duration: null == (o = t.transitions) || null == (o = o.duration) ? void 0 : o.shorter
                    }),
                    fontSize: {
                        inherit: "inherit",
                        small: (null == (a = t.typography) || null == (s = a.pxToRem) ? void 0 : s.call(a, 20)) || "1.25rem",
                        medium: (null == (l = t.typography) || null == (c = l.pxToRem) ? void 0 : c.call(l, 24)) || "1.5rem",
                        large: (null == (u = t.typography) || null == (d = u.pxToRem) ? void 0 : d.call(u, 35)) || "2.1875rem"
                    }[n.fontSize],
                    color: null != (h = null == (p = (t.vars || t).palette) || null == (p = p[n.color]) ? void 0 : p.main) ? h : {
                        action: null == (f = (t.vars || t).palette) || null == (f = f.action) ? void 0 : f.active,
                        disabled: null == (m = (t.vars || t).palette) || null == (m = m.action) ? void 0 : m.disabled,
                        inherit: void 0
                    }[n.color]
                }
            }
            ))
              , v = i.forwardRef((function(e, t) {
                const n = (0,
                c.b)({
                    props: e,
                    name: "MuiSvgIcon"
                })
                  , {children: u, className: d, color: h="inherit", component: v="svg", fontSize: y="medium", htmlColor: b, inheritViewBox: _=!1, titleAccess: A, viewBox: x="0 0 24 24"} = n
                  , S = (0,
                o.A)(n, m)
                  , w = i.isValidElement(u) && "svg" === u.type
                  , E = (0,
                r.A)({}, n, {
                    color: h,
                    component: v,
                    fontSize: y,
                    instanceFontSize: e.fontSize,
                    inheritViewBox: _,
                    viewBox: x,
                    hasSvgAsChild: w
                })
                  , M = {};
                _ || (M.viewBox = x);
                const C = (e => {
                    const {color: t, fontSize: n, classes: r} = e
                      , i = {
                        root: ["root", "inherit" !== t && `color${(0,
                        l.A)(t)}`, `fontSize${(0,
                        l.A)(n)}`]
                    };
                    return (0,
                    s.A)(i, p, r)
                }
                )(E);
                return (0,
                f.jsxs)(g, (0,
                r.A)({
                    as: v,
                    className: (0,
                    a.A)(C.root, d),
                    focusable: "false",
                    color: b,
                    "aria-hidden": !A || void 0,
                    role: A ? "img" : void 0,
                    ref: t
                }, M, S, w && u.props, {
                    ownerState: E,
                    children: [w ? u.props.children : u, A ? (0,
                    f.jsx)("title", {
                        children: A
                    }) : null]
                }))
            }
            ));
            v.muiName = "SvgIcon";
            const y = v;
            function b(e, t) {
                function n(n, i) {
                    return (0,
                    f.jsx)(y, (0,
                    r.A)({
                        "data-testid": `${t}Icon`,
                        ref: i
                    }, n, {
                        children: e
                    }))
                }
                return n.muiName = y.muiName,
                i.memo(i.forwardRef(n))
            }
        }
        ,
        1380: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => r
            });
            const r = function(e) {
                let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 166;
                function r() {
                    for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)
                        i[o] = arguments[o];
                    clearTimeout(t),
                    t = setTimeout(( () => {
                        e.apply(this, i)
                    }
                    ), n)
                }
                return r.clear = () => {
                    clearTimeout(t)
                }
                ,
                r
            }
        }
        ,
        1572: (e, t, n) => {
            "use strict";
            n.r(t),
            n.d(t, {
                capitalize: () => i.A,
                createChainedFunction: () => o,
                createSvgIcon: () => a.A,
                debounce: () => s.A,
                deprecatedPropType: () => l,
                isMuiElement: () => u,
                ownerDocument: () => d.A,
                ownerWindow: () => h.A,
                requirePropFactory: () => p,
                setRef: () => f,
                unstable_ClassNameGenerator: () => x,
                unstable_useEnhancedEffect: () => m.A,
                unstable_useId: () => g.A,
                unsupportedProp: () => v,
                useControlled: () => y.A,
                useEventCallback: () => b.A,
                useForkRef: () => _.A,
                useIsFocusVisible: () => A.A
            });
            var r = n(4501)
              , i = n(1676);
            const o = n(5511).A;
            var a = n(3235)
              , s = n(1380);
            const l = function(e, t) {
                return () => null
            };
            var c = n(9950);
            const u = function(e, t) {
                var n, r;
                return c.isValidElement(e) && -1 !== t.indexOf(null != (n = e.type.muiName) ? n : null == (r = e.type) || null == (r = r._payload) || null == (r = r.value) ? void 0 : r.muiName)
            };
            var d = n(7402)
              , h = n(827);
            n(8168);
            const p = function(e, t) {
                return () => null
            };
            const f = n(5587).A;
            var m = n(9044)
              , g = n(1014);
            const v = function(e, t, n, r, i) {
                return null
            };
            var y = n(4570)
              , b = n(1976)
              , _ = n(1506)
              , A = n(2937);
            const x = {
                configure: e => {
                    r.A.configure(e)
                }
            }
        }
        ,
        7402: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => r
            });
            const r = n(6907).A
        }
        ,
        827: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => r
            });
            const r = n(8635).A
        }
        ,
        4570: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => i
            });
            var r = n(9950);
            const i = function(e) {
                let {controlled: t, default: n, name: i, state: o="value"} = e;
                const {current: a} = r.useRef(void 0 !== t)
                  , [s,l] = r.useState(n);
                return [a ? t : s, r.useCallback((e => {
                    a || l(e)
                }
                ), [])]
            }
        }
        ,
        9044: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => r
            });
            const r = n(1399).A
        }
        ,
        1976: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => r
            });
            const r = n(2529).A
        }
        ,
        1506: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => r
            });
            const r = n(5393).A
        }
        ,
        1014: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => r
            });
            const r = n(3539).A
        }
        ,
        2937: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => p
            });
            var r = n(9950)
              , i = n(1824);
            let o = !0
              , a = !1;
            const s = new i.E
              , l = {
                text: !0,
                search: !0,
                url: !0,
                tel: !0,
                email: !0,
                password: !0,
                number: !0,
                date: !0,
                month: !0,
                week: !0,
                time: !0,
                datetime: !0,
                "datetime-local": !0
            };
            function c(e) {
                e.metaKey || e.altKey || e.ctrlKey || (o = !0)
            }
            function u() {
                o = !1
            }
            function d() {
                "hidden" === this.visibilityState && a && (o = !0)
            }
            function h(e) {
                const {target: t} = e;
                try {
                    return t.matches(":focus-visible")
                } catch (n) {}
                return o || function(e) {
                    const {type: t, tagName: n} = e;
                    return !("INPUT" !== n || !l[t] || e.readOnly) || "TEXTAREA" === n && !e.readOnly || !!e.isContentEditable
                }(t)
            }
            const p = function() {
                const e = r.useCallback((e => {
                    var t;
                    null != e && ((t = e.ownerDocument).addEventListener("keydown", c, !0),
                    t.addEventListener("mousedown", u, !0),
                    t.addEventListener("pointerdown", u, !0),
                    t.addEventListener("touchstart", u, !0),
                    t.addEventListener("visibilitychange", d, !0))
                }
                ), [])
                  , t = r.useRef(!1);
                return {
                    isFocusVisibleRef: t,
                    onFocus: function(e) {
                        return !!h(e) && (t.current = !0,
                        !0)
                    },
                    onBlur: function() {
                        return !!t.current && (a = !0,
                        s.start(100, ( () => {
                            a = !1
                        }
                        )),
                        t.current = !1,
                        !0)
                    },
                    ref: e
                }
            }
        }
        ,
        8661: (e, t, n) => {
            "use strict";
            n.r(t),
            n.d(t, {
                GlobalStyles: () => S,
                StyledEngineProvider: () => x,
                ThemeContext: () => l.T,
                css: () => y.AH,
                default: () => w,
                internal_processStyles: () => E,
                keyframes: () => y.i7
            });
            var r = n(8168)
              , i = n(9950)
              , o = n(7923)
              , a = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/
              , s = (0,
            o.A)((function(e) {
                return a.test(e) || 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && e.charCodeAt(2) < 91
            }
            ))
              , l = n(7576)
              , c = n(1783)
              , u = n(9015)
              , d = n(6477)
              , h = s
              , p = function(e) {
                return "theme" !== e
            }
              , f = function(e) {
                return "string" === typeof e && e.charCodeAt(0) > 96 ? h : p
            }
              , m = function(e, t, n) {
                var r;
                if (t) {
                    var i = t.shouldForwardProp;
                    r = e.__emotion_forwardProp && i ? function(t) {
                        return e.__emotion_forwardProp(t) && i(t)
                    }
                    : i
                }
                return "function" !== typeof r && n && (r = e.__emotion_forwardProp),
                r
            }
              , g = function(e) {
                var t = e.cache
                  , n = e.serialized
                  , r = e.isStringTag;
                return (0,
                c.SF)(t, n, r),
                (0,
                d.s)((function() {
                    return (0,
                    c.sk)(t, n, r)
                }
                )),
                null
            }
              , v = function e(t, n) {
                var o, a, s = t.__emotion_real === t, d = s && t.__emotion_base || t;
                void 0 !== n && (o = n.label,
                a = n.target);
                var h = m(t, n, s)
                  , p = h || f(d)
                  , v = !p("as");
                return function() {
                    var y = arguments
                      , b = s && void 0 !== t.__emotion_styles ? t.__emotion_styles.slice(0) : [];
                    if (void 0 !== o && b.push("label:" + o + ";"),
                    null == y[0] || void 0 === y[0].raw)
                        b.push.apply(b, y);
                    else {
                        b.push(y[0][0]);
                        for (var _ = y.length, A = 1; A < _; A++)
                            b.push(y[A], y[0][A])
                    }
                    var x = (0,
                    l.w)((function(e, t, n) {
                        var r = v && e.as || d
                          , o = ""
                          , s = []
                          , m = e;
                        if (null == e.theme) {
                            for (var y in m = {},
                            e)
                                m[y] = e[y];
                            m.theme = i.useContext(l.T)
                        }
                        "string" === typeof e.className ? o = (0,
                        c.Rk)(t.registered, s, e.className) : null != e.className && (o = e.className + " ");
                        var _ = (0,
                        u.J)(b.concat(s), t.registered, m);
                        o += t.key + "-" + _.name,
                        void 0 !== a && (o += " " + a);
                        var A = v && void 0 === h ? f(r) : p
                          , x = {};
                        for (var S in e)
                            v && "as" === S || A(S) && (x[S] = e[S]);
                        return x.className = o,
                        n && (x.ref = n),
                        i.createElement(i.Fragment, null, i.createElement(g, {
                            cache: t,
                            serialized: _,
                            isStringTag: "string" === typeof r
                        }), i.createElement(r, x))
                    }
                    ));
                    return x.displayName = void 0 !== o ? o : "Styled(" + ("string" === typeof d ? d : d.displayName || d.name || "Component") + ")",
                    x.defaultProps = t.defaultProps,
                    x.__emotion_real = x,
                    x.__emotion_base = d,
                    x.__emotion_styles = b,
                    x.__emotion_forwardProp = h,
                    Object.defineProperty(x, "toString", {
                        value: function() {
                            return "." + a
                        }
                    }),
                    x.withComponent = function(t, i) {
                        return e(t, (0,
                        r.A)({}, n, i, {
                            shouldForwardProp: m(x, i, !0)
                        })).apply(void 0, b)
                    }
                    ,
                    x
                }
            }
            .bind();
            ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"].forEach((function(e) {
                v[e] = v(e)
            }
            ));
            var y = n(8283)
              , b = n(8603)
              , _ = n(4414);
            let A;
            function x(e) {
                const {injectFirst: t, children: n} = e;
                return t && A ? (0,
                _.jsx)(l.C, {
                    value: A,
                    children: n
                }) : n
            }
            function S(e) {
                const {styles: t, defaultTheme: n={}} = e
                  , r = "function" === typeof t ? e => {
                    return t(void 0 === (r = e) || null === r || 0 === Object.keys(r).length ? n : e);
                    var r
                }
                : t;
                return (0,
                _.jsx)(y.mL, {
                    styles: r
                })
            }
            function w(e, t) {
                return v(e, t)
            }
            "object" === typeof document && (A = (0,
            b.A)({
                key: "css",
                prepend: !0
            }));
            const E = (e, t) => {
                Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles))
            }
        }
        ,
        9269: (e, t, n) => {
            "use strict";
            var r = n(4994);
            t.X4 = p,
            t.e$ = f,
            t.eM = function(e, t) {
                const n = h(e)
                  , r = h(t);
                return (Math.max(n, r) + .05) / (Math.min(n, r) + .05)
            }
            ,
            t.a = m;
            var i = r(n(9234))
              , o = r(n(3383));
            function a(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                return (0,
                o.default)(e, t, n)
            }
            function s(e) {
                e = e.slice(1);
                const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`,"g");
                let n = e.match(t);
                return n && 1 === n[0].length && (n = n.map((e => e + e))),
                n ? `rgb${4 === n.length ? "a" : ""}(${n.map(( (e, t) => t < 3 ? parseInt(e, 16) : Math.round(parseInt(e, 16) / 255 * 1e3) / 1e3)).join(", ")})` : ""
            }
            function l(e) {
                if (e.type)
                    return e;
                if ("#" === e.charAt(0))
                    return l(s(e));
                const t = e.indexOf("(")
                  , n = e.substring(0, t);
                if (-1 === ["rgb", "rgba", "hsl", "hsla", "color"].indexOf(n))
                    throw new Error((0,
                    i.default)(9, e));
                let r, o = e.substring(t + 1, e.length - 1);
                if ("color" === n) {
                    if (o = o.split(" "),
                    r = o.shift(),
                    4 === o.length && "/" === o[3].charAt(0) && (o[3] = o[3].slice(1)),
                    -1 === ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(r))
                        throw new Error((0,
                        i.default)(10, r))
                } else
                    o = o.split(",");
                return o = o.map((e => parseFloat(e))),
                {
                    type: n,
                    values: o,
                    colorSpace: r
                }
            }
            const c = e => {
                const t = l(e);
                return t.values.slice(0, 3).map(( (e, n) => -1 !== t.type.indexOf("hsl") && 0 !== n ? `${e}%` : e)).join(" ")
            }
            ;
            function u(e) {
                const {type: t, colorSpace: n} = e;
                let {values: r} = e;
                return -1 !== t.indexOf("rgb") ? r = r.map(( (e, t) => t < 3 ? parseInt(e, 10) : e)) : -1 !== t.indexOf("hsl") && (r[1] = `${r[1]}%`,
                r[2] = `${r[2]}%`),
                r = -1 !== t.indexOf("color") ? `${n} ${r.join(" ")}` : `${r.join(", ")}`,
                `${t}(${r})`
            }
            function d(e) {
                e = l(e);
                const {values: t} = e
                  , n = t[0]
                  , r = t[1] / 100
                  , i = t[2] / 100
                  , o = r * Math.min(i, 1 - i)
                  , a = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : (e + n / 30) % 12;
                    return i - o * Math.max(Math.min(t - 3, 9 - t, 1), -1)
                };
                let s = "rgb";
                const c = [Math.round(255 * a(0)), Math.round(255 * a(8)), Math.round(255 * a(4))];
                return "hsla" === e.type && (s += "a",
                c.push(t[3])),
                u({
                    type: s,
                    values: c
                })
            }
            function h(e) {
                let t = "hsl" === (e = l(e)).type || "hsla" === e.type ? l(d(e)).values : e.values;
                return t = t.map((t => ("color" !== e.type && (t /= 255),
                t <= .03928 ? t / 12.92 : ((t + .055) / 1.055) ** 2.4))),
                Number((.2126 * t[0] + .7152 * t[1] + .0722 * t[2]).toFixed(3))
            }
            function p(e, t) {
                return e = l(e),
                t = a(t),
                "rgb" !== e.type && "hsl" !== e.type || (e.type += "a"),
                "color" === e.type ? e.values[3] = `/${t}` : e.values[3] = t,
                u(e)
            }
            function f(e, t) {
                if (e = l(e),
                t = a(t),
                -1 !== e.type.indexOf("hsl"))
                    e.values[2] *= 1 - t;
                else if (-1 !== e.type.indexOf("rgb") || -1 !== e.type.indexOf("color"))
                    for (let n = 0; n < 3; n += 1)
                        e.values[n] *= 1 - t;
                return u(e)
            }
            function m(e, t) {
                if (e = l(e),
                t = a(t),
                -1 !== e.type.indexOf("hsl"))
                    e.values[2] += (100 - e.values[2]) * t;
                else if (-1 !== e.type.indexOf("rgb"))
                    for (let n = 0; n < 3; n += 1)
                        e.values[n] += (255 - e.values[n]) * t;
                else if (-1 !== e.type.indexOf("color"))
                    for (let n = 0; n < 3; n += 1)
                        e.values[n] += (1 - e.values[n]) * t;
                return u(e)
            }
            function g(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .15;
                return h(e) > .5 ? f(e, t) : m(e, t)
            }
        }
        ,
        7295: (e, t, n) => {
            "use strict";
            var r = n(4994);
            t.Ay = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const {themeId: t, defaultTheme: n=m, rootShouldForwardProp: r=f, slotShouldForwardProp: l=f} = e
                  , u = e => (0,
                c.default)((0,
                i.default)({}, e, {
                    theme: v((0,
                    i.default)({}, e, {
                        defaultTheme: n,
                        themeId: t
                    }))
                }));
                return u.__mui_systemSx = !0,
                function(e) {
                    let c = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    (0,
                    a.internal_processStyles)(e, (e => e.filter((e => !(null != e && e.__mui_systemSx)))));
                    const {name: d, slot: p, skipVariantsResolver: m, skipSx: _, overridesResolver: A=y(g(p))} = c
                      , x = (0,
                    o.default)(c, h)
                      , S = void 0 !== m ? m : p && "Root" !== p && "root" !== p || !1
                      , w = _ || !1;
                    let E = f;
                    "Root" === p || "root" === p ? E = r : p ? E = l : function(e) {
                        return "string" === typeof e && e.charCodeAt(0) > 96
                    }(e) && (E = void 0);
                    const M = (0,
                    a.default)(e, (0,
                    i.default)({
                        shouldForwardProp: E,
                        label: undefined
                    }, x))
                      , C = e => "function" === typeof e && e.__emotion_real !== e || (0,
                    s.isPlainObject)(e) ? r => b(e, (0,
                    i.default)({}, r, {
                        theme: v({
                            theme: r.theme,
                            defaultTheme: n,
                            themeId: t
                        })
                    })) : e
                      , T = function(r) {
                        let o = C(r);
                        for (var a = arguments.length, s = new Array(a > 1 ? a - 1 : 0), l = 1; l < a; l++)
                            s[l - 1] = arguments[l];
                        const c = s ? s.map(C) : [];
                        d && A && c.push((e => {
                            const r = v((0,
                            i.default)({}, e, {
                                defaultTheme: n,
                                themeId: t
                            }));
                            if (!r.components || !r.components[d] || !r.components[d].styleOverrides)
                                return null;
                            const o = r.components[d].styleOverrides
                              , a = {};
                            return Object.entries(o).forEach((t => {
                                let[n,o] = t;
                                a[n] = b(o, (0,
                                i.default)({}, e, {
                                    theme: r
                                }))
                            }
                            )),
                            A(e, a)
                        }
                        )),
                        d && !S && c.push((e => {
                            var r;
                            const o = v((0,
                            i.default)({}, e, {
                                defaultTheme: n,
                                themeId: t
                            }));
                            return b({
                                variants: null == o || null == (r = o.components) || null == (r = r[d]) ? void 0 : r.variants
                            }, (0,
                            i.default)({}, e, {
                                theme: o
                            }))
                        }
                        )),
                        w || c.push(u);
                        const h = c.length - s.length;
                        if (Array.isArray(r) && h > 0) {
                            const e = new Array(h).fill("");
                            o = [...r, ...e],
                            o.raw = [...r.raw, ...e]
                        }
                        const p = M(o, ...c);
                        return e.muiName && (p.muiName = e.muiName),
                        p
                    };
                    return M.withConfig && (T.withConfig = M.withConfig),
                    T
                }
            }
            ;
            var i = r(n(4634))
              , o = r(n(4893))
              , a = function(e, t) {
                if (!t && e && e.__esModule)
                    return e;
                if (null === e || "object" != typeof e && "function" != typeof e)
                    return {
                        default: e
                    };
                var n = p(t);
                if (n && n.has(e))
                    return n.get(e);
                var r = {
                    __proto__: null
                }
                  , i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var o in e)
                    if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                        var a = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                        a && (a.get || a.set) ? Object.defineProperty(r, o, a) : r[o] = e[o]
                    }
                return r.default = e,
                n && n.set(e, r),
                r
            }(n(8661))
              , s = n(7785)
              , l = (r(n(304)),
            r(n(8399)),
            r(n(9904)))
              , c = r(n(8807));
            const u = ["ownerState"]
              , d = ["variants"]
              , h = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
            function p(e) {
                if ("function" != typeof WeakMap)
                    return null;
                var t = new WeakMap
                  , n = new WeakMap;
                return (p = function(e) {
                    return e ? n : t
                }
                )(e)
            }
            function f(e) {
                return "ownerState" !== e && "theme" !== e && "sx" !== e && "as" !== e
            }
            const m = (0,
            l.default)()
              , g = e => e ? e.charAt(0).toLowerCase() + e.slice(1) : e;
            function v(e) {
                let {defaultTheme: t, theme: n, themeId: r} = e;
                return i = n,
                0 === Object.keys(i).length ? t : n[r] || n;
                var i
            }
            function y(e) {
                return e ? (t, n) => n[e] : null
            }
            function b(e, t) {
                let {ownerState: n} = t
                  , r = (0,
                o.default)(t, u);
                const a = "function" === typeof e ? e((0,
                i.default)({
                    ownerState: n
                }, r)) : e;
                if (Array.isArray(a))
                    return a.flatMap((e => b(e, (0,
                    i.default)({
                        ownerState: n
                    }, r))));
                if (a && "object" === typeof a && Array.isArray(a.variants)) {
                    const {variants: e=[]} = a;
                    let t = (0,
                    o.default)(a, d);
                    return e.forEach((e => {
                        let o = !0;
                        "function" === typeof e.props ? o = e.props((0,
                        i.default)({
                            ownerState: n
                        }, r, n)) : Object.keys(e.props).forEach((t => {
                            (null == n ? void 0 : n[t]) !== e.props[t] && r[t] !== e.props[t] && (o = !1)
                        }
                        )),
                        o && (Array.isArray(t) || (t = [t]),
                        t.push("function" === typeof e.style ? e.style((0,
                        i.default)({
                            ownerState: n
                        }, r, n)) : e.style))
                    }
                    )),
                    t
                }
                return a
            }
        }
        ,
        6171: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => l,
                b: () => s
            });
            var r = n(9950)
              , i = n(5537)
              , o = n(4414);
            const a = r.createContext(void 0);
            function s(e) {
                let {props: t, name: n} = e;
                return function(e) {
                    const {theme: t, name: n, props: r} = e;
                    if (!t || !t.components || !t.components[n])
                        return r;
                    const o = t.components[n];
                    return o.defaultProps ? (0,
                    i.A)(o.defaultProps, r) : o.styleOverrides || o.variants ? r : (0,
                    i.A)(o, r)
                }({
                    props: t,
                    name: n,
                    theme: {
                        components: r.useContext(a)
                    }
                })
            }
            const l = function(e) {
                let {value: t, children: n} = e;
                return (0,
                o.jsx)(a.Provider, {
                    value: t,
                    children: n
                })
            }
        }
        ,
        8286: (e, t, n) => {
            "use strict";
            n.d(t, {
                EU: () => a,
                NI: () => o,
                kW: () => l,
                vf: () => s,
                zu: () => r
            });
            const r = {
                xs: 0,
                sm: 600,
                md: 900,
                lg: 1200,
                xl: 1536
            }
              , i = {
                keys: ["xs", "sm", "md", "lg", "xl"],
                up: e => `@media (min-width:${r[e]}px)`
            };
            function o(e, t, n) {
                const o = e.theme || {};
                if (Array.isArray(t)) {
                    const e = o.breakpoints || i;
                    return t.reduce(( (r, i, o) => (r[e.up(e.keys[o])] = n(t[o]),
                    r)), {})
                }
                if ("object" === typeof t) {
                    const e = o.breakpoints || i;
                    return Object.keys(t).reduce(( (i, o) => {
                        if (-1 !== Object.keys(e.values || r).indexOf(o)) {
                            i[e.up(o)] = n(t[o], o)
                        } else {
                            const e = o;
                            i[e] = t[e]
                        }
                        return i
                    }
                    ), {})
                }
                return n(t)
            }
            function a() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                var t;
                return (null == (t = e.keys) ? void 0 : t.reduce(( (t, n) => (t[e.up(n)] = {},
                t)), {})) || {}
            }
            function s(e, t) {
                return e.reduce(( (e, t) => {
                    const n = e[t];
                    return (!n || 0 === Object.keys(n).length) && delete e[t],
                    e
                }
                ), t)
            }
            function l(e) {
                let {values: t, breakpoints: n, base: r} = e;
                const i = r || function(e, t) {
                    if ("object" !== typeof e)
                        return {};
                    const n = {}
                      , r = Object.keys(t);
                    return Array.isArray(e) ? r.forEach(( (t, r) => {
                        r < e.length && (n[t] = !0)
                    }
                    )) : r.forEach((t => {
                        null != e[t] && (n[t] = !0)
                    }
                    )),
                    n
                }(t, n)
                  , o = Object.keys(i);
                if (0 === o.length)
                    return t;
                let a;
                return o.reduce(( (e, n, r) => (Array.isArray(t) ? (e[n] = null != t[r] ? t[r] : t[a],
                a = r) : "object" === typeof t ? (e[n] = null != t[n] ? t[n] : t[a],
                a = n) : e[n] = t,
                e)), {})
            }
        }
        ,
        86: (e, t, n) => {
            "use strict";
            function r(e, t) {
                const n = this;
                if (n.vars && "function" === typeof n.getColorSchemeSelector) {
                    const r = n.getColorSchemeSelector(e).replace(/(\[[^\]]+\])/, "*:where($1)");
                    return {
                        [r]: t
                    }
                }
                return n.palette.mode === e ? t : {}
            }
            n.d(t, {
                A: () => r
            })
        }
        ,
        3628: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => s
            });
            var r = n(8587)
              , i = n(8168);
            const o = ["values", "unit", "step"]
              , a = e => {
                const t = Object.keys(e).map((t => ({
                    key: t,
                    val: e[t]
                }))) || [];
                return t.sort(( (e, t) => e.val - t.val)),
                t.reduce(( (e, t) => (0,
                i.A)({}, e, {
                    [t.key]: t.val
                })), {})
            }
            ;
            function s(e) {
                const {values: t={
                    xs: 0,
                    sm: 600,
                    md: 900,
                    lg: 1200,
                    xl: 1536
                }, unit: n="px", step: s=5} = e
                  , l = (0,
                r.A)(e, o)
                  , c = a(t)
                  , u = Object.keys(c);
                function d(e) {
                    return `@media (min-width:${"number" === typeof t[e] ? t[e] : e}${n})`
                }
                function h(e) {
                    return `@media (max-width:${("number" === typeof t[e] ? t[e] : e) - s / 100}${n})`
                }
                function p(e, r) {
                    const i = u.indexOf(r);
                    return `@media (min-width:${"number" === typeof t[e] ? t[e] : e}${n}) and (max-width:${(-1 !== i && "number" === typeof t[u[i]] ? t[u[i]] : r) - s / 100}${n})`
                }
                return (0,
                i.A)({
                    keys: u,
                    values: c,
                    up: d,
                    down: h,
                    between: p,
                    only: function(e) {
                        return u.indexOf(e) + 1 < u.length ? p(e, u[u.indexOf(e) + 1]) : d(e)
                    },
                    not: function(e) {
                        const t = u.indexOf(e);
                        return 0 === t ? d(u[1]) : t === u.length - 1 ? h(u[t]) : p(e, u[u.indexOf(e) + 1]).replace("@media", "@media not all and")
                    },
                    unit: n
                }, l)
            }
        }
        ,
        2860: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => p
            });
            var r = n(8168)
              , i = n(8587)
              , o = n(7483)
              , a = n(3628);
            const s = {
                borderRadius: 4
            };
            var l = n(7937);
            var c = n(505)
              , u = n(8076)
              , d = n(86);
            const h = ["breakpoints", "palette", "spacing", "shape"];
            const p = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const {breakpoints: t={}, palette: n={}, spacing: p, shape: f={}} = e
                  , m = (0,
                i.A)(e, h)
                  , g = (0,
                a.A)(t)
                  , v = function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8;
                    if (e.mui)
                        return e;
                    const t = (0,
                    l.LX)({
                        spacing: e
                    })
                      , n = function() {
                        for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
                            n[r] = arguments[r];
                        return (0 === n.length ? [1] : n).map((e => {
                            const n = t(e);
                            return "number" === typeof n ? `${n}px` : n
                        }
                        )).join(" ")
                    };
                    return n.mui = !0,
                    n
                }(p);
                let y = (0,
                o.A)({
                    breakpoints: g,
                    direction: "ltr",
                    components: {},
                    palette: (0,
                    r.A)({
                        mode: "light"
                    }, n),
                    spacing: v,
                    shape: (0,
                    r.A)({}, s, f)
                }, m);
                y.applyStyles = d.A;
                for (var b = arguments.length, _ = new Array(b > 1 ? b - 1 : 0), A = 1; A < b; A++)
                    _[A - 1] = arguments[A];
                return y = _.reduce(( (e, t) => (0,
                o.A)(e, t)), y),
                y.unstable_sxConfig = (0,
                r.A)({}, u.A, null == m ? void 0 : m.unstable_sxConfig),
                y.unstable_sx = function(e) {
                    return (0,
                    c.A)({
                        sx: e,
                        theme: this
                    })
                }
                ,
                y
            }
        }
        ,
        9904: (e, t, n) => {
            "use strict";
            n.r(t),
            n.d(t, {
                default: () => r.A,
                private_createBreakpoints: () => i.A,
                unstable_applyStyles: () => o.A
            });
            var r = n(2860)
              , i = n(3628)
              , o = n(86)
        }
        ,
        6206: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => i
            });
            var r = n(7483);
            const i = function(e, t) {
                return t ? (0,
                r.A)(e, t, {
                    clone: !1
                }) : e
            }
        }
        ,
        7937: (e, t, n) => {
            "use strict";
            n.d(t, {
                LX: () => f,
                MA: () => p,
                _W: () => m,
                Lc: () => y,
                Ms: () => b
            });
            var r = n(8286)
              , i = n(2703)
              , o = n(6206);
            const a = {
                m: "margin",
                p: "padding"
            }
              , s = {
                t: "Top",
                r: "Right",
                b: "Bottom",
                l: "Left",
                x: ["Left", "Right"],
                y: ["Top", "Bottom"]
            }
              , l = {
                marginX: "mx",
                marginY: "my",
                paddingX: "px",
                paddingY: "py"
            }
              , c = function(e) {
                const t = {};
                return n => (void 0 === t[n] && (t[n] = e(n)),
                t[n])
            }((e => {
                if (e.length > 2) {
                    if (!l[e])
                        return [e];
                    e = l[e]
                }
                const [t,n] = e.split("")
                  , r = a[t]
                  , i = s[n] || "";
                return Array.isArray(i) ? i.map((e => r + e)) : [r + i]
            }
            ))
              , u = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"]
              , d = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"]
              , h = [...u, ...d];
            function p(e, t, n, r) {
                var o;
                const a = null != (o = (0,
                i.Yn)(e, t, !1)) ? o : n;
                return "number" === typeof a ? e => "string" === typeof e ? e : a * e : Array.isArray(a) ? e => "string" === typeof e ? e : a[e] : "function" === typeof a ? a : () => {}
            }
            function f(e) {
                return p(e, "spacing", 8)
            }
            function m(e, t) {
                if ("string" === typeof t || null == t)
                    return t;
                const n = e(Math.abs(t));
                return t >= 0 ? n : "number" === typeof n ? -n : `-${n}`
            }
            function g(e, t, n, i) {
                if (-1 === t.indexOf(n))
                    return null;
                const o = function(e, t) {
                    return n => e.reduce(( (e, r) => (e[r] = m(t, n),
                    e)), {})
                }(c(n), i)
                  , a = e[n];
                return (0,
                r.NI)(e, a, o)
            }
            function v(e, t) {
                const n = f(e.theme);
                return Object.keys(e).map((r => g(e, t, r, n))).reduce(o.A, {})
            }
            function y(e) {
                return v(e, u)
            }
            function b(e) {
                return v(e, d)
            }
            function _(e) {
                return v(e, h)
            }
            y.propTypes = {},
            y.filterProps = u,
            b.propTypes = {},
            b.filterProps = d,
            _.propTypes = {},
            _.filterProps = h
        }
        ,
        2703: (e, t, n) => {
            "use strict";
            n.d(t, {
                Ay: () => s,
                BO: () => a,
                Yn: () => o
            });
            var r = n(5501)
              , i = n(8286);
            function o(e, t) {
                let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                if (!t || "string" !== typeof t)
                    return null;
                if (e && e.vars && n) {
                    const n = `vars.${t}`.split(".").reduce(( (e, t) => e && e[t] ? e[t] : null), e);
                    if (null != n)
                        return n
                }
                return t.split(".").reduce(( (e, t) => e && null != e[t] ? e[t] : null), e)
            }
            function a(e, t, n) {
                let r, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : n;
                return r = "function" === typeof e ? e(n) : Array.isArray(e) ? e[n] || i : o(e, n) || i,
                t && (r = t(r, i, e)),
                r
            }
            const s = function(e) {
                const {prop: t, cssProperty: n=e.prop, themeKey: s, transform: l} = e
                  , c = e => {
                    if (null == e[t])
                        return null;
                    const c = e[t]
                      , u = o(e.theme, s) || {};
                    return (0,
                    i.NI)(e, c, (e => {
                        let i = a(u, l, e);
                        return e === i && "string" === typeof e && (i = a(u, l, `${t}${"default" === e ? "" : (0,
                        r.A)(e)}`, e)),
                        !1 === n ? i : {
                            [n]: i
                        }
                    }
                    ))
                }
                ;
                return c.propTypes = {},
                c.filterProps = [t],
                c
            }
        }
        ,
        8076: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => k
            });
            var r = n(7937)
              , i = n(2703)
              , o = n(6206);
            const a = function() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                const r = t.reduce(( (e, t) => (t.filterProps.forEach((n => {
                    e[n] = t
                }
                )),
                e)), {})
                  , i = e => Object.keys(e).reduce(( (t, n) => r[n] ? (0,
                o.A)(t, r[n](e)) : t), {});
                return i.propTypes = {},
                i.filterProps = t.reduce(( (e, t) => e.concat(t.filterProps)), []),
                i
            };
            var s = n(8286);
            function l(e) {
                return "number" !== typeof e ? e : `${e}px solid`
            }
            function c(e, t) {
                return (0,
                i.Ay)({
                    prop: e,
                    themeKey: "borders",
                    transform: t
                })
            }
            const u = c("border", l)
              , d = c("borderTop", l)
              , h = c("borderRight", l)
              , p = c("borderBottom", l)
              , f = c("borderLeft", l)
              , m = c("borderColor")
              , g = c("borderTopColor")
              , v = c("borderRightColor")
              , y = c("borderBottomColor")
              , b = c("borderLeftColor")
              , _ = c("outline", l)
              , A = c("outlineColor")
              , x = e => {
                if (void 0 !== e.borderRadius && null !== e.borderRadius) {
                    const t = (0,
                    r.MA)(e.theme, "shape.borderRadius", 4, "borderRadius")
                      , n = e => ({
                        borderRadius: (0,
                        r._W)(t, e)
                    });
                    return (0,
                    s.NI)(e, e.borderRadius, n)
                }
                return null
            }
            ;
            x.propTypes = {},
            x.filterProps = ["borderRadius"];
            a(u, d, h, p, f, m, g, v, y, b, x, _, A);
            const S = e => {
                if (void 0 !== e.gap && null !== e.gap) {
                    const t = (0,
                    r.MA)(e.theme, "spacing", 8, "gap")
                      , n = e => ({
                        gap: (0,
                        r._W)(t, e)
                    });
                    return (0,
                    s.NI)(e, e.gap, n)
                }
                return null
            }
            ;
            S.propTypes = {},
            S.filterProps = ["gap"];
            const w = e => {
                if (void 0 !== e.columnGap && null !== e.columnGap) {
                    const t = (0,
                    r.MA)(e.theme, "spacing", 8, "columnGap")
                      , n = e => ({
                        columnGap: (0,
                        r._W)(t, e)
                    });
                    return (0,
                    s.NI)(e, e.columnGap, n)
                }
                return null
            }
            ;
            w.propTypes = {},
            w.filterProps = ["columnGap"];
            const E = e => {
                if (void 0 !== e.rowGap && null !== e.rowGap) {
                    const t = (0,
                    r.MA)(e.theme, "spacing", 8, "rowGap")
                      , n = e => ({
                        rowGap: (0,
                        r._W)(t, e)
                    });
                    return (0,
                    s.NI)(e, e.rowGap, n)
                }
                return null
            }
            ;
            E.propTypes = {},
            E.filterProps = ["rowGap"];
            a(S, w, E, (0,
            i.Ay)({
                prop: "gridColumn"
            }), (0,
            i.Ay)({
                prop: "gridRow"
            }), (0,
            i.Ay)({
                prop: "gridAutoFlow"
            }), (0,
            i.Ay)({
                prop: "gridAutoColumns"
            }), (0,
            i.Ay)({
                prop: "gridAutoRows"
            }), (0,
            i.Ay)({
                prop: "gridTemplateColumns"
            }), (0,
            i.Ay)({
                prop: "gridTemplateRows"
            }), (0,
            i.Ay)({
                prop: "gridTemplateAreas"
            }), (0,
            i.Ay)({
                prop: "gridArea"
            }));
            function M(e, t) {
                return "grey" === t ? t : e
            }
            a((0,
            i.Ay)({
                prop: "color",
                themeKey: "palette",
                transform: M
            }), (0,
            i.Ay)({
                prop: "bgcolor",
                cssProperty: "backgroundColor",
                themeKey: "palette",
                transform: M
            }), (0,
            i.Ay)({
                prop: "backgroundColor",
                themeKey: "palette",
                transform: M
            }));
            function C(e) {
                return e <= 1 && 0 !== e ? 100 * e + "%" : e
            }
            const T = (0,
            i.Ay)({
                prop: "width",
                transform: C
            })
              , R = e => {
                if (void 0 !== e.maxWidth && null !== e.maxWidth) {
                    const t = t => {
                        var n, r;
                        const i = (null == (n = e.theme) || null == (n = n.breakpoints) || null == (n = n.values) ? void 0 : n[t]) || s.zu[t];
                        return i ? "px" !== (null == (r = e.theme) || null == (r = r.breakpoints) ? void 0 : r.unit) ? {
                            maxWidth: `${i}${e.theme.breakpoints.unit}`
                        } : {
                            maxWidth: i
                        } : {
                            maxWidth: C(t)
                        }
                    }
                    ;
                    return (0,
                    s.NI)(e, e.maxWidth, t)
                }
                return null
            }
            ;
            R.filterProps = ["maxWidth"];
            const P = (0,
            i.Ay)({
                prop: "minWidth",
                transform: C
            })
              , B = (0,
            i.Ay)({
                prop: "height",
                transform: C
            })
              , I = (0,
            i.Ay)({
                prop: "maxHeight",
                transform: C
            })
              , L = (0,
            i.Ay)({
                prop: "minHeight",
                transform: C
            })
              , k = ((0,
            i.Ay)({
                prop: "size",
                cssProperty: "width",
                transform: C
            }),
            (0,
            i.Ay)({
                prop: "size",
                cssProperty: "height",
                transform: C
            }),
            a(T, R, P, B, I, L, (0,
            i.Ay)({
                prop: "boxSizing"
            })),
            {
                border: {
                    themeKey: "borders",
                    transform: l
                },
                borderTop: {
                    themeKey: "borders",
                    transform: l
                },
                borderRight: {
                    themeKey: "borders",
                    transform: l
                },
                borderBottom: {
                    themeKey: "borders",
                    transform: l
                },
                borderLeft: {
                    themeKey: "borders",
                    transform: l
                },
                borderColor: {
                    themeKey: "palette"
                },
                borderTopColor: {
                    themeKey: "palette"
                },
                borderRightColor: {
                    themeKey: "palette"
                },
                borderBottomColor: {
                    themeKey: "palette"
                },
                borderLeftColor: {
                    themeKey: "palette"
                },
                outline: {
                    themeKey: "borders",
                    transform: l
                },
                outlineColor: {
                    themeKey: "palette"
                },
                borderRadius: {
                    themeKey: "shape.borderRadius",
                    style: x
                },
                color: {
                    themeKey: "palette",
                    transform: M
                },
                bgcolor: {
                    themeKey: "palette",
                    cssProperty: "backgroundColor",
                    transform: M
                },
                backgroundColor: {
                    themeKey: "palette",
                    transform: M
                },
                p: {
                    style: r.Ms
                },
                pt: {
                    style: r.Ms
                },
                pr: {
                    style: r.Ms
                },
                pb: {
                    style: r.Ms
                },
                pl: {
                    style: r.Ms
                },
                px: {
                    style: r.Ms
                },
                py: {
                    style: r.Ms
                },
                padding: {
                    style: r.Ms
                },
                paddingTop: {
                    style: r.Ms
                },
                paddingRight: {
                    style: r.Ms
                },
                paddingBottom: {
                    style: r.Ms
                },
                paddingLeft: {
                    style: r.Ms
                },
                paddingX: {
                    style: r.Ms
                },
                paddingY: {
                    style: r.Ms
                },
                paddingInline: {
                    style: r.Ms
                },
                paddingInlineStart: {
                    style: r.Ms
                },
                paddingInlineEnd: {
                    style: r.Ms
                },
                paddingBlock: {
                    style: r.Ms
                },
                paddingBlockStart: {
                    style: r.Ms
                },
                paddingBlockEnd: {
                    style: r.Ms
                },
                m: {
                    style: r.Lc
                },
                mt: {
                    style: r.Lc
                },
                mr: {
                    style: r.Lc
                },
                mb: {
                    style: r.Lc
                },
                ml: {
                    style: r.Lc
                },
                mx: {
                    style: r.Lc
                },
                my: {
                    style: r.Lc
                },
                margin: {
                    style: r.Lc
                },
                marginTop: {
                    style: r.Lc
                },
                marginRight: {
                    style: r.Lc
                },
                marginBottom: {
                    style: r.Lc
                },
                marginLeft: {
                    style: r.Lc
                },
                marginX: {
                    style: r.Lc
                },
                marginY: {
                    style: r.Lc
                },
                marginInline: {
                    style: r.Lc
                },
                marginInlineStart: {
                    style: r.Lc
                },
                marginInlineEnd: {
                    style: r.Lc
                },
                marginBlock: {
                    style: r.Lc
                },
                marginBlockStart: {
                    style: r.Lc
                },
                marginBlockEnd: {
                    style: r.Lc
                },
                displayPrint: {
                    cssProperty: !1,
                    transform: e => ({
                        "@media print": {
                            display: e
                        }
                    })
                },
                display: {},
                overflow: {},
                textOverflow: {},
                visibility: {},
                whiteSpace: {},
                flexBasis: {},
                flexDirection: {},
                flexWrap: {},
                justifyContent: {},
                alignItems: {},
                alignContent: {},
                order: {},
                flex: {},
                flexGrow: {},
                flexShrink: {},
                alignSelf: {},
                justifyItems: {},
                justifySelf: {},
                gap: {
                    style: S
                },
                rowGap: {
                    style: E
                },
                columnGap: {
                    style: w
                },
                gridColumn: {},
                gridRow: {},
                gridAutoFlow: {},
                gridAutoColumns: {},
                gridAutoRows: {},
                gridTemplateColumns: {},
                gridTemplateRows: {},
                gridTemplateAreas: {},
                gridArea: {},
                position: {},
                zIndex: {
                    themeKey: "zIndex"
                },
                top: {},
                right: {},
                bottom: {},
                left: {},
                boxShadow: {
                    themeKey: "shadows"
                },
                width: {
                    transform: C
                },
                maxWidth: {
                    style: R
                },
                minWidth: {
                    transform: C
                },
                height: {
                    transform: C
                },
                maxHeight: {
                    transform: C
                },
                minHeight: {
                    transform: C
                },
                boxSizing: {},
                fontFamily: {
                    themeKey: "typography"
                },
                fontSize: {
                    themeKey: "typography"
                },
                fontStyle: {
                    themeKey: "typography"
                },
                fontWeight: {
                    themeKey: "typography"
                },
                letterSpacing: {},
                textTransform: {},
                lineHeight: {},
                textAlign: {},
                typography: {
                    cssProperty: !1,
                    themeKey: "typography"
                }
            })
        }
        ,
        237: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => c
            });
            var r = n(8168)
              , i = n(8587)
              , o = n(7483)
              , a = n(8076);
            const s = ["sx"]
              , l = e => {
                var t, n;
                const r = {
                    systemProps: {},
                    otherProps: {}
                }
                  , i = null != (t = null == e || null == (n = e.theme) ? void 0 : n.unstable_sxConfig) ? t : a.A;
                return Object.keys(e).forEach((t => {
                    i[t] ? r.systemProps[t] = e[t] : r.otherProps[t] = e[t]
                }
                )),
                r
            }
            ;
            function c(e) {
                const {sx: t} = e
                  , n = (0,
                i.A)(e, s)
                  , {systemProps: a, otherProps: c} = l(n);
                let u;
                return u = Array.isArray(t) ? [a, ...t] : "function" === typeof t ? function() {
                    const e = t(...arguments);
                    return (0,
                    o.Q)(e) ? (0,
                    r.A)({}, a, e) : a
                }
                : (0,
                r.A)({}, a, t),
                (0,
                r.A)({}, c, {
                    sx: u
                })
            }
        }
        ,
        8807: (e, t, n) => {
            "use strict";
            n.r(t),
            n.d(t, {
                default: () => r.A,
                extendSxProp: () => i.A,
                unstable_createStyleFunctionSx: () => r.k,
                unstable_defaultSxConfig: () => o.A
            });
            var r = n(505)
              , i = n(237)
              , o = n(8076)
        }
        ,
        505: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => u,
                k: () => l
            });
            var r = n(5501)
              , i = n(6206)
              , o = n(2703)
              , a = n(8286)
              , s = n(8076);
            function l() {
                function e(e, t, n, i) {
                    const s = {
                        [e]: t,
                        theme: n
                    }
                      , l = i[e];
                    if (!l)
                        return {
                            [e]: t
                        };
                    const {cssProperty: c=e, themeKey: u, transform: d, style: h} = l;
                    if (null == t)
                        return null;
                    if ("typography" === u && "inherit" === t)
                        return {
                            [e]: t
                        };
                    const p = (0,
                    o.Yn)(n, u) || {};
                    if (h)
                        return h(s);
                    return (0,
                    a.NI)(s, t, (t => {
                        let n = (0,
                        o.BO)(p, d, t);
                        return t === n && "string" === typeof t && (n = (0,
                        o.BO)(p, d, `${e}${"default" === t ? "" : (0,
                        r.A)(t)}`, t)),
                        !1 === c ? n : {
                            [c]: n
                        }
                    }
                    ))
                }
                return function t(n) {
                    var r;
                    const {sx: o, theme: l={}} = n || {};
                    if (!o)
                        return null;
                    const c = null != (r = l.unstable_sxConfig) ? r : s.A;
                    function u(n) {
                        let r = n;
                        if ("function" === typeof n)
                            r = n(l);
                        else if ("object" !== typeof n)
                            return n;
                        if (!r)
                            return null;
                        const o = (0,
                        a.EU)(l.breakpoints)
                          , s = Object.keys(o);
                        let u = o;
                        return Object.keys(r).forEach((n => {
                            const o = (s = r[n],
                            d = l,
                            "function" === typeof s ? s(d) : s);
                            var s, d;
                            if (null !== o && void 0 !== o)
                                if ("object" === typeof o)
                                    if (c[n])
                                        u = (0,
                                        i.A)(u, e(n, o, l, c));
                                    else {
                                        const e = (0,
                                        a.NI)({
                                            theme: l
                                        }, o, (e => ({
                                            [n]: e
                                        })));
                                        !function() {
                                            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                                                t[n] = arguments[n];
                                            const r = t.reduce(( (e, t) => e.concat(Object.keys(t))), [])
                                              , i = new Set(r);
                                            return t.every((e => i.size === Object.keys(e).length))
                                        }(e, o) ? u = (0,
                                        i.A)(u, e) : u[n] = t({
                                            sx: o,
                                            theme: l
                                        })
                                    }
                                else
                                    u = (0,
                                    i.A)(u, e(n, o, l, c))
                        }
                        )),
                        (0,
                        a.vf)(s, u)
                    }
                    return Array.isArray(o) ? o.map(u) : u(o)
                }
            }
            const c = l();
            c.filterProps = ["sx"];
            const u = c
        }
        ,
        5329: (e, t, n) => {
            "use strict";
            t.A = void 0;
            var r = function(e, t) {
                if (!t && e && e.__esModule)
                    return e;
                if (null === e || "object" != typeof e && "function" != typeof e)
                    return {
                        default: e
                    };
                var n = o(t);
                if (n && n.has(e))
                    return n.get(e);
                var r = {
                    __proto__: null
                }
                  , i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var a in e)
                    if ("default" !== a && Object.prototype.hasOwnProperty.call(e, a)) {
                        var s = i ? Object.getOwnPropertyDescriptor(e, a) : null;
                        s && (s.get || s.set) ? Object.defineProperty(r, a, s) : r[a] = e[a]
                    }
                return r.default = e,
                n && n.set(e, r),
                r
            }(n(9950))
              , i = n(8661);
            function o(e) {
                if ("function" != typeof WeakMap)
                    return null;
                var t = new WeakMap
                  , n = new WeakMap;
                return (o = function(e) {
                    return e ? n : t
                }
                )(e)
            }
            t.A = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                const t = r.useContext(i.ThemeContext);
                return t && (n = t,
                0 !== Object.keys(n).length) ? t : e;
                var n
            }
        }
        ,
        4501: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => i
            });
            const r = e => e
              , i = ( () => {
                let e = r;
                return {
                    configure(t) {
                        e = t
                    },
                    generate: t => e(t),
                    reset() {
                        e = r
                    }
                }
            }
            )()
        }
        ,
        5501: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => i
            });
            var r = n(8099);
            function i(e) {
                if ("string" !== typeof e)
                    throw new Error((0,
                    r.A)(7));
                return e.charAt(0).toUpperCase() + e.slice(1)
            }
        }
        ,
        304: (e, t, n) => {
            "use strict";
            n.r(t),
            n.d(t, {
                default: () => r.A
            });
            var r = n(5501)
        }
        ,
        3383: (e, t, n) => {
            "use strict";
            n.r(t),
            n.d(t, {
                default: () => r
            });
            const r = function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MIN_SAFE_INTEGER
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number.MAX_SAFE_INTEGER;
                return Math.max(t, Math.min(e, n))
            }
        }
        ,
        8465: (e, t, n) => {
            "use strict";
            function r(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
                const r = {};
                return Object.keys(e).forEach((i => {
                    r[i] = e[i].reduce(( (e, r) => {
                        if (r) {
                            const i = t(r);
                            "" !== i && e.push(i),
                            n && n[r] && e.push(n[r])
                        }
                        return e
                    }
                    ), []).join(" ")
                }
                )),
                r
            }
            n.d(t, {
                A: () => r
            })
        }
        ,
        5511: (e, t, n) => {
            "use strict";
            function r() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                return t.reduce(( (e, t) => null == t ? e : function() {
                    for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
                        r[i] = arguments[i];
                    e.apply(this, r),
                    t.apply(this, r)
                }
                ), ( () => {}
                ))
            }
            n.d(t, {
                A: () => r
            })
        }
        ,
        7483: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => a,
                Q: () => i
            });
            var r = n(8168);
            function i(e) {
                if ("object" !== typeof e || null === e)
                    return !1;
                const t = Object.getPrototypeOf(e);
                return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
            }
            function o(e) {
                if (!i(e))
                    return e;
                const t = {};
                return Object.keys(e).forEach((n => {
                    t[n] = o(e[n])
                }
                )),
                t
            }
            function a(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                    clone: !0
                };
                const s = n.clone ? (0,
                r.A)({}, e) : e;
                return i(e) && i(t) && Object.keys(t).forEach((r => {
                    i(t[r]) && Object.prototype.hasOwnProperty.call(e, r) && i(e[r]) ? s[r] = a(e[r], t[r], n) : n.clone ? s[r] = i(t[r]) ? o(t[r]) : t[r] : s[r] = t[r]
                }
                )),
                s
            }
        }
        ,
        7785: (e, t, n) => {
            "use strict";
            n.r(t),
            n.d(t, {
                default: () => r.A,
                isPlainObject: () => r.Q
            });
            var r = n(7483)
        }
        ,
        8099: (e, t, n) => {
            "use strict";
            function r(e) {
                let t = "https://mui.com/production-error/?code=" + e;
                for (let n = 1; n < arguments.length; n += 1)
                    t += "&args[]=" + encodeURIComponent(arguments[n]);
                return "Minified MUI error #" + e + "; visit " + t + " for the full message."
            }
            n.d(t, {
                A: () => r
            })
        }
        ,
        9234: (e, t, n) => {
            "use strict";
            n.r(t),
            n.d(t, {
                default: () => r.A
            });
            var r = n(8099)
        }
        ,
        423: (e, t, n) => {
            "use strict";
            n.d(t, {
                Ay: () => o
            });
            var r = n(4501);
            const i = {
                active: "active",
                checked: "checked",
                completed: "completed",
                disabled: "disabled",
                error: "error",
                expanded: "expanded",
                focused: "focused",
                focusVisible: "focusVisible",
                open: "open",
                readOnly: "readOnly",
                required: "required",
                selected: "selected"
            };
            function o(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "Mui";
                const o = i[t];
                return o ? `${n}-${o}` : `${r.A.generate(e)}-${t}`
            }
        }
        ,
        1763: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => i
            });
            var r = n(423);
            function i(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "Mui";
                const i = {};
                return t.forEach((t => {
                    i[t] = (0,
                    r.Ay)(e, t, n)
                }
                )),
                i
            }
        }
        ,
        8399: (e, t, n) => {
            "use strict";
            n.r(t),
            n.d(t, {
                default: () => l,
                getFunctionName: () => o
            });
            var r = n(6429);
            const i = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
            function o(e) {
                const t = `${e}`.match(i);
                return t && t[1] || ""
            }
            function a(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                return e.displayName || e.name || o(e) || t
            }
            function s(e, t, n) {
                const r = a(t);
                return e.displayName || ("" !== r ? `${n}(${r})` : n)
            }
            function l(e) {
                if (null != e) {
                    if ("string" === typeof e)
                        return e;
                    if ("function" === typeof e)
                        return a(e, "Component");
                    if ("object" === typeof e)
                        switch (e.$$typeof) {
                        case r.ForwardRef:
                            return s(e, e.render, "ForwardRef");
                        case r.Memo:
                            return s(e, e.type, "memo");
                        default:
                            return
                        }
                }
            }
        }
        ,
        6907: (e, t, n) => {
            "use strict";
            function r(e) {
                return e && e.ownerDocument || document
            }
            n.d(t, {
                A: () => r
            })
        }
        ,
        8635: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => i
            });
            var r = n(6907);
            function i(e) {
                return (0,
                r.A)(e).defaultView || window
            }
        }
        ,
        5537: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => i
            });
            var r = n(8168);
            function i(e, t) {
                const n = (0,
                r.A)({}, t);
                return Object.keys(e).forEach((o => {
                    if (o.toString().match(/^(components|slots)$/))
                        n[o] = (0,
                        r.A)({}, e[o], n[o]);
                    else if (o.toString().match(/^(componentsProps|slotProps)$/)) {
                        const a = e[o] || {}
                          , s = t[o];
                        n[o] = {},
                        s && Object.keys(s) ? a && Object.keys(a) ? (n[o] = (0,
                        r.A)({}, s),
                        Object.keys(a).forEach((e => {
                            n[o][e] = i(a[e], s[e])
                        }
                        ))) : n[o] = s : n[o] = a
                    } else
                        void 0 === n[o] && (n[o] = e[o])
                }
                )),
                n
            }
        }
        ,
        5587: (e, t, n) => {
            "use strict";
            function r(e, t) {
                "function" === typeof e ? e(t) : e && (e.current = t)
            }
            n.d(t, {
                A: () => r
            })
        }
        ,
        1399: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => i
            });
            var r = n(9950);
            const i = "undefined" !== typeof window ? r.useLayoutEffect : r.useEffect
        }
        ,
        2529: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var r = n(9950)
              , i = n(1399);
            const o = function(e) {
                const t = r.useRef(e);
                return (0,
                i.A)(( () => {
                    t.current = e
                }
                )),
                r.useRef((function() {
                    return (0,
                    t.current)(...arguments)
                }
                )).current
            }
        }
        ,
        5393: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var r = n(9950)
              , i = n(5587);
            function o() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                return r.useMemo(( () => t.every((e => null == e)) ? null : e => {
                    t.forEach((t => {
                        (0,
                        i.A)(t, e)
                    }
                    ))
                }
                ), t)
            }
        }
        ,
        3539: (e, t, n) => {
            "use strict";
            var r;
            n.d(t, {
                A: () => s
            });
            var i = n(9950);
            let o = 0;
            const a = (r || (r = n.t(i, 2)))["useId".toString()];
            function s(e) {
                if (void 0 !== a) {
                    const t = a();
                    return null != e ? e : t
                }
                return function(e) {
                    const [t,n] = i.useState(e)
                      , r = e || t;
                    return i.useEffect(( () => {
                        null == t && (o += 1,
                        n(`mui-${o}`))
                    }
                    ), [t]),
                    r
                }(e)
            }
        }
        ,
        1824: (e, t, n) => {
            "use strict";
            n.d(t, {
                E: () => a,
                A: () => s
            });
            var r = n(9950);
            const i = {};
            const o = [];
            class a {
                constructor() {
                    this.currentId = null,
                    this.clear = () => {
                        null !== this.currentId && (clearTimeout(this.currentId),
                        this.currentId = null)
                    }
                    ,
                    this.disposeEffect = () => this.clear
                }
                static create() {
                    return new a
                }
                start(e, t) {
                    this.clear(),
                    this.currentId = setTimeout(( () => {
                        this.currentId = null,
                        t()
                    }
                    ), e)
                }
            }
            function s() {
                const e = function(e, t) {
                    const n = r.useRef(i);
                    return n.current === i && (n.current = e(t)),
                    n
                }(a.create).current;
                var t;
                return t = e.disposeEffect,
                r.useEffect(t, o),
                e
            }
        }
        ,
        2803: (e, t, n) => {
            "use strict";
            function r(e) {
                var t, n, i = "";
                if ("string" == typeof e || "number" == typeof e)
                    i += e;
                else if ("object" == typeof e)
                    if (Array.isArray(e))
                        for (t = 0; t < e.length; t++)
                            e[t] && (n = r(e[t])) && (i && (i += " "),
                            i += n);
                    else
                        for (t in e)
                            e[t] && (i && (i += " "),
                            i += t);
                return i
            }
            function i() {
                for (var e, t, n = 0, i = ""; n < arguments.length; )
                    (e = arguments[n++]) && (t = r(e)) && (i && (i += " "),
                    i += t);
                return i
            }
            n.r(t),
            n.d(t, {
                clsx: () => i,
                default: () => o
            });
            const o = i
        }
        ,
        9356: e => {
            function t(e, t, n) {
                var r, i, o, a, s;
                function l() {
                    var c = Date.now() - a;
                    c < t && c >= 0 ? r = setTimeout(l, t - c) : (r = null,
                    n || (s = e.apply(o, i),
                    o = i = null))
                }
                null == t && (t = 100);
                var c = function() {
                    o = this,
                    i = arguments,
                    a = Date.now();
                    var c = n && !r;
                    return r || (r = setTimeout(l, t)),
                    c && (s = e.apply(o, i),
                    o = i = null),
                    s
                };
                return c.clear = function() {
                    r && (clearTimeout(r),
                    r = null)
                }
                ,
                c.flush = function() {
                    r && (s = e.apply(o, i),
                    o = i = null,
                    clearTimeout(r),
                    r = null)
                }
                ,
                c
            }
            t.debounce = t,
            e.exports = t
        }
        ,
        3876: (e, t, n) => {
            "use strict";
            var r = n(630)
              , i = {
                childContextTypes: !0,
                contextType: !0,
                contextTypes: !0,
                defaultProps: !0,
                displayName: !0,
                getDefaultProps: !0,
                getDerivedStateFromError: !0,
                getDerivedStateFromProps: !0,
                mixins: !0,
                propTypes: !0,
                type: !0
            }
              , o = {
                name: !0,
                length: !0,
                prototype: !0,
                caller: !0,
                callee: !0,
                arguments: !0,
                arity: !0
            }
              , a = {
                $$typeof: !0,
                compare: !0,
                defaultProps: !0,
                displayName: !0,
                propTypes: !0,
                type: !0
            }
              , s = {};
            function l(e) {
                return r.isMemo(e) ? a : s[e.$$typeof] || i
            }
            s[r.ForwardRef] = {
                $$typeof: !0,
                render: !0,
                defaultProps: !0,
                displayName: !0,
                propTypes: !0
            },
            s[r.Memo] = a;
            var c = Object.defineProperty
              , u = Object.getOwnPropertyNames
              , d = Object.getOwnPropertySymbols
              , h = Object.getOwnPropertyDescriptor
              , p = Object.getPrototypeOf
              , f = Object.prototype;
            e.exports = function e(t, n, r) {
                if ("string" !== typeof n) {
                    if (f) {
                        var i = p(n);
                        i && i !== f && e(t, i, r)
                    }
                    var a = u(n);
                    d && (a = a.concat(d(n)));
                    for (var s = l(t), m = l(n), g = 0; g < a.length; ++g) {
                        var v = a[g];
                        if (!o[v] && (!r || !r[v]) && (!m || !m[v]) && (!s || !s[v])) {
                            var y = h(n, v);
                            try {
                                c(t, v, y)
                            } catch (b) {}
                        }
                    }
                }
                return t
            }
        }
        ,
        2138: (e, t) => {
            "use strict";
            var n = "function" === typeof Symbol && Symbol.for
              , r = n ? Symbol.for("react.element") : 60103
              , i = n ? Symbol.for("react.portal") : 60106
              , o = n ? Symbol.for("react.fragment") : 60107
              , a = n ? Symbol.for("react.strict_mode") : 60108
              , s = n ? Symbol.for("react.profiler") : 60114
              , l = n ? Symbol.for("react.provider") : 60109
              , c = n ? Symbol.for("react.context") : 60110
              , u = n ? Symbol.for("react.async_mode") : 60111
              , d = n ? Symbol.for("react.concurrent_mode") : 60111
              , h = n ? Symbol.for("react.forward_ref") : 60112
              , p = n ? Symbol.for("react.suspense") : 60113
              , f = n ? Symbol.for("react.suspense_list") : 60120
              , m = n ? Symbol.for("react.memo") : 60115
              , g = n ? Symbol.for("react.lazy") : 60116
              , v = n ? Symbol.for("react.block") : 60121
              , y = n ? Symbol.for("react.fundamental") : 60117
              , b = n ? Symbol.for("react.responder") : 60118
              , _ = n ? Symbol.for("react.scope") : 60119;
            function A(e) {
                if ("object" === typeof e && null !== e) {
                    var t = e.$$typeof;
                    switch (t) {
                    case r:
                        switch (e = e.type) {
                        case u:
                        case d:
                        case o:
                        case s:
                        case a:
                        case p:
                            return e;
                        default:
                            switch (e = e && e.$$typeof) {
                            case c:
                            case h:
                            case g:
                            case m:
                            case l:
                                return e;
                            default:
                                return t
                            }
                        }
                    case i:
                        return t
                    }
                }
            }
            function x(e) {
                return A(e) === d
            }
            t.AsyncMode = u,
            t.ConcurrentMode = d,
            t.ContextConsumer = c,
            t.ContextProvider = l,
            t.Element = r,
            t.ForwardRef = h,
            t.Fragment = o,
            t.Lazy = g,
            t.Memo = m,
            t.Portal = i,
            t.Profiler = s,
            t.StrictMode = a,
            t.Suspense = p,
            t.isAsyncMode = function(e) {
                return x(e) || A(e) === u
            }
            ,
            t.isConcurrentMode = x,
            t.isContextConsumer = function(e) {
                return A(e) === c
            }
            ,
            t.isContextProvider = function(e) {
                return A(e) === l
            }
            ,
            t.isElement = function(e) {
                return "object" === typeof e && null !== e && e.$$typeof === r
            }
            ,
            t.isForwardRef = function(e) {
                return A(e) === h
            }
            ,
            t.isFragment = function(e) {
                return A(e) === o
            }
            ,
            t.isLazy = function(e) {
                return A(e) === g
            }
            ,
            t.isMemo = function(e) {
                return A(e) === m
            }
            ,
            t.isPortal = function(e) {
                return A(e) === i
            }
            ,
            t.isProfiler = function(e) {
                return A(e) === s
            }
            ,
            t.isStrictMode = function(e) {
                return A(e) === a
            }
            ,
            t.isSuspense = function(e) {
                return A(e) === p
            }
            ,
            t.isValidElementType = function(e) {
                return "string" === typeof e || "function" === typeof e || e === o || e === d || e === s || e === a || e === p || e === f || "object" === typeof e && null !== e && (e.$$typeof === g || e.$$typeof === m || e.$$typeof === l || e.$$typeof === c || e.$$typeof === h || e.$$typeof === y || e.$$typeof === b || e.$$typeof === _ || e.$$typeof === v)
            }
            ,
            t.typeOf = A
        }
        ,
        630: (e, t, n) => {
            "use strict";
            e.exports = n(2138)
        }
        ,
        3488: (e, t, n) => {
            "use strict";
            var r = n(3959);
            function i() {}
            function o() {}
            o.resetWarningCache = i,
            e.exports = function() {
                function e(e, t, n, i, o, a) {
                    if (a !== r) {
                        var s = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                        throw s.name = "Invariant Violation",
                        s
                    }
                }
                function t() {
                    return e
                }
                e.isRequired = e;
                var n = {
                    array: e,
                    bigint: e,
                    bool: e,
                    func: e,
                    number: e,
                    object: e,
                    string: e,
                    symbol: e,
                    any: e,
                    arrayOf: t,
                    element: e,
                    elementType: e,
                    instanceOf: t,
                    node: e,
                    objectOf: t,
                    oneOf: t,
                    oneOfType: t,
                    shape: t,
                    exact: t,
                    checkPropTypes: o,
                    resetWarningCache: i
                };
                return n.PropTypes = n,
                n
            }
        }
        ,
        1942: (e, t, n) => {
            e.exports = n(3488)()
        }
        ,
        3959: e => {
            "use strict";
            e.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
        }
        ,
        3528: (module, __unused_webpack_exports, __webpack_require__) => {
            module.exports = function(e) {
                var t = {};
                function n(r) {
                    if (t[r])
                        return t[r].exports;
                    var i = t[r] = {
                        i: r,
                        l: !1,
                        exports: {}
                    };
                    return e[r].call(i.exports, i, i.exports, n),
                    i.l = !0,
                    i.exports
                }
                return n.m = e,
                n.c = t,
                n.d = function(e, t, r) {
                    n.o(e, t) || Object.defineProperty(e, t, {
                        enumerable: !0,
                        get: r
                    })
                }
                ,
                n.r = function(e) {
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                        value: "Module"
                    }),
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    })
                }
                ,
                n.t = function(e, t) {
                    if (1 & t && (e = n(e)),
                    8 & t)
                        return e;
                    if (4 & t && "object" == typeof e && e && e.__esModule)
                        return e;
                    var r = Object.create(null);
                    if (n.r(r),
                    Object.defineProperty(r, "default", {
                        enumerable: !0,
                        value: e
                    }),
                    2 & t && "string" != typeof e)
                        for (var i in e)
                            n.d(r, i, function(t) {
                                return e[t]
                            }
                            .bind(null, i));
                    return r
                }
                ,
                n.n = function(e) {
                    var t = e && e.__esModule ? function() {
                        return e.default
                    }
                    : function() {
                        return e
                    }
                    ;
                    return n.d(t, "a", t),
                    t
                }
                ,
                n.o = function(e, t) {
                    return Object.prototype.hasOwnProperty.call(e, t)
                }
                ,
                n.p = "",
                n(n.s = 2)
            }([function(e, t) {
                e.exports = __webpack_require__(1942)
            }
            , function(e, t) {
                e.exports = __webpack_require__(9950)
            }
            , function(module, __nested_webpack_exports__, __nested_webpack_require_1455__) {
                "use strict";
                __nested_webpack_require_1455__.r(__nested_webpack_exports__),
                function(module) {
                    var react__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1455__(1), react__WEBPACK_IMPORTED_MODULE_0___default = __nested_webpack_require_1455__.n(react__WEBPACK_IMPORTED_MODULE_0__), prop_types__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1455__(0), prop_types__WEBPACK_IMPORTED_MODULE_1___default = __nested_webpack_require_1455__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__), enterModule;
                    function _typeof(e) {
                        return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                            return typeof e
                        }
                        : function(e) {
                            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                        }
                        )(e)
                    }
                    function _extends() {
                        return (_extends = Object.assign || function(e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var n = arguments[t];
                                for (var r in n)
                                    Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                            }
                            return e
                        }
                        ).apply(this, arguments)
                    }
                    function _classCallCheck(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }
                    function _defineProperties(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1,
                            r.configurable = !0,
                            "value"in r && (r.writable = !0),
                            Object.defineProperty(e, r.key, r)
                        }
                    }
                    function _createClass(e, t, n) {
                        return t && _defineProperties(e.prototype, t),
                        n && _defineProperties(e, n),
                        e
                    }
                    function _inherits(e, t) {
                        if ("function" != typeof t && null !== t)
                            throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }),
                        t && _setPrototypeOf(e, t)
                    }
                    function _setPrototypeOf(e, t) {
                        return (_setPrototypeOf = Object.setPrototypeOf || function(e, t) {
                            return e.__proto__ = t,
                            e
                        }
                        )(e, t)
                    }
                    function _createSuper(e) {
                        return function() {
                            var t, n = _getPrototypeOf(e);
                            if (_isNativeReflectConstruct()) {
                                var r = _getPrototypeOf(this).constructor;
                                t = Reflect.construct(n, arguments, r)
                            } else
                                t = n.apply(this, arguments);
                            return _possibleConstructorReturn(this, t)
                        }
                    }
                    function _possibleConstructorReturn(e, t) {
                        return !t || "object" !== _typeof(t) && "function" != typeof t ? _assertThisInitialized(e) : t
                    }
                    function _assertThisInitialized(e) {
                        if (void 0 === e)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }
                    function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct)
                            return !1;
                        if (Reflect.construct.sham)
                            return !1;
                        if ("function" == typeof Proxy)
                            return !0;
                        try {
                            return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}
                            ))),
                            !0
                        } catch (e) {
                            return !1
                        }
                    }
                    function _getPrototypeOf(e) {
                        return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                            return e.__proto__ || Object.getPrototypeOf(e)
                        }
                        )(e)
                    }
                    function _defineProperty(e, t, n) {
                        return t in e ? Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = n,
                        e
                    }
                    enterModule = "undefined" != typeof reactHotLoaderGlobal ? reactHotLoaderGlobal.enterModule : void 0,
                    enterModule && enterModule(module);
                    var __signature__ = "undefined" != typeof reactHotLoaderGlobal ? reactHotLoaderGlobal.default.signature : function(e) {
                        return e
                    }
                      , ReactAudioPlayer = function(_Component) {
                        _inherits(ReactAudioPlayer, _Component);
                        var _super = _createSuper(ReactAudioPlayer);
                        function ReactAudioPlayer() {
                            var e;
                            _classCallCheck(this, ReactAudioPlayer);
                            for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
                                n[r] = arguments[r];
                            return _defineProperty(_assertThisInitialized(e = _super.call.apply(_super, [this].concat(n))), "audioEl", react__WEBPACK_IMPORTED_MODULE_0___default.a.createRef()),
                            _defineProperty(_assertThisInitialized(e), "listenTracker", void 0),
                            _defineProperty(_assertThisInitialized(e), "onError", (function(t) {
                                var n, r;
                                return null === (n = (r = e.props).onError) || void 0 === n ? void 0 : n.call(r, t)
                            }
                            )),
                            _defineProperty(_assertThisInitialized(e), "onCanPlay", (function(t) {
                                var n, r;
                                return null === (n = (r = e.props).onCanPlay) || void 0 === n ? void 0 : n.call(r, t)
                            }
                            )),
                            _defineProperty(_assertThisInitialized(e), "onCanPlayThrough", (function(t) {
                                var n, r;
                                return null === (n = (r = e.props).onCanPlayThrough) || void 0 === n ? void 0 : n.call(r, t)
                            }
                            )),
                            _defineProperty(_assertThisInitialized(e), "onPlay", (function(t) {
                                var n, r;
                                e.setListenTrack(),
                                null === (n = (r = e.props).onPlay) || void 0 === n || n.call(r, t)
                            }
                            )),
                            _defineProperty(_assertThisInitialized(e), "onAbort", (function(t) {
                                var n, r;
                                e.clearListenTrack(),
                                null === (n = (r = e.props).onAbort) || void 0 === n || n.call(r, t)
                            }
                            )),
                            _defineProperty(_assertThisInitialized(e), "onEnded", (function(t) {
                                var n, r;
                                e.clearListenTrack(),
                                null === (n = (r = e.props).onEnded) || void 0 === n || n.call(r, t)
                            }
                            )),
                            _defineProperty(_assertThisInitialized(e), "onPause", (function(t) {
                                var n, r;
                                e.clearListenTrack(),
                                null === (n = (r = e.props).onPause) || void 0 === n || n.call(r, t)
                            }
                            )),
                            _defineProperty(_assertThisInitialized(e), "onSeeked", (function(t) {
                                var n, r;
                                null === (n = (r = e.props).onSeeked) || void 0 === n || n.call(r, t)
                            }
                            )),
                            _defineProperty(_assertThisInitialized(e), "onLoadedMetadata", (function(t) {
                                var n, r;
                                null === (n = (r = e.props).onLoadedMetadata) || void 0 === n || n.call(r, t)
                            }
                            )),
                            _defineProperty(_assertThisInitialized(e), "onVolumeChanged", (function(t) {
                                var n, r;
                                null === (n = (r = e.props).onVolumeChanged) || void 0 === n || n.call(r, t)
                            }
                            )),
                            e
                        }
                        return _createClass(ReactAudioPlayer, [{
                            key: "componentDidMount",
                            value: function() {
                                var e = this.audioEl.current;
                                e && (this.updateVolume(this.props.volume),
                                e.addEventListener("error", this.onError),
                                e.addEventListener("canplay", this.onCanPlay),
                                e.addEventListener("canplaythrough", this.onCanPlayThrough),
                                e.addEventListener("play", this.onPlay),
                                e.addEventListener("abort", this.onAbort),
                                e.addEventListener("ended", this.onEnded),
                                e.addEventListener("pause", this.onPause),
                                e.addEventListener("seeked", this.onSeeked),
                                e.addEventListener("loadedmetadata", this.onLoadedMetadata),
                                e.addEventListener("volumechange", this.onVolumeChanged))
                            }
                        }, {
                            key: "componentWillUnmount",
                            value: function() {
                                var e = this.audioEl.current;
                                e && (e.removeEventListener("error", this.onError),
                                e.removeEventListener("canplay", this.onCanPlay),
                                e.removeEventListener("canplaythrough", this.onCanPlayThrough),
                                e.removeEventListener("play", this.onPlay),
                                e.removeEventListener("abort", this.onAbort),
                                e.removeEventListener("ended", this.onEnded),
                                e.removeEventListener("pause", this.onPause),
                                e.removeEventListener("seeked", this.onSeeked),
                                e.removeEventListener("loadedmetadata", this.onLoadedMetadata),
                                e.removeEventListener("volumechange", this.onVolumeChanged))
                            }
                        }, {
                            key: "componentDidUpdate",
                            value: function(e) {
                                this.updateVolume(this.props.volume)
                            }
                        }, {
                            key: "setListenTrack",
                            value: function() {
                                var e = this;
                                if (!this.listenTracker) {
                                    var t = this.props.listenInterval;
                                    this.listenTracker = window.setInterval((function() {
                                        var t, n;
                                        e.audioEl.current && (null === (t = (n = e.props).onListen) || void 0 === t || t.call(n, e.audioEl.current.currentTime))
                                    }
                                    ), t)
                                }
                            }
                        }, {
                            key: "updateVolume",
                            value: function(e) {
                                var t = this.audioEl.current;
                                null !== t && "number" == typeof e && e !== (null == t ? void 0 : t.volume) && (t.volume = e)
                            }
                        }, {
                            key: "clearListenTrack",
                            value: function() {
                                this.listenTracker && (clearInterval(this.listenTracker),
                                delete this.listenTracker)
                            }
                        }, {
                            key: "render",
                            value: function() {
                                var e = this.props.children || react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", null, "Your browser does not support the ", react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("code", null, "audio"), " element.")
                                  , t = !(!1 === this.props.controls)
                                  , n = this.props.title ? this.props.title : this.props.src
                                  , r = {};
                                return this.props.controlsList && (r.controlsList = this.props.controlsList),
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("audio", _extends({
                                    autoPlay: this.props.autoPlay,
                                    className: "react-audio-player ".concat(this.props.className),
                                    controls: t,
                                    crossOrigin: this.props.crossOrigin,
                                    id: this.props.id,
                                    loop: this.props.loop,
                                    muted: this.props.muted,
                                    preload: this.props.preload,
                                    ref: this.audioEl,
                                    src: this.props.src,
                                    style: this.props.style,
                                    title: n
                                }, r), e)
                            }
                        }, {
                            key: "__reactstandin__regenerateByEval",
                            value: function __reactstandin__regenerateByEval(key, code) {
                                this[key] = eval(code)
                            }
                        }]),
                        ReactAudioPlayer
                    }(react__WEBPACK_IMPORTED_MODULE_0__.Component);
                    _defineProperty(ReactAudioPlayer, "propTypes", void 0),
                    _defineProperty(ReactAudioPlayer, "defaultProps", void 0),
                    ReactAudioPlayer.defaultProps = {
                        autoPlay: !1,
                        children: null,
                        className: "",
                        controls: !1,
                        controlsList: "",
                        id: "",
                        listenInterval: 1e4,
                        loop: !1,
                        muted: !1,
                        onAbort: function() {},
                        onCanPlay: function() {},
                        onCanPlayThrough: function() {},
                        onEnded: function() {},
                        onError: function() {},
                        onListen: function() {},
                        onPause: function() {},
                        onPlay: function() {},
                        onSeeked: function() {},
                        onVolumeChanged: function() {},
                        onLoadedMetadata: function() {},
                        preload: "metadata",
                        style: {},
                        title: "",
                        volume: 1
                    },
                    ReactAudioPlayer.propTypes = {
                        autoPlay: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
                        children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.element,
                        className: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
                        controls: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
                        controlsList: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
                        crossOrigin: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
                        id: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
                        listenInterval: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,
                        loop: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
                        muted: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
                        onAbort: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
                        onCanPlay: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
                        onCanPlayThrough: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
                        onEnded: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
                        onError: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
                        onListen: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
                        onLoadedMetadata: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
                        onPause: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
                        onPlay: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
                        onSeeked: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
                        onVolumeChanged: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
                        preload: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOf(["", "none", "metadata", "auto"]),
                        src: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
                        style: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.objectOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string),
                        title: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
                        volume: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number
                    };
                    var _default = ReactAudioPlayer, reactHotLoader, leaveModule;
                    __nested_webpack_exports__.default = _default,
                    reactHotLoader = "undefined" != typeof reactHotLoaderGlobal ? reactHotLoaderGlobal.default : void 0,
                    reactHotLoader && (reactHotLoader.register(ReactAudioPlayer, "ReactAudioPlayer", "/home/justin/Projects/react-audio-player/src/index.tsx"),
                    reactHotLoader.register(_default, "default", "/home/justin/Projects/react-audio-player/src/index.tsx")),
                    leaveModule = "undefined" != typeof reactHotLoaderGlobal ? reactHotLoaderGlobal.leaveModule : void 0,
                    leaveModule && leaveModule(module)
                }
                .call(this, __nested_webpack_require_1455__(3)(module))
            }
            , function(e, t) {
                e.exports = function(e) {
                    if (!e.webpackPolyfill) {
                        var t = Object.create(e);
                        t.children || (t.children = []),
                        Object.defineProperty(t, "loaded", {
                            enumerable: !0,
                            get: function() {
                                return t.l
                            }
                        }),
                        Object.defineProperty(t, "id", {
                            enumerable: !0,
                            get: function() {
                                return t.i
                            }
                        }),
                        Object.defineProperty(t, "exports", {
                            enumerable: !0
                        }),
                        t.webpackPolyfill = 1
                    }
                    return t
                }
            }
            ])
        }
        ,
        8345: (e, t, n) => {
            "use strict";
            var r = n(9950)
              , i = n(3204);
            function o(e) {
                for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)
                    t += "&args[]=" + encodeURIComponent(arguments[n]);
                return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
            }
            var a = new Set
              , s = {};
            function l(e, t) {
                c(e, t),
                c(e + "Capture", t)
            }
            function c(e, t) {
                for (s[e] = t,
                e = 0; e < t.length; e++)
                    a.add(t[e])
            }
            var u = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement)
              , d = Object.prototype.hasOwnProperty
              , h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
              , p = {}
              , f = {};
            function m(e, t, n, r, i, o, a) {
                this.acceptsBooleans = 2 === t || 3 === t || 4 === t,
                this.attributeName = r,
                this.attributeNamespace = i,
                this.mustUseProperty = n,
                this.propertyName = e,
                this.type = t,
                this.sanitizeURL = o,
                this.removeEmptyString = a
            }
            var g = {};
            "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e) {
                g[e] = new m(e,0,!1,e,null,!1,!1)
            }
            )),
            [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach((function(e) {
                var t = e[0];
                g[t] = new m(t,1,!1,e[1],null,!1,!1)
            }
            )),
            ["contentEditable", "draggable", "spellCheck", "value"].forEach((function(e) {
                g[e] = new m(e,2,!1,e.toLowerCase(),null,!1,!1)
            }
            )),
            ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function(e) {
                g[e] = new m(e,2,!1,e,null,!1,!1)
            }
            )),
            "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e) {
                g[e] = new m(e,3,!1,e.toLowerCase(),null,!1,!1)
            }
            )),
            ["checked", "multiple", "muted", "selected"].forEach((function(e) {
                g[e] = new m(e,3,!0,e,null,!1,!1)
            }
            )),
            ["capture", "download"].forEach((function(e) {
                g[e] = new m(e,4,!1,e,null,!1,!1)
            }
            )),
            ["cols", "rows", "size", "span"].forEach((function(e) {
                g[e] = new m(e,6,!1,e,null,!1,!1)
            }
            )),
            ["rowSpan", "start"].forEach((function(e) {
                g[e] = new m(e,5,!1,e.toLowerCase(),null,!1,!1)
            }
            ));
            var v = /[\-:]([a-z])/g;
            function y(e) {
                return e[1].toUpperCase()
            }
            function b(e, t, n, r) {
                var i = g.hasOwnProperty(t) ? g[t] : null;
                (null !== i ? 0 !== i.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function(e, t, n, r) {
                    if (null === t || "undefined" === typeof t || function(e, t, n, r) {
                        if (null !== n && 0 === n.type)
                            return !1;
                        switch (typeof t) {
                        case "function":
                        case "symbol":
                            return !0;
                        case "boolean":
                            return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e);
                        default:
                            return !1
                        }
                    }(e, t, n, r))
                        return !0;
                    if (r)
                        return !1;
                    if (null !== n)
                        switch (n.type) {
                        case 3:
                            return !t;
                        case 4:
                            return !1 === t;
                        case 5:
                            return isNaN(t);
                        case 6:
                            return isNaN(t) || 1 > t
                        }
                    return !1
                }(t, n, i, r) && (n = null),
                r || null === i ? function(e) {
                    return !!d.call(f, e) || !d.call(p, e) && (h.test(e) ? f[e] = !0 : (p[e] = !0,
                    !1))
                }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName,
                r = i.attributeNamespace,
                null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n,
                r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
            }
            "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e) {
                var t = e.replace(v, y);
                g[t] = new m(t,1,!1,e,null,!1,!1)
            }
            )),
            "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e) {
                var t = e.replace(v, y);
                g[t] = new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)
            }
            )),
            ["xml:base", "xml:lang", "xml:space"].forEach((function(e) {
                var t = e.replace(v, y);
                g[t] = new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)
            }
            )),
            ["tabIndex", "crossOrigin"].forEach((function(e) {
                g[e] = new m(e,1,!1,e.toLowerCase(),null,!1,!1)
            }
            )),
            g.xlinkHref = new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),
            ["src", "href", "action", "formAction"].forEach((function(e) {
                g[e] = new m(e,1,!1,e.toLowerCase(),null,!0,!0)
            }
            ));
            var _ = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
              , A = Symbol.for("react.element")
              , x = Symbol.for("react.portal")
              , S = Symbol.for("react.fragment")
              , w = Symbol.for("react.strict_mode")
              , E = Symbol.for("react.profiler")
              , M = Symbol.for("react.provider")
              , C = Symbol.for("react.context")
              , T = Symbol.for("react.forward_ref")
              , R = Symbol.for("react.suspense")
              , P = Symbol.for("react.suspense_list")
              , B = Symbol.for("react.memo")
              , I = Symbol.for("react.lazy");
            Symbol.for("react.scope"),
            Symbol.for("react.debug_trace_mode");
            var L = Symbol.for("react.offscreen");
            Symbol.for("react.legacy_hidden"),
            Symbol.for("react.cache"),
            Symbol.for("react.tracing_marker");
            var k = Symbol.iterator;
            function D(e) {
                return null === e || "object" !== typeof e ? null : "function" === typeof (e = k && e[k] || e["@@iterator"]) ? e : null
            }
            var O, N = Object.assign;
            function F(e) {
                if (void 0 === O)
                    try {
                        throw Error()
                    } catch (n) {
                        var t = n.stack.trim().match(/\n( *(at )?)/);
                        O = t && t[1] || ""
                    }
                return "\n" + O + e
            }
            var U = !1;
            function z(e, t) {
                if (!e || U)
                    return "";
                U = !0;
                var n = Error.prepareStackTrace;
                Error.prepareStackTrace = void 0;
                try {
                    if (t)
                        if (t = function() {
                            throw Error()
                        }
                        ,
                        Object.defineProperty(t.prototype, "props", {
                            set: function() {
                                throw Error()
                            }
                        }),
                        "object" === typeof Reflect && Reflect.construct) {
                            try {
                                Reflect.construct(t, [])
                            } catch (c) {
                                var r = c
                            }
                            Reflect.construct(e, [], t)
                        } else {
                            try {
                                t.call()
                            } catch (c) {
                                r = c
                            }
                            e.call(t.prototype)
                        }
                    else {
                        try {
                            throw Error()
                        } catch (c) {
                            r = c
                        }
                        e()
                    }
                } catch (c) {
                    if (c && r && "string" === typeof c.stack) {
                        for (var i = c.stack.split("\n"), o = r.stack.split("\n"), a = i.length - 1, s = o.length - 1; 1 <= a && 0 <= s && i[a] !== o[s]; )
                            s--;
                        for (; 1 <= a && 0 <= s; a--,
                        s--)
                            if (i[a] !== o[s]) {
                                if (1 !== a || 1 !== s)
                                    do {
                                        if (a--,
                                        0 > --s || i[a] !== o[s]) {
                                            var l = "\n" + i[a].replace(" at new ", " at ");
                                            return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)),
                                            l
                                        }
                                    } while (1 <= a && 0 <= s);
                                break
                            }
                    }
                } finally {
                    U = !1,
                    Error.prepareStackTrace = n
                }
                return (e = e ? e.displayName || e.name : "") ? F(e) : ""
            }
            function G(e) {
                switch (e.tag) {
                case 5:
                    return F(e.type);
                case 16:
                    return F("Lazy");
                case 13:
                    return F("Suspense");
                case 19:
                    return F("SuspenseList");
                case 0:
                case 2:
                case 15:
                    return e = z(e.type, !1);
                case 11:
                    return e = z(e.type.render, !1);
                case 1:
                    return e = z(e.type, !0);
                default:
                    return ""
                }
            }
            function H(e) {
                if (null == e)
                    return null;
                if ("function" === typeof e)
                    return e.displayName || e.name || null;
                if ("string" === typeof e)
                    return e;
                switch (e) {
                case S:
                    return "Fragment";
                case x:
                    return "Portal";
                case E:
                    return "Profiler";
                case w:
                    return "StrictMode";
                case R:
                    return "Suspense";
                case P:
                    return "SuspenseList"
                }
                if ("object" === typeof e)
                    switch (e.$$typeof) {
                    case C:
                        return (e.displayName || "Context") + ".Consumer";
                    case M:
                        return (e._context.displayName || "Context") + ".Provider";
                    case T:
                        var t = e.render;
                        return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"),
                        e;
                    case B:
                        return null !== (t = e.displayName || null) ? t : H(e.type) || "Memo";
                    case I:
                        t = e._payload,
                        e = e._init;
                        try {
                            return H(e(t))
                        } catch (n) {}
                    }
                return null
            }
            function j(e) {
                var t = e.type;
                switch (e.tag) {
                case 24:
                    return "Cache";
                case 9:
                    return (t.displayName || "Context") + ".Consumer";
                case 10:
                    return (t._context.displayName || "Context") + ".Provider";
                case 18:
                    return "DehydratedFragment";
                case 11:
                    return e = (e = t.render).displayName || e.name || "",
                    t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef");
                case 7:
                    return "Fragment";
                case 5:
                    return t;
                case 4:
                    return "Portal";
                case 3:
                    return "Root";
                case 6:
                    return "Text";
                case 16:
                    return H(t);
                case 8:
                    return t === w ? "StrictMode" : "Mode";
                case 22:
                    return "Offscreen";
                case 12:
                    return "Profiler";
                case 21:
                    return "Scope";
                case 13:
                    return "Suspense";
                case 19:
                    return "SuspenseList";
                case 25:
                    return "TracingMarker";
                case 1:
                case 0:
                case 17:
                case 2:
                case 14:
                case 15:
                    if ("function" === typeof t)
                        return t.displayName || t.name || null;
                    if ("string" === typeof t)
                        return t
                }
                return null
            }
            function W(e) {
                switch (typeof e) {
                case "boolean":
                case "number":
                case "string":
                case "undefined":
                case "object":
                    return e;
                default:
                    return ""
                }
            }
            function V(e) {
                var t = e.type;
                return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t)
            }
            function X(e) {
                e._valueTracker || (e._valueTracker = function(e) {
                    var t = V(e) ? "checked" : "value"
                      , n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t)
                      , r = "" + e[t];
                    if (!e.hasOwnProperty(t) && "undefined" !== typeof n && "function" === typeof n.get && "function" === typeof n.set) {
                        var i = n.get
                          , o = n.set;
                        return Object.defineProperty(e, t, {
                            configurable: !0,
                            get: function() {
                                return i.call(this)
                            },
                            set: function(e) {
                                r = "" + e,
                                o.call(this, e)
                            }
                        }),
                        Object.defineProperty(e, t, {
                            enumerable: n.enumerable
                        }),
                        {
                            getValue: function() {
                                return r
                            },
                            setValue: function(e) {
                                r = "" + e
                            },
                            stopTracking: function() {
                                e._valueTracker = null,
                                delete e[t]
                            }
                        }
                    }
                }(e))
            }
            function J(e) {
                if (!e)
                    return !1;
                var t = e._valueTracker;
                if (!t)
                    return !0;
                var n = t.getValue()
                  , r = "";
                return e && (r = V(e) ? e.checked ? "true" : "false" : e.value),
                (e = r) !== n && (t.setValue(e),
                !0)
            }
            function K(e) {
                if ("undefined" === typeof (e = e || ("undefined" !== typeof document ? document : void 0)))
                    return null;
                try {
                    return e.activeElement || e.body
                } catch (t) {
                    return e.body
                }
            }
            function q(e, t) {
                var n = t.checked;
                return N({}, t, {
                    defaultChecked: void 0,
                    defaultValue: void 0,
                    value: void 0,
                    checked: null != n ? n : e._wrapperState.initialChecked
                })
            }
            function Y(e, t) {
                var n = null == t.defaultValue ? "" : t.defaultValue
                  , r = null != t.checked ? t.checked : t.defaultChecked;
                n = W(null != t.value ? t.value : n),
                e._wrapperState = {
                    initialChecked: r,
                    initialValue: n,
                    controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value
                }
            }
            function Q(e, t) {
                null != (t = t.checked) && b(e, "checked", t, !1)
            }
            function Z(e, t) {
                Q(e, t);
                var n = W(t.value)
                  , r = t.type;
                if (null != n)
                    "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
                else if ("submit" === r || "reset" === r)
                    return void e.removeAttribute("value");
                t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, W(t.defaultValue)),
                null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked)
            }
            function $(e, t, n) {
                if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
                    var r = t.type;
                    if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value))
                        return;
                    t = "" + e._wrapperState.initialValue,
                    n || t === e.value || (e.value = t),
                    e.defaultValue = t
                }
                "" !== (n = e.name) && (e.name = ""),
                e.defaultChecked = !!e._wrapperState.initialChecked,
                "" !== n && (e.name = n)
            }
            function ee(e, t, n) {
                "number" === t && K(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
            }
            var te = Array.isArray;
            function ne(e, t, n, r) {
                if (e = e.options,
                t) {
                    t = {};
                    for (var i = 0; i < n.length; i++)
                        t["$" + n[i]] = !0;
                    for (n = 0; n < e.length; n++)
                        i = t.hasOwnProperty("$" + e[n].value),
                        e[n].selected !== i && (e[n].selected = i),
                        i && r && (e[n].defaultSelected = !0)
                } else {
                    for (n = "" + W(n),
                    t = null,
                    i = 0; i < e.length; i++) {
                        if (e[i].value === n)
                            return e[i].selected = !0,
                            void (r && (e[i].defaultSelected = !0));
                        null !== t || e[i].disabled || (t = e[i])
                    }
                    null !== t && (t.selected = !0)
                }
            }
            function re(e, t) {
                if (null != t.dangerouslySetInnerHTML)
                    throw Error(o(91));
                return N({}, t, {
                    value: void 0,
                    defaultValue: void 0,
                    children: "" + e._wrapperState.initialValue
                })
            }
            function ie(e, t) {
                var n = t.value;
                if (null == n) {
                    if (n = t.children,
                    t = t.defaultValue,
                    null != n) {
                        if (null != t)
                            throw Error(o(92));
                        if (te(n)) {
                            if (1 < n.length)
                                throw Error(o(93));
                            n = n[0]
                        }
                        t = n
                    }
                    null == t && (t = ""),
                    n = t
                }
                e._wrapperState = {
                    initialValue: W(n)
                }
            }
            function oe(e, t) {
                var n = W(t.value)
                  , r = W(t.defaultValue);
                null != n && ((n = "" + n) !== e.value && (e.value = n),
                null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)),
                null != r && (e.defaultValue = "" + r)
            }
            function ae(e) {
                var t = e.textContent;
                t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t)
            }
            function se(e) {
                switch (e) {
                case "svg":
                    return "http://www.w3.org/2000/svg";
                case "math":
                    return "http://www.w3.org/1998/Math/MathML";
                default:
                    return "http://www.w3.org/1999/xhtml"
                }
            }
            function le(e, t) {
                return null == e || "http://www.w3.org/1999/xhtml" === e ? se(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e
            }
            var ce, ue, de = (ue = function(e, t) {
                if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML"in e)
                    e.innerHTML = t;
                else {
                    for ((ce = ce || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
                    t = ce.firstChild; e.firstChild; )
                        e.removeChild(e.firstChild);
                    for (; t.firstChild; )
                        e.appendChild(t.firstChild)
                }
            }
            ,
            "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(e, t, n, r) {
                MSApp.execUnsafeLocalFunction((function() {
                    return ue(e, t)
                }
                ))
            }
            : ue);
            function he(e, t) {
                if (t) {
                    var n = e.firstChild;
                    if (n && n === e.lastChild && 3 === n.nodeType)
                        return void (n.nodeValue = t)
                }
                e.textContent = t
            }
            var pe = {
                animationIterationCount: !0,
                aspectRatio: !0,
                borderImageOutset: !0,
                borderImageSlice: !0,
                borderImageWidth: !0,
                boxFlex: !0,
                boxFlexGroup: !0,
                boxOrdinalGroup: !0,
                columnCount: !0,
                columns: !0,
                flex: !0,
                flexGrow: !0,
                flexPositive: !0,
                flexShrink: !0,
                flexNegative: !0,
                flexOrder: !0,
                gridArea: !0,
                gridRow: !0,
                gridRowEnd: !0,
                gridRowSpan: !0,
                gridRowStart: !0,
                gridColumn: !0,
                gridColumnEnd: !0,
                gridColumnSpan: !0,
                gridColumnStart: !0,
                fontWeight: !0,
                lineClamp: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                tabSize: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0,
                fillOpacity: !0,
                floodOpacity: !0,
                stopOpacity: !0,
                strokeDasharray: !0,
                strokeDashoffset: !0,
                strokeMiterlimit: !0,
                strokeOpacity: !0,
                strokeWidth: !0
            }
              , fe = ["Webkit", "ms", "Moz", "O"];
            function me(e, t, n) {
                return null == t || "boolean" === typeof t || "" === t ? "" : n || "number" !== typeof t || 0 === t || pe.hasOwnProperty(e) && pe[e] ? ("" + t).trim() : t + "px"
            }
            function ge(e, t) {
                for (var n in e = e.style,
                t)
                    if (t.hasOwnProperty(n)) {
                        var r = 0 === n.indexOf("--")
                          , i = me(n, t[n], r);
                        "float" === n && (n = "cssFloat"),
                        r ? e.setProperty(n, i) : e[n] = i
                    }
            }
            Object.keys(pe).forEach((function(e) {
                fe.forEach((function(t) {
                    t = t + e.charAt(0).toUpperCase() + e.substring(1),
                    pe[t] = pe[e]
                }
                ))
            }
            ));
            var ve = N({
                menuitem: !0
            }, {
                area: !0,
                base: !0,
                br: !0,
                col: !0,
                embed: !0,
                hr: !0,
                img: !0,
                input: !0,
                keygen: !0,
                link: !0,
                meta: !0,
                param: !0,
                source: !0,
                track: !0,
                wbr: !0
            });
            function ye(e, t) {
                if (t) {
                    if (ve[e] && (null != t.children || null != t.dangerouslySetInnerHTML))
                        throw Error(o(137, e));
                    if (null != t.dangerouslySetInnerHTML) {
                        if (null != t.children)
                            throw Error(o(60));
                        if ("object" !== typeof t.dangerouslySetInnerHTML || !("__html"in t.dangerouslySetInnerHTML))
                            throw Error(o(61))
                    }
                    if (null != t.style && "object" !== typeof t.style)
                        throw Error(o(62))
                }
            }
            function be(e, t) {
                if (-1 === e.indexOf("-"))
                    return "string" === typeof t.is;
                switch (e) {
                case "annotation-xml":
                case "color-profile":
                case "font-face":
                case "font-face-src":
                case "font-face-uri":
                case "font-face-format":
                case "font-face-name":
                case "missing-glyph":
                    return !1;
                default:
                    return !0
                }
            }
            var _e = null;
            function Ae(e) {
                return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement),
                3 === e.nodeType ? e.parentNode : e
            }
            var xe = null
              , Se = null
              , we = null;
            function Ee(e) {
                if (e = bi(e)) {
                    if ("function" !== typeof xe)
                        throw Error(o(280));
                    var t = e.stateNode;
                    t && (t = Ai(t),
                    xe(e.stateNode, e.type, t))
                }
            }
            function Me(e) {
                Se ? we ? we.push(e) : we = [e] : Se = e
            }
            function Ce() {
                if (Se) {
                    var e = Se
                      , t = we;
                    if (we = Se = null,
                    Ee(e),
                    t)
                        for (e = 0; e < t.length; e++)
                            Ee(t[e])
                }
            }
            function Te(e, t) {
                return e(t)
            }
            function Re() {}
            var Pe = !1;
            function Be(e, t, n) {
                if (Pe)
                    return e(t, n);
                Pe = !0;
                try {
                    return Te(e, t, n)
                } finally {
                    Pe = !1,
                    (null !== Se || null !== we) && (Re(),
                    Ce())
                }
            }
            function Ie(e, t) {
                var n = e.stateNode;
                if (null === n)
                    return null;
                var r = Ai(n);
                if (null === r)
                    return null;
                n = r[t];
                e: switch (t) {
                case "onClick":
                case "onClickCapture":
                case "onDoubleClick":
                case "onDoubleClickCapture":
                case "onMouseDown":
                case "onMouseDownCapture":
                case "onMouseMove":
                case "onMouseMoveCapture":
                case "onMouseUp":
                case "onMouseUpCapture":
                case "onMouseEnter":
                    (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)),
                    e = !r;
                    break e;
                default:
                    e = !1
                }
                if (e)
                    return null;
                if (n && "function" !== typeof n)
                    throw Error(o(231, t, typeof n));
                return n
            }
            var Le = !1;
            if (u)
                try {
                    var ke = {};
                    Object.defineProperty(ke, "passive", {
                        get: function() {
                            Le = !0
                        }
                    }),
                    window.addEventListener("test", ke, ke),
                    window.removeEventListener("test", ke, ke)
                } catch (ue) {
                    Le = !1
                }
            function De(e, t, n, r, i, o, a, s, l) {
                var c = Array.prototype.slice.call(arguments, 3);
                try {
                    t.apply(n, c)
                } catch (u) {
                    this.onError(u)
                }
            }
            var Oe = !1
              , Ne = null
              , Fe = !1
              , Ue = null
              , ze = {
                onError: function(e) {
                    Oe = !0,
                    Ne = e
                }
            };
            function Ge(e, t, n, r, i, o, a, s, l) {
                Oe = !1,
                Ne = null,
                De.apply(ze, arguments)
            }
            function He(e) {
                var t = e
                  , n = e;
                if (e.alternate)
                    for (; t.return; )
                        t = t.return;
                else {
                    e = t;
                    do {
                        0 !== (4098 & (t = e).flags) && (n = t.return),
                        e = t.return
                    } while (e)
                }
                return 3 === t.tag ? n : null
            }
            function je(e) {
                if (13 === e.tag) {
                    var t = e.memoizedState;
                    if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)),
                    null !== t)
                        return t.dehydrated
                }
                return null
            }
            function We(e) {
                if (He(e) !== e)
                    throw Error(o(188))
            }
            function Ve(e) {
                return null !== (e = function(e) {
                    var t = e.alternate;
                    if (!t) {
                        if (null === (t = He(e)))
                            throw Error(o(188));
                        return t !== e ? null : e
                    }
                    for (var n = e, r = t; ; ) {
                        var i = n.return;
                        if (null === i)
                            break;
                        var a = i.alternate;
                        if (null === a) {
                            if (null !== (r = i.return)) {
                                n = r;
                                continue
                            }
                            break
                        }
                        if (i.child === a.child) {
                            for (a = i.child; a; ) {
                                if (a === n)
                                    return We(i),
                                    e;
                                if (a === r)
                                    return We(i),
                                    t;
                                a = a.sibling
                            }
                            throw Error(o(188))
                        }
                        if (n.return !== r.return)
                            n = i,
                            r = a;
                        else {
                            for (var s = !1, l = i.child; l; ) {
                                if (l === n) {
                                    s = !0,
                                    n = i,
                                    r = a;
                                    break
                                }
                                if (l === r) {
                                    s = !0,
                                    r = i,
                                    n = a;
                                    break
                                }
                                l = l.sibling
                            }
                            if (!s) {
                                for (l = a.child; l; ) {
                                    if (l === n) {
                                        s = !0,
                                        n = a,
                                        r = i;
                                        break
                                    }
                                    if (l === r) {
                                        s = !0,
                                        r = a,
                                        n = i;
                                        break
                                    }
                                    l = l.sibling
                                }
                                if (!s)
                                    throw Error(o(189))
                            }
                        }
                        if (n.alternate !== r)
                            throw Error(o(190))
                    }
                    if (3 !== n.tag)
                        throw Error(o(188));
                    return n.stateNode.current === n ? e : t
                }(e)) ? Xe(e) : null
            }
            function Xe(e) {
                if (5 === e.tag || 6 === e.tag)
                    return e;
                for (e = e.child; null !== e; ) {
                    var t = Xe(e);
                    if (null !== t)
                        return t;
                    e = e.sibling
                }
                return null
            }
            var Je = i.unstable_scheduleCallback
              , Ke = i.unstable_cancelCallback
              , qe = i.unstable_shouldYield
              , Ye = i.unstable_requestPaint
              , Qe = i.unstable_now
              , Ze = i.unstable_getCurrentPriorityLevel
              , $e = i.unstable_ImmediatePriority
              , et = i.unstable_UserBlockingPriority
              , tt = i.unstable_NormalPriority
              , nt = i.unstable_LowPriority
              , rt = i.unstable_IdlePriority
              , it = null
              , ot = null;
            var at = Math.clz32 ? Math.clz32 : function(e) {
                return e >>>= 0,
                0 === e ? 32 : 31 - (st(e) / lt | 0) | 0
            }
              , st = Math.log
              , lt = Math.LN2;
            var ct = 64
              , ut = 4194304;
            function dt(e) {
                switch (e & -e) {
                case 1:
                    return 1;
                case 2:
                    return 2;
                case 4:
                    return 4;
                case 8:
                    return 8;
                case 16:
                    return 16;
                case 32:
                    return 32;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return 4194240 & e;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    return 130023424 & e;
                case 134217728:
                    return 134217728;
                case 268435456:
                    return 268435456;
                case 536870912:
                    return 536870912;
                case 1073741824:
                    return 1073741824;
                default:
                    return e
                }
            }
            function ht(e, t) {
                var n = e.pendingLanes;
                if (0 === n)
                    return 0;
                var r = 0
                  , i = e.suspendedLanes
                  , o = e.pingedLanes
                  , a = 268435455 & n;
                if (0 !== a) {
                    var s = a & ~i;
                    0 !== s ? r = dt(s) : 0 !== (o &= a) && (r = dt(o))
                } else
                    0 !== (a = n & ~i) ? r = dt(a) : 0 !== o && (r = dt(o));
                if (0 === r)
                    return 0;
                if (0 !== t && t !== r && 0 === (t & i) && ((i = r & -r) >= (o = t & -t) || 16 === i && 0 !== (4194240 & o)))
                    return t;
                if (0 !== (4 & r) && (r |= 16 & n),
                0 !== (t = e.entangledLanes))
                    for (e = e.entanglements,
                    t &= r; 0 < t; )
                        i = 1 << (n = 31 - at(t)),
                        r |= e[n],
                        t &= ~i;
                return r
            }
            function pt(e, t) {
                switch (e) {
                case 1:
                case 2:
                case 4:
                    return t + 250;
                case 8:
                case 16:
                case 32:
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return t + 5e3;
                default:
                    return -1
                }
            }
            function ft(e) {
                return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0
            }
            function mt() {
                var e = ct;
                return 0 === (4194240 & (ct <<= 1)) && (ct = 64),
                e
            }
            function gt(e) {
                for (var t = [], n = 0; 31 > n; n++)
                    t.push(e);
                return t
            }
            function vt(e, t, n) {
                e.pendingLanes |= t,
                536870912 !== t && (e.suspendedLanes = 0,
                e.pingedLanes = 0),
                (e = e.eventTimes)[t = 31 - at(t)] = n
            }
            function yt(e, t) {
                var n = e.entangledLanes |= t;
                for (e = e.entanglements; n; ) {
                    var r = 31 - at(n)
                      , i = 1 << r;
                    i & t | e[r] & t && (e[r] |= t),
                    n &= ~i
                }
            }
            var bt = 0;
            function _t(e) {
                return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1
            }
            var At, xt, St, wt, Et, Mt = !1, Ct = [], Tt = null, Rt = null, Pt = null, Bt = new Map, It = new Map, Lt = [], kt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
            function Dt(e, t) {
                switch (e) {
                case "focusin":
                case "focusout":
                    Tt = null;
                    break;
                case "dragenter":
                case "dragleave":
                    Rt = null;
                    break;
                case "mouseover":
                case "mouseout":
                    Pt = null;
                    break;
                case "pointerover":
                case "pointerout":
                    Bt.delete(t.pointerId);
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                    It.delete(t.pointerId)
                }
            }
            function Ot(e, t, n, r, i, o) {
                return null === e || e.nativeEvent !== o ? (e = {
                    blockedOn: t,
                    domEventName: n,
                    eventSystemFlags: r,
                    nativeEvent: o,
                    targetContainers: [i]
                },
                null !== t && (null !== (t = bi(t)) && xt(t)),
                e) : (e.eventSystemFlags |= r,
                t = e.targetContainers,
                null !== i && -1 === t.indexOf(i) && t.push(i),
                e)
            }
            function Nt(e) {
                var t = yi(e.target);
                if (null !== t) {
                    var n = He(t);
                    if (null !== n)
                        if (13 === (t = n.tag)) {
                            if (null !== (t = je(n)))
                                return e.blockedOn = t,
                                void Et(e.priority, (function() {
                                    St(n)
                                }
                                ))
                        } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated)
                            return void (e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null)
                }
                e.blockedOn = null
            }
            function Ft(e) {
                if (null !== e.blockedOn)
                    return !1;
                for (var t = e.targetContainers; 0 < t.length; ) {
                    var n = qt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
                    if (null !== n)
                        return null !== (t = bi(n)) && xt(t),
                        e.blockedOn = n,
                        !1;
                    var r = new (n = e.nativeEvent).constructor(n.type,n);
                    _e = r,
                    n.target.dispatchEvent(r),
                    _e = null,
                    t.shift()
                }
                return !0
            }
            function Ut(e, t, n) {
                Ft(e) && n.delete(t)
            }
            function zt() {
                Mt = !1,
                null !== Tt && Ft(Tt) && (Tt = null),
                null !== Rt && Ft(Rt) && (Rt = null),
                null !== Pt && Ft(Pt) && (Pt = null),
                Bt.forEach(Ut),
                It.forEach(Ut)
            }
            function Gt(e, t) {
                e.blockedOn === t && (e.blockedOn = null,
                Mt || (Mt = !0,
                i.unstable_scheduleCallback(i.unstable_NormalPriority, zt)))
            }
            function Ht(e) {
                function t(t) {
                    return Gt(t, e)
                }
                if (0 < Ct.length) {
                    Gt(Ct[0], e);
                    for (var n = 1; n < Ct.length; n++) {
                        var r = Ct[n];
                        r.blockedOn === e && (r.blockedOn = null)
                    }
                }
                for (null !== Tt && Gt(Tt, e),
                null !== Rt && Gt(Rt, e),
                null !== Pt && Gt(Pt, e),
                Bt.forEach(t),
                It.forEach(t),
                n = 0; n < Lt.length; n++)
                    (r = Lt[n]).blockedOn === e && (r.blockedOn = null);
                for (; 0 < Lt.length && null === (n = Lt[0]).blockedOn; )
                    Nt(n),
                    null === n.blockedOn && Lt.shift()
            }
            var jt = _.ReactCurrentBatchConfig
              , Wt = !0;
            function Vt(e, t, n, r) {
                var i = bt
                  , o = jt.transition;
                jt.transition = null;
                try {
                    bt = 1,
                    Jt(e, t, n, r)
                } finally {
                    bt = i,
                    jt.transition = o
                }
            }
            function Xt(e, t, n, r) {
                var i = bt
                  , o = jt.transition;
                jt.transition = null;
                try {
                    bt = 4,
                    Jt(e, t, n, r)
                } finally {
                    bt = i,
                    jt.transition = o
                }
            }
            function Jt(e, t, n, r) {
                if (Wt) {
                    var i = qt(e, t, n, r);
                    if (null === i)
                        Wr(e, t, r, Kt, n),
                        Dt(e, r);
                    else if (function(e, t, n, r, i) {
                        switch (t) {
                        case "focusin":
                            return Tt = Ot(Tt, e, t, n, r, i),
                            !0;
                        case "dragenter":
                            return Rt = Ot(Rt, e, t, n, r, i),
                            !0;
                        case "mouseover":
                            return Pt = Ot(Pt, e, t, n, r, i),
                            !0;
                        case "pointerover":
                            var o = i.pointerId;
                            return Bt.set(o, Ot(Bt.get(o) || null, e, t, n, r, i)),
                            !0;
                        case "gotpointercapture":
                            return o = i.pointerId,
                            It.set(o, Ot(It.get(o) || null, e, t, n, r, i)),
                            !0
                        }
                        return !1
                    }(i, e, t, n, r))
                        r.stopPropagation();
                    else if (Dt(e, r),
                    4 & t && -1 < kt.indexOf(e)) {
                        for (; null !== i; ) {
                            var o = bi(i);
                            if (null !== o && At(o),
                            null === (o = qt(e, t, n, r)) && Wr(e, t, r, Kt, n),
                            o === i)
                                break;
                            i = o
                        }
                        null !== i && r.stopPropagation()
                    } else
                        Wr(e, t, r, null, n)
                }
            }
            var Kt = null;
            function qt(e, t, n, r) {
                if (Kt = null,
                null !== (e = yi(e = Ae(r))))
                    if (null === (t = He(e)))
                        e = null;
                    else if (13 === (n = t.tag)) {
                        if (null !== (e = je(t)))
                            return e;
                        e = null
                    } else if (3 === n) {
                        if (t.stateNode.current.memoizedState.isDehydrated)
                            return 3 === t.tag ? t.stateNode.containerInfo : null;
                        e = null
                    } else
                        t !== e && (e = null);
                return Kt = e,
                null
            }
            function Yt(e) {
                switch (e) {
                case "cancel":
                case "click":
                case "close":
                case "contextmenu":
                case "copy":
                case "cut":
                case "auxclick":
                case "dblclick":
                case "dragend":
                case "dragstart":
                case "drop":
                case "focusin":
                case "focusout":
                case "input":
                case "invalid":
                case "keydown":
                case "keypress":
                case "keyup":
                case "mousedown":
                case "mouseup":
                case "paste":
                case "pause":
                case "play":
                case "pointercancel":
                case "pointerdown":
                case "pointerup":
                case "ratechange":
                case "reset":
                case "resize":
                case "seeked":
                case "submit":
                case "touchcancel":
                case "touchend":
                case "touchstart":
                case "volumechange":
                case "change":
                case "selectionchange":
                case "textInput":
                case "compositionstart":
                case "compositionend":
                case "compositionupdate":
                case "beforeblur":
                case "afterblur":
                case "beforeinput":
                case "blur":
                case "fullscreenchange":
                case "focus":
                case "hashchange":
                case "popstate":
                case "select":
                case "selectstart":
                    return 1;
                case "drag":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "mousemove":
                case "mouseout":
                case "mouseover":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "scroll":
                case "toggle":
                case "touchmove":
                case "wheel":
                case "mouseenter":
                case "mouseleave":
                case "pointerenter":
                case "pointerleave":
                    return 4;
                case "message":
                    switch (Ze()) {
                    case $e:
                        return 1;
                    case et:
                        return 4;
                    case tt:
                    case nt:
                        return 16;
                    case rt:
                        return 536870912;
                    default:
                        return 16
                    }
                default:
                    return 16
                }
            }
            var Qt = null
              , Zt = null
              , $t = null;
            function en() {
                if ($t)
                    return $t;
                var e, t, n = Zt, r = n.length, i = "value"in Qt ? Qt.value : Qt.textContent, o = i.length;
                for (e = 0; e < r && n[e] === i[e]; e++)
                    ;
                var a = r - e;
                for (t = 1; t <= a && n[r - t] === i[o - t]; t++)
                    ;
                return $t = i.slice(e, 1 < t ? 1 - t : void 0)
            }
            function tn(e) {
                var t = e.keyCode;
                return "charCode"in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t,
                10 === e && (e = 13),
                32 <= e || 13 === e ? e : 0
            }
            function nn() {
                return !0
            }
            function rn() {
                return !1
            }
            function on(e) {
                function t(t, n, r, i, o) {
                    for (var a in this._reactName = t,
                    this._targetInst = r,
                    this.type = n,
                    this.nativeEvent = i,
                    this.target = o,
                    this.currentTarget = null,
                    e)
                        e.hasOwnProperty(a) && (t = e[a],
                        this[a] = t ? t(i) : i[a]);
                    return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? nn : rn,
                    this.isPropagationStopped = rn,
                    this
                }
                return N(t.prototype, {
                    preventDefault: function() {
                        this.defaultPrevented = !0;
                        var e = this.nativeEvent;
                        e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1),
                        this.isDefaultPrevented = nn)
                    },
                    stopPropagation: function() {
                        var e = this.nativeEvent;
                        e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0),
                        this.isPropagationStopped = nn)
                    },
                    persist: function() {},
                    isPersistent: nn
                }),
                t
            }
            var an, sn, ln, cn = {
                eventPhase: 0,
                bubbles: 0,
                cancelable: 0,
                timeStamp: function(e) {
                    return e.timeStamp || Date.now()
                },
                defaultPrevented: 0,
                isTrusted: 0
            }, un = on(cn), dn = N({}, cn, {
                view: 0,
                detail: 0
            }), hn = on(dn), pn = N({}, dn, {
                screenX: 0,
                screenY: 0,
                clientX: 0,
                clientY: 0,
                pageX: 0,
                pageY: 0,
                ctrlKey: 0,
                shiftKey: 0,
                altKey: 0,
                metaKey: 0,
                getModifierState: En,
                button: 0,
                buttons: 0,
                relatedTarget: function(e) {
                    return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
                },
                movementX: function(e) {
                    return "movementX"in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (an = e.screenX - ln.screenX,
                    sn = e.screenY - ln.screenY) : sn = an = 0,
                    ln = e),
                    an)
                },
                movementY: function(e) {
                    return "movementY"in e ? e.movementY : sn
                }
            }), fn = on(pn), mn = on(N({}, pn, {
                dataTransfer: 0
            })), gn = on(N({}, dn, {
                relatedTarget: 0
            })), vn = on(N({}, cn, {
                animationName: 0,
                elapsedTime: 0,
                pseudoElement: 0
            })), yn = N({}, cn, {
                clipboardData: function(e) {
                    return "clipboardData"in e ? e.clipboardData : window.clipboardData
                }
            }), bn = on(yn), _n = on(N({}, cn, {
                data: 0
            })), An = {
                Esc: "Escape",
                Spacebar: " ",
                Left: "ArrowLeft",
                Up: "ArrowUp",
                Right: "ArrowRight",
                Down: "ArrowDown",
                Del: "Delete",
                Win: "OS",
                Menu: "ContextMenu",
                Apps: "ContextMenu",
                Scroll: "ScrollLock",
                MozPrintableKey: "Unidentified"
            }, xn = {
                8: "Backspace",
                9: "Tab",
                12: "Clear",
                13: "Enter",
                16: "Shift",
                17: "Control",
                18: "Alt",
                19: "Pause",
                20: "CapsLock",
                27: "Escape",
                32: " ",
                33: "PageUp",
                34: "PageDown",
                35: "End",
                36: "Home",
                37: "ArrowLeft",
                38: "ArrowUp",
                39: "ArrowRight",
                40: "ArrowDown",
                45: "Insert",
                46: "Delete",
                112: "F1",
                113: "F2",
                114: "F3",
                115: "F4",
                116: "F5",
                117: "F6",
                118: "F7",
                119: "F8",
                120: "F9",
                121: "F10",
                122: "F11",
                123: "F12",
                144: "NumLock",
                145: "ScrollLock",
                224: "Meta"
            }, Sn = {
                Alt: "altKey",
                Control: "ctrlKey",
                Meta: "metaKey",
                Shift: "shiftKey"
            };
            function wn(e) {
                var t = this.nativeEvent;
                return t.getModifierState ? t.getModifierState(e) : !!(e = Sn[e]) && !!t[e]
            }
            function En() {
                return wn
            }
            var Mn = N({}, dn, {
                key: function(e) {
                    if (e.key) {
                        var t = An[e.key] || e.key;
                        if ("Unidentified" !== t)
                            return t
                    }
                    return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? xn[e.keyCode] || "Unidentified" : ""
                },
                code: 0,
                location: 0,
                ctrlKey: 0,
                shiftKey: 0,
                altKey: 0,
                metaKey: 0,
                repeat: 0,
                locale: 0,
                getModifierState: En,
                charCode: function(e) {
                    return "keypress" === e.type ? tn(e) : 0
                },
                keyCode: function(e) {
                    return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                },
                which: function(e) {
                    return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                }
            })
              , Cn = on(Mn)
              , Tn = on(N({}, pn, {
                pointerId: 0,
                width: 0,
                height: 0,
                pressure: 0,
                tangentialPressure: 0,
                tiltX: 0,
                tiltY: 0,
                twist: 0,
                pointerType: 0,
                isPrimary: 0
            }))
              , Rn = on(N({}, dn, {
                touches: 0,
                targetTouches: 0,
                changedTouches: 0,
                altKey: 0,
                metaKey: 0,
                ctrlKey: 0,
                shiftKey: 0,
                getModifierState: En
            }))
              , Pn = on(N({}, cn, {
                propertyName: 0,
                elapsedTime: 0,
                pseudoElement: 0
            }))
              , Bn = N({}, pn, {
                deltaX: function(e) {
                    return "deltaX"in e ? e.deltaX : "wheelDeltaX"in e ? -e.wheelDeltaX : 0
                },
                deltaY: function(e) {
                    return "deltaY"in e ? e.deltaY : "wheelDeltaY"in e ? -e.wheelDeltaY : "wheelDelta"in e ? -e.wheelDelta : 0
                },
                deltaZ: 0,
                deltaMode: 0
            })
              , In = on(Bn)
              , Ln = [9, 13, 27, 32]
              , kn = u && "CompositionEvent"in window
              , Dn = null;
            u && "documentMode"in document && (Dn = document.documentMode);
            var On = u && "TextEvent"in window && !Dn
              , Nn = u && (!kn || Dn && 8 < Dn && 11 >= Dn)
              , Fn = String.fromCharCode(32)
              , Un = !1;
            function zn(e, t) {
                switch (e) {
                case "keyup":
                    return -1 !== Ln.indexOf(t.keyCode);
                case "keydown":
                    return 229 !== t.keyCode;
                case "keypress":
                case "mousedown":
                case "focusout":
                    return !0;
                default:
                    return !1
                }
            }
            function Gn(e) {
                return "object" === typeof (e = e.detail) && "data"in e ? e.data : null
            }
            var Hn = !1;
            var jn = {
                color: !0,
                date: !0,
                datetime: !0,
                "datetime-local": !0,
                email: !0,
                month: !0,
                number: !0,
                password: !0,
                range: !0,
                search: !0,
                tel: !0,
                text: !0,
                time: !0,
                url: !0,
                week: !0
            };
            function Wn(e) {
                var t = e && e.nodeName && e.nodeName.toLowerCase();
                return "input" === t ? !!jn[e.type] : "textarea" === t
            }
            function Vn(e, t, n, r) {
                Me(r),
                0 < (t = Xr(t, "onChange")).length && (n = new un("onChange","change",null,n,r),
                e.push({
                    event: n,
                    listeners: t
                }))
            }
            var Xn = null
              , Jn = null;
            function Kn(e) {
                Fr(e, 0)
            }
            function qn(e) {
                if (J(_i(e)))
                    return e
            }
            function Yn(e, t) {
                if ("change" === e)
                    return t
            }
            var Qn = !1;
            if (u) {
                var Zn;
                if (u) {
                    var $n = "oninput"in document;
                    if (!$n) {
                        var er = document.createElement("div");
                        er.setAttribute("oninput", "return;"),
                        $n = "function" === typeof er.oninput
                    }
                    Zn = $n
                } else
                    Zn = !1;
                Qn = Zn && (!document.documentMode || 9 < document.documentMode)
            }
            function tr() {
                Xn && (Xn.detachEvent("onpropertychange", nr),
                Jn = Xn = null)
            }
            function nr(e) {
                if ("value" === e.propertyName && qn(Jn)) {
                    var t = [];
                    Vn(t, Jn, e, Ae(e)),
                    Be(Kn, t)
                }
            }
            function rr(e, t, n) {
                "focusin" === e ? (tr(),
                Jn = n,
                (Xn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr()
            }
            function ir(e) {
                if ("selectionchange" === e || "keyup" === e || "keydown" === e)
                    return qn(Jn)
            }
            function or(e, t) {
                if ("click" === e)
                    return qn(t)
            }
            function ar(e, t) {
                if ("input" === e || "change" === e)
                    return qn(t)
            }
            var sr = "function" === typeof Object.is ? Object.is : function(e, t) {
                return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
            }
            ;
            function lr(e, t) {
                if (sr(e, t))
                    return !0;
                if ("object" !== typeof e || null === e || "object" !== typeof t || null === t)
                    return !1;
                var n = Object.keys(e)
                  , r = Object.keys(t);
                if (n.length !== r.length)
                    return !1;
                for (r = 0; r < n.length; r++) {
                    var i = n[r];
                    if (!d.call(t, i) || !sr(e[i], t[i]))
                        return !1
                }
                return !0
            }
            function cr(e) {
                for (; e && e.firstChild; )
                    e = e.firstChild;
                return e
            }
            function ur(e, t) {
                var n, r = cr(e);
                for (e = 0; r; ) {
                    if (3 === r.nodeType) {
                        if (n = e + r.textContent.length,
                        e <= t && n >= t)
                            return {
                                node: r,
                                offset: t - e
                            };
                        e = n
                    }
                    e: {
                        for (; r; ) {
                            if (r.nextSibling) {
                                r = r.nextSibling;
                                break e
                            }
                            r = r.parentNode
                        }
                        r = void 0
                    }
                    r = cr(r)
                }
            }
            function dr(e, t) {
                return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? dr(e, t.parentNode) : "contains"in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t))))
            }
            function hr() {
                for (var e = window, t = K(); t instanceof e.HTMLIFrameElement; ) {
                    try {
                        var n = "string" === typeof t.contentWindow.location.href
                    } catch (r) {
                        n = !1
                    }
                    if (!n)
                        break;
                    t = K((e = t.contentWindow).document)
                }
                return t
            }
            function pr(e) {
                var t = e && e.nodeName && e.nodeName.toLowerCase();
                return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable)
            }
            function fr(e) {
                var t = hr()
                  , n = e.focusedElem
                  , r = e.selectionRange;
                if (t !== n && n && n.ownerDocument && dr(n.ownerDocument.documentElement, n)) {
                    if (null !== r && pr(n))
                        if (t = r.start,
                        void 0 === (e = r.end) && (e = t),
                        "selectionStart"in n)
                            n.selectionStart = t,
                            n.selectionEnd = Math.min(e, n.value.length);
                        else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) {
                            e = e.getSelection();
                            var i = n.textContent.length
                              , o = Math.min(r.start, i);
                            r = void 0 === r.end ? o : Math.min(r.end, i),
                            !e.extend && o > r && (i = r,
                            r = o,
                            o = i),
                            i = ur(n, o);
                            var a = ur(n, r);
                            i && a && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== a.node || e.focusOffset !== a.offset) && ((t = t.createRange()).setStart(i.node, i.offset),
                            e.removeAllRanges(),
                            o > r ? (e.addRange(t),
                            e.extend(a.node, a.offset)) : (t.setEnd(a.node, a.offset),
                            e.addRange(t)))
                        }
                    for (t = [],
                    e = n; e = e.parentNode; )
                        1 === e.nodeType && t.push({
                            element: e,
                            left: e.scrollLeft,
                            top: e.scrollTop
                        });
                    for ("function" === typeof n.focus && n.focus(),
                    n = 0; n < t.length; n++)
                        (e = t[n]).element.scrollLeft = e.left,
                        e.element.scrollTop = e.top
                }
            }
            var mr = u && "documentMode"in document && 11 >= document.documentMode
              , gr = null
              , vr = null
              , yr = null
              , br = !1;
            function _r(e, t, n) {
                var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument;
                br || null == gr || gr !== K(r) || ("selectionStart"in (r = gr) && pr(r) ? r = {
                    start: r.selectionStart,
                    end: r.selectionEnd
                } : r = {
                    anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode,
                    anchorOffset: r.anchorOffset,
                    focusNode: r.focusNode,
                    focusOffset: r.focusOffset
                },
                yr && lr(yr, r) || (yr = r,
                0 < (r = Xr(vr, "onSelect")).length && (t = new un("onSelect","select",null,t,n),
                e.push({
                    event: t,
                    listeners: r
                }),
                t.target = gr)))
            }
            function Ar(e, t) {
                var n = {};
                return n[e.toLowerCase()] = t.toLowerCase(),
                n["Webkit" + e] = "webkit" + t,
                n["Moz" + e] = "moz" + t,
                n
            }
            var xr = {
                animationend: Ar("Animation", "AnimationEnd"),
                animationiteration: Ar("Animation", "AnimationIteration"),
                animationstart: Ar("Animation", "AnimationStart"),
                transitionend: Ar("Transition", "TransitionEnd")
            }
              , Sr = {}
              , wr = {};
            function Er(e) {
                if (Sr[e])
                    return Sr[e];
                if (!xr[e])
                    return e;
                var t, n = xr[e];
                for (t in n)
                    if (n.hasOwnProperty(t) && t in wr)
                        return Sr[e] = n[t];
                return e
            }
            u && (wr = document.createElement("div").style,
            "AnimationEvent"in window || (delete xr.animationend.animation,
            delete xr.animationiteration.animation,
            delete xr.animationstart.animation),
            "TransitionEvent"in window || delete xr.transitionend.transition);
            var Mr = Er("animationend")
              , Cr = Er("animationiteration")
              , Tr = Er("animationstart")
              , Rr = Er("transitionend")
              , Pr = new Map
              , Br = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
            function Ir(e, t) {
                Pr.set(e, t),
                l(t, [e])
            }
            for (var Lr = 0; Lr < Br.length; Lr++) {
                var kr = Br[Lr];
                Ir(kr.toLowerCase(), "on" + (kr[0].toUpperCase() + kr.slice(1)))
            }
            Ir(Mr, "onAnimationEnd"),
            Ir(Cr, "onAnimationIteration"),
            Ir(Tr, "onAnimationStart"),
            Ir("dblclick", "onDoubleClick"),
            Ir("focusin", "onFocus"),
            Ir("focusout", "onBlur"),
            Ir(Rr, "onTransitionEnd"),
            c("onMouseEnter", ["mouseout", "mouseover"]),
            c("onMouseLeave", ["mouseout", "mouseover"]),
            c("onPointerEnter", ["pointerout", "pointerover"]),
            c("onPointerLeave", ["pointerout", "pointerover"]),
            l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
            l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
            l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
            l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
            l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
            l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
            var Dr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
              , Or = new Set("cancel close invalid load scroll toggle".split(" ").concat(Dr));
            function Nr(e, t, n) {
                var r = e.type || "unknown-event";
                e.currentTarget = n,
                function(e, t, n, r, i, a, s, l, c) {
                    if (Ge.apply(this, arguments),
                    Oe) {
                        if (!Oe)
                            throw Error(o(198));
                        var u = Ne;
                        Oe = !1,
                        Ne = null,
                        Fe || (Fe = !0,
                        Ue = u)
                    }
                }(r, t, void 0, e),
                e.currentTarget = null
            }
            function Fr(e, t) {
                t = 0 !== (4 & t);
                for (var n = 0; n < e.length; n++) {
                    var r = e[n]
                      , i = r.event;
                    r = r.listeners;
                    e: {
                        var o = void 0;
                        if (t)
                            for (var a = r.length - 1; 0 <= a; a--) {
                                var s = r[a]
                                  , l = s.instance
                                  , c = s.currentTarget;
                                if (s = s.listener,
                                l !== o && i.isPropagationStopped())
                                    break e;
                                Nr(i, s, c),
                                o = l
                            }
                        else
                            for (a = 0; a < r.length; a++) {
                                if (l = (s = r[a]).instance,
                                c = s.currentTarget,
                                s = s.listener,
                                l !== o && i.isPropagationStopped())
                                    break e;
                                Nr(i, s, c),
                                o = l
                            }
                    }
                }
                if (Fe)
                    throw e = Ue,
                    Fe = !1,
                    Ue = null,
                    e
            }
            function Ur(e, t) {
                var n = t[mi];
                void 0 === n && (n = t[mi] = new Set);
                var r = e + "__bubble";
                n.has(r) || (jr(t, e, 2, !1),
                n.add(r))
            }
            function zr(e, t, n) {
                var r = 0;
                t && (r |= 4),
                jr(n, e, r, t)
            }
            var Gr = "_reactListening" + Math.random().toString(36).slice(2);
            function Hr(e) {
                if (!e[Gr]) {
                    e[Gr] = !0,
                    a.forEach((function(t) {
                        "selectionchange" !== t && (Or.has(t) || zr(t, !1, e),
                        zr(t, !0, e))
                    }
                    ));
                    var t = 9 === e.nodeType ? e : e.ownerDocument;
                    null === t || t[Gr] || (t[Gr] = !0,
                    zr("selectionchange", !1, t))
                }
            }
            function jr(e, t, n, r) {
                switch (Yt(t)) {
                case 1:
                    var i = Vt;
                    break;
                case 4:
                    i = Xt;
                    break;
                default:
                    i = Jt
                }
                n = i.bind(null, t, n, e),
                i = void 0,
                !Le || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0),
                r ? void 0 !== i ? e.addEventListener(t, n, {
                    capture: !0,
                    passive: i
                }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, {
                    passive: i
                }) : e.addEventListener(t, n, !1)
            }
            function Wr(e, t, n, r, i) {
                var o = r;
                if (0 === (1 & t) && 0 === (2 & t) && null !== r)
                    e: for (; ; ) {
                        if (null === r)
                            return;
                        var a = r.tag;
                        if (3 === a || 4 === a) {
                            var s = r.stateNode.containerInfo;
                            if (s === i || 8 === s.nodeType && s.parentNode === i)
                                break;
                            if (4 === a)
                                for (a = r.return; null !== a; ) {
                                    var l = a.tag;
                                    if ((3 === l || 4 === l) && ((l = a.stateNode.containerInfo) === i || 8 === l.nodeType && l.parentNode === i))
                                        return;
                                    a = a.return
                                }
                            for (; null !== s; ) {
                                if (null === (a = yi(s)))
                                    return;
                                if (5 === (l = a.tag) || 6 === l) {
                                    r = o = a;
                                    continue e
                                }
                                s = s.parentNode
                            }
                        }
                        r = r.return
                    }
                Be((function() {
                    var r = o
                      , i = Ae(n)
                      , a = [];
                    e: {
                        var s = Pr.get(e);
                        if (void 0 !== s) {
                            var l = un
                              , c = e;
                            switch (e) {
                            case "keypress":
                                if (0 === tn(n))
                                    break e;
                            case "keydown":
                            case "keyup":
                                l = Cn;
                                break;
                            case "focusin":
                                c = "focus",
                                l = gn;
                                break;
                            case "focusout":
                                c = "blur",
                                l = gn;
                                break;
                            case "beforeblur":
                            case "afterblur":
                                l = gn;
                                break;
                            case "click":
                                if (2 === n.button)
                                    break e;
                            case "auxclick":
                            case "dblclick":
                            case "mousedown":
                            case "mousemove":
                            case "mouseup":
                            case "mouseout":
                            case "mouseover":
                            case "contextmenu":
                                l = fn;
                                break;
                            case "drag":
                            case "dragend":
                            case "dragenter":
                            case "dragexit":
                            case "dragleave":
                            case "dragover":
                            case "dragstart":
                            case "drop":
                                l = mn;
                                break;
                            case "touchcancel":
                            case "touchend":
                            case "touchmove":
                            case "touchstart":
                                l = Rn;
                                break;
                            case Mr:
                            case Cr:
                            case Tr:
                                l = vn;
                                break;
                            case Rr:
                                l = Pn;
                                break;
                            case "scroll":
                                l = hn;
                                break;
                            case "wheel":
                                l = In;
                                break;
                            case "copy":
                            case "cut":
                            case "paste":
                                l = bn;
                                break;
                            case "gotpointercapture":
                            case "lostpointercapture":
                            case "pointercancel":
                            case "pointerdown":
                            case "pointermove":
                            case "pointerout":
                            case "pointerover":
                            case "pointerup":
                                l = Tn
                            }
                            var u = 0 !== (4 & t)
                              , d = !u && "scroll" === e
                              , h = u ? null !== s ? s + "Capture" : null : s;
                            u = [];
                            for (var p, f = r; null !== f; ) {
                                var m = (p = f).stateNode;
                                if (5 === p.tag && null !== m && (p = m,
                                null !== h && (null != (m = Ie(f, h)) && u.push(Vr(f, m, p)))),
                                d)
                                    break;
                                f = f.return
                            }
                            0 < u.length && (s = new l(s,c,null,n,i),
                            a.push({
                                event: s,
                                listeners: u
                            }))
                        }
                    }
                    if (0 === (7 & t)) {
                        if (l = "mouseout" === e || "pointerout" === e,
                        (!(s = "mouseover" === e || "pointerover" === e) || n === _e || !(c = n.relatedTarget || n.fromElement) || !yi(c) && !c[fi]) && (l || s) && (s = i.window === i ? i : (s = i.ownerDocument) ? s.defaultView || s.parentWindow : window,
                        l ? (l = r,
                        null !== (c = (c = n.relatedTarget || n.toElement) ? yi(c) : null) && (c !== (d = He(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (l = null,
                        c = r),
                        l !== c)) {
                            if (u = fn,
                            m = "onMouseLeave",
                            h = "onMouseEnter",
                            f = "mouse",
                            "pointerout" !== e && "pointerover" !== e || (u = Tn,
                            m = "onPointerLeave",
                            h = "onPointerEnter",
                            f = "pointer"),
                            d = null == l ? s : _i(l),
                            p = null == c ? s : _i(c),
                            (s = new u(m,f + "leave",l,n,i)).target = d,
                            s.relatedTarget = p,
                            m = null,
                            yi(i) === r && ((u = new u(h,f + "enter",c,n,i)).target = p,
                            u.relatedTarget = d,
                            m = u),
                            d = m,
                            l && c)
                                e: {
                                    for (h = c,
                                    f = 0,
                                    p = u = l; p; p = Jr(p))
                                        f++;
                                    for (p = 0,
                                    m = h; m; m = Jr(m))
                                        p++;
                                    for (; 0 < f - p; )
                                        u = Jr(u),
                                        f--;
                                    for (; 0 < p - f; )
                                        h = Jr(h),
                                        p--;
                                    for (; f--; ) {
                                        if (u === h || null !== h && u === h.alternate)
                                            break e;
                                        u = Jr(u),
                                        h = Jr(h)
                                    }
                                    u = null
                                }
                            else
                                u = null;
                            null !== l && Kr(a, s, l, u, !1),
                            null !== c && null !== d && Kr(a, d, c, u, !0)
                        }
                        if ("select" === (l = (s = r ? _i(r) : window).nodeName && s.nodeName.toLowerCase()) || "input" === l && "file" === s.type)
                            var g = Yn;
                        else if (Wn(s))
                            if (Qn)
                                g = ar;
                            else {
                                g = ir;
                                var v = rr
                            }
                        else
                            (l = s.nodeName) && "input" === l.toLowerCase() && ("checkbox" === s.type || "radio" === s.type) && (g = or);
                        switch (g && (g = g(e, r)) ? Vn(a, g, n, i) : (v && v(e, s, r),
                        "focusout" === e && (v = s._wrapperState) && v.controlled && "number" === s.type && ee(s, "number", s.value)),
                        v = r ? _i(r) : window,
                        e) {
                        case "focusin":
                            (Wn(v) || "true" === v.contentEditable) && (gr = v,
                            vr = r,
                            yr = null);
                            break;
                        case "focusout":
                            yr = vr = gr = null;
                            break;
                        case "mousedown":
                            br = !0;
                            break;
                        case "contextmenu":
                        case "mouseup":
                        case "dragend":
                            br = !1,
                            _r(a, n, i);
                            break;
                        case "selectionchange":
                            if (mr)
                                break;
                        case "keydown":
                        case "keyup":
                            _r(a, n, i)
                        }
                        var y;
                        if (kn)
                            e: {
                                switch (e) {
                                case "compositionstart":
                                    var b = "onCompositionStart";
                                    break e;
                                case "compositionend":
                                    b = "onCompositionEnd";
                                    break e;
                                case "compositionupdate":
                                    b = "onCompositionUpdate";
                                    break e
                                }
                                b = void 0
                            }
                        else
                            Hn ? zn(e, n) && (b = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (b = "onCompositionStart");
                        b && (Nn && "ko" !== n.locale && (Hn || "onCompositionStart" !== b ? "onCompositionEnd" === b && Hn && (y = en()) : (Zt = "value"in (Qt = i) ? Qt.value : Qt.textContent,
                        Hn = !0)),
                        0 < (v = Xr(r, b)).length && (b = new _n(b,e,null,n,i),
                        a.push({
                            event: b,
                            listeners: v
                        }),
                        y ? b.data = y : null !== (y = Gn(n)) && (b.data = y))),
                        (y = On ? function(e, t) {
                            switch (e) {
                            case "compositionend":
                                return Gn(t);
                            case "keypress":
                                return 32 !== t.which ? null : (Un = !0,
                                Fn);
                            case "textInput":
                                return (e = t.data) === Fn && Un ? null : e;
                            default:
                                return null
                            }
                        }(e, n) : function(e, t) {
                            if (Hn)
                                return "compositionend" === e || !kn && zn(e, t) ? (e = en(),
                                $t = Zt = Qt = null,
                                Hn = !1,
                                e) : null;
                            switch (e) {
                            case "paste":
                            default:
                                return null;
                            case "keypress":
                                if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                                    if (t.char && 1 < t.char.length)
                                        return t.char;
                                    if (t.which)
                                        return String.fromCharCode(t.which)
                                }
                                return null;
                            case "compositionend":
                                return Nn && "ko" !== t.locale ? null : t.data
                            }
                        }(e, n)) && (0 < (r = Xr(r, "onBeforeInput")).length && (i = new _n("onBeforeInput","beforeinput",null,n,i),
                        a.push({
                            event: i,
                            listeners: r
                        }),
                        i.data = y))
                    }
                    Fr(a, t)
                }
                ))
            }
            function Vr(e, t, n) {
                return {
                    instance: e,
                    listener: t,
                    currentTarget: n
                }
            }
            function Xr(e, t) {
                for (var n = t + "Capture", r = []; null !== e; ) {
                    var i = e
                      , o = i.stateNode;
                    5 === i.tag && null !== o && (i = o,
                    null != (o = Ie(e, n)) && r.unshift(Vr(e, o, i)),
                    null != (o = Ie(e, t)) && r.push(Vr(e, o, i))),
                    e = e.return
                }
                return r
            }
            function Jr(e) {
                if (null === e)
                    return null;
                do {
                    e = e.return
                } while (e && 5 !== e.tag);
                return e || null
            }
            function Kr(e, t, n, r, i) {
                for (var o = t._reactName, a = []; null !== n && n !== r; ) {
                    var s = n
                      , l = s.alternate
                      , c = s.stateNode;
                    if (null !== l && l === r)
                        break;
                    5 === s.tag && null !== c && (s = c,
                    i ? null != (l = Ie(n, o)) && a.unshift(Vr(n, l, s)) : i || null != (l = Ie(n, o)) && a.push(Vr(n, l, s))),
                    n = n.return
                }
                0 !== a.length && e.push({
                    event: t,
                    listeners: a
                })
            }
            var qr = /\r\n?/g
              , Yr = /\u0000|\uFFFD/g;
            function Qr(e) {
                return ("string" === typeof e ? e : "" + e).replace(qr, "\n").replace(Yr, "")
            }
            function Zr(e, t, n) {
                if (t = Qr(t),
                Qr(e) !== t && n)
                    throw Error(o(425))
            }
            function $r() {}
            var ei = null
              , ti = null;
            function ni(e, t) {
                return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html
            }
            var ri = "function" === typeof setTimeout ? setTimeout : void 0
              , ii = "function" === typeof clearTimeout ? clearTimeout : void 0
              , oi = "function" === typeof Promise ? Promise : void 0
              , ai = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof oi ? function(e) {
                return oi.resolve(null).then(e).catch(si)
            }
            : ri;
            function si(e) {
                setTimeout((function() {
                    throw e
                }
                ))
            }
            function li(e, t) {
                var n = t
                  , r = 0;
                do {
                    var i = n.nextSibling;
                    if (e.removeChild(n),
                    i && 8 === i.nodeType)
                        if ("/$" === (n = i.data)) {
                            if (0 === r)
                                return e.removeChild(i),
                                void Ht(t);
                            r--
                        } else
                            "$" !== n && "$?" !== n && "$!" !== n || r++;
                    n = i
                } while (n);
                Ht(t)
            }
            function ci(e) {
                for (; null != e; e = e.nextSibling) {
                    var t = e.nodeType;
                    if (1 === t || 3 === t)
                        break;
                    if (8 === t) {
                        if ("$" === (t = e.data) || "$!" === t || "$?" === t)
                            break;
                        if ("/$" === t)
                            return null
                    }
                }
                return e
            }
            function ui(e) {
                e = e.previousSibling;
                for (var t = 0; e; ) {
                    if (8 === e.nodeType) {
                        var n = e.data;
                        if ("$" === n || "$!" === n || "$?" === n) {
                            if (0 === t)
                                return e;
                            t--
                        } else
                            "/$" === n && t++
                    }
                    e = e.previousSibling
                }
                return null
            }
            var di = Math.random().toString(36).slice(2)
              , hi = "__reactFiber$" + di
              , pi = "__reactProps$" + di
              , fi = "__reactContainer$" + di
              , mi = "__reactEvents$" + di
              , gi = "__reactListeners$" + di
              , vi = "__reactHandles$" + di;
            function yi(e) {
                var t = e[hi];
                if (t)
                    return t;
                for (var n = e.parentNode; n; ) {
                    if (t = n[fi] || n[hi]) {
                        if (n = t.alternate,
                        null !== t.child || null !== n && null !== n.child)
                            for (e = ui(e); null !== e; ) {
                                if (n = e[hi])
                                    return n;
                                e = ui(e)
                            }
                        return t
                    }
                    n = (e = n).parentNode
                }
                return null
            }
            function bi(e) {
                return !(e = e[hi] || e[fi]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e
            }
            function _i(e) {
                if (5 === e.tag || 6 === e.tag)
                    return e.stateNode;
                throw Error(o(33))
            }
            function Ai(e) {
                return e[pi] || null
            }
            var xi = []
              , Si = -1;
            function wi(e) {
                return {
                    current: e
                }
            }
            function Ei(e) {
                0 > Si || (e.current = xi[Si],
                xi[Si] = null,
                Si--)
            }
            function Mi(e, t) {
                Si++,
                xi[Si] = e.current,
                e.current = t
            }
            var Ci = {}
              , Ti = wi(Ci)
              , Ri = wi(!1)
              , Pi = Ci;
            function Bi(e, t) {
                var n = e.type.contextTypes;
                if (!n)
                    return Ci;
                var r = e.stateNode;
                if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
                    return r.__reactInternalMemoizedMaskedChildContext;
                var i, o = {};
                for (i in n)
                    o[i] = t[i];
                return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t,
                e.__reactInternalMemoizedMaskedChildContext = o),
                o
            }
            function Ii(e) {
                return null !== (e = e.childContextTypes) && void 0 !== e
            }
            function Li() {
                Ei(Ri),
                Ei(Ti)
            }
            function ki(e, t, n) {
                if (Ti.current !== Ci)
                    throw Error(o(168));
                Mi(Ti, t),
                Mi(Ri, n)
            }
            function Di(e, t, n) {
                var r = e.stateNode;
                if (t = t.childContextTypes,
                "function" !== typeof r.getChildContext)
                    return n;
                for (var i in r = r.getChildContext())
                    if (!(i in t))
                        throw Error(o(108, j(e) || "Unknown", i));
                return N({}, n, r)
            }
            function Oi(e) {
                return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Ci,
                Pi = Ti.current,
                Mi(Ti, e),
                Mi(Ri, Ri.current),
                !0
            }
            function Ni(e, t, n) {
                var r = e.stateNode;
                if (!r)
                    throw Error(o(169));
                n ? (e = Di(e, t, Pi),
                r.__reactInternalMemoizedMergedChildContext = e,
                Ei(Ri),
                Ei(Ti),
                Mi(Ti, e)) : Ei(Ri),
                Mi(Ri, n)
            }
            var Fi = null
              , Ui = !1
              , zi = !1;
            function Gi(e) {
                null === Fi ? Fi = [e] : Fi.push(e)
            }
            function Hi() {
                if (!zi && null !== Fi) {
                    zi = !0;
                    var e = 0
                      , t = bt;
                    try {
                        var n = Fi;
                        for (bt = 1; e < n.length; e++) {
                            var r = n[e];
                            do {
                                r = r(!0)
                            } while (null !== r)
                        }
                        Fi = null,
                        Ui = !1
                    } catch (i) {
                        throw null !== Fi && (Fi = Fi.slice(e + 1)),
                        Je($e, Hi),
                        i
                    } finally {
                        bt = t,
                        zi = !1
                    }
                }
                return null
            }
            var ji = []
              , Wi = 0
              , Vi = null
              , Xi = 0
              , Ji = []
              , Ki = 0
              , qi = null
              , Yi = 1
              , Qi = "";
            function Zi(e, t) {
                ji[Wi++] = Xi,
                ji[Wi++] = Vi,
                Vi = e,
                Xi = t
            }
            function $i(e, t, n) {
                Ji[Ki++] = Yi,
                Ji[Ki++] = Qi,
                Ji[Ki++] = qi,
                qi = e;
                var r = Yi;
                e = Qi;
                var i = 32 - at(r) - 1;
                r &= ~(1 << i),
                n += 1;
                var o = 32 - at(t) + i;
                if (30 < o) {
                    var a = i - i % 5;
                    o = (r & (1 << a) - 1).toString(32),
                    r >>= a,
                    i -= a,
                    Yi = 1 << 32 - at(t) + i | n << i | r,
                    Qi = o + e
                } else
                    Yi = 1 << o | n << i | r,
                    Qi = e
            }
            function eo(e) {
                null !== e.return && (Zi(e, 1),
                $i(e, 1, 0))
            }
            function to(e) {
                for (; e === Vi; )
                    Vi = ji[--Wi],
                    ji[Wi] = null,
                    Xi = ji[--Wi],
                    ji[Wi] = null;
                for (; e === qi; )
                    qi = Ji[--Ki],
                    Ji[Ki] = null,
                    Qi = Ji[--Ki],
                    Ji[Ki] = null,
                    Yi = Ji[--Ki],
                    Ji[Ki] = null
            }
            var no = null
              , ro = null
              , io = !1
              , oo = null;
            function ao(e, t) {
                var n = Bc(5, null, null, 0);
                n.elementType = "DELETED",
                n.stateNode = t,
                n.return = e,
                null === (t = e.deletions) ? (e.deletions = [n],
                e.flags |= 16) : t.push(n)
            }
            function so(e, t) {
                switch (e.tag) {
                case 5:
                    var n = e.type;
                    return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t,
                    no = e,
                    ro = ci(t.firstChild),
                    !0);
                case 6:
                    return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t,
                    no = e,
                    ro = null,
                    !0);
                case 13:
                    return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== qi ? {
                        id: Yi,
                        overflow: Qi
                    } : null,
                    e.memoizedState = {
                        dehydrated: t,
                        treeContext: n,
                        retryLane: 1073741824
                    },
                    (n = Bc(18, null, null, 0)).stateNode = t,
                    n.return = e,
                    e.child = n,
                    no = e,
                    ro = null,
                    !0);
                default:
                    return !1
                }
            }
            function lo(e) {
                return 0 !== (1 & e.mode) && 0 === (128 & e.flags)
            }
            function co(e) {
                if (io) {
                    var t = ro;
                    if (t) {
                        var n = t;
                        if (!so(e, t)) {
                            if (lo(e))
                                throw Error(o(418));
                            t = ci(n.nextSibling);
                            var r = no;
                            t && so(e, t) ? ao(r, n) : (e.flags = -4097 & e.flags | 2,
                            io = !1,
                            no = e)
                        }
                    } else {
                        if (lo(e))
                            throw Error(o(418));
                        e.flags = -4097 & e.flags | 2,
                        io = !1,
                        no = e
                    }
                }
            }
            function uo(e) {
                for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag; )
                    e = e.return;
                no = e
            }
            function ho(e) {
                if (e !== no)
                    return !1;
                if (!io)
                    return uo(e),
                    io = !0,
                    !1;
                var t;
                if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !ni(e.type, e.memoizedProps)),
                t && (t = ro)) {
                    if (lo(e))
                        throw po(),
                        Error(o(418));
                    for (; t; )
                        ao(e, t),
                        t = ci(t.nextSibling)
                }
                if (uo(e),
                13 === e.tag) {
                    if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null))
                        throw Error(o(317));
                    e: {
                        for (e = e.nextSibling,
                        t = 0; e; ) {
                            if (8 === e.nodeType) {
                                var n = e.data;
                                if ("/$" === n) {
                                    if (0 === t) {
                                        ro = ci(e.nextSibling);
                                        break e
                                    }
                                    t--
                                } else
                                    "$" !== n && "$!" !== n && "$?" !== n || t++
                            }
                            e = e.nextSibling
                        }
                        ro = null
                    }
                } else
                    ro = no ? ci(e.stateNode.nextSibling) : null;
                return !0
            }
            function po() {
                for (var e = ro; e; )
                    e = ci(e.nextSibling)
            }
            function fo() {
                ro = no = null,
                io = !1
            }
            function mo(e) {
                null === oo ? oo = [e] : oo.push(e)
            }
            var go = _.ReactCurrentBatchConfig;
            function vo(e, t, n) {
                if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) {
                    if (n._owner) {
                        if (n = n._owner) {
                            if (1 !== n.tag)
                                throw Error(o(309));
                            var r = n.stateNode
                        }
                        if (!r)
                            throw Error(o(147, e));
                        var i = r
                          , a = "" + e;
                        return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === a ? t.ref : (t = function(e) {
                            var t = i.refs;
                            null === e ? delete t[a] : t[a] = e
                        }
                        ,
                        t._stringRef = a,
                        t)
                    }
                    if ("string" !== typeof e)
                        throw Error(o(284));
                    if (!n._owner)
                        throw Error(o(290, e))
                }
                return e
            }
            function yo(e, t) {
                throw e = Object.prototype.toString.call(t),
                Error(o(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
            }
            function bo(e) {
                return (0,
                e._init)(e._payload)
            }
            function _o(e) {
                function t(t, n) {
                    if (e) {
                        var r = t.deletions;
                        null === r ? (t.deletions = [n],
                        t.flags |= 16) : r.push(n)
                    }
                }
                function n(n, r) {
                    if (!e)
                        return null;
                    for (; null !== r; )
                        t(n, r),
                        r = r.sibling;
                    return null
                }
                function r(e, t) {
                    for (e = new Map; null !== t; )
                        null !== t.key ? e.set(t.key, t) : e.set(t.index, t),
                        t = t.sibling;
                    return e
                }
                function i(e, t) {
                    return (e = Lc(e, t)).index = 0,
                    e.sibling = null,
                    e
                }
                function a(t, n, r) {
                    return t.index = r,
                    e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2,
                    n) : r : (t.flags |= 2,
                    n) : (t.flags |= 1048576,
                    n)
                }
                function s(t) {
                    return e && null === t.alternate && (t.flags |= 2),
                    t
                }
                function l(e, t, n, r) {
                    return null === t || 6 !== t.tag ? ((t = Nc(n, e.mode, r)).return = e,
                    t) : ((t = i(t, n)).return = e,
                    t)
                }
                function c(e, t, n, r) {
                    var o = n.type;
                    return o === S ? d(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === o || "object" === typeof o && null !== o && o.$$typeof === I && bo(o) === t.type) ? ((r = i(t, n.props)).ref = vo(e, t, n),
                    r.return = e,
                    r) : ((r = kc(n.type, n.key, n.props, null, e.mode, r)).ref = vo(e, t, n),
                    r.return = e,
                    r)
                }
                function u(e, t, n, r) {
                    return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Fc(n, e.mode, r)).return = e,
                    t) : ((t = i(t, n.children || [])).return = e,
                    t)
                }
                function d(e, t, n, r, o) {
                    return null === t || 7 !== t.tag ? ((t = Dc(n, e.mode, r, o)).return = e,
                    t) : ((t = i(t, n)).return = e,
                    t)
                }
                function h(e, t, n) {
                    if ("string" === typeof t && "" !== t || "number" === typeof t)
                        return (t = Nc("" + t, e.mode, n)).return = e,
                        t;
                    if ("object" === typeof t && null !== t) {
                        switch (t.$$typeof) {
                        case A:
                            return (n = kc(t.type, t.key, t.props, null, e.mode, n)).ref = vo(e, null, t),
                            n.return = e,
                            n;
                        case x:
                            return (t = Fc(t, e.mode, n)).return = e,
                            t;
                        case I:
                            return h(e, (0,
                            t._init)(t._payload), n)
                        }
                        if (te(t) || D(t))
                            return (t = Dc(t, e.mode, n, null)).return = e,
                            t;
                        yo(e, t)
                    }
                    return null
                }
                function p(e, t, n, r) {
                    var i = null !== t ? t.key : null;
                    if ("string" === typeof n && "" !== n || "number" === typeof n)
                        return null !== i ? null : l(e, t, "" + n, r);
                    if ("object" === typeof n && null !== n) {
                        switch (n.$$typeof) {
                        case A:
                            return n.key === i ? c(e, t, n, r) : null;
                        case x:
                            return n.key === i ? u(e, t, n, r) : null;
                        case I:
                            return p(e, t, (i = n._init)(n._payload), r)
                        }
                        if (te(n) || D(n))
                            return null !== i ? null : d(e, t, n, r, null);
                        yo(e, n)
                    }
                    return null
                }
                function f(e, t, n, r, i) {
                    if ("string" === typeof r && "" !== r || "number" === typeof r)
                        return l(t, e = e.get(n) || null, "" + r, i);
                    if ("object" === typeof r && null !== r) {
                        switch (r.$$typeof) {
                        case A:
                            return c(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                        case x:
                            return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                        case I:
                            return f(e, t, n, (0,
                            r._init)(r._payload), i)
                        }
                        if (te(r) || D(r))
                            return d(t, e = e.get(n) || null, r, i, null);
                        yo(t, r)
                    }
                    return null
                }
                function m(i, o, s, l) {
                    for (var c = null, u = null, d = o, m = o = 0, g = null; null !== d && m < s.length; m++) {
                        d.index > m ? (g = d,
                        d = null) : g = d.sibling;
                        var v = p(i, d, s[m], l);
                        if (null === v) {
                            null === d && (d = g);
                            break
                        }
                        e && d && null === v.alternate && t(i, d),
                        o = a(v, o, m),
                        null === u ? c = v : u.sibling = v,
                        u = v,
                        d = g
                    }
                    if (m === s.length)
                        return n(i, d),
                        io && Zi(i, m),
                        c;
                    if (null === d) {
                        for (; m < s.length; m++)
                            null !== (d = h(i, s[m], l)) && (o = a(d, o, m),
                            null === u ? c = d : u.sibling = d,
                            u = d);
                        return io && Zi(i, m),
                        c
                    }
                    for (d = r(i, d); m < s.length; m++)
                        null !== (g = f(d, i, m, s[m], l)) && (e && null !== g.alternate && d.delete(null === g.key ? m : g.key),
                        o = a(g, o, m),
                        null === u ? c = g : u.sibling = g,
                        u = g);
                    return e && d.forEach((function(e) {
                        return t(i, e)
                    }
                    )),
                    io && Zi(i, m),
                    c
                }
                function g(i, s, l, c) {
                    var u = D(l);
                    if ("function" !== typeof u)
                        throw Error(o(150));
                    if (null == (l = u.call(l)))
                        throw Error(o(151));
                    for (var d = u = null, m = s, g = s = 0, v = null, y = l.next(); null !== m && !y.done; g++,
                    y = l.next()) {
                        m.index > g ? (v = m,
                        m = null) : v = m.sibling;
                        var b = p(i, m, y.value, c);
                        if (null === b) {
                            null === m && (m = v);
                            break
                        }
                        e && m && null === b.alternate && t(i, m),
                        s = a(b, s, g),
                        null === d ? u = b : d.sibling = b,
                        d = b,
                        m = v
                    }
                    if (y.done)
                        return n(i, m),
                        io && Zi(i, g),
                        u;
                    if (null === m) {
                        for (; !y.done; g++,
                        y = l.next())
                            null !== (y = h(i, y.value, c)) && (s = a(y, s, g),
                            null === d ? u = y : d.sibling = y,
                            d = y);
                        return io && Zi(i, g),
                        u
                    }
                    for (m = r(i, m); !y.done; g++,
                    y = l.next())
                        null !== (y = f(m, i, g, y.value, c)) && (e && null !== y.alternate && m.delete(null === y.key ? g : y.key),
                        s = a(y, s, g),
                        null === d ? u = y : d.sibling = y,
                        d = y);
                    return e && m.forEach((function(e) {
                        return t(i, e)
                    }
                    )),
                    io && Zi(i, g),
                    u
                }
                return function e(r, o, a, l) {
                    if ("object" === typeof a && null !== a && a.type === S && null === a.key && (a = a.props.children),
                    "object" === typeof a && null !== a) {
                        switch (a.$$typeof) {
                        case A:
                            e: {
                                for (var c = a.key, u = o; null !== u; ) {
                                    if (u.key === c) {
                                        if ((c = a.type) === S) {
                                            if (7 === u.tag) {
                                                n(r, u.sibling),
                                                (o = i(u, a.props.children)).return = r,
                                                r = o;
                                                break e
                                            }
                                        } else if (u.elementType === c || "object" === typeof c && null !== c && c.$$typeof === I && bo(c) === u.type) {
                                            n(r, u.sibling),
                                            (o = i(u, a.props)).ref = vo(r, u, a),
                                            o.return = r,
                                            r = o;
                                            break e
                                        }
                                        n(r, u);
                                        break
                                    }
                                    t(r, u),
                                    u = u.sibling
                                }
                                a.type === S ? ((o = Dc(a.props.children, r.mode, l, a.key)).return = r,
                                r = o) : ((l = kc(a.type, a.key, a.props, null, r.mode, l)).ref = vo(r, o, a),
                                l.return = r,
                                r = l)
                            }
                            return s(r);
                        case x:
                            e: {
                                for (u = a.key; null !== o; ) {
                                    if (o.key === u) {
                                        if (4 === o.tag && o.stateNode.containerInfo === a.containerInfo && o.stateNode.implementation === a.implementation) {
                                            n(r, o.sibling),
                                            (o = i(o, a.children || [])).return = r,
                                            r = o;
                                            break e
                                        }
                                        n(r, o);
                                        break
                                    }
                                    t(r, o),
                                    o = o.sibling
                                }
                                (o = Fc(a, r.mode, l)).return = r,
                                r = o
                            }
                            return s(r);
                        case I:
                            return e(r, o, (u = a._init)(a._payload), l)
                        }
                        if (te(a))
                            return m(r, o, a, l);
                        if (D(a))
                            return g(r, o, a, l);
                        yo(r, a)
                    }
                    return "string" === typeof a && "" !== a || "number" === typeof a ? (a = "" + a,
                    null !== o && 6 === o.tag ? (n(r, o.sibling),
                    (o = i(o, a)).return = r,
                    r = o) : (n(r, o),
                    (o = Nc(a, r.mode, l)).return = r,
                    r = o),
                    s(r)) : n(r, o)
                }
            }
            var Ao = _o(!0)
              , xo = _o(!1)
              , So = wi(null)
              , wo = null
              , Eo = null
              , Mo = null;
            function Co() {
                Mo = Eo = wo = null
            }
            function To(e) {
                var t = So.current;
                Ei(So),
                e._currentValue = t
            }
            function Ro(e, t, n) {
                for (; null !== e; ) {
                    var r = e.alternate;
                    if ((e.childLanes & t) !== t ? (e.childLanes |= t,
                    null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t),
                    e === n)
                        break;
                    e = e.return
                }
            }
            function Po(e, t) {
                wo = e,
                Mo = Eo = null,
                null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (bs = !0),
                e.firstContext = null)
            }
            function Bo(e) {
                var t = e._currentValue;
                if (Mo !== e)
                    if (e = {
                        context: e,
                        memoizedValue: t,
                        next: null
                    },
                    null === Eo) {
                        if (null === wo)
                            throw Error(o(308));
                        Eo = e,
                        wo.dependencies = {
                            lanes: 0,
                            firstContext: e
                        }
                    } else
                        Eo = Eo.next = e;
                return t
            }
            var Io = null;
            function Lo(e) {
                null === Io ? Io = [e] : Io.push(e)
            }
            function ko(e, t, n, r) {
                var i = t.interleaved;
                return null === i ? (n.next = n,
                Lo(t)) : (n.next = i.next,
                i.next = n),
                t.interleaved = n,
                Do(e, r)
            }
            function Do(e, t) {
                e.lanes |= t;
                var n = e.alternate;
                for (null !== n && (n.lanes |= t),
                n = e,
                e = e.return; null !== e; )
                    e.childLanes |= t,
                    null !== (n = e.alternate) && (n.childLanes |= t),
                    n = e,
                    e = e.return;
                return 3 === n.tag ? n.stateNode : null
            }
            var Oo = !1;
            function No(e) {
                e.updateQueue = {
                    baseState: e.memoizedState,
                    firstBaseUpdate: null,
                    lastBaseUpdate: null,
                    shared: {
                        pending: null,
                        interleaved: null,
                        lanes: 0
                    },
                    effects: null
                }
            }
            function Fo(e, t) {
                e = e.updateQueue,
                t.updateQueue === e && (t.updateQueue = {
                    baseState: e.baseState,
                    firstBaseUpdate: e.firstBaseUpdate,
                    lastBaseUpdate: e.lastBaseUpdate,
                    shared: e.shared,
                    effects: e.effects
                })
            }
            function Uo(e, t) {
                return {
                    eventTime: e,
                    lane: t,
                    tag: 0,
                    payload: null,
                    callback: null,
                    next: null
                }
            }
            function zo(e, t, n) {
                var r = e.updateQueue;
                if (null === r)
                    return null;
                if (r = r.shared,
                0 !== (2 & Tl)) {
                    var i = r.pending;
                    return null === i ? t.next = t : (t.next = i.next,
                    i.next = t),
                    r.pending = t,
                    Do(e, n)
                }
                return null === (i = r.interleaved) ? (t.next = t,
                Lo(r)) : (t.next = i.next,
                i.next = t),
                r.interleaved = t,
                Do(e, n)
            }
            function Go(e, t, n) {
                if (null !== (t = t.updateQueue) && (t = t.shared,
                0 !== (4194240 & n))) {
                    var r = t.lanes;
                    n |= r &= e.pendingLanes,
                    t.lanes = n,
                    yt(e, n)
                }
            }
            function Ho(e, t) {
                var n = e.updateQueue
                  , r = e.alternate;
                if (null !== r && n === (r = r.updateQueue)) {
                    var i = null
                      , o = null;
                    if (null !== (n = n.firstBaseUpdate)) {
                        do {
                            var a = {
                                eventTime: n.eventTime,
                                lane: n.lane,
                                tag: n.tag,
                                payload: n.payload,
                                callback: n.callback,
                                next: null
                            };
                            null === o ? i = o = a : o = o.next = a,
                            n = n.next
                        } while (null !== n);
                        null === o ? i = o = t : o = o.next = t
                    } else
                        i = o = t;
                    return n = {
                        baseState: r.baseState,
                        firstBaseUpdate: i,
                        lastBaseUpdate: o,
                        shared: r.shared,
                        effects: r.effects
                    },
                    void (e.updateQueue = n)
                }
                null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t,
                n.lastBaseUpdate = t
            }
            function jo(e, t, n, r) {
                var i = e.updateQueue;
                Oo = !1;
                var o = i.firstBaseUpdate
                  , a = i.lastBaseUpdate
                  , s = i.shared.pending;
                if (null !== s) {
                    i.shared.pending = null;
                    var l = s
                      , c = l.next;
                    l.next = null,
                    null === a ? o = c : a.next = c,
                    a = l;
                    var u = e.alternate;
                    null !== u && ((s = (u = u.updateQueue).lastBaseUpdate) !== a && (null === s ? u.firstBaseUpdate = c : s.next = c,
                    u.lastBaseUpdate = l))
                }
                if (null !== o) {
                    var d = i.baseState;
                    for (a = 0,
                    u = c = l = null,
                    s = o; ; ) {
                        var h = s.lane
                          , p = s.eventTime;
                        if ((r & h) === h) {
                            null !== u && (u = u.next = {
                                eventTime: p,
                                lane: 0,
                                tag: s.tag,
                                payload: s.payload,
                                callback: s.callback,
                                next: null
                            });
                            e: {
                                var f = e
                                  , m = s;
                                switch (h = t,
                                p = n,
                                m.tag) {
                                case 1:
                                    if ("function" === typeof (f = m.payload)) {
                                        d = f.call(p, d, h);
                                        break e
                                    }
                                    d = f;
                                    break e;
                                case 3:
                                    f.flags = -65537 & f.flags | 128;
                                case 0:
                                    if (null === (h = "function" === typeof (f = m.payload) ? f.call(p, d, h) : f) || void 0 === h)
                                        break e;
                                    d = N({}, d, h);
                                    break e;
                                case 2:
                                    Oo = !0
                                }
                            }
                            null !== s.callback && 0 !== s.lane && (e.flags |= 64,
                            null === (h = i.effects) ? i.effects = [s] : h.push(s))
                        } else
                            p = {
                                eventTime: p,
                                lane: h,
                                tag: s.tag,
                                payload: s.payload,
                                callback: s.callback,
                                next: null
                            },
                            null === u ? (c = u = p,
                            l = d) : u = u.next = p,
                            a |= h;
                        if (null === (s = s.next)) {
                            if (null === (s = i.shared.pending))
                                break;
                            s = (h = s).next,
                            h.next = null,
                            i.lastBaseUpdate = h,
                            i.shared.pending = null
                        }
                    }
                    if (null === u && (l = d),
                    i.baseState = l,
                    i.firstBaseUpdate = c,
                    i.lastBaseUpdate = u,
                    null !== (t = i.shared.interleaved)) {
                        i = t;
                        do {
                            a |= i.lane,
                            i = i.next
                        } while (i !== t)
                    } else
                        null === o && (i.shared.lanes = 0);
                    Ol |= a,
                    e.lanes = a,
                    e.memoizedState = d
                }
            }
            function Wo(e, t, n) {
                if (e = t.effects,
                t.effects = null,
                null !== e)
                    for (t = 0; t < e.length; t++) {
                        var r = e[t]
                          , i = r.callback;
                        if (null !== i) {
                            if (r.callback = null,
                            r = n,
                            "function" !== typeof i)
                                throw Error(o(191, i));
                            i.call(r)
                        }
                    }
            }
            var Vo = {}
              , Xo = wi(Vo)
              , Jo = wi(Vo)
              , Ko = wi(Vo);
            function qo(e) {
                if (e === Vo)
                    throw Error(o(174));
                return e
            }
            function Yo(e, t) {
                switch (Mi(Ko, t),
                Mi(Jo, e),
                Mi(Xo, Vo),
                e = t.nodeType) {
                case 9:
                case 11:
                    t = (t = t.documentElement) ? t.namespaceURI : le(null, "");
                    break;
                default:
                    t = le(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName)
                }
                Ei(Xo),
                Mi(Xo, t)
            }
            function Qo() {
                Ei(Xo),
                Ei(Jo),
                Ei(Ko)
            }
            function Zo(e) {
                qo(Ko.current);
                var t = qo(Xo.current)
                  , n = le(t, e.type);
                t !== n && (Mi(Jo, e),
                Mi(Xo, n))
            }
            function $o(e) {
                Jo.current === e && (Ei(Xo),
                Ei(Jo))
            }
            var ea = wi(0);
            function ta(e) {
                for (var t = e; null !== t; ) {
                    if (13 === t.tag) {
                        var n = t.memoizedState;
                        if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data))
                            return t
                    } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
                        if (0 !== (128 & t.flags))
                            return t
                    } else if (null !== t.child) {
                        t.child.return = t,
                        t = t.child;
                        continue
                    }
                    if (t === e)
                        break;
                    for (; null === t.sibling; ) {
                        if (null === t.return || t.return === e)
                            return null;
                        t = t.return
                    }
                    t.sibling.return = t.return,
                    t = t.sibling
                }
                return null
            }
            var na = [];
            function ra() {
                for (var e = 0; e < na.length; e++)
                    na[e]._workInProgressVersionPrimary = null;
                na.length = 0
            }
            var ia = _.ReactCurrentDispatcher
              , oa = _.ReactCurrentBatchConfig
              , aa = 0
              , sa = null
              , la = null
              , ca = null
              , ua = !1
              , da = !1
              , ha = 0
              , pa = 0;
            function fa() {
                throw Error(o(321))
            }
            function ma(e, t) {
                if (null === t)
                    return !1;
                for (var n = 0; n < t.length && n < e.length; n++)
                    if (!sr(e[n], t[n]))
                        return !1;
                return !0
            }
            function ga(e, t, n, r, i, a) {
                if (aa = a,
                sa = t,
                t.memoizedState = null,
                t.updateQueue = null,
                t.lanes = 0,
                ia.current = null === e || null === e.memoizedState ? $a : es,
                e = n(r, i),
                da) {
                    a = 0;
                    do {
                        if (da = !1,
                        ha = 0,
                        25 <= a)
                            throw Error(o(301));
                        a += 1,
                        ca = la = null,
                        t.updateQueue = null,
                        ia.current = ts,
                        e = n(r, i)
                    } while (da)
                }
                if (ia.current = Za,
                t = null !== la && null !== la.next,
                aa = 0,
                ca = la = sa = null,
                ua = !1,
                t)
                    throw Error(o(300));
                return e
            }
            function va() {
                var e = 0 !== ha;
                return ha = 0,
                e
            }
            function ya() {
                var e = {
                    memoizedState: null,
                    baseState: null,
                    baseQueue: null,
                    queue: null,
                    next: null
                };
                return null === ca ? sa.memoizedState = ca = e : ca = ca.next = e,
                ca
            }
            function ba() {
                if (null === la) {
                    var e = sa.alternate;
                    e = null !== e ? e.memoizedState : null
                } else
                    e = la.next;
                var t = null === ca ? sa.memoizedState : ca.next;
                if (null !== t)
                    ca = t,
                    la = e;
                else {
                    if (null === e)
                        throw Error(o(310));
                    e = {
                        memoizedState: (la = e).memoizedState,
                        baseState: la.baseState,
                        baseQueue: la.baseQueue,
                        queue: la.queue,
                        next: null
                    },
                    null === ca ? sa.memoizedState = ca = e : ca = ca.next = e
                }
                return ca
            }
            function _a(e, t) {
                return "function" === typeof t ? t(e) : t
            }
            function Aa(e) {
                var t = ba()
                  , n = t.queue;
                if (null === n)
                    throw Error(o(311));
                n.lastRenderedReducer = e;
                var r = la
                  , i = r.baseQueue
                  , a = n.pending;
                if (null !== a) {
                    if (null !== i) {
                        var s = i.next;
                        i.next = a.next,
                        a.next = s
                    }
                    r.baseQueue = i = a,
                    n.pending = null
                }
                if (null !== i) {
                    a = i.next,
                    r = r.baseState;
                    var l = s = null
                      , c = null
                      , u = a;
                    do {
                        var d = u.lane;
                        if ((aa & d) === d)
                            null !== c && (c = c.next = {
                                lane: 0,
                                action: u.action,
                                hasEagerState: u.hasEagerState,
                                eagerState: u.eagerState,
                                next: null
                            }),
                            r = u.hasEagerState ? u.eagerState : e(r, u.action);
                        else {
                            var h = {
                                lane: d,
                                action: u.action,
                                hasEagerState: u.hasEagerState,
                                eagerState: u.eagerState,
                                next: null
                            };
                            null === c ? (l = c = h,
                            s = r) : c = c.next = h,
                            sa.lanes |= d,
                            Ol |= d
                        }
                        u = u.next
                    } while (null !== u && u !== a);
                    null === c ? s = r : c.next = l,
                    sr(r, t.memoizedState) || (bs = !0),
                    t.memoizedState = r,
                    t.baseState = s,
                    t.baseQueue = c,
                    n.lastRenderedState = r
                }
                if (null !== (e = n.interleaved)) {
                    i = e;
                    do {
                        a = i.lane,
                        sa.lanes |= a,
                        Ol |= a,
                        i = i.next
                    } while (i !== e)
                } else
                    null === i && (n.lanes = 0);
                return [t.memoizedState, n.dispatch]
            }
            function xa(e) {
                var t = ba()
                  , n = t.queue;
                if (null === n)
                    throw Error(o(311));
                n.lastRenderedReducer = e;
                var r = n.dispatch
                  , i = n.pending
                  , a = t.memoizedState;
                if (null !== i) {
                    n.pending = null;
                    var s = i = i.next;
                    do {
                        a = e(a, s.action),
                        s = s.next
                    } while (s !== i);
                    sr(a, t.memoizedState) || (bs = !0),
                    t.memoizedState = a,
                    null === t.baseQueue && (t.baseState = a),
                    n.lastRenderedState = a
                }
                return [a, r]
            }
            function Sa() {}
            function wa(e, t) {
                var n = sa
                  , r = ba()
                  , i = t()
                  , a = !sr(r.memoizedState, i);
                if (a && (r.memoizedState = i,
                bs = !0),
                r = r.queue,
                Oa(Ca.bind(null, n, r, e), [e]),
                r.getSnapshot !== t || a || null !== ca && 1 & ca.memoizedState.tag) {
                    if (n.flags |= 2048,
                    Ba(9, Ma.bind(null, n, r, i, t), void 0, null),
                    null === Rl)
                        throw Error(o(349));
                    0 !== (30 & aa) || Ea(n, t, i)
                }
                return i
            }
            function Ea(e, t, n) {
                e.flags |= 16384,
                e = {
                    getSnapshot: t,
                    value: n
                },
                null === (t = sa.updateQueue) ? (t = {
                    lastEffect: null,
                    stores: null
                },
                sa.updateQueue = t,
                t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e)
            }
            function Ma(e, t, n, r) {
                t.value = n,
                t.getSnapshot = r,
                Ta(t) && Ra(e)
            }
            function Ca(e, t, n) {
                return n((function() {
                    Ta(t) && Ra(e)
                }
                ))
            }
            function Ta(e) {
                var t = e.getSnapshot;
                e = e.value;
                try {
                    var n = t();
                    return !sr(e, n)
                } catch (r) {
                    return !0
                }
            }
            function Ra(e) {
                var t = Do(e, 1);
                null !== t && nc(t, e, 1, -1)
            }
            function Pa(e) {
                var t = ya();
                return "function" === typeof e && (e = e()),
                t.memoizedState = t.baseState = e,
                e = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: _a,
                    lastRenderedState: e
                },
                t.queue = e,
                e = e.dispatch = Ka.bind(null, sa, e),
                [t.memoizedState, e]
            }
            function Ba(e, t, n, r) {
                return e = {
                    tag: e,
                    create: t,
                    destroy: n,
                    deps: r,
                    next: null
                },
                null === (t = sa.updateQueue) ? (t = {
                    lastEffect: null,
                    stores: null
                },
                sa.updateQueue = t,
                t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next,
                n.next = e,
                e.next = r,
                t.lastEffect = e),
                e
            }
            function Ia() {
                return ba().memoizedState
            }
            function La(e, t, n, r) {
                var i = ya();
                sa.flags |= e,
                i.memoizedState = Ba(1 | t, n, void 0, void 0 === r ? null : r)
            }
            function ka(e, t, n, r) {
                var i = ba();
                r = void 0 === r ? null : r;
                var o = void 0;
                if (null !== la) {
                    var a = la.memoizedState;
                    if (o = a.destroy,
                    null !== r && ma(r, a.deps))
                        return void (i.memoizedState = Ba(t, n, o, r))
                }
                sa.flags |= e,
                i.memoizedState = Ba(1 | t, n, o, r)
            }
            function Da(e, t) {
                return La(8390656, 8, e, t)
            }
            function Oa(e, t) {
                return ka(2048, 8, e, t)
            }
            function Na(e, t) {
                return ka(4, 2, e, t)
            }
            function Fa(e, t) {
                return ka(4, 4, e, t)
            }
            function Ua(e, t) {
                return "function" === typeof t ? (e = e(),
                t(e),
                function() {
                    t(null)
                }
                ) : null !== t && void 0 !== t ? (e = e(),
                t.current = e,
                function() {
                    t.current = null
                }
                ) : void 0
            }
            function za(e, t, n) {
                return n = null !== n && void 0 !== n ? n.concat([e]) : null,
                ka(4, 4, Ua.bind(null, t, e), n)
            }
            function Ga() {}
            function Ha(e, t) {
                var n = ba();
                t = void 0 === t ? null : t;
                var r = n.memoizedState;
                return null !== r && null !== t && ma(t, r[1]) ? r[0] : (n.memoizedState = [e, t],
                e)
            }
            function ja(e, t) {
                var n = ba();
                t = void 0 === t ? null : t;
                var r = n.memoizedState;
                return null !== r && null !== t && ma(t, r[1]) ? r[0] : (e = e(),
                n.memoizedState = [e, t],
                e)
            }
            function Wa(e, t, n) {
                return 0 === (21 & aa) ? (e.baseState && (e.baseState = !1,
                bs = !0),
                e.memoizedState = n) : (sr(n, t) || (n = mt(),
                sa.lanes |= n,
                Ol |= n,
                e.baseState = !0),
                t)
            }
            function Va(e, t) {
                var n = bt;
                bt = 0 !== n && 4 > n ? n : 4,
                e(!0);
                var r = oa.transition;
                oa.transition = {};
                try {
                    e(!1),
                    t()
                } finally {
                    bt = n,
                    oa.transition = r
                }
            }
            function Xa() {
                return ba().memoizedState
            }
            function Ja(e, t, n) {
                var r = tc(e);
                if (n = {
                    lane: r,
                    action: n,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null
                },
                qa(e))
                    Ya(t, n);
                else if (null !== (n = ko(e, t, n, r))) {
                    nc(n, e, r, ec()),
                    Qa(n, t, r)
                }
            }
            function Ka(e, t, n) {
                var r = tc(e)
                  , i = {
                    lane: r,
                    action: n,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null
                };
                if (qa(e))
                    Ya(t, i);
                else {
                    var o = e.alternate;
                    if (0 === e.lanes && (null === o || 0 === o.lanes) && null !== (o = t.lastRenderedReducer))
                        try {
                            var a = t.lastRenderedState
                              , s = o(a, n);
                            if (i.hasEagerState = !0,
                            i.eagerState = s,
                            sr(s, a)) {
                                var l = t.interleaved;
                                return null === l ? (i.next = i,
                                Lo(t)) : (i.next = l.next,
                                l.next = i),
                                void (t.interleaved = i)
                            }
                        } catch (c) {}
                    null !== (n = ko(e, t, i, r)) && (nc(n, e, r, i = ec()),
                    Qa(n, t, r))
                }
            }
            function qa(e) {
                var t = e.alternate;
                return e === sa || null !== t && t === sa
            }
            function Ya(e, t) {
                da = ua = !0;
                var n = e.pending;
                null === n ? t.next = t : (t.next = n.next,
                n.next = t),
                e.pending = t
            }
            function Qa(e, t, n) {
                if (0 !== (4194240 & n)) {
                    var r = t.lanes;
                    n |= r &= e.pendingLanes,
                    t.lanes = n,
                    yt(e, n)
                }
            }
            var Za = {
                readContext: Bo,
                useCallback: fa,
                useContext: fa,
                useEffect: fa,
                useImperativeHandle: fa,
                useInsertionEffect: fa,
                useLayoutEffect: fa,
                useMemo: fa,
                useReducer: fa,
                useRef: fa,
                useState: fa,
                useDebugValue: fa,
                useDeferredValue: fa,
                useTransition: fa,
                useMutableSource: fa,
                useSyncExternalStore: fa,
                useId: fa,
                unstable_isNewReconciler: !1
            }
              , $a = {
                readContext: Bo,
                useCallback: function(e, t) {
                    return ya().memoizedState = [e, void 0 === t ? null : t],
                    e
                },
                useContext: Bo,
                useEffect: Da,
                useImperativeHandle: function(e, t, n) {
                    return n = null !== n && void 0 !== n ? n.concat([e]) : null,
                    La(4194308, 4, Ua.bind(null, t, e), n)
                },
                useLayoutEffect: function(e, t) {
                    return La(4194308, 4, e, t)
                },
                useInsertionEffect: function(e, t) {
                    return La(4, 2, e, t)
                },
                useMemo: function(e, t) {
                    var n = ya();
                    return t = void 0 === t ? null : t,
                    e = e(),
                    n.memoizedState = [e, t],
                    e
                },
                useReducer: function(e, t, n) {
                    var r = ya();
                    return t = void 0 !== n ? n(t) : t,
                    r.memoizedState = r.baseState = t,
                    e = {
                        pending: null,
                        interleaved: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: e,
                        lastRenderedState: t
                    },
                    r.queue = e,
                    e = e.dispatch = Ja.bind(null, sa, e),
                    [r.memoizedState, e]
                },
                useRef: function(e) {
                    return e = {
                        current: e
                    },
                    ya().memoizedState = e
                },
                useState: Pa,
                useDebugValue: Ga,
                useDeferredValue: function(e) {
                    return ya().memoizedState = e
                },
                useTransition: function() {
                    var e = Pa(!1)
                      , t = e[0];
                    return e = Va.bind(null, e[1]),
                    ya().memoizedState = e,
                    [t, e]
                },
                useMutableSource: function() {},
                useSyncExternalStore: function(e, t, n) {
                    var r = sa
                      , i = ya();
                    if (io) {
                        if (void 0 === n)
                            throw Error(o(407));
                        n = n()
                    } else {
                        if (n = t(),
                        null === Rl)
                            throw Error(o(349));
                        0 !== (30 & aa) || Ea(r, t, n)
                    }
                    i.memoizedState = n;
                    var a = {
                        value: n,
                        getSnapshot: t
                    };
                    return i.queue = a,
                    Da(Ca.bind(null, r, a, e), [e]),
                    r.flags |= 2048,
                    Ba(9, Ma.bind(null, r, a, n, t), void 0, null),
                    n
                },
                useId: function() {
                    var e = ya()
                      , t = Rl.identifierPrefix;
                    if (io) {
                        var n = Qi;
                        t = ":" + t + "R" + (n = (Yi & ~(1 << 32 - at(Yi) - 1)).toString(32) + n),
                        0 < (n = ha++) && (t += "H" + n.toString(32)),
                        t += ":"
                    } else
                        t = ":" + t + "r" + (n = pa++).toString(32) + ":";
                    return e.memoizedState = t
                },
                unstable_isNewReconciler: !1
            }
              , es = {
                readContext: Bo,
                useCallback: Ha,
                useContext: Bo,
                useEffect: Oa,
                useImperativeHandle: za,
                useInsertionEffect: Na,
                useLayoutEffect: Fa,
                useMemo: ja,
                useReducer: Aa,
                useRef: Ia,
                useState: function() {
                    return Aa(_a)
                },
                useDebugValue: Ga,
                useDeferredValue: function(e) {
                    return Wa(ba(), la.memoizedState, e)
                },
                useTransition: function() {
                    return [Aa(_a)[0], ba().memoizedState]
                },
                useMutableSource: Sa,
                useSyncExternalStore: wa,
                useId: Xa,
                unstable_isNewReconciler: !1
            }
              , ts = {
                readContext: Bo,
                useCallback: Ha,
                useContext: Bo,
                useEffect: Oa,
                useImperativeHandle: za,
                useInsertionEffect: Na,
                useLayoutEffect: Fa,
                useMemo: ja,
                useReducer: xa,
                useRef: Ia,
                useState: function() {
                    return xa(_a)
                },
                useDebugValue: Ga,
                useDeferredValue: function(e) {
                    var t = ba();
                    return null === la ? t.memoizedState = e : Wa(t, la.memoizedState, e)
                },
                useTransition: function() {
                    return [xa(_a)[0], ba().memoizedState]
                },
                useMutableSource: Sa,
                useSyncExternalStore: wa,
                useId: Xa,
                unstable_isNewReconciler: !1
            };
            function ns(e, t) {
                if (e && e.defaultProps) {
                    for (var n in t = N({}, t),
                    e = e.defaultProps)
                        void 0 === t[n] && (t[n] = e[n]);
                    return t
                }
                return t
            }
            function rs(e, t, n, r) {
                n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : N({}, t, n),
                e.memoizedState = n,
                0 === e.lanes && (e.updateQueue.baseState = n)
            }
            var is = {
                isMounted: function(e) {
                    return !!(e = e._reactInternals) && He(e) === e
                },
                enqueueSetState: function(e, t, n) {
                    e = e._reactInternals;
                    var r = ec()
                      , i = tc(e)
                      , o = Uo(r, i);
                    o.payload = t,
                    void 0 !== n && null !== n && (o.callback = n),
                    null !== (t = zo(e, o, i)) && (nc(t, e, i, r),
                    Go(t, e, i))
                },
                enqueueReplaceState: function(e, t, n) {
                    e = e._reactInternals;
                    var r = ec()
                      , i = tc(e)
                      , o = Uo(r, i);
                    o.tag = 1,
                    o.payload = t,
                    void 0 !== n && null !== n && (o.callback = n),
                    null !== (t = zo(e, o, i)) && (nc(t, e, i, r),
                    Go(t, e, i))
                },
                enqueueForceUpdate: function(e, t) {
                    e = e._reactInternals;
                    var n = ec()
                      , r = tc(e)
                      , i = Uo(n, r);
                    i.tag = 2,
                    void 0 !== t && null !== t && (i.callback = t),
                    null !== (t = zo(e, i, r)) && (nc(t, e, r, n),
                    Go(t, e, r))
                }
            };
            function os(e, t, n, r, i, o, a) {
                return "function" === typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, o, a) : !t.prototype || !t.prototype.isPureReactComponent || (!lr(n, r) || !lr(i, o))
            }
            function as(e, t, n) {
                var r = !1
                  , i = Ci
                  , o = t.contextType;
                return "object" === typeof o && null !== o ? o = Bo(o) : (i = Ii(t) ? Pi : Ti.current,
                o = (r = null !== (r = t.contextTypes) && void 0 !== r) ? Bi(e, i) : Ci),
                t = new t(n,o),
                e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null,
                t.updater = is,
                e.stateNode = t,
                t._reactInternals = e,
                r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i,
                e.__reactInternalMemoizedMaskedChildContext = o),
                t
            }
            function ss(e, t, n, r) {
                e = t.state,
                "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r),
                "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r),
                t.state !== e && is.enqueueReplaceState(t, t.state, null)
            }
            function ls(e, t, n, r) {
                var i = e.stateNode;
                i.props = n,
                i.state = e.memoizedState,
                i.refs = {},
                No(e);
                var o = t.contextType;
                "object" === typeof o && null !== o ? i.context = Bo(o) : (o = Ii(t) ? Pi : Ti.current,
                i.context = Bi(e, o)),
                i.state = e.memoizedState,
                "function" === typeof (o = t.getDerivedStateFromProps) && (rs(e, t, o, n),
                i.state = e.memoizedState),
                "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state,
                "function" === typeof i.componentWillMount && i.componentWillMount(),
                "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(),
                t !== i.state && is.enqueueReplaceState(i, i.state, null),
                jo(e, n, i, r),
                i.state = e.memoizedState),
                "function" === typeof i.componentDidMount && (e.flags |= 4194308)
            }
            function cs(e, t) {
                try {
                    var n = ""
                      , r = t;
                    do {
                        n += G(r),
                        r = r.return
                    } while (r);
                    var i = n
                } catch (o) {
                    i = "\nError generating stack: " + o.message + "\n" + o.stack
                }
                return {
                    value: e,
                    source: t,
                    stack: i,
                    digest: null
                }
            }
            function us(e, t, n) {
                return {
                    value: e,
                    source: null,
                    stack: null != n ? n : null,
                    digest: null != t ? t : null
                }
            }
            function ds(e, t) {
                try {
                    console.error(t.value)
                } catch (n) {
                    setTimeout((function() {
                        throw n
                    }
                    ))
                }
            }
            var hs = "function" === typeof WeakMap ? WeakMap : Map;
            function ps(e, t, n) {
                (n = Uo(-1, n)).tag = 3,
                n.payload = {
                    element: null
                };
                var r = t.value;
                return n.callback = function() {
                    Wl || (Wl = !0,
                    Vl = r),
                    ds(0, t)
                }
                ,
                n
            }
            function fs(e, t, n) {
                (n = Uo(-1, n)).tag = 3;
                var r = e.type.getDerivedStateFromError;
                if ("function" === typeof r) {
                    var i = t.value;
                    n.payload = function() {
                        return r(i)
                    }
                    ,
                    n.callback = function() {
                        ds(0, t)
                    }
                }
                var o = e.stateNode;
                return null !== o && "function" === typeof o.componentDidCatch && (n.callback = function() {
                    ds(0, t),
                    "function" !== typeof r && (null === Xl ? Xl = new Set([this]) : Xl.add(this));
                    var e = t.stack;
                    this.componentDidCatch(t.value, {
                        componentStack: null !== e ? e : ""
                    })
                }
                ),
                n
            }
            function ms(e, t, n) {
                var r = e.pingCache;
                if (null === r) {
                    r = e.pingCache = new hs;
                    var i = new Set;
                    r.set(t, i)
                } else
                    void 0 === (i = r.get(t)) && (i = new Set,
                    r.set(t, i));
                i.has(n) || (i.add(n),
                e = Ec.bind(null, e, t, n),
                t.then(e, e))
            }
            function gs(e) {
                do {
                    var t;
                    if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated),
                    t)
                        return e;
                    e = e.return
                } while (null !== e);
                return null
            }
            function vs(e, t, n, r, i) {
                return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128,
                n.flags |= 131072,
                n.flags &= -52805,
                1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = Uo(-1, 1)).tag = 2,
                zo(n, t, 1))),
                n.lanes |= 1),
                e) : (e.flags |= 65536,
                e.lanes = i,
                e)
            }
            var ys = _.ReactCurrentOwner
              , bs = !1;
            function _s(e, t, n, r) {
                t.child = null === e ? xo(t, null, n, r) : Ao(t, e.child, n, r)
            }
            function As(e, t, n, r, i) {
                n = n.render;
                var o = t.ref;
                return Po(t, i),
                r = ga(e, t, n, r, o, i),
                n = va(),
                null === e || bs ? (io && n && eo(t),
                t.flags |= 1,
                _s(e, t, r, i),
                t.child) : (t.updateQueue = e.updateQueue,
                t.flags &= -2053,
                e.lanes &= ~i,
                Ws(e, t, i))
            }
            function xs(e, t, n, r, i) {
                if (null === e) {
                    var o = n.type;
                    return "function" !== typeof o || Ic(o) || void 0 !== o.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = kc(n.type, null, r, t, t.mode, i)).ref = t.ref,
                    e.return = t,
                    t.child = e) : (t.tag = 15,
                    t.type = o,
                    Ss(e, t, o, r, i))
                }
                if (o = e.child,
                0 === (e.lanes & i)) {
                    var a = o.memoizedProps;
                    if ((n = null !== (n = n.compare) ? n : lr)(a, r) && e.ref === t.ref)
                        return Ws(e, t, i)
                }
                return t.flags |= 1,
                (e = Lc(o, r)).ref = t.ref,
                e.return = t,
                t.child = e
            }
            function Ss(e, t, n, r, i) {
                if (null !== e) {
                    var o = e.memoizedProps;
                    if (lr(o, r) && e.ref === t.ref) {
                        if (bs = !1,
                        t.pendingProps = r = o,
                        0 === (e.lanes & i))
                            return t.lanes = e.lanes,
                            Ws(e, t, i);
                        0 !== (131072 & e.flags) && (bs = !0)
                    }
                }
                return Ms(e, t, n, r, i)
            }
            function ws(e, t, n) {
                var r = t.pendingProps
                  , i = r.children
                  , o = null !== e ? e.memoizedState : null;
                if ("hidden" === r.mode)
                    if (0 === (1 & t.mode))
                        t.memoizedState = {
                            baseLanes: 0,
                            cachePool: null,
                            transitions: null
                        },
                        Mi(Ll, Il),
                        Il |= n;
                    else {
                        if (0 === (1073741824 & n))
                            return e = null !== o ? o.baseLanes | n : n,
                            t.lanes = t.childLanes = 1073741824,
                            t.memoizedState = {
                                baseLanes: e,
                                cachePool: null,
                                transitions: null
                            },
                            t.updateQueue = null,
                            Mi(Ll, Il),
                            Il |= e,
                            null;
                        t.memoizedState = {
                            baseLanes: 0,
                            cachePool: null,
                            transitions: null
                        },
                        r = null !== o ? o.baseLanes : n,
                        Mi(Ll, Il),
                        Il |= r
                    }
                else
                    null !== o ? (r = o.baseLanes | n,
                    t.memoizedState = null) : r = n,
                    Mi(Ll, Il),
                    Il |= r;
                return _s(e, t, i, n),
                t.child
            }
            function Es(e, t) {
                var n = t.ref;
                (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512,
                t.flags |= 2097152)
            }
            function Ms(e, t, n, r, i) {
                var o = Ii(n) ? Pi : Ti.current;
                return o = Bi(t, o),
                Po(t, i),
                n = ga(e, t, n, r, o, i),
                r = va(),
                null === e || bs ? (io && r && eo(t),
                t.flags |= 1,
                _s(e, t, n, i),
                t.child) : (t.updateQueue = e.updateQueue,
                t.flags &= -2053,
                e.lanes &= ~i,
                Ws(e, t, i))
            }
            function Cs(e, t, n, r, i) {
                if (Ii(n)) {
                    var o = !0;
                    Oi(t)
                } else
                    o = !1;
                if (Po(t, i),
                null === t.stateNode)
                    js(e, t),
                    as(t, n, r),
                    ls(t, n, r, i),
                    r = !0;
                else if (null === e) {
                    var a = t.stateNode
                      , s = t.memoizedProps;
                    a.props = s;
                    var l = a.context
                      , c = n.contextType;
                    "object" === typeof c && null !== c ? c = Bo(c) : c = Bi(t, c = Ii(n) ? Pi : Ti.current);
                    var u = n.getDerivedStateFromProps
                      , d = "function" === typeof u || "function" === typeof a.getSnapshotBeforeUpdate;
                    d || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== r || l !== c) && ss(t, a, r, c),
                    Oo = !1;
                    var h = t.memoizedState;
                    a.state = h,
                    jo(t, r, a, i),
                    l = t.memoizedState,
                    s !== r || h !== l || Ri.current || Oo ? ("function" === typeof u && (rs(t, n, u, r),
                    l = t.memoizedState),
                    (s = Oo || os(t, n, s, r, h, l, c)) ? (d || "function" !== typeof a.UNSAFE_componentWillMount && "function" !== typeof a.componentWillMount || ("function" === typeof a.componentWillMount && a.componentWillMount(),
                    "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount()),
                    "function" === typeof a.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308),
                    t.memoizedProps = r,
                    t.memoizedState = l),
                    a.props = r,
                    a.state = l,
                    a.context = c,
                    r = s) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308),
                    r = !1)
                } else {
                    a = t.stateNode,
                    Fo(e, t),
                    s = t.memoizedProps,
                    c = t.type === t.elementType ? s : ns(t.type, s),
                    a.props = c,
                    d = t.pendingProps,
                    h = a.context,
                    "object" === typeof (l = n.contextType) && null !== l ? l = Bo(l) : l = Bi(t, l = Ii(n) ? Pi : Ti.current);
                    var p = n.getDerivedStateFromProps;
                    (u = "function" === typeof p || "function" === typeof a.getSnapshotBeforeUpdate) || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== d || h !== l) && ss(t, a, r, l),
                    Oo = !1,
                    h = t.memoizedState,
                    a.state = h,
                    jo(t, r, a, i);
                    var f = t.memoizedState;
                    s !== d || h !== f || Ri.current || Oo ? ("function" === typeof p && (rs(t, n, p, r),
                    f = t.memoizedState),
                    (c = Oo || os(t, n, c, r, h, f, l) || !1) ? (u || "function" !== typeof a.UNSAFE_componentWillUpdate && "function" !== typeof a.componentWillUpdate || ("function" === typeof a.componentWillUpdate && a.componentWillUpdate(r, f, l),
                    "function" === typeof a.UNSAFE_componentWillUpdate && a.UNSAFE_componentWillUpdate(r, f, l)),
                    "function" === typeof a.componentDidUpdate && (t.flags |= 4),
                    "function" === typeof a.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4),
                    "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024),
                    t.memoizedProps = r,
                    t.memoizedState = f),
                    a.props = r,
                    a.state = f,
                    a.context = l,
                    r = c) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4),
                    "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024),
                    r = !1)
                }
                return Ts(e, t, n, r, o, i)
            }
            function Ts(e, t, n, r, i, o) {
                Es(e, t);
                var a = 0 !== (128 & t.flags);
                if (!r && !a)
                    return i && Ni(t, n, !1),
                    Ws(e, t, o);
                r = t.stateNode,
                ys.current = t;
                var s = a && "function" !== typeof n.getDerivedStateFromError ? null : r.render();
                return t.flags |= 1,
                null !== e && a ? (t.child = Ao(t, e.child, null, o),
                t.child = Ao(t, null, s, o)) : _s(e, t, s, o),
                t.memoizedState = r.state,
                i && Ni(t, n, !0),
                t.child
            }
            function Rs(e) {
                var t = e.stateNode;
                t.pendingContext ? ki(0, t.pendingContext, t.pendingContext !== t.context) : t.context && ki(0, t.context, !1),
                Yo(e, t.containerInfo)
            }
            function Ps(e, t, n, r, i) {
                return fo(),
                mo(i),
                t.flags |= 256,
                _s(e, t, n, r),
                t.child
            }
            var Bs, Is, Ls, ks, Ds = {
                dehydrated: null,
                treeContext: null,
                retryLane: 0
            };
            function Os(e) {
                return {
                    baseLanes: e,
                    cachePool: null,
                    transitions: null
                }
            }
            function Ns(e, t, n) {
                var r, i = t.pendingProps, a = ea.current, s = !1, l = 0 !== (128 & t.flags);
                if ((r = l) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & a)),
                r ? (s = !0,
                t.flags &= -129) : null !== e && null === e.memoizedState || (a |= 1),
                Mi(ea, 1 & a),
                null === e)
                    return co(t),
                    null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824,
                    null) : (l = i.children,
                    e = i.fallback,
                    s ? (i = t.mode,
                    s = t.child,
                    l = {
                        mode: "hidden",
                        children: l
                    },
                    0 === (1 & i) && null !== s ? (s.childLanes = 0,
                    s.pendingProps = l) : s = Oc(l, i, 0, null),
                    e = Dc(e, i, n, null),
                    s.return = t,
                    e.return = t,
                    s.sibling = e,
                    t.child = s,
                    t.child.memoizedState = Os(n),
                    t.memoizedState = Ds,
                    e) : Fs(t, l));
                if (null !== (a = e.memoizedState) && null !== (r = a.dehydrated))
                    return function(e, t, n, r, i, a, s) {
                        if (n)
                            return 256 & t.flags ? (t.flags &= -257,
                            Us(e, t, s, r = us(Error(o(422))))) : null !== t.memoizedState ? (t.child = e.child,
                            t.flags |= 128,
                            null) : (a = r.fallback,
                            i = t.mode,
                            r = Oc({
                                mode: "visible",
                                children: r.children
                            }, i, 0, null),
                            (a = Dc(a, i, s, null)).flags |= 2,
                            r.return = t,
                            a.return = t,
                            r.sibling = a,
                            t.child = r,
                            0 !== (1 & t.mode) && Ao(t, e.child, null, s),
                            t.child.memoizedState = Os(s),
                            t.memoizedState = Ds,
                            a);
                        if (0 === (1 & t.mode))
                            return Us(e, t, s, null);
                        if ("$!" === i.data) {
                            if (r = i.nextSibling && i.nextSibling.dataset)
                                var l = r.dgst;
                            return r = l,
                            Us(e, t, s, r = us(a = Error(o(419)), r, void 0))
                        }
                        if (l = 0 !== (s & e.childLanes),
                        bs || l) {
                            if (null !== (r = Rl)) {
                                switch (s & -s) {
                                case 4:
                                    i = 2;
                                    break;
                                case 16:
                                    i = 8;
                                    break;
                                case 64:
                                case 128:
                                case 256:
                                case 512:
                                case 1024:
                                case 2048:
                                case 4096:
                                case 8192:
                                case 16384:
                                case 32768:
                                case 65536:
                                case 131072:
                                case 262144:
                                case 524288:
                                case 1048576:
                                case 2097152:
                                case 4194304:
                                case 8388608:
                                case 16777216:
                                case 33554432:
                                case 67108864:
                                    i = 32;
                                    break;
                                case 536870912:
                                    i = 268435456;
                                    break;
                                default:
                                    i = 0
                                }
                                0 !== (i = 0 !== (i & (r.suspendedLanes | s)) ? 0 : i) && i !== a.retryLane && (a.retryLane = i,
                                Do(e, i),
                                nc(r, e, i, -1))
                            }
                            return mc(),
                            Us(e, t, s, r = us(Error(o(421))))
                        }
                        return "$?" === i.data ? (t.flags |= 128,
                        t.child = e.child,
                        t = Cc.bind(null, e),
                        i._reactRetry = t,
                        null) : (e = a.treeContext,
                        ro = ci(i.nextSibling),
                        no = t,
                        io = !0,
                        oo = null,
                        null !== e && (Ji[Ki++] = Yi,
                        Ji[Ki++] = Qi,
                        Ji[Ki++] = qi,
                        Yi = e.id,
                        Qi = e.overflow,
                        qi = t),
                        t = Fs(t, r.children),
                        t.flags |= 4096,
                        t)
                    }(e, t, l, i, r, a, n);
                if (s) {
                    s = i.fallback,
                    l = t.mode,
                    r = (a = e.child).sibling;
                    var c = {
                        mode: "hidden",
                        children: i.children
                    };
                    return 0 === (1 & l) && t.child !== a ? ((i = t.child).childLanes = 0,
                    i.pendingProps = c,
                    t.deletions = null) : (i = Lc(a, c)).subtreeFlags = 14680064 & a.subtreeFlags,
                    null !== r ? s = Lc(r, s) : (s = Dc(s, l, n, null)).flags |= 2,
                    s.return = t,
                    i.return = t,
                    i.sibling = s,
                    t.child = i,
                    i = s,
                    s = t.child,
                    l = null === (l = e.child.memoizedState) ? Os(n) : {
                        baseLanes: l.baseLanes | n,
                        cachePool: null,
                        transitions: l.transitions
                    },
                    s.memoizedState = l,
                    s.childLanes = e.childLanes & ~n,
                    t.memoizedState = Ds,
                    i
                }
                return e = (s = e.child).sibling,
                i = Lc(s, {
                    mode: "visible",
                    children: i.children
                }),
                0 === (1 & t.mode) && (i.lanes = n),
                i.return = t,
                i.sibling = null,
                null !== e && (null === (n = t.deletions) ? (t.deletions = [e],
                t.flags |= 16) : n.push(e)),
                t.child = i,
                t.memoizedState = null,
                i
            }
            function Fs(e, t) {
                return (t = Oc({
                    mode: "visible",
                    children: t
                }, e.mode, 0, null)).return = e,
                e.child = t
            }
            function Us(e, t, n, r) {
                return null !== r && mo(r),
                Ao(t, e.child, null, n),
                (e = Fs(t, t.pendingProps.children)).flags |= 2,
                t.memoizedState = null,
                e
            }
            function zs(e, t, n) {
                e.lanes |= t;
                var r = e.alternate;
                null !== r && (r.lanes |= t),
                Ro(e.return, t, n)
            }
            function Gs(e, t, n, r, i) {
                var o = e.memoizedState;
                null === o ? e.memoizedState = {
                    isBackwards: t,
                    rendering: null,
                    renderingStartTime: 0,
                    last: r,
                    tail: n,
                    tailMode: i
                } : (o.isBackwards = t,
                o.rendering = null,
                o.renderingStartTime = 0,
                o.last = r,
                o.tail = n,
                o.tailMode = i)
            }
            function Hs(e, t, n) {
                var r = t.pendingProps
                  , i = r.revealOrder
                  , o = r.tail;
                if (_s(e, t, r.children, n),
                0 !== (2 & (r = ea.current)))
                    r = 1 & r | 2,
                    t.flags |= 128;
                else {
                    if (null !== e && 0 !== (128 & e.flags))
                        e: for (e = t.child; null !== e; ) {
                            if (13 === e.tag)
                                null !== e.memoizedState && zs(e, n, t);
                            else if (19 === e.tag)
                                zs(e, n, t);
                            else if (null !== e.child) {
                                e.child.return = e,
                                e = e.child;
                                continue
                            }
                            if (e === t)
                                break e;
                            for (; null === e.sibling; ) {
                                if (null === e.return || e.return === t)
                                    break e;
                                e = e.return
                            }
                            e.sibling.return = e.return,
                            e = e.sibling
                        }
                    r &= 1
                }
                if (Mi(ea, r),
                0 === (1 & t.mode))
                    t.memoizedState = null;
                else
                    switch (i) {
                    case "forwards":
                        for (n = t.child,
                        i = null; null !== n; )
                            null !== (e = n.alternate) && null === ta(e) && (i = n),
                            n = n.sibling;
                        null === (n = i) ? (i = t.child,
                        t.child = null) : (i = n.sibling,
                        n.sibling = null),
                        Gs(t, !1, i, n, o);
                        break;
                    case "backwards":
                        for (n = null,
                        i = t.child,
                        t.child = null; null !== i; ) {
                            if (null !== (e = i.alternate) && null === ta(e)) {
                                t.child = i;
                                break
                            }
                            e = i.sibling,
                            i.sibling = n,
                            n = i,
                            i = e
                        }
                        Gs(t, !0, n, null, o);
                        break;
                    case "together":
                        Gs(t, !1, null, null, void 0);
                        break;
                    default:
                        t.memoizedState = null
                    }
                return t.child
            }
            function js(e, t) {
                0 === (1 & t.mode) && null !== e && (e.alternate = null,
                t.alternate = null,
                t.flags |= 2)
            }
            function Ws(e, t, n) {
                if (null !== e && (t.dependencies = e.dependencies),
                Ol |= t.lanes,
                0 === (n & t.childLanes))
                    return null;
                if (null !== e && t.child !== e.child)
                    throw Error(o(153));
                if (null !== t.child) {
                    for (n = Lc(e = t.child, e.pendingProps),
                    t.child = n,
                    n.return = t; null !== e.sibling; )
                        e = e.sibling,
                        (n = n.sibling = Lc(e, e.pendingProps)).return = t;
                    n.sibling = null
                }
                return t.child
            }
            function Vs(e, t) {
                if (!io)
                    switch (e.tailMode) {
                    case "hidden":
                        t = e.tail;
                        for (var n = null; null !== t; )
                            null !== t.alternate && (n = t),
                            t = t.sibling;
                        null === n ? e.tail = null : n.sibling = null;
                        break;
                    case "collapsed":
                        n = e.tail;
                        for (var r = null; null !== n; )
                            null !== n.alternate && (r = n),
                            n = n.sibling;
                        null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null
                    }
            }
            function Xs(e) {
                var t = null !== e.alternate && e.alternate.child === e.child
                  , n = 0
                  , r = 0;
                if (t)
                    for (var i = e.child; null !== i; )
                        n |= i.lanes | i.childLanes,
                        r |= 14680064 & i.subtreeFlags,
                        r |= 14680064 & i.flags,
                        i.return = e,
                        i = i.sibling;
                else
                    for (i = e.child; null !== i; )
                        n |= i.lanes | i.childLanes,
                        r |= i.subtreeFlags,
                        r |= i.flags,
                        i.return = e,
                        i = i.sibling;
                return e.subtreeFlags |= r,
                e.childLanes = n,
                t
            }
            function Js(e, t, n) {
                var r = t.pendingProps;
                switch (to(t),
                t.tag) {
                case 2:
                case 16:
                case 15:
                case 0:
                case 11:
                case 7:
                case 8:
                case 12:
                case 9:
                case 14:
                    return Xs(t),
                    null;
                case 1:
                case 17:
                    return Ii(t.type) && Li(),
                    Xs(t),
                    null;
                case 3:
                    return r = t.stateNode,
                    Qo(),
                    Ei(Ri),
                    Ei(Ti),
                    ra(),
                    r.pendingContext && (r.context = r.pendingContext,
                    r.pendingContext = null),
                    null !== e && null !== e.child || (ho(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024,
                    null !== oo && (ac(oo),
                    oo = null))),
                    Is(e, t),
                    Xs(t),
                    null;
                case 5:
                    $o(t);
                    var i = qo(Ko.current);
                    if (n = t.type,
                    null !== e && null != t.stateNode)
                        Ls(e, t, n, r, i),
                        e.ref !== t.ref && (t.flags |= 512,
                        t.flags |= 2097152);
                    else {
                        if (!r) {
                            if (null === t.stateNode)
                                throw Error(o(166));
                            return Xs(t),
                            null
                        }
                        if (e = qo(Xo.current),
                        ho(t)) {
                            r = t.stateNode,
                            n = t.type;
                            var a = t.memoizedProps;
                            switch (r[hi] = t,
                            r[pi] = a,
                            e = 0 !== (1 & t.mode),
                            n) {
                            case "dialog":
                                Ur("cancel", r),
                                Ur("close", r);
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                Ur("load", r);
                                break;
                            case "video":
                            case "audio":
                                for (i = 0; i < Dr.length; i++)
                                    Ur(Dr[i], r);
                                break;
                            case "source":
                                Ur("error", r);
                                break;
                            case "img":
                            case "image":
                            case "link":
                                Ur("error", r),
                                Ur("load", r);
                                break;
                            case "details":
                                Ur("toggle", r);
                                break;
                            case "input":
                                Y(r, a),
                                Ur("invalid", r);
                                break;
                            case "select":
                                r._wrapperState = {
                                    wasMultiple: !!a.multiple
                                },
                                Ur("invalid", r);
                                break;
                            case "textarea":
                                ie(r, a),
                                Ur("invalid", r)
                            }
                            for (var l in ye(n, a),
                            i = null,
                            a)
                                if (a.hasOwnProperty(l)) {
                                    var c = a[l];
                                    "children" === l ? "string" === typeof c ? r.textContent !== c && (!0 !== a.suppressHydrationWarning && Zr(r.textContent, c, e),
                                    i = ["children", c]) : "number" === typeof c && r.textContent !== "" + c && (!0 !== a.suppressHydrationWarning && Zr(r.textContent, c, e),
                                    i = ["children", "" + c]) : s.hasOwnProperty(l) && null != c && "onScroll" === l && Ur("scroll", r)
                                }
                            switch (n) {
                            case "input":
                                X(r),
                                $(r, a, !0);
                                break;
                            case "textarea":
                                X(r),
                                ae(r);
                                break;
                            case "select":
                            case "option":
                                break;
                            default:
                                "function" === typeof a.onClick && (r.onclick = $r)
                            }
                            r = i,
                            t.updateQueue = r,
                            null !== r && (t.flags |= 4)
                        } else {
                            l = 9 === i.nodeType ? i : i.ownerDocument,
                            "http://www.w3.org/1999/xhtml" === e && (e = se(n)),
                            "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = l.createElement("div")).innerHTML = "<script><\/script>",
                            e = e.removeChild(e.firstChild)) : "string" === typeof r.is ? e = l.createElement(n, {
                                is: r.is
                            }) : (e = l.createElement(n),
                            "select" === n && (l = e,
                            r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : e = l.createElementNS(e, n),
                            e[hi] = t,
                            e[pi] = r,
                            Bs(e, t, !1, !1),
                            t.stateNode = e;
                            e: {
                                switch (l = be(n, r),
                                n) {
                                case "dialog":
                                    Ur("cancel", e),
                                    Ur("close", e),
                                    i = r;
                                    break;
                                case "iframe":
                                case "object":
                                case "embed":
                                    Ur("load", e),
                                    i = r;
                                    break;
                                case "video":
                                case "audio":
                                    for (i = 0; i < Dr.length; i++)
                                        Ur(Dr[i], e);
                                    i = r;
                                    break;
                                case "source":
                                    Ur("error", e),
                                    i = r;
                                    break;
                                case "img":
                                case "image":
                                case "link":
                                    Ur("error", e),
                                    Ur("load", e),
                                    i = r;
                                    break;
                                case "details":
                                    Ur("toggle", e),
                                    i = r;
                                    break;
                                case "input":
                                    Y(e, r),
                                    i = q(e, r),
                                    Ur("invalid", e);
                                    break;
                                case "option":
                                default:
                                    i = r;
                                    break;
                                case "select":
                                    e._wrapperState = {
                                        wasMultiple: !!r.multiple
                                    },
                                    i = N({}, r, {
                                        value: void 0
                                    }),
                                    Ur("invalid", e);
                                    break;
                                case "textarea":
                                    ie(e, r),
                                    i = re(e, r),
                                    Ur("invalid", e)
                                }
                                for (a in ye(n, i),
                                c = i)
                                    if (c.hasOwnProperty(a)) {
                                        var u = c[a];
                                        "style" === a ? ge(e, u) : "dangerouslySetInnerHTML" === a ? null != (u = u ? u.__html : void 0) && de(e, u) : "children" === a ? "string" === typeof u ? ("textarea" !== n || "" !== u) && he(e, u) : "number" === typeof u && he(e, "" + u) : "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && "autoFocus" !== a && (s.hasOwnProperty(a) ? null != u && "onScroll" === a && Ur("scroll", e) : null != u && b(e, a, u, l))
                                    }
                                switch (n) {
                                case "input":
                                    X(e),
                                    $(e, r, !1);
                                    break;
                                case "textarea":
                                    X(e),
                                    ae(e);
                                    break;
                                case "option":
                                    null != r.value && e.setAttribute("value", "" + W(r.value));
                                    break;
                                case "select":
                                    e.multiple = !!r.multiple,
                                    null != (a = r.value) ? ne(e, !!r.multiple, a, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0);
                                    break;
                                default:
                                    "function" === typeof i.onClick && (e.onclick = $r)
                                }
                                switch (n) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    r = !!r.autoFocus;
                                    break e;
                                case "img":
                                    r = !0;
                                    break e;
                                default:
                                    r = !1
                                }
                            }
                            r && (t.flags |= 4)
                        }
                        null !== t.ref && (t.flags |= 512,
                        t.flags |= 2097152)
                    }
                    return Xs(t),
                    null;
                case 6:
                    if (e && null != t.stateNode)
                        ks(e, t, e.memoizedProps, r);
                    else {
                        if ("string" !== typeof r && null === t.stateNode)
                            throw Error(o(166));
                        if (n = qo(Ko.current),
                        qo(Xo.current),
                        ho(t)) {
                            if (r = t.stateNode,
                            n = t.memoizedProps,
                            r[hi] = t,
                            (a = r.nodeValue !== n) && null !== (e = no))
                                switch (e.tag) {
                                case 3:
                                    Zr(r.nodeValue, n, 0 !== (1 & e.mode));
                                    break;
                                case 5:
                                    !0 !== e.memoizedProps.suppressHydrationWarning && Zr(r.nodeValue, n, 0 !== (1 & e.mode))
                                }
                            a && (t.flags |= 4)
                        } else
                            (r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[hi] = t,
                            t.stateNode = r
                    }
                    return Xs(t),
                    null;
                case 13:
                    if (Ei(ea),
                    r = t.memoizedState,
                    null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) {
                        if (io && null !== ro && 0 !== (1 & t.mode) && 0 === (128 & t.flags))
                            po(),
                            fo(),
                            t.flags |= 98560,
                            a = !1;
                        else if (a = ho(t),
                        null !== r && null !== r.dehydrated) {
                            if (null === e) {
                                if (!a)
                                    throw Error(o(318));
                                if (!(a = null !== (a = t.memoizedState) ? a.dehydrated : null))
                                    throw Error(o(317));
                                a[hi] = t
                            } else
                                fo(),
                                0 === (128 & t.flags) && (t.memoizedState = null),
                                t.flags |= 4;
                            Xs(t),
                            a = !1
                        } else
                            null !== oo && (ac(oo),
                            oo = null),
                            a = !0;
                        if (!a)
                            return 65536 & t.flags ? t : null
                    }
                    return 0 !== (128 & t.flags) ? (t.lanes = n,
                    t) : ((r = null !== r) !== (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192,
                    0 !== (1 & t.mode) && (null === e || 0 !== (1 & ea.current) ? 0 === kl && (kl = 3) : mc())),
                    null !== t.updateQueue && (t.flags |= 4),
                    Xs(t),
                    null);
                case 4:
                    return Qo(),
                    Is(e, t),
                    null === e && Hr(t.stateNode.containerInfo),
                    Xs(t),
                    null;
                case 10:
                    return To(t.type._context),
                    Xs(t),
                    null;
                case 19:
                    if (Ei(ea),
                    null === (a = t.memoizedState))
                        return Xs(t),
                        null;
                    if (r = 0 !== (128 & t.flags),
                    null === (l = a.rendering))
                        if (r)
                            Vs(a, !1);
                        else {
                            if (0 !== kl || null !== e && 0 !== (128 & e.flags))
                                for (e = t.child; null !== e; ) {
                                    if (null !== (l = ta(e))) {
                                        for (t.flags |= 128,
                                        Vs(a, !1),
                                        null !== (r = l.updateQueue) && (t.updateQueue = r,
                                        t.flags |= 4),
                                        t.subtreeFlags = 0,
                                        r = n,
                                        n = t.child; null !== n; )
                                            e = r,
                                            (a = n).flags &= 14680066,
                                            null === (l = a.alternate) ? (a.childLanes = 0,
                                            a.lanes = e,
                                            a.child = null,
                                            a.subtreeFlags = 0,
                                            a.memoizedProps = null,
                                            a.memoizedState = null,
                                            a.updateQueue = null,
                                            a.dependencies = null,
                                            a.stateNode = null) : (a.childLanes = l.childLanes,
                                            a.lanes = l.lanes,
                                            a.child = l.child,
                                            a.subtreeFlags = 0,
                                            a.deletions = null,
                                            a.memoizedProps = l.memoizedProps,
                                            a.memoizedState = l.memoizedState,
                                            a.updateQueue = l.updateQueue,
                                            a.type = l.type,
                                            e = l.dependencies,
                                            a.dependencies = null === e ? null : {
                                                lanes: e.lanes,
                                                firstContext: e.firstContext
                                            }),
                                            n = n.sibling;
                                        return Mi(ea, 1 & ea.current | 2),
                                        t.child
                                    }
                                    e = e.sibling
                                }
                            null !== a.tail && Qe() > Hl && (t.flags |= 128,
                            r = !0,
                            Vs(a, !1),
                            t.lanes = 4194304)
                        }
                    else {
                        if (!r)
                            if (null !== (e = ta(l))) {
                                if (t.flags |= 128,
                                r = !0,
                                null !== (n = e.updateQueue) && (t.updateQueue = n,
                                t.flags |= 4),
                                Vs(a, !0),
                                null === a.tail && "hidden" === a.tailMode && !l.alternate && !io)
                                    return Xs(t),
                                    null
                            } else
                                2 * Qe() - a.renderingStartTime > Hl && 1073741824 !== n && (t.flags |= 128,
                                r = !0,
                                Vs(a, !1),
                                t.lanes = 4194304);
                        a.isBackwards ? (l.sibling = t.child,
                        t.child = l) : (null !== (n = a.last) ? n.sibling = l : t.child = l,
                        a.last = l)
                    }
                    return null !== a.tail ? (t = a.tail,
                    a.rendering = t,
                    a.tail = t.sibling,
                    a.renderingStartTime = Qe(),
                    t.sibling = null,
                    n = ea.current,
                    Mi(ea, r ? 1 & n | 2 : 1 & n),
                    t) : (Xs(t),
                    null);
                case 22:
                case 23:
                    return dc(),
                    r = null !== t.memoizedState,
                    null !== e && null !== e.memoizedState !== r && (t.flags |= 8192),
                    r && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Il) && (Xs(t),
                    6 & t.subtreeFlags && (t.flags |= 8192)) : Xs(t),
                    null;
                case 24:
                case 25:
                    return null
                }
                throw Error(o(156, t.tag))
            }
            function Ks(e, t) {
                switch (to(t),
                t.tag) {
                case 1:
                    return Ii(t.type) && Li(),
                    65536 & (e = t.flags) ? (t.flags = -65537 & e | 128,
                    t) : null;
                case 3:
                    return Qo(),
                    Ei(Ri),
                    Ei(Ti),
                    ra(),
                    0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128,
                    t) : null;
                case 5:
                    return $o(t),
                    null;
                case 13:
                    if (Ei(ea),
                    null !== (e = t.memoizedState) && null !== e.dehydrated) {
                        if (null === t.alternate)
                            throw Error(o(340));
                        fo()
                    }
                    return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128,
                    t) : null;
                case 19:
                    return Ei(ea),
                    null;
                case 4:
                    return Qo(),
                    null;
                case 10:
                    return To(t.type._context),
                    null;
                case 22:
                case 23:
                    return dc(),
                    null;
                default:
                    return null
                }
            }
            Bs = function(e, t) {
                for (var n = t.child; null !== n; ) {
                    if (5 === n.tag || 6 === n.tag)
                        e.appendChild(n.stateNode);
                    else if (4 !== n.tag && null !== n.child) {
                        n.child.return = n,
                        n = n.child;
                        continue
                    }
                    if (n === t)
                        break;
                    for (; null === n.sibling; ) {
                        if (null === n.return || n.return === t)
                            return;
                        n = n.return
                    }
                    n.sibling.return = n.return,
                    n = n.sibling
                }
            }
            ,
            Is = function() {}
            ,
            Ls = function(e, t, n, r) {
                var i = e.memoizedProps;
                if (i !== r) {
                    e = t.stateNode,
                    qo(Xo.current);
                    var o, a = null;
                    switch (n) {
                    case "input":
                        i = q(e, i),
                        r = q(e, r),
                        a = [];
                        break;
                    case "select":
                        i = N({}, i, {
                            value: void 0
                        }),
                        r = N({}, r, {
                            value: void 0
                        }),
                        a = [];
                        break;
                    case "textarea":
                        i = re(e, i),
                        r = re(e, r),
                        a = [];
                        break;
                    default:
                        "function" !== typeof i.onClick && "function" === typeof r.onClick && (e.onclick = $r)
                    }
                    for (u in ye(n, r),
                    n = null,
                    i)
                        if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && null != i[u])
                            if ("style" === u) {
                                var l = i[u];
                                for (o in l)
                                    l.hasOwnProperty(o) && (n || (n = {}),
                                    n[o] = "")
                            } else
                                "dangerouslySetInnerHTML" !== u && "children" !== u && "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && "autoFocus" !== u && (s.hasOwnProperty(u) ? a || (a = []) : (a = a || []).push(u, null));
                    for (u in r) {
                        var c = r[u];
                        if (l = null != i ? i[u] : void 0,
                        r.hasOwnProperty(u) && c !== l && (null != c || null != l))
                            if ("style" === u)
                                if (l) {
                                    for (o in l)
                                        !l.hasOwnProperty(o) || c && c.hasOwnProperty(o) || (n || (n = {}),
                                        n[o] = "");
                                    for (o in c)
                                        c.hasOwnProperty(o) && l[o] !== c[o] && (n || (n = {}),
                                        n[o] = c[o])
                                } else
                                    n || (a || (a = []),
                                    a.push(u, n)),
                                    n = c;
                            else
                                "dangerouslySetInnerHTML" === u ? (c = c ? c.__html : void 0,
                                l = l ? l.__html : void 0,
                                null != c && l !== c && (a = a || []).push(u, c)) : "children" === u ? "string" !== typeof c && "number" !== typeof c || (a = a || []).push(u, "" + c) : "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && (s.hasOwnProperty(u) ? (null != c && "onScroll" === u && Ur("scroll", e),
                                a || l === c || (a = [])) : (a = a || []).push(u, c))
                    }
                    n && (a = a || []).push("style", n);
                    var u = a;
                    (t.updateQueue = u) && (t.flags |= 4)
                }
            }
            ,
            ks = function(e, t, n, r) {
                n !== r && (t.flags |= 4)
            }
            ;
            var qs = !1
              , Ys = !1
              , Qs = "function" === typeof WeakSet ? WeakSet : Set
              , Zs = null;
            function $s(e, t) {
                var n = e.ref;
                if (null !== n)
                    if ("function" === typeof n)
                        try {
                            n(null)
                        } catch (r) {
                            wc(e, t, r)
                        }
                    else
                        n.current = null
            }
            function el(e, t, n) {
                try {
                    n()
                } catch (r) {
                    wc(e, t, r)
                }
            }
            var tl = !1;
            function nl(e, t, n) {
                var r = t.updateQueue;
                if (null !== (r = null !== r ? r.lastEffect : null)) {
                    var i = r = r.next;
                    do {
                        if ((i.tag & e) === e) {
                            var o = i.destroy;
                            i.destroy = void 0,
                            void 0 !== o && el(t, n, o)
                        }
                        i = i.next
                    } while (i !== r)
                }
            }
            function rl(e, t) {
                if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) {
                    var n = t = t.next;
                    do {
                        if ((n.tag & e) === e) {
                            var r = n.create;
                            n.destroy = r()
                        }
                        n = n.next
                    } while (n !== t)
                }
            }
            function il(e) {
                var t = e.ref;
                if (null !== t) {
                    var n = e.stateNode;
                    e.tag,
                    e = n,
                    "function" === typeof t ? t(e) : t.current = e
                }
            }
            function ol(e) {
                var t = e.alternate;
                null !== t && (e.alternate = null,
                ol(t)),
                e.child = null,
                e.deletions = null,
                e.sibling = null,
                5 === e.tag && (null !== (t = e.stateNode) && (delete t[hi],
                delete t[pi],
                delete t[mi],
                delete t[gi],
                delete t[vi])),
                e.stateNode = null,
                e.return = null,
                e.dependencies = null,
                e.memoizedProps = null,
                e.memoizedState = null,
                e.pendingProps = null,
                e.stateNode = null,
                e.updateQueue = null
            }
            function al(e) {
                return 5 === e.tag || 3 === e.tag || 4 === e.tag
            }
            function sl(e) {
                e: for (; ; ) {
                    for (; null === e.sibling; ) {
                        if (null === e.return || al(e.return))
                            return null;
                        e = e.return
                    }
                    for (e.sibling.return = e.return,
                    e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag; ) {
                        if (2 & e.flags)
                            continue e;
                        if (null === e.child || 4 === e.tag)
                            continue e;
                        e.child.return = e,
                        e = e.child
                    }
                    if (!(2 & e.flags))
                        return e.stateNode
                }
            }
            function ll(e, t, n) {
                var r = e.tag;
                if (5 === r || 6 === r)
                    e = e.stateNode,
                    t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e),
                    null !== (n = n._reactRootContainer) && void 0 !== n || null !== t.onclick || (t.onclick = $r));
                else if (4 !== r && null !== (e = e.child))
                    for (ll(e, t, n),
                    e = e.sibling; null !== e; )
                        ll(e, t, n),
                        e = e.sibling
            }
            function cl(e, t, n) {
                var r = e.tag;
                if (5 === r || 6 === r)
                    e = e.stateNode,
                    t ? n.insertBefore(e, t) : n.appendChild(e);
                else if (4 !== r && null !== (e = e.child))
                    for (cl(e, t, n),
                    e = e.sibling; null !== e; )
                        cl(e, t, n),
                        e = e.sibling
            }
            var ul = null
              , dl = !1;
            function hl(e, t, n) {
                for (n = n.child; null !== n; )
                    pl(e, t, n),
                    n = n.sibling
            }
            function pl(e, t, n) {
                if (ot && "function" === typeof ot.onCommitFiberUnmount)
                    try {
                        ot.onCommitFiberUnmount(it, n)
                    } catch (s) {}
                switch (n.tag) {
                case 5:
                    Ys || $s(n, t);
                case 6:
                    var r = ul
                      , i = dl;
                    ul = null,
                    hl(e, t, n),
                    dl = i,
                    null !== (ul = r) && (dl ? (e = ul,
                    n = n.stateNode,
                    8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : ul.removeChild(n.stateNode));
                    break;
                case 18:
                    null !== ul && (dl ? (e = ul,
                    n = n.stateNode,
                    8 === e.nodeType ? li(e.parentNode, n) : 1 === e.nodeType && li(e, n),
                    Ht(e)) : li(ul, n.stateNode));
                    break;
                case 4:
                    r = ul,
                    i = dl,
                    ul = n.stateNode.containerInfo,
                    dl = !0,
                    hl(e, t, n),
                    ul = r,
                    dl = i;
                    break;
                case 0:
                case 11:
                case 14:
                case 15:
                    if (!Ys && (null !== (r = n.updateQueue) && null !== (r = r.lastEffect))) {
                        i = r = r.next;
                        do {
                            var o = i
                              , a = o.destroy;
                            o = o.tag,
                            void 0 !== a && (0 !== (2 & o) || 0 !== (4 & o)) && el(n, t, a),
                            i = i.next
                        } while (i !== r)
                    }
                    hl(e, t, n);
                    break;
                case 1:
                    if (!Ys && ($s(n, t),
                    "function" === typeof (r = n.stateNode).componentWillUnmount))
                        try {
                            r.props = n.memoizedProps,
                            r.state = n.memoizedState,
                            r.componentWillUnmount()
                        } catch (s) {
                            wc(n, t, s)
                        }
                    hl(e, t, n);
                    break;
                case 21:
                    hl(e, t, n);
                    break;
                case 22:
                    1 & n.mode ? (Ys = (r = Ys) || null !== n.memoizedState,
                    hl(e, t, n),
                    Ys = r) : hl(e, t, n);
                    break;
                default:
                    hl(e, t, n)
                }
            }
            function fl(e) {
                var t = e.updateQueue;
                if (null !== t) {
                    e.updateQueue = null;
                    var n = e.stateNode;
                    null === n && (n = e.stateNode = new Qs),
                    t.forEach((function(t) {
                        var r = Tc.bind(null, e, t);
                        n.has(t) || (n.add(t),
                        t.then(r, r))
                    }
                    ))
                }
            }
            function ml(e, t) {
                var n = t.deletions;
                if (null !== n)
                    for (var r = 0; r < n.length; r++) {
                        var i = n[r];
                        try {
                            var a = e
                              , s = t
                              , l = s;
                            e: for (; null !== l; ) {
                                switch (l.tag) {
                                case 5:
                                    ul = l.stateNode,
                                    dl = !1;
                                    break e;
                                case 3:
                                case 4:
                                    ul = l.stateNode.containerInfo,
                                    dl = !0;
                                    break e
                                }
                                l = l.return
                            }
                            if (null === ul)
                                throw Error(o(160));
                            pl(a, s, i),
                            ul = null,
                            dl = !1;
                            var c = i.alternate;
                            null !== c && (c.return = null),
                            i.return = null
                        } catch (u) {
                            wc(i, t, u)
                        }
                    }
                if (12854 & t.subtreeFlags)
                    for (t = t.child; null !== t; )
                        gl(t, e),
                        t = t.sibling
            }
            function gl(e, t) {
                var n = e.alternate
                  , r = e.flags;
                switch (e.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                    if (ml(t, e),
                    vl(e),
                    4 & r) {
                        try {
                            nl(3, e, e.return),
                            rl(3, e)
                        } catch (g) {
                            wc(e, e.return, g)
                        }
                        try {
                            nl(5, e, e.return)
                        } catch (g) {
                            wc(e, e.return, g)
                        }
                    }
                    break;
                case 1:
                    ml(t, e),
                    vl(e),
                    512 & r && null !== n && $s(n, n.return);
                    break;
                case 5:
                    if (ml(t, e),
                    vl(e),
                    512 & r && null !== n && $s(n, n.return),
                    32 & e.flags) {
                        var i = e.stateNode;
                        try {
                            he(i, "")
                        } catch (g) {
                            wc(e, e.return, g)
                        }
                    }
                    if (4 & r && null != (i = e.stateNode)) {
                        var a = e.memoizedProps
                          , s = null !== n ? n.memoizedProps : a
                          , l = e.type
                          , c = e.updateQueue;
                        if (e.updateQueue = null,
                        null !== c)
                            try {
                                "input" === l && "radio" === a.type && null != a.name && Q(i, a),
                                be(l, s);
                                var u = be(l, a);
                                for (s = 0; s < c.length; s += 2) {
                                    var d = c[s]
                                      , h = c[s + 1];
                                    "style" === d ? ge(i, h) : "dangerouslySetInnerHTML" === d ? de(i, h) : "children" === d ? he(i, h) : b(i, d, h, u)
                                }
                                switch (l) {
                                case "input":
                                    Z(i, a);
                                    break;
                                case "textarea":
                                    oe(i, a);
                                    break;
                                case "select":
                                    var p = i._wrapperState.wasMultiple;
                                    i._wrapperState.wasMultiple = !!a.multiple;
                                    var f = a.value;
                                    null != f ? ne(i, !!a.multiple, f, !1) : p !== !!a.multiple && (null != a.defaultValue ? ne(i, !!a.multiple, a.defaultValue, !0) : ne(i, !!a.multiple, a.multiple ? [] : "", !1))
                                }
                                i[pi] = a
                            } catch (g) {
                                wc(e, e.return, g)
                            }
                    }
                    break;
                case 6:
                    if (ml(t, e),
                    vl(e),
                    4 & r) {
                        if (null === e.stateNode)
                            throw Error(o(162));
                        i = e.stateNode,
                        a = e.memoizedProps;
                        try {
                            i.nodeValue = a
                        } catch (g) {
                            wc(e, e.return, g)
                        }
                    }
                    break;
                case 3:
                    if (ml(t, e),
                    vl(e),
                    4 & r && null !== n && n.memoizedState.isDehydrated)
                        try {
                            Ht(t.containerInfo)
                        } catch (g) {
                            wc(e, e.return, g)
                        }
                    break;
                case 4:
                default:
                    ml(t, e),
                    vl(e);
                    break;
                case 13:
                    ml(t, e),
                    vl(e),
                    8192 & (i = e.child).flags && (a = null !== i.memoizedState,
                    i.stateNode.isHidden = a,
                    !a || null !== i.alternate && null !== i.alternate.memoizedState || (Gl = Qe())),
                    4 & r && fl(e);
                    break;
                case 22:
                    if (d = null !== n && null !== n.memoizedState,
                    1 & e.mode ? (Ys = (u = Ys) || d,
                    ml(t, e),
                    Ys = u) : ml(t, e),
                    vl(e),
                    8192 & r) {
                        if (u = null !== e.memoizedState,
                        (e.stateNode.isHidden = u) && !d && 0 !== (1 & e.mode))
                            for (Zs = e,
                            d = e.child; null !== d; ) {
                                for (h = Zs = d; null !== Zs; ) {
                                    switch (f = (p = Zs).child,
                                    p.tag) {
                                    case 0:
                                    case 11:
                                    case 14:
                                    case 15:
                                        nl(4, p, p.return);
                                        break;
                                    case 1:
                                        $s(p, p.return);
                                        var m = p.stateNode;
                                        if ("function" === typeof m.componentWillUnmount) {
                                            r = p,
                                            n = p.return;
                                            try {
                                                t = r,
                                                m.props = t.memoizedProps,
                                                m.state = t.memoizedState,
                                                m.componentWillUnmount()
                                            } catch (g) {
                                                wc(r, n, g)
                                            }
                                        }
                                        break;
                                    case 5:
                                        $s(p, p.return);
                                        break;
                                    case 22:
                                        if (null !== p.memoizedState) {
                                            Al(h);
                                            continue
                                        }
                                    }
                                    null !== f ? (f.return = p,
                                    Zs = f) : Al(h)
                                }
                                d = d.sibling
                            }
                        e: for (d = null,
                        h = e; ; ) {
                            if (5 === h.tag) {
                                if (null === d) {
                                    d = h;
                                    try {
                                        i = h.stateNode,
                                        u ? "function" === typeof (a = i.style).setProperty ? a.setProperty("display", "none", "important") : a.display = "none" : (l = h.stateNode,
                                        s = void 0 !== (c = h.memoizedProps.style) && null !== c && c.hasOwnProperty("display") ? c.display : null,
                                        l.style.display = me("display", s))
                                    } catch (g) {
                                        wc(e, e.return, g)
                                    }
                                }
                            } else if (6 === h.tag) {
                                if (null === d)
                                    try {
                                        h.stateNode.nodeValue = u ? "" : h.memoizedProps
                                    } catch (g) {
                                        wc(e, e.return, g)
                                    }
                            } else if ((22 !== h.tag && 23 !== h.tag || null === h.memoizedState || h === e) && null !== h.child) {
                                h.child.return = h,
                                h = h.child;
                                continue
                            }
                            if (h === e)
                                break e;
                            for (; null === h.sibling; ) {
                                if (null === h.return || h.return === e)
                                    break e;
                                d === h && (d = null),
                                h = h.return
                            }
                            d === h && (d = null),
                            h.sibling.return = h.return,
                            h = h.sibling
                        }
                    }
                    break;
                case 19:
                    ml(t, e),
                    vl(e),
                    4 & r && fl(e);
                case 21:
                }
            }
            function vl(e) {
                var t = e.flags;
                if (2 & t) {
                    try {
                        e: {
                            for (var n = e.return; null !== n; ) {
                                if (al(n)) {
                                    var r = n;
                                    break e
                                }
                                n = n.return
                            }
                            throw Error(o(160))
                        }
                        switch (r.tag) {
                        case 5:
                            var i = r.stateNode;
                            32 & r.flags && (he(i, ""),
                            r.flags &= -33),
                            cl(e, sl(e), i);
                            break;
                        case 3:
                        case 4:
                            var a = r.stateNode.containerInfo;
                            ll(e, sl(e), a);
                            break;
                        default:
                            throw Error(o(161))
                        }
                    } catch (s) {
                        wc(e, e.return, s)
                    }
                    e.flags &= -3
                }
                4096 & t && (e.flags &= -4097)
            }
            function yl(e, t, n) {
                Zs = e,
                bl(e, t, n)
            }
            function bl(e, t, n) {
                for (var r = 0 !== (1 & e.mode); null !== Zs; ) {
                    var i = Zs
                      , o = i.child;
                    if (22 === i.tag && r) {
                        var a = null !== i.memoizedState || qs;
                        if (!a) {
                            var s = i.alternate
                              , l = null !== s && null !== s.memoizedState || Ys;
                            s = qs;
                            var c = Ys;
                            if (qs = a,
                            (Ys = l) && !c)
                                for (Zs = i; null !== Zs; )
                                    l = (a = Zs).child,
                                    22 === a.tag && null !== a.memoizedState ? xl(i) : null !== l ? (l.return = a,
                                    Zs = l) : xl(i);
                            for (; null !== o; )
                                Zs = o,
                                bl(o, t, n),
                                o = o.sibling;
                            Zs = i,
                            qs = s,
                            Ys = c
                        }
                        _l(e)
                    } else
                        0 !== (8772 & i.subtreeFlags) && null !== o ? (o.return = i,
                        Zs = o) : _l(e)
                }
            }
            function _l(e) {
                for (; null !== Zs; ) {
                    var t = Zs;
                    if (0 !== (8772 & t.flags)) {
                        var n = t.alternate;
                        try {
                            if (0 !== (8772 & t.flags))
                                switch (t.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Ys || rl(5, t);
                                    break;
                                case 1:
                                    var r = t.stateNode;
                                    if (4 & t.flags && !Ys)
                                        if (null === n)
                                            r.componentDidMount();
                                        else {
                                            var i = t.elementType === t.type ? n.memoizedProps : ns(t.type, n.memoizedProps);
                                            r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                                        }
                                    var a = t.updateQueue;
                                    null !== a && Wo(t, a, r);
                                    break;
                                case 3:
                                    var s = t.updateQueue;
                                    if (null !== s) {
                                        if (n = null,
                                        null !== t.child)
                                            switch (t.child.tag) {
                                            case 5:
                                            case 1:
                                                n = t.child.stateNode
                                            }
                                        Wo(t, s, n)
                                    }
                                    break;
                                case 5:
                                    var l = t.stateNode;
                                    if (null === n && 4 & t.flags) {
                                        n = l;
                                        var c = t.memoizedProps;
                                        switch (t.type) {
                                        case "button":
                                        case "input":
                                        case "select":
                                        case "textarea":
                                            c.autoFocus && n.focus();
                                            break;
                                        case "img":
                                            c.src && (n.src = c.src)
                                        }
                                    }
                                    break;
                                case 6:
                                case 4:
                                case 12:
                                case 19:
                                case 17:
                                case 21:
                                case 22:
                                case 23:
                                case 25:
                                    break;
                                case 13:
                                    if (null === t.memoizedState) {
                                        var u = t.alternate;
                                        if (null !== u) {
                                            var d = u.memoizedState;
                                            if (null !== d) {
                                                var h = d.dehydrated;
                                                null !== h && Ht(h)
                                            }
                                        }
                                    }
                                    break;
                                default:
                                    throw Error(o(163))
                                }
                            Ys || 512 & t.flags && il(t)
                        } catch (p) {
                            wc(t, t.return, p)
                        }
                    }
                    if (t === e) {
                        Zs = null;
                        break
                    }
                    if (null !== (n = t.sibling)) {
                        n.return = t.return,
                        Zs = n;
                        break
                    }
                    Zs = t.return
                }
            }
            function Al(e) {
                for (; null !== Zs; ) {
                    var t = Zs;
                    if (t === e) {
                        Zs = null;
                        break
                    }
                    var n = t.sibling;
                    if (null !== n) {
                        n.return = t.return,
                        Zs = n;
                        break
                    }
                    Zs = t.return
                }
            }
            function xl(e) {
                for (; null !== Zs; ) {
                    var t = Zs;
                    try {
                        switch (t.tag) {
                        case 0:
                        case 11:
                        case 15:
                            var n = t.return;
                            try {
                                rl(4, t)
                            } catch (l) {
                                wc(t, n, l)
                            }
                            break;
                        case 1:
                            var r = t.stateNode;
                            if ("function" === typeof r.componentDidMount) {
                                var i = t.return;
                                try {
                                    r.componentDidMount()
                                } catch (l) {
                                    wc(t, i, l)
                                }
                            }
                            var o = t.return;
                            try {
                                il(t)
                            } catch (l) {
                                wc(t, o, l)
                            }
                            break;
                        case 5:
                            var a = t.return;
                            try {
                                il(t)
                            } catch (l) {
                                wc(t, a, l)
                            }
                        }
                    } catch (l) {
                        wc(t, t.return, l)
                    }
                    if (t === e) {
                        Zs = null;
                        break
                    }
                    var s = t.sibling;
                    if (null !== s) {
                        s.return = t.return,
                        Zs = s;
                        break
                    }
                    Zs = t.return
                }
            }
            var Sl, wl = Math.ceil, El = _.ReactCurrentDispatcher, Ml = _.ReactCurrentOwner, Cl = _.ReactCurrentBatchConfig, Tl = 0, Rl = null, Pl = null, Bl = 0, Il = 0, Ll = wi(0), kl = 0, Dl = null, Ol = 0, Nl = 0, Fl = 0, Ul = null, zl = null, Gl = 0, Hl = 1 / 0, jl = null, Wl = !1, Vl = null, Xl = null, Jl = !1, Kl = null, ql = 0, Yl = 0, Ql = null, Zl = -1, $l = 0;
            function ec() {
                return 0 !== (6 & Tl) ? Qe() : -1 !== Zl ? Zl : Zl = Qe()
            }
            function tc(e) {
                return 0 === (1 & e.mode) ? 1 : 0 !== (2 & Tl) && 0 !== Bl ? Bl & -Bl : null !== go.transition ? (0 === $l && ($l = mt()),
                $l) : 0 !== (e = bt) ? e : e = void 0 === (e = window.event) ? 16 : Yt(e.type)
            }
            function nc(e, t, n, r) {
                if (50 < Yl)
                    throw Yl = 0,
                    Ql = null,
                    Error(o(185));
                vt(e, n, r),
                0 !== (2 & Tl) && e === Rl || (e === Rl && (0 === (2 & Tl) && (Nl |= n),
                4 === kl && sc(e, Bl)),
                rc(e, r),
                1 === n && 0 === Tl && 0 === (1 & t.mode) && (Hl = Qe() + 500,
                Ui && Hi()))
            }
            function rc(e, t) {
                var n = e.callbackNode;
                !function(e, t) {
                    for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o; ) {
                        var a = 31 - at(o)
                          , s = 1 << a
                          , l = i[a];
                        -1 === l ? 0 !== (s & n) && 0 === (s & r) || (i[a] = pt(s, t)) : l <= t && (e.expiredLanes |= s),
                        o &= ~s
                    }
                }(e, t);
                var r = ht(e, e === Rl ? Bl : 0);
                if (0 === r)
                    null !== n && Ke(n),
                    e.callbackNode = null,
                    e.callbackPriority = 0;
                else if (t = r & -r,
                e.callbackPriority !== t) {
                    if (null != n && Ke(n),
                    1 === t)
                        0 === e.tag ? function(e) {
                            Ui = !0,
                            Gi(e)
                        }(lc.bind(null, e)) : Gi(lc.bind(null, e)),
                        ai((function() {
                            0 === (6 & Tl) && Hi()
                        }
                        )),
                        n = null;
                    else {
                        switch (_t(r)) {
                        case 1:
                            n = $e;
                            break;
                        case 4:
                            n = et;
                            break;
                        case 16:
                        default:
                            n = tt;
                            break;
                        case 536870912:
                            n = rt
                        }
                        n = Rc(n, ic.bind(null, e))
                    }
                    e.callbackPriority = t,
                    e.callbackNode = n
                }
            }
            function ic(e, t) {
                if (Zl = -1,
                $l = 0,
                0 !== (6 & Tl))
                    throw Error(o(327));
                var n = e.callbackNode;
                if (xc() && e.callbackNode !== n)
                    return null;
                var r = ht(e, e === Rl ? Bl : 0);
                if (0 === r)
                    return null;
                if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t)
                    t = gc(e, r);
                else {
                    t = r;
                    var i = Tl;
                    Tl |= 2;
                    var a = fc();
                    for (Rl === e && Bl === t || (jl = null,
                    Hl = Qe() + 500,
                    hc(e, t)); ; )
                        try {
                            yc();
                            break
                        } catch (l) {
                            pc(e, l)
                        }
                    Co(),
                    El.current = a,
                    Tl = i,
                    null !== Pl ? t = 0 : (Rl = null,
                    Bl = 0,
                    t = kl)
                }
                if (0 !== t) {
                    if (2 === t && (0 !== (i = ft(e)) && (r = i,
                    t = oc(e, i))),
                    1 === t)
                        throw n = Dl,
                        hc(e, 0),
                        sc(e, r),
                        rc(e, Qe()),
                        n;
                    if (6 === t)
                        sc(e, r);
                    else {
                        if (i = e.current.alternate,
                        0 === (30 & r) && !function(e) {
                            for (var t = e; ; ) {
                                if (16384 & t.flags) {
                                    var n = t.updateQueue;
                                    if (null !== n && null !== (n = n.stores))
                                        for (var r = 0; r < n.length; r++) {
                                            var i = n[r]
                                              , o = i.getSnapshot;
                                            i = i.value;
                                            try {
                                                if (!sr(o(), i))
                                                    return !1
                                            } catch (s) {
                                                return !1
                                            }
                                        }
                                }
                                if (n = t.child,
                                16384 & t.subtreeFlags && null !== n)
                                    n.return = t,
                                    t = n;
                                else {
                                    if (t === e)
                                        break;
                                    for (; null === t.sibling; ) {
                                        if (null === t.return || t.return === e)
                                            return !0;
                                        t = t.return
                                    }
                                    t.sibling.return = t.return,
                                    t = t.sibling
                                }
                            }
                            return !0
                        }(i) && (2 === (t = gc(e, r)) && (0 !== (a = ft(e)) && (r = a,
                        t = oc(e, a))),
                        1 === t))
                            throw n = Dl,
                            hc(e, 0),
                            sc(e, r),
                            rc(e, Qe()),
                            n;
                        switch (e.finishedWork = i,
                        e.finishedLanes = r,
                        t) {
                        case 0:
                        case 1:
                            throw Error(o(345));
                        case 2:
                        case 5:
                            Ac(e, zl, jl);
                            break;
                        case 3:
                            if (sc(e, r),
                            (130023424 & r) === r && 10 < (t = Gl + 500 - Qe())) {
                                if (0 !== ht(e, 0))
                                    break;
                                if (((i = e.suspendedLanes) & r) !== r) {
                                    ec(),
                                    e.pingedLanes |= e.suspendedLanes & i;
                                    break
                                }
                                e.timeoutHandle = ri(Ac.bind(null, e, zl, jl), t);
                                break
                            }
                            Ac(e, zl, jl);
                            break;
                        case 4:
                            if (sc(e, r),
                            (4194240 & r) === r)
                                break;
                            for (t = e.eventTimes,
                            i = -1; 0 < r; ) {
                                var s = 31 - at(r);
                                a = 1 << s,
                                (s = t[s]) > i && (i = s),
                                r &= ~a
                            }
                            if (r = i,
                            10 < (r = (120 > (r = Qe() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * wl(r / 1960)) - r)) {
                                e.timeoutHandle = ri(Ac.bind(null, e, zl, jl), r);
                                break
                            }
                            Ac(e, zl, jl);
                            break;
                        default:
                            throw Error(o(329))
                        }
                    }
                }
                return rc(e, Qe()),
                e.callbackNode === n ? ic.bind(null, e) : null
            }
            function oc(e, t) {
                var n = Ul;
                return e.current.memoizedState.isDehydrated && (hc(e, t).flags |= 256),
                2 !== (e = gc(e, t)) && (t = zl,
                zl = n,
                null !== t && ac(t)),
                e
            }
            function ac(e) {
                null === zl ? zl = e : zl.push.apply(zl, e)
            }
            function sc(e, t) {
                for (t &= ~Fl,
                t &= ~Nl,
                e.suspendedLanes |= t,
                e.pingedLanes &= ~t,
                e = e.expirationTimes; 0 < t; ) {
                    var n = 31 - at(t)
                      , r = 1 << n;
                    e[n] = -1,
                    t &= ~r
                }
            }
            function lc(e) {
                if (0 !== (6 & Tl))
                    throw Error(o(327));
                xc();
                var t = ht(e, 0);
                if (0 === (1 & t))
                    return rc(e, Qe()),
                    null;
                var n = gc(e, t);
                if (0 !== e.tag && 2 === n) {
                    var r = ft(e);
                    0 !== r && (t = r,
                    n = oc(e, r))
                }
                if (1 === n)
                    throw n = Dl,
                    hc(e, 0),
                    sc(e, t),
                    rc(e, Qe()),
                    n;
                if (6 === n)
                    throw Error(o(345));
                return e.finishedWork = e.current.alternate,
                e.finishedLanes = t,
                Ac(e, zl, jl),
                rc(e, Qe()),
                null
            }
            function cc(e, t) {
                var n = Tl;
                Tl |= 1;
                try {
                    return e(t)
                } finally {
                    0 === (Tl = n) && (Hl = Qe() + 500,
                    Ui && Hi())
                }
            }
            function uc(e) {
                null !== Kl && 0 === Kl.tag && 0 === (6 & Tl) && xc();
                var t = Tl;
                Tl |= 1;
                var n = Cl.transition
                  , r = bt;
                try {
                    if (Cl.transition = null,
                    bt = 1,
                    e)
                        return e()
                } finally {
                    bt = r,
                    Cl.transition = n,
                    0 === (6 & (Tl = t)) && Hi()
                }
            }
            function dc() {
                Il = Ll.current,
                Ei(Ll)
            }
            function hc(e, t) {
                e.finishedWork = null,
                e.finishedLanes = 0;
                var n = e.timeoutHandle;
                if (-1 !== n && (e.timeoutHandle = -1,
                ii(n)),
                null !== Pl)
                    for (n = Pl.return; null !== n; ) {
                        var r = n;
                        switch (to(r),
                        r.tag) {
                        case 1:
                            null !== (r = r.type.childContextTypes) && void 0 !== r && Li();
                            break;
                        case 3:
                            Qo(),
                            Ei(Ri),
                            Ei(Ti),
                            ra();
                            break;
                        case 5:
                            $o(r);
                            break;
                        case 4:
                            Qo();
                            break;
                        case 13:
                        case 19:
                            Ei(ea);
                            break;
                        case 10:
                            To(r.type._context);
                            break;
                        case 22:
                        case 23:
                            dc()
                        }
                        n = n.return
                    }
                if (Rl = e,
                Pl = e = Lc(e.current, null),
                Bl = Il = t,
                kl = 0,
                Dl = null,
                Fl = Nl = Ol = 0,
                zl = Ul = null,
                null !== Io) {
                    for (t = 0; t < Io.length; t++)
                        if (null !== (r = (n = Io[t]).interleaved)) {
                            n.interleaved = null;
                            var i = r.next
                              , o = n.pending;
                            if (null !== o) {
                                var a = o.next;
                                o.next = i,
                                r.next = a
                            }
                            n.pending = r
                        }
                    Io = null
                }
                return e
            }
            function pc(e, t) {
                for (; ; ) {
                    var n = Pl;
                    try {
                        if (Co(),
                        ia.current = Za,
                        ua) {
                            for (var r = sa.memoizedState; null !== r; ) {
                                var i = r.queue;
                                null !== i && (i.pending = null),
                                r = r.next
                            }
                            ua = !1
                        }
                        if (aa = 0,
                        ca = la = sa = null,
                        da = !1,
                        ha = 0,
                        Ml.current = null,
                        null === n || null === n.return) {
                            kl = 1,
                            Dl = t,
                            Pl = null;
                            break
                        }
                        e: {
                            var a = e
                              , s = n.return
                              , l = n
                              , c = t;
                            if (t = Bl,
                            l.flags |= 32768,
                            null !== c && "object" === typeof c && "function" === typeof c.then) {
                                var u = c
                                  , d = l
                                  , h = d.tag;
                                if (0 === (1 & d.mode) && (0 === h || 11 === h || 15 === h)) {
                                    var p = d.alternate;
                                    p ? (d.updateQueue = p.updateQueue,
                                    d.memoizedState = p.memoizedState,
                                    d.lanes = p.lanes) : (d.updateQueue = null,
                                    d.memoizedState = null)
                                }
                                var f = gs(s);
                                if (null !== f) {
                                    f.flags &= -257,
                                    vs(f, s, l, 0, t),
                                    1 & f.mode && ms(a, u, t),
                                    c = u;
                                    var m = (t = f).updateQueue;
                                    if (null === m) {
                                        var g = new Set;
                                        g.add(c),
                                        t.updateQueue = g
                                    } else
                                        m.add(c);
                                    break e
                                }
                                if (0 === (1 & t)) {
                                    ms(a, u, t),
                                    mc();
                                    break e
                                }
                                c = Error(o(426))
                            } else if (io && 1 & l.mode) {
                                var v = gs(s);
                                if (null !== v) {
                                    0 === (65536 & v.flags) && (v.flags |= 256),
                                    vs(v, s, l, 0, t),
                                    mo(cs(c, l));
                                    break e
                                }
                            }
                            a = c = cs(c, l),
                            4 !== kl && (kl = 2),
                            null === Ul ? Ul = [a] : Ul.push(a),
                            a = s;
                            do {
                                switch (a.tag) {
                                case 3:
                                    a.flags |= 65536,
                                    t &= -t,
                                    a.lanes |= t,
                                    Ho(a, ps(0, c, t));
                                    break e;
                                case 1:
                                    l = c;
                                    var y = a.type
                                      , b = a.stateNode;
                                    if (0 === (128 & a.flags) && ("function" === typeof y.getDerivedStateFromError || null !== b && "function" === typeof b.componentDidCatch && (null === Xl || !Xl.has(b)))) {
                                        a.flags |= 65536,
                                        t &= -t,
                                        a.lanes |= t,
                                        Ho(a, fs(a, l, t));
                                        break e
                                    }
                                }
                                a = a.return
                            } while (null !== a)
                        }
                        _c(n)
                    } catch (_) {
                        t = _,
                        Pl === n && null !== n && (Pl = n = n.return);
                        continue
                    }
                    break
                }
            }
            function fc() {
                var e = El.current;
                return El.current = Za,
                null === e ? Za : e
            }
            function mc() {
                0 !== kl && 3 !== kl && 2 !== kl || (kl = 4),
                null === Rl || 0 === (268435455 & Ol) && 0 === (268435455 & Nl) || sc(Rl, Bl)
            }
            function gc(e, t) {
                var n = Tl;
                Tl |= 2;
                var r = fc();
                for (Rl === e && Bl === t || (jl = null,
                hc(e, t)); ; )
                    try {
                        vc();
                        break
                    } catch (i) {
                        pc(e, i)
                    }
                if (Co(),
                Tl = n,
                El.current = r,
                null !== Pl)
                    throw Error(o(261));
                return Rl = null,
                Bl = 0,
                kl
            }
            function vc() {
                for (; null !== Pl; )
                    bc(Pl)
            }
            function yc() {
                for (; null !== Pl && !qe(); )
                    bc(Pl)
            }
            function bc(e) {
                var t = Sl(e.alternate, e, Il);
                e.memoizedProps = e.pendingProps,
                null === t ? _c(e) : Pl = t,
                Ml.current = null
            }
            function _c(e) {
                var t = e;
                do {
                    var n = t.alternate;
                    if (e = t.return,
                    0 === (32768 & t.flags)) {
                        if (null !== (n = Js(n, t, Il)))
                            return void (Pl = n)
                    } else {
                        if (null !== (n = Ks(n, t)))
                            return n.flags &= 32767,
                            void (Pl = n);
                        if (null === e)
                            return kl = 6,
                            void (Pl = null);
                        e.flags |= 32768,
                        e.subtreeFlags = 0,
                        e.deletions = null
                    }
                    if (null !== (t = t.sibling))
                        return void (Pl = t);
                    Pl = t = e
                } while (null !== t);
                0 === kl && (kl = 5)
            }
            function Ac(e, t, n) {
                var r = bt
                  , i = Cl.transition;
                try {
                    Cl.transition = null,
                    bt = 1,
                    function(e, t, n, r) {
                        do {
                            xc()
                        } while (null !== Kl);
                        if (0 !== (6 & Tl))
                            throw Error(o(327));
                        n = e.finishedWork;
                        var i = e.finishedLanes;
                        if (null === n)
                            return null;
                        if (e.finishedWork = null,
                        e.finishedLanes = 0,
                        n === e.current)
                            throw Error(o(177));
                        e.callbackNode = null,
                        e.callbackPriority = 0;
                        var a = n.lanes | n.childLanes;
                        if (function(e, t) {
                            var n = e.pendingLanes & ~t;
                            e.pendingLanes = t,
                            e.suspendedLanes = 0,
                            e.pingedLanes = 0,
                            e.expiredLanes &= t,
                            e.mutableReadLanes &= t,
                            e.entangledLanes &= t,
                            t = e.entanglements;
                            var r = e.eventTimes;
                            for (e = e.expirationTimes; 0 < n; ) {
                                var i = 31 - at(n)
                                  , o = 1 << i;
                                t[i] = 0,
                                r[i] = -1,
                                e[i] = -1,
                                n &= ~o
                            }
                        }(e, a),
                        e === Rl && (Pl = Rl = null,
                        Bl = 0),
                        0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags) || Jl || (Jl = !0,
                        Rc(tt, (function() {
                            return xc(),
                            null
                        }
                        ))),
                        a = 0 !== (15990 & n.flags),
                        0 !== (15990 & n.subtreeFlags) || a) {
                            a = Cl.transition,
                            Cl.transition = null;
                            var s = bt;
                            bt = 1;
                            var l = Tl;
                            Tl |= 4,
                            Ml.current = null,
                            function(e, t) {
                                if (ei = Wt,
                                pr(e = hr())) {
                                    if ("selectionStart"in e)
                                        var n = {
                                            start: e.selectionStart,
                                            end: e.selectionEnd
                                        };
                                    else
                                        e: {
                                            var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection();
                                            if (r && 0 !== r.rangeCount) {
                                                n = r.anchorNode;
                                                var i = r.anchorOffset
                                                  , a = r.focusNode;
                                                r = r.focusOffset;
                                                try {
                                                    n.nodeType,
                                                    a.nodeType
                                                } catch (A) {
                                                    n = null;
                                                    break e
                                                }
                                                var s = 0
                                                  , l = -1
                                                  , c = -1
                                                  , u = 0
                                                  , d = 0
                                                  , h = e
                                                  , p = null;
                                                t: for (; ; ) {
                                                    for (var f; h !== n || 0 !== i && 3 !== h.nodeType || (l = s + i),
                                                    h !== a || 0 !== r && 3 !== h.nodeType || (c = s + r),
                                                    3 === h.nodeType && (s += h.nodeValue.length),
                                                    null !== (f = h.firstChild); )
                                                        p = h,
                                                        h = f;
                                                    for (; ; ) {
                                                        if (h === e)
                                                            break t;
                                                        if (p === n && ++u === i && (l = s),
                                                        p === a && ++d === r && (c = s),
                                                        null !== (f = h.nextSibling))
                                                            break;
                                                        p = (h = p).parentNode
                                                    }
                                                    h = f
                                                }
                                                n = -1 === l || -1 === c ? null : {
                                                    start: l,
                                                    end: c
                                                }
                                            } else
                                                n = null
                                        }
                                    n = n || {
                                        start: 0,
                                        end: 0
                                    }
                                } else
                                    n = null;
                                for (ti = {
                                    focusedElem: e,
                                    selectionRange: n
                                },
                                Wt = !1,
                                Zs = t; null !== Zs; )
                                    if (e = (t = Zs).child,
                                    0 !== (1028 & t.subtreeFlags) && null !== e)
                                        e.return = t,
                                        Zs = e;
                                    else
                                        for (; null !== Zs; ) {
                                            t = Zs;
                                            try {
                                                var m = t.alternate;
                                                if (0 !== (1024 & t.flags))
                                                    switch (t.tag) {
                                                    case 0:
                                                    case 11:
                                                    case 15:
                                                    case 5:
                                                    case 6:
                                                    case 4:
                                                    case 17:
                                                        break;
                                                    case 1:
                                                        if (null !== m) {
                                                            var g = m.memoizedProps
                                                              , v = m.memoizedState
                                                              , y = t.stateNode
                                                              , b = y.getSnapshotBeforeUpdate(t.elementType === t.type ? g : ns(t.type, g), v);
                                                            y.__reactInternalSnapshotBeforeUpdate = b
                                                        }
                                                        break;
                                                    case 3:
                                                        var _ = t.stateNode.containerInfo;
                                                        1 === _.nodeType ? _.textContent = "" : 9 === _.nodeType && _.documentElement && _.removeChild(_.documentElement);
                                                        break;
                                                    default:
                                                        throw Error(o(163))
                                                    }
                                            } catch (A) {
                                                wc(t, t.return, A)
                                            }
                                            if (null !== (e = t.sibling)) {
                                                e.return = t.return,
                                                Zs = e;
                                                break
                                            }
                                            Zs = t.return
                                        }
                                m = tl,
                                tl = !1
                            }(e, n),
                            gl(n, e),
                            fr(ti),
                            Wt = !!ei,
                            ti = ei = null,
                            e.current = n,
                            yl(n, e, i),
                            Ye(),
                            Tl = l,
                            bt = s,
                            Cl.transition = a
                        } else
                            e.current = n;
                        if (Jl && (Jl = !1,
                        Kl = e,
                        ql = i),
                        a = e.pendingLanes,
                        0 === a && (Xl = null),
                        function(e) {
                            if (ot && "function" === typeof ot.onCommitFiberRoot)
                                try {
                                    ot.onCommitFiberRoot(it, e, void 0, 128 === (128 & e.current.flags))
                                } catch (t) {}
                        }(n.stateNode),
                        rc(e, Qe()),
                        null !== t)
                            for (r = e.onRecoverableError,
                            n = 0; n < t.length; n++)
                                i = t[n],
                                r(i.value, {
                                    componentStack: i.stack,
                                    digest: i.digest
                                });
                        if (Wl)
                            throw Wl = !1,
                            e = Vl,
                            Vl = null,
                            e;
                        0 !== (1 & ql) && 0 !== e.tag && xc(),
                        a = e.pendingLanes,
                        0 !== (1 & a) ? e === Ql ? Yl++ : (Yl = 0,
                        Ql = e) : Yl = 0,
                        Hi()
                    }(e, t, n, r)
                } finally {
                    Cl.transition = i,
                    bt = r
                }
                return null
            }
            function xc() {
                if (null !== Kl) {
                    var e = _t(ql)
                      , t = Cl.transition
                      , n = bt;
                    try {
                        if (Cl.transition = null,
                        bt = 16 > e ? 16 : e,
                        null === Kl)
                            var r = !1;
                        else {
                            if (e = Kl,
                            Kl = null,
                            ql = 0,
                            0 !== (6 & Tl))
                                throw Error(o(331));
                            var i = Tl;
                            for (Tl |= 4,
                            Zs = e.current; null !== Zs; ) {
                                var a = Zs
                                  , s = a.child;
                                if (0 !== (16 & Zs.flags)) {
                                    var l = a.deletions;
                                    if (null !== l) {
                                        for (var c = 0; c < l.length; c++) {
                                            var u = l[c];
                                            for (Zs = u; null !== Zs; ) {
                                                var d = Zs;
                                                switch (d.tag) {
                                                case 0:
                                                case 11:
                                                case 15:
                                                    nl(8, d, a)
                                                }
                                                var h = d.child;
                                                if (null !== h)
                                                    h.return = d,
                                                    Zs = h;
                                                else
                                                    for (; null !== Zs; ) {
                                                        var p = (d = Zs).sibling
                                                          , f = d.return;
                                                        if (ol(d),
                                                        d === u) {
                                                            Zs = null;
                                                            break
                                                        }
                                                        if (null !== p) {
                                                            p.return = f,
                                                            Zs = p;
                                                            break
                                                        }
                                                        Zs = f
                                                    }
                                            }
                                        }
                                        var m = a.alternate;
                                        if (null !== m) {
                                            var g = m.child;
                                            if (null !== g) {
                                                m.child = null;
                                                do {
                                                    var v = g.sibling;
                                                    g.sibling = null,
                                                    g = v
                                                } while (null !== g)
                                            }
                                        }
                                        Zs = a
                                    }
                                }
                                if (0 !== (2064 & a.subtreeFlags) && null !== s)
                                    s.return = a,
                                    Zs = s;
                                else
                                    e: for (; null !== Zs; ) {
                                        if (0 !== (2048 & (a = Zs).flags))
                                            switch (a.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                nl(9, a, a.return)
                                            }
                                        var y = a.sibling;
                                        if (null !== y) {
                                            y.return = a.return,
                                            Zs = y;
                                            break e
                                        }
                                        Zs = a.return
                                    }
                            }
                            var b = e.current;
                            for (Zs = b; null !== Zs; ) {
                                var _ = (s = Zs).child;
                                if (0 !== (2064 & s.subtreeFlags) && null !== _)
                                    _.return = s,
                                    Zs = _;
                                else
                                    e: for (s = b; null !== Zs; ) {
                                        if (0 !== (2048 & (l = Zs).flags))
                                            try {
                                                switch (l.tag) {
                                                case 0:
                                                case 11:
                                                case 15:
                                                    rl(9, l)
                                                }
                                            } catch (x) {
                                                wc(l, l.return, x)
                                            }
                                        if (l === s) {
                                            Zs = null;
                                            break e
                                        }
                                        var A = l.sibling;
                                        if (null !== A) {
                                            A.return = l.return,
                                            Zs = A;
                                            break e
                                        }
                                        Zs = l.return
                                    }
                            }
                            if (Tl = i,
                            Hi(),
                            ot && "function" === typeof ot.onPostCommitFiberRoot)
                                try {
                                    ot.onPostCommitFiberRoot(it, e)
                                } catch (x) {}
                            r = !0
                        }
                        return r
                    } finally {
                        bt = n,
                        Cl.transition = t
                    }
                }
                return !1
            }
            function Sc(e, t, n) {
                e = zo(e, t = ps(0, t = cs(n, t), 1), 1),
                t = ec(),
                null !== e && (vt(e, 1, t),
                rc(e, t))
            }
            function wc(e, t, n) {
                if (3 === e.tag)
                    Sc(e, e, n);
                else
                    for (; null !== t; ) {
                        if (3 === t.tag) {
                            Sc(t, e, n);
                            break
                        }
                        if (1 === t.tag) {
                            var r = t.stateNode;
                            if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === Xl || !Xl.has(r))) {
                                t = zo(t, e = fs(t, e = cs(n, e), 1), 1),
                                e = ec(),
                                null !== t && (vt(t, 1, e),
                                rc(t, e));
                                break
                            }
                        }
                        t = t.return
                    }
            }
            function Ec(e, t, n) {
                var r = e.pingCache;
                null !== r && r.delete(t),
                t = ec(),
                e.pingedLanes |= e.suspendedLanes & n,
                Rl === e && (Bl & n) === n && (4 === kl || 3 === kl && (130023424 & Bl) === Bl && 500 > Qe() - Gl ? hc(e, 0) : Fl |= n),
                rc(e, t)
            }
            function Mc(e, t) {
                0 === t && (0 === (1 & e.mode) ? t = 1 : (t = ut,
                0 === (130023424 & (ut <<= 1)) && (ut = 4194304)));
                var n = ec();
                null !== (e = Do(e, t)) && (vt(e, t, n),
                rc(e, n))
            }
            function Cc(e) {
                var t = e.memoizedState
                  , n = 0;
                null !== t && (n = t.retryLane),
                Mc(e, n)
            }
            function Tc(e, t) {
                var n = 0;
                switch (e.tag) {
                case 13:
                    var r = e.stateNode
                      , i = e.memoizedState;
                    null !== i && (n = i.retryLane);
                    break;
                case 19:
                    r = e.stateNode;
                    break;
                default:
                    throw Error(o(314))
                }
                null !== r && r.delete(t),
                Mc(e, n)
            }
            function Rc(e, t) {
                return Je(e, t)
            }
            function Pc(e, t, n, r) {
                this.tag = e,
                this.key = n,
                this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
                this.index = 0,
                this.ref = null,
                this.pendingProps = t,
                this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
                this.mode = r,
                this.subtreeFlags = this.flags = 0,
                this.deletions = null,
                this.childLanes = this.lanes = 0,
                this.alternate = null
            }
            function Bc(e, t, n, r) {
                return new Pc(e,t,n,r)
            }
            function Ic(e) {
                return !(!(e = e.prototype) || !e.isReactComponent)
            }
            function Lc(e, t) {
                var n = e.alternate;
                return null === n ? ((n = Bc(e.tag, t, e.key, e.mode)).elementType = e.elementType,
                n.type = e.type,
                n.stateNode = e.stateNode,
                n.alternate = e,
                e.alternate = n) : (n.pendingProps = t,
                n.type = e.type,
                n.flags = 0,
                n.subtreeFlags = 0,
                n.deletions = null),
                n.flags = 14680064 & e.flags,
                n.childLanes = e.childLanes,
                n.lanes = e.lanes,
                n.child = e.child,
                n.memoizedProps = e.memoizedProps,
                n.memoizedState = e.memoizedState,
                n.updateQueue = e.updateQueue,
                t = e.dependencies,
                n.dependencies = null === t ? null : {
                    lanes: t.lanes,
                    firstContext: t.firstContext
                },
                n.sibling = e.sibling,
                n.index = e.index,
                n.ref = e.ref,
                n
            }
            function kc(e, t, n, r, i, a) {
                var s = 2;
                if (r = e,
                "function" === typeof e)
                    Ic(e) && (s = 1);
                else if ("string" === typeof e)
                    s = 5;
                else
                    e: switch (e) {
                    case S:
                        return Dc(n.children, i, a, t);
                    case w:
                        s = 8,
                        i |= 8;
                        break;
                    case E:
                        return (e = Bc(12, n, t, 2 | i)).elementType = E,
                        e.lanes = a,
                        e;
                    case R:
                        return (e = Bc(13, n, t, i)).elementType = R,
                        e.lanes = a,
                        e;
                    case P:
                        return (e = Bc(19, n, t, i)).elementType = P,
                        e.lanes = a,
                        e;
                    case L:
                        return Oc(n, i, a, t);
                    default:
                        if ("object" === typeof e && null !== e)
                            switch (e.$$typeof) {
                            case M:
                                s = 10;
                                break e;
                            case C:
                                s = 9;
                                break e;
                            case T:
                                s = 11;
                                break e;
                            case B:
                                s = 14;
                                break e;
                            case I:
                                s = 16,
                                r = null;
                                break e
                            }
                        throw Error(o(130, null == e ? e : typeof e, ""))
                    }
                return (t = Bc(s, n, t, i)).elementType = e,
                t.type = r,
                t.lanes = a,
                t
            }
            function Dc(e, t, n, r) {
                return (e = Bc(7, e, r, t)).lanes = n,
                e
            }
            function Oc(e, t, n, r) {
                return (e = Bc(22, e, r, t)).elementType = L,
                e.lanes = n,
                e.stateNode = {
                    isHidden: !1
                },
                e
            }
            function Nc(e, t, n) {
                return (e = Bc(6, e, null, t)).lanes = n,
                e
            }
            function Fc(e, t, n) {
                return (t = Bc(4, null !== e.children ? e.children : [], e.key, t)).lanes = n,
                t.stateNode = {
                    containerInfo: e.containerInfo,
                    pendingChildren: null,
                    implementation: e.implementation
                },
                t
            }
            function Uc(e, t, n, r, i) {
                this.tag = t,
                this.containerInfo = e,
                this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
                this.timeoutHandle = -1,
                this.callbackNode = this.pendingContext = this.context = null,
                this.callbackPriority = 0,
                this.eventTimes = gt(0),
                this.expirationTimes = gt(-1),
                this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
                this.entanglements = gt(0),
                this.identifierPrefix = r,
                this.onRecoverableError = i,
                this.mutableSourceEagerHydrationData = null
            }
            function zc(e, t, n, r, i, o, a, s, l) {
                return e = new Uc(e,t,n,s,l),
                1 === t ? (t = 1,
                !0 === o && (t |= 8)) : t = 0,
                o = Bc(3, null, null, t),
                e.current = o,
                o.stateNode = e,
                o.memoizedState = {
                    element: r,
                    isDehydrated: n,
                    cache: null,
                    transitions: null,
                    pendingSuspenseBoundaries: null
                },
                No(o),
                e
            }
            function Gc(e) {
                if (!e)
                    return Ci;
                e: {
                    if (He(e = e._reactInternals) !== e || 1 !== e.tag)
                        throw Error(o(170));
                    var t = e;
                    do {
                        switch (t.tag) {
                        case 3:
                            t = t.stateNode.context;
                            break e;
                        case 1:
                            if (Ii(t.type)) {
                                t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                                break e
                            }
                        }
                        t = t.return
                    } while (null !== t);
                    throw Error(o(171))
                }
                if (1 === e.tag) {
                    var n = e.type;
                    if (Ii(n))
                        return Di(e, n, t)
                }
                return t
            }
            function Hc(e, t, n, r, i, o, a, s, l) {
                return (e = zc(n, r, !0, e, 0, o, 0, s, l)).context = Gc(null),
                n = e.current,
                (o = Uo(r = ec(), i = tc(n))).callback = void 0 !== t && null !== t ? t : null,
                zo(n, o, i),
                e.current.lanes = i,
                vt(e, i, r),
                rc(e, r),
                e
            }
            function jc(e, t, n, r) {
                var i = t.current
                  , o = ec()
                  , a = tc(i);
                return n = Gc(n),
                null === t.context ? t.context = n : t.pendingContext = n,
                (t = Uo(o, a)).payload = {
                    element: e
                },
                null !== (r = void 0 === r ? null : r) && (t.callback = r),
                null !== (e = zo(i, t, a)) && (nc(e, i, a, o),
                Go(e, i, a)),
                a
            }
            function Wc(e) {
                return (e = e.current).child ? (e.child.tag,
                e.child.stateNode) : null
            }
            function Vc(e, t) {
                if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
                    var n = e.retryLane;
                    e.retryLane = 0 !== n && n < t ? n : t
                }
            }
            function Xc(e, t) {
                Vc(e, t),
                (e = e.alternate) && Vc(e, t)
            }
            Sl = function(e, t, n) {
                if (null !== e)
                    if (e.memoizedProps !== t.pendingProps || Ri.current)
                        bs = !0;
                    else {
                        if (0 === (e.lanes & n) && 0 === (128 & t.flags))
                            return bs = !1,
                            function(e, t, n) {
                                switch (t.tag) {
                                case 3:
                                    Rs(t),
                                    fo();
                                    break;
                                case 5:
                                    Zo(t);
                                    break;
                                case 1:
                                    Ii(t.type) && Oi(t);
                                    break;
                                case 4:
                                    Yo(t, t.stateNode.containerInfo);
                                    break;
                                case 10:
                                    var r = t.type._context
                                      , i = t.memoizedProps.value;
                                    Mi(So, r._currentValue),
                                    r._currentValue = i;
                                    break;
                                case 13:
                                    if (null !== (r = t.memoizedState))
                                        return null !== r.dehydrated ? (Mi(ea, 1 & ea.current),
                                        t.flags |= 128,
                                        null) : 0 !== (n & t.child.childLanes) ? Ns(e, t, n) : (Mi(ea, 1 & ea.current),
                                        null !== (e = Ws(e, t, n)) ? e.sibling : null);
                                    Mi(ea, 1 & ea.current);
                                    break;
                                case 19:
                                    if (r = 0 !== (n & t.childLanes),
                                    0 !== (128 & e.flags)) {
                                        if (r)
                                            return Hs(e, t, n);
                                        t.flags |= 128
                                    }
                                    if (null !== (i = t.memoizedState) && (i.rendering = null,
                                    i.tail = null,
                                    i.lastEffect = null),
                                    Mi(ea, ea.current),
                                    r)
                                        break;
                                    return null;
                                case 22:
                                case 23:
                                    return t.lanes = 0,
                                    ws(e, t, n)
                                }
                                return Ws(e, t, n)
                            }(e, t, n);
                        bs = 0 !== (131072 & e.flags)
                    }
                else
                    bs = !1,
                    io && 0 !== (1048576 & t.flags) && $i(t, Xi, t.index);
                switch (t.lanes = 0,
                t.tag) {
                case 2:
                    var r = t.type;
                    js(e, t),
                    e = t.pendingProps;
                    var i = Bi(t, Ti.current);
                    Po(t, n),
                    i = ga(null, t, r, e, i, n);
                    var a = va();
                    return t.flags |= 1,
                    "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof ? (t.tag = 1,
                    t.memoizedState = null,
                    t.updateQueue = null,
                    Ii(r) ? (a = !0,
                    Oi(t)) : a = !1,
                    t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null,
                    No(t),
                    i.updater = is,
                    t.stateNode = i,
                    i._reactInternals = t,
                    ls(t, r, e, n),
                    t = Ts(null, t, r, !0, a, n)) : (t.tag = 0,
                    io && a && eo(t),
                    _s(null, t, i, n),
                    t = t.child),
                    t;
                case 16:
                    r = t.elementType;
                    e: {
                        switch (js(e, t),
                        e = t.pendingProps,
                        r = (i = r._init)(r._payload),
                        t.type = r,
                        i = t.tag = function(e) {
                            if ("function" === typeof e)
                                return Ic(e) ? 1 : 0;
                            if (void 0 !== e && null !== e) {
                                if ((e = e.$$typeof) === T)
                                    return 11;
                                if (e === B)
                                    return 14
                            }
                            return 2
                        }(r),
                        e = ns(r, e),
                        i) {
                        case 0:
                            t = Ms(null, t, r, e, n);
                            break e;
                        case 1:
                            t = Cs(null, t, r, e, n);
                            break e;
                        case 11:
                            t = As(null, t, r, e, n);
                            break e;
                        case 14:
                            t = xs(null, t, r, ns(r.type, e), n);
                            break e
                        }
                        throw Error(o(306, r, ""))
                    }
                    return t;
                case 0:
                    return r = t.type,
                    i = t.pendingProps,
                    Ms(e, t, r, i = t.elementType === r ? i : ns(r, i), n);
                case 1:
                    return r = t.type,
                    i = t.pendingProps,
                    Cs(e, t, r, i = t.elementType === r ? i : ns(r, i), n);
                case 3:
                    e: {
                        if (Rs(t),
                        null === e)
                            throw Error(o(387));
                        r = t.pendingProps,
                        i = (a = t.memoizedState).element,
                        Fo(e, t),
                        jo(t, r, null, n);
                        var s = t.memoizedState;
                        if (r = s.element,
                        a.isDehydrated) {
                            if (a = {
                                element: r,
                                isDehydrated: !1,
                                cache: s.cache,
                                pendingSuspenseBoundaries: s.pendingSuspenseBoundaries,
                                transitions: s.transitions
                            },
                            t.updateQueue.baseState = a,
                            t.memoizedState = a,
                            256 & t.flags) {
                                t = Ps(e, t, r, n, i = cs(Error(o(423)), t));
                                break e
                            }
                            if (r !== i) {
                                t = Ps(e, t, r, n, i = cs(Error(o(424)), t));
                                break e
                            }
                            for (ro = ci(t.stateNode.containerInfo.firstChild),
                            no = t,
                            io = !0,
                            oo = null,
                            n = xo(t, null, r, n),
                            t.child = n; n; )
                                n.flags = -3 & n.flags | 4096,
                                n = n.sibling
                        } else {
                            if (fo(),
                            r === i) {
                                t = Ws(e, t, n);
                                break e
                            }
                            _s(e, t, r, n)
                        }
                        t = t.child
                    }
                    return t;
                case 5:
                    return Zo(t),
                    null === e && co(t),
                    r = t.type,
                    i = t.pendingProps,
                    a = null !== e ? e.memoizedProps : null,
                    s = i.children,
                    ni(r, i) ? s = null : null !== a && ni(r, a) && (t.flags |= 32),
                    Es(e, t),
                    _s(e, t, s, n),
                    t.child;
                case 6:
                    return null === e && co(t),
                    null;
                case 13:
                    return Ns(e, t, n);
                case 4:
                    return Yo(t, t.stateNode.containerInfo),
                    r = t.pendingProps,
                    null === e ? t.child = Ao(t, null, r, n) : _s(e, t, r, n),
                    t.child;
                case 11:
                    return r = t.type,
                    i = t.pendingProps,
                    As(e, t, r, i = t.elementType === r ? i : ns(r, i), n);
                case 7:
                    return _s(e, t, t.pendingProps, n),
                    t.child;
                case 8:
                case 12:
                    return _s(e, t, t.pendingProps.children, n),
                    t.child;
                case 10:
                    e: {
                        if (r = t.type._context,
                        i = t.pendingProps,
                        a = t.memoizedProps,
                        s = i.value,
                        Mi(So, r._currentValue),
                        r._currentValue = s,
                        null !== a)
                            if (sr(a.value, s)) {
                                if (a.children === i.children && !Ri.current) {
                                    t = Ws(e, t, n);
                                    break e
                                }
                            } else
                                for (null !== (a = t.child) && (a.return = t); null !== a; ) {
                                    var l = a.dependencies;
                                    if (null !== l) {
                                        s = a.child;
                                        for (var c = l.firstContext; null !== c; ) {
                                            if (c.context === r) {
                                                if (1 === a.tag) {
                                                    (c = Uo(-1, n & -n)).tag = 2;
                                                    var u = a.updateQueue;
                                                    if (null !== u) {
                                                        var d = (u = u.shared).pending;
                                                        null === d ? c.next = c : (c.next = d.next,
                                                        d.next = c),
                                                        u.pending = c
                                                    }
                                                }
                                                a.lanes |= n,
                                                null !== (c = a.alternate) && (c.lanes |= n),
                                                Ro(a.return, n, t),
                                                l.lanes |= n;
                                                break
                                            }
                                            c = c.next
                                        }
                                    } else if (10 === a.tag)
                                        s = a.type === t.type ? null : a.child;
                                    else if (18 === a.tag) {
                                        if (null === (s = a.return))
                                            throw Error(o(341));
                                        s.lanes |= n,
                                        null !== (l = s.alternate) && (l.lanes |= n),
                                        Ro(s, n, t),
                                        s = a.sibling
                                    } else
                                        s = a.child;
                                    if (null !== s)
                                        s.return = a;
                                    else
                                        for (s = a; null !== s; ) {
                                            if (s === t) {
                                                s = null;
                                                break
                                            }
                                            if (null !== (a = s.sibling)) {
                                                a.return = s.return,
                                                s = a;
                                                break
                                            }
                                            s = s.return
                                        }
                                    a = s
                                }
                        _s(e, t, i.children, n),
                        t = t.child
                    }
                    return t;
                case 9:
                    return i = t.type,
                    r = t.pendingProps.children,
                    Po(t, n),
                    r = r(i = Bo(i)),
                    t.flags |= 1,
                    _s(e, t, r, n),
                    t.child;
                case 14:
                    return i = ns(r = t.type, t.pendingProps),
                    xs(e, t, r, i = ns(r.type, i), n);
                case 15:
                    return Ss(e, t, t.type, t.pendingProps, n);
                case 17:
                    return r = t.type,
                    i = t.pendingProps,
                    i = t.elementType === r ? i : ns(r, i),
                    js(e, t),
                    t.tag = 1,
                    Ii(r) ? (e = !0,
                    Oi(t)) : e = !1,
                    Po(t, n),
                    as(t, r, i),
                    ls(t, r, i, n),
                    Ts(null, t, r, !0, e, n);
                case 19:
                    return Hs(e, t, n);
                case 22:
                    return ws(e, t, n)
                }
                throw Error(o(156, t.tag))
            }
            ;
            var Jc = "function" === typeof reportError ? reportError : function(e) {
                console.error(e)
            }
            ;
            function Kc(e) {
                this._internalRoot = e
            }
            function qc(e) {
                this._internalRoot = e
            }
            function Yc(e) {
                return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType)
            }
            function Qc(e) {
                return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue))
            }
            function Zc() {}
            function $c(e, t, n, r, i) {
                var o = n._reactRootContainer;
                if (o) {
                    var a = o;
                    if ("function" === typeof i) {
                        var s = i;
                        i = function() {
                            var e = Wc(a);
                            s.call(e)
                        }
                    }
                    jc(t, a, e, i)
                } else
                    a = function(e, t, n, r, i) {
                        if (i) {
                            if ("function" === typeof r) {
                                var o = r;
                                r = function() {
                                    var e = Wc(a);
                                    o.call(e)
                                }
                            }
                            var a = Hc(t, r, e, 0, null, !1, 0, "", Zc);
                            return e._reactRootContainer = a,
                            e[fi] = a.current,
                            Hr(8 === e.nodeType ? e.parentNode : e),
                            uc(),
                            a
                        }
                        for (; i = e.lastChild; )
                            e.removeChild(i);
                        if ("function" === typeof r) {
                            var s = r;
                            r = function() {
                                var e = Wc(l);
                                s.call(e)
                            }
                        }
                        var l = zc(e, 0, !1, null, 0, !1, 0, "", Zc);
                        return e._reactRootContainer = l,
                        e[fi] = l.current,
                        Hr(8 === e.nodeType ? e.parentNode : e),
                        uc((function() {
                            jc(t, l, n, r)
                        }
                        )),
                        l
                    }(n, t, e, i, r);
                return Wc(a)
            }
            qc.prototype.render = Kc.prototype.render = function(e) {
                var t = this._internalRoot;
                if (null === t)
                    throw Error(o(409));
                jc(e, t, null, null)
            }
            ,
            qc.prototype.unmount = Kc.prototype.unmount = function() {
                var e = this._internalRoot;
                if (null !== e) {
                    this._internalRoot = null;
                    var t = e.containerInfo;
                    uc((function() {
                        jc(null, e, null, null)
                    }
                    )),
                    t[fi] = null
                }
            }
            ,
            qc.prototype.unstable_scheduleHydration = function(e) {
                if (e) {
                    var t = wt();
                    e = {
                        blockedOn: null,
                        target: e,
                        priority: t
                    };
                    for (var n = 0; n < Lt.length && 0 !== t && t < Lt[n].priority; n++)
                        ;
                    Lt.splice(n, 0, e),
                    0 === n && Nt(e)
                }
            }
            ,
            At = function(e) {
                switch (e.tag) {
                case 3:
                    var t = e.stateNode;
                    if (t.current.memoizedState.isDehydrated) {
                        var n = dt(t.pendingLanes);
                        0 !== n && (yt(t, 1 | n),
                        rc(t, Qe()),
                        0 === (6 & Tl) && (Hl = Qe() + 500,
                        Hi()))
                    }
                    break;
                case 13:
                    uc((function() {
                        var t = Do(e, 1);
                        if (null !== t) {
                            var n = ec();
                            nc(t, e, 1, n)
                        }
                    }
                    )),
                    Xc(e, 1)
                }
            }
            ,
            xt = function(e) {
                if (13 === e.tag) {
                    var t = Do(e, 134217728);
                    if (null !== t)
                        nc(t, e, 134217728, ec());
                    Xc(e, 134217728)
                }
            }
            ,
            St = function(e) {
                if (13 === e.tag) {
                    var t = tc(e)
                      , n = Do(e, t);
                    if (null !== n)
                        nc(n, e, t, ec());
                    Xc(e, t)
                }
            }
            ,
            wt = function() {
                return bt
            }
            ,
            Et = function(e, t) {
                var n = bt;
                try {
                    return bt = e,
                    t()
                } finally {
                    bt = n
                }
            }
            ,
            xe = function(e, t, n) {
                switch (t) {
                case "input":
                    if (Z(e, n),
                    t = n.name,
                    "radio" === n.type && null != t) {
                        for (n = e; n.parentNode; )
                            n = n.parentNode;
                        for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'),
                        t = 0; t < n.length; t++) {
                            var r = n[t];
                            if (r !== e && r.form === e.form) {
                                var i = Ai(r);
                                if (!i)
                                    throw Error(o(90));
                                J(r),
                                Z(r, i)
                            }
                        }
                    }
                    break;
                case "textarea":
                    oe(e, n);
                    break;
                case "select":
                    null != (t = n.value) && ne(e, !!n.multiple, t, !1)
                }
            }
            ,
            Te = cc,
            Re = uc;
            var eu = {
                usingClientEntryPoint: !1,
                Events: [bi, _i, Ai, Me, Ce, cc]
            }
              , tu = {
                findFiberByHostInstance: yi,
                bundleType: 0,
                version: "18.3.1",
                rendererPackageName: "react-dom"
            }
              , nu = {
                bundleType: tu.bundleType,
                version: tu.version,
                rendererPackageName: tu.rendererPackageName,
                rendererConfig: tu.rendererConfig,
                overrideHookState: null,
                overrideHookStateDeletePath: null,
                overrideHookStateRenamePath: null,
                overrideProps: null,
                overridePropsDeletePath: null,
                overridePropsRenamePath: null,
                setErrorHandler: null,
                setSuspenseHandler: null,
                scheduleUpdate: null,
                currentDispatcherRef: _.ReactCurrentDispatcher,
                findHostInstanceByFiber: function(e) {
                    return null === (e = Ve(e)) ? null : e.stateNode
                },
                findFiberByHostInstance: tu.findFiberByHostInstance || function() {
                    return null
                }
                ,
                findHostInstancesForRefresh: null,
                scheduleRefresh: null,
                scheduleRoot: null,
                setRefreshHandler: null,
                getCurrentFiber: null,
                reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
            };
            if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
                var ru = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (!ru.isDisabled && ru.supportsFiber)
                    try {
                        it = ru.inject(nu),
                        ot = ru
                    } catch (ue) {}
            }
            t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = eu,
            t.createPortal = function(e, t) {
                var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                if (!Yc(t))
                    throw Error(o(200));
                return function(e, t, n) {
                    var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
                    return {
                        $$typeof: x,
                        key: null == r ? null : "" + r,
                        children: e,
                        containerInfo: t,
                        implementation: n
                    }
                }(e, t, null, n)
            }
            ,
            t.createRoot = function(e, t) {
                if (!Yc(e))
                    throw Error(o(299));
                var n = !1
                  , r = ""
                  , i = Jc;
                return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (n = !0),
                void 0 !== t.identifierPrefix && (r = t.identifierPrefix),
                void 0 !== t.onRecoverableError && (i = t.onRecoverableError)),
                t = zc(e, 1, !1, null, 0, n, 0, r, i),
                e[fi] = t.current,
                Hr(8 === e.nodeType ? e.parentNode : e),
                new Kc(t)
            }
            ,
            t.findDOMNode = function(e) {
                if (null == e)
                    return null;
                if (1 === e.nodeType)
                    return e;
                var t = e._reactInternals;
                if (void 0 === t) {
                    if ("function" === typeof e.render)
                        throw Error(o(188));
                    throw e = Object.keys(e).join(","),
                    Error(o(268, e))
                }
                return e = null === (e = Ve(t)) ? null : e.stateNode
            }
            ,
            t.flushSync = function(e) {
                return uc(e)
            }
            ,
            t.hydrate = function(e, t, n) {
                if (!Qc(t))
                    throw Error(o(200));
                return $c(null, e, t, !0, n)
            }
            ,
            t.hydrateRoot = function(e, t, n) {
                if (!Yc(e))
                    throw Error(o(405));
                var r = null != n && n.hydratedSources || null
                  , i = !1
                  , a = ""
                  , s = Jc;
                if (null !== n && void 0 !== n && (!0 === n.unstable_strictMode && (i = !0),
                void 0 !== n.identifierPrefix && (a = n.identifierPrefix),
                void 0 !== n.onRecoverableError && (s = n.onRecoverableError)),
                t = Hc(t, null, e, 1, null != n ? n : null, i, 0, a, s),
                e[fi] = t.current,
                Hr(e),
                r)
                    for (e = 0; e < r.length; e++)
                        i = (i = (n = r[e])._getVersion)(n._source),
                        null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i);
                return new qc(t)
            }
            ,
            t.render = function(e, t, n) {
                if (!Qc(t))
                    throw Error(o(200));
                return $c(null, e, t, !1, n)
            }
            ,
            t.unmountComponentAtNode = function(e) {
                if (!Qc(e))
                    throw Error(o(40));
                return !!e._reactRootContainer && (uc((function() {
                    $c(null, null, e, !1, (function() {
                        e._reactRootContainer = null,
                        e[fi] = null
                    }
                    ))
                }
                )),
                !0)
            }
            ,
            t.unstable_batchedUpdates = cc,
            t.unstable_renderSubtreeIntoContainer = function(e, t, n, r) {
                if (!Qc(n))
                    throw Error(o(200));
                if (null == e || void 0 === e._reactInternals)
                    throw Error(o(38));
                return $c(e, t, n, !1, r)
            }
            ,
            t.version = "18.3.1-next-f1338f8080-20240426"
        }
        ,
        1352: (e, t, n) => {
            "use strict";
            var r = n(7119);
            t.createRoot = r.createRoot,
            t.hydrateRoot = r.hydrateRoot
        }
        ,
        7119: (e, t, n) => {
            "use strict";
            !function e() {
                if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)
                    try {
                        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
                    } catch (t) {
                        console.error(t)
                    }
            }(),
            e.exports = n(8345)
        }
        ,
        2969: (e, t) => {
            "use strict";
            function n(e, t) {
                var n = e.length;
                e.push(t);
                e: for (; 0 < n; ) {
                    var r = n - 1 >>> 1
                      , i = e[r];
                    if (!(0 < o(i, t)))
                        break e;
                    e[r] = t,
                    e[n] = i,
                    n = r
                }
            }
            function r(e) {
                return 0 === e.length ? null : e[0]
            }
            function i(e) {
                if (0 === e.length)
                    return null;
                var t = e[0]
                  , n = e.pop();
                if (n !== t) {
                    e[0] = n;
                    e: for (var r = 0, i = e.length, a = i >>> 1; r < a; ) {
                        var s = 2 * (r + 1) - 1
                          , l = e[s]
                          , c = s + 1
                          , u = e[c];
                        if (0 > o(l, n))
                            c < i && 0 > o(u, l) ? (e[r] = u,
                            e[c] = n,
                            r = c) : (e[r] = l,
                            e[s] = n,
                            r = s);
                        else {
                            if (!(c < i && 0 > o(u, n)))
                                break e;
                            e[r] = u,
                            e[c] = n,
                            r = c
                        }
                    }
                }
                return t
            }
            function o(e, t) {
                var n = e.sortIndex - t.sortIndex;
                return 0 !== n ? n : e.id - t.id
            }
            if ("object" === typeof performance && "function" === typeof performance.now) {
                var a = performance;
                t.unstable_now = function() {
                    return a.now()
                }
            } else {
                var s = Date
                  , l = s.now();
                t.unstable_now = function() {
                    return s.now() - l
                }
            }
            var c = []
              , u = []
              , d = 1
              , h = null
              , p = 3
              , f = !1
              , m = !1
              , g = !1
              , v = "function" === typeof setTimeout ? setTimeout : null
              , y = "function" === typeof clearTimeout ? clearTimeout : null
              , b = "undefined" !== typeof setImmediate ? setImmediate : null;
            function _(e) {
                for (var t = r(u); null !== t; ) {
                    if (null === t.callback)
                        i(u);
                    else {
                        if (!(t.startTime <= e))
                            break;
                        i(u),
                        t.sortIndex = t.expirationTime,
                        n(c, t)
                    }
                    t = r(u)
                }
            }
            function A(e) {
                if (g = !1,
                _(e),
                !m)
                    if (null !== r(c))
                        m = !0,
                        L(x);
                    else {
                        var t = r(u);
                        null !== t && k(A, t.startTime - e)
                    }
            }
            function x(e, n) {
                m = !1,
                g && (g = !1,
                y(M),
                M = -1),
                f = !0;
                var o = p;
                try {
                    for (_(n),
                    h = r(c); null !== h && (!(h.expirationTime > n) || e && !R()); ) {
                        var a = h.callback;
                        if ("function" === typeof a) {
                            h.callback = null,
                            p = h.priorityLevel;
                            var s = a(h.expirationTime <= n);
                            n = t.unstable_now(),
                            "function" === typeof s ? h.callback = s : h === r(c) && i(c),
                            _(n)
                        } else
                            i(c);
                        h = r(c)
                    }
                    if (null !== h)
                        var l = !0;
                    else {
                        var d = r(u);
                        null !== d && k(A, d.startTime - n),
                        l = !1
                    }
                    return l
                } finally {
                    h = null,
                    p = o,
                    f = !1
                }
            }
            "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
            var S, w = !1, E = null, M = -1, C = 5, T = -1;
            function R() {
                return !(t.unstable_now() - T < C)
            }
            function P() {
                if (null !== E) {
                    var e = t.unstable_now();
                    T = e;
                    var n = !0;
                    try {
                        n = E(!0, e)
                    } finally {
                        n ? S() : (w = !1,
                        E = null)
                    }
                } else
                    w = !1
            }
            if ("function" === typeof b)
                S = function() {
                    b(P)
                }
                ;
            else if ("undefined" !== typeof MessageChannel) {
                var B = new MessageChannel
                  , I = B.port2;
                B.port1.onmessage = P,
                S = function() {
                    I.postMessage(null)
                }
            } else
                S = function() {
                    v(P, 0)
                }
                ;
            function L(e) {
                E = e,
                w || (w = !0,
                S())
            }
            function k(e, n) {
                M = v((function() {
                    e(t.unstable_now())
                }
                ), n)
            }
            t.unstable_IdlePriority = 5,
            t.unstable_ImmediatePriority = 1,
            t.unstable_LowPriority = 4,
            t.unstable_NormalPriority = 3,
            t.unstable_Profiling = null,
            t.unstable_UserBlockingPriority = 2,
            t.unstable_cancelCallback = function(e) {
                e.callback = null
            }
            ,
            t.unstable_continueExecution = function() {
                m || f || (m = !0,
                L(x))
            }
            ,
            t.unstable_forceFrameRate = function(e) {
                0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < e ? Math.floor(1e3 / e) : 5
            }
            ,
            t.unstable_getCurrentPriorityLevel = function() {
                return p
            }
            ,
            t.unstable_getFirstCallbackNode = function() {
                return r(c)
            }
            ,
            t.unstable_next = function(e) {
                switch (p) {
                case 1:
                case 2:
                case 3:
                    var t = 3;
                    break;
                default:
                    t = p
                }
                var n = p;
                p = t;
                try {
                    return e()
                } finally {
                    p = n
                }
            }
            ,
            t.unstable_pauseExecution = function() {}
            ,
            t.unstable_requestPaint = function() {}
            ,
            t.unstable_runWithPriority = function(e, t) {
                switch (e) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                default:
                    e = 3
                }
                var n = p;
                p = e;
                try {
                    return t()
                } finally {
                    p = n
                }
            }
            ,
            t.unstable_scheduleCallback = function(e, i, o) {
                var a = t.unstable_now();
                switch ("object" === typeof o && null !== o ? o = "number" === typeof (o = o.delay) && 0 < o ? a + o : a : o = a,
                e) {
                case 1:
                    var s = -1;
                    break;
                case 2:
                    s = 250;
                    break;
                case 5:
                    s = 1073741823;
                    break;
                case 4:
                    s = 1e4;
                    break;
                default:
                    s = 5e3
                }
                return e = {
                    id: d++,
                    callback: i,
                    priorityLevel: e,
                    startTime: o,
                    expirationTime: s = o + s,
                    sortIndex: -1
                },
                o > a ? (e.sortIndex = o,
                n(u, e),
                null === r(c) && e === r(u) && (g ? (y(M),
                M = -1) : g = !0,
                k(A, o - a))) : (e.sortIndex = s,
                n(c, e),
                m || f || (m = !0,
                L(x))),
                e
            }
            ,
            t.unstable_shouldYield = R,
            t.unstable_wrapCallback = function(e) {
                var t = p;
                return function() {
                    var n = p;
                    p = t;
                    try {
                        return e.apply(this, arguments)
                    } finally {
                        p = n
                    }
                }
            }
        }
        ,
        3204: (e, t, n) => {
            "use strict";
            e.exports = n(2969)
        }
        ,
        5217: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            Object.defineProperty(t, "DraggableCore", {
                enumerable: !0,
                get: function() {
                    return u.default
                }
            }),
            t.default = void 0;
            var r = function(e, t) {
                if (!t && e && e.__esModule)
                    return e;
                if (null === e || "object" !== typeof e && "function" !== typeof e)
                    return {
                        default: e
                    };
                var n = p(t);
                if (n && n.has(e))
                    return n.get(e);
                var r = {}
                  , i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var o in e)
                    if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                        var a = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                        a && (a.get || a.set) ? Object.defineProperty(r, o, a) : r[o] = e[o]
                    }
                r.default = e,
                n && n.set(e, r);
                return r
            }(n(9950))
              , i = h(n(1942))
              , o = h(n(7119))
              , a = h(n(2803))
              , s = n(9219)
              , l = n(7616)
              , c = n(5190)
              , u = h(n(6450))
              , d = h(n(3782));
            function h(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            function p(e) {
                if ("function" !== typeof WeakMap)
                    return null;
                var t = new WeakMap
                  , n = new WeakMap;
                return (p = function(e) {
                    return e ? n : t
                }
                )(e)
            }
            function f() {
                return f = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var r in n)
                            Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                    }
                    return e
                }
                ,
                f.apply(this, arguments)
            }
            function m(e, t, n) {
                return (t = function(e) {
                    var t = function(e, t) {
                        if ("object" !== typeof e || null === e)
                            return e;
                        var n = e[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var r = n.call(e, t || "default");
                            if ("object" !== typeof r)
                                return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === t ? String : Number)(e)
                    }(e, "string");
                    return "symbol" === typeof t ? t : String(t)
                }(t))in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n,
                e
            }
            class g extends r.Component {
                static getDerivedStateFromProps(e, t) {
                    let {position: n} = e
                      , {prevPropsPosition: r} = t;
                    return !n || r && n.x === r.x && n.y === r.y ? null : ((0,
                    d.default)("Draggable: getDerivedStateFromProps %j", {
                        position: n,
                        prevPropsPosition: r
                    }),
                    {
                        x: n.x,
                        y: n.y,
                        prevPropsPosition: {
                            ...n
                        }
                    })
                }
                constructor(e) {
                    super(e),
                    m(this, "onDragStart", ( (e, t) => {
                        (0,
                        d.default)("Draggable: onDragStart: %j", t);
                        if (!1 === this.props.onStart(e, (0,
                        l.createDraggableData)(this, t)))
                            return !1;
                        this.setState({
                            dragging: !0,
                            dragged: !0
                        })
                    }
                    )),
                    m(this, "onDrag", ( (e, t) => {
                        if (!this.state.dragging)
                            return !1;
                        (0,
                        d.default)("Draggable: onDrag: %j", t);
                        const n = (0,
                        l.createDraggableData)(this, t)
                          , r = {
                            x: n.x,
                            y: n.y,
                            slackX: 0,
                            slackY: 0
                        };
                        if (this.props.bounds) {
                            const {x: e, y: t} = r;
                            r.x += this.state.slackX,
                            r.y += this.state.slackY;
                            const [i,o] = (0,
                            l.getBoundPosition)(this, r.x, r.y);
                            r.x = i,
                            r.y = o,
                            r.slackX = this.state.slackX + (e - r.x),
                            r.slackY = this.state.slackY + (t - r.y),
                            n.x = r.x,
                            n.y = r.y,
                            n.deltaX = r.x - this.state.x,
                            n.deltaY = r.y - this.state.y
                        }
                        if (!1 === this.props.onDrag(e, n))
                            return !1;
                        this.setState(r)
                    }
                    )),
                    m(this, "onDragStop", ( (e, t) => {
                        if (!this.state.dragging)
                            return !1;
                        if (!1 === this.props.onStop(e, (0,
                        l.createDraggableData)(this, t)))
                            return !1;
                        (0,
                        d.default)("Draggable: onDragStop: %j", t);
                        const n = {
                            dragging: !1,
                            slackX: 0,
                            slackY: 0
                        };
                        if (Boolean(this.props.position)) {
                            const {x: e, y: t} = this.props.position;
                            n.x = e,
                            n.y = t
                        }
                        this.setState(n)
                    }
                    )),
                    this.state = {
                        dragging: !1,
                        dragged: !1,
                        x: e.position ? e.position.x : e.defaultPosition.x,
                        y: e.position ? e.position.y : e.defaultPosition.y,
                        prevPropsPosition: {
                            ...e.position
                        },
                        slackX: 0,
                        slackY: 0,
                        isElementSVG: !1
                    },
                    !e.position || e.onDrag || e.onStop || console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.")
                }
                componentDidMount() {
                    "undefined" !== typeof window.SVGElement && this.findDOMNode()instanceof window.SVGElement && this.setState({
                        isElementSVG: !0
                    })
                }
                componentWillUnmount() {
                    this.setState({
                        dragging: !1
                    })
                }
                findDOMNode() {
                    var e, t;
                    return null !== (e = null === (t = this.props) || void 0 === t || null === (t = t.nodeRef) || void 0 === t ? void 0 : t.current) && void 0 !== e ? e : o.default.findDOMNode(this)
                }
                render() {
                    const {axis: e, bounds: t, children: n, defaultPosition: i, defaultClassName: o, defaultClassNameDragging: c, defaultClassNameDragged: d, position: h, positionOffset: p, scale: m, ...g} = this.props;
                    let v = {}
                      , y = null;
                    const b = !Boolean(h) || this.state.dragging
                      , _ = h || i
                      , A = {
                        x: (0,
                        l.canDragX)(this) && b ? this.state.x : _.x,
                        y: (0,
                        l.canDragY)(this) && b ? this.state.y : _.y
                    };
                    this.state.isElementSVG ? y = (0,
                    s.createSVGTransform)(A, p) : v = (0,
                    s.createCSSTransform)(A, p);
                    const x = (0,
                    a.default)(n.props.className || "", o, {
                        [c]: this.state.dragging,
                        [d]: this.state.dragged
                    });
                    return r.createElement(u.default, f({}, g, {
                        onStart: this.onDragStart,
                        onDrag: this.onDrag,
                        onStop: this.onDragStop
                    }), r.cloneElement(r.Children.only(n), {
                        className: x,
                        style: {
                            ...n.props.style,
                            ...v
                        },
                        transform: y
                    }))
                }
            }
            t.default = g,
            m(g, "displayName", "Draggable"),
            m(g, "propTypes", {
                ...u.default.propTypes,
                axis: i.default.oneOf(["both", "x", "y", "none"]),
                bounds: i.default.oneOfType([i.default.shape({
                    left: i.default.number,
                    right: i.default.number,
                    top: i.default.number,
                    bottom: i.default.number
                }), i.default.string, i.default.oneOf([!1])]),
                defaultClassName: i.default.string,
                defaultClassNameDragging: i.default.string,
                defaultClassNameDragged: i.default.string,
                defaultPosition: i.default.shape({
                    x: i.default.number,
                    y: i.default.number
                }),
                positionOffset: i.default.shape({
                    x: i.default.oneOfType([i.default.number, i.default.string]),
                    y: i.default.oneOfType([i.default.number, i.default.string])
                }),
                position: i.default.shape({
                    x: i.default.number,
                    y: i.default.number
                }),
                className: c.dontSetMe,
                style: c.dontSetMe,
                transform: c.dontSetMe
            }),
            m(g, "defaultProps", {
                ...u.default.defaultProps,
                axis: "both",
                bounds: !1,
                defaultClassName: "react-draggable",
                defaultClassNameDragging: "react-draggable-dragging",
                defaultClassNameDragged: "react-draggable-dragged",
                defaultPosition: {
                    x: 0,
                    y: 0
                },
                scale: 1
            })
        }
        ,
        6450: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = void 0;
            var r = function(e, t) {
                if (!t && e && e.__esModule)
                    return e;
                if (null === e || "object" !== typeof e && "function" !== typeof e)
                    return {
                        default: e
                    };
                var n = d(t);
                if (n && n.has(e))
                    return n.get(e);
                var r = {}
                  , i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var o in e)
                    if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                        var a = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                        a && (a.get || a.set) ? Object.defineProperty(r, o, a) : r[o] = e[o]
                    }
                r.default = e,
                n && n.set(e, r);
                return r
            }(n(9950))
              , i = u(n(1942))
              , o = u(n(7119))
              , a = n(9219)
              , s = n(7616)
              , l = n(5190)
              , c = u(n(3782));
            function u(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            function d(e) {
                if ("function" !== typeof WeakMap)
                    return null;
                var t = new WeakMap
                  , n = new WeakMap;
                return (d = function(e) {
                    return e ? n : t
                }
                )(e)
            }
            function h(e, t, n) {
                return (t = function(e) {
                    var t = function(e, t) {
                        if ("object" !== typeof e || null === e)
                            return e;
                        var n = e[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var r = n.call(e, t || "default");
                            if ("object" !== typeof r)
                                return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === t ? String : Number)(e)
                    }(e, "string");
                    return "symbol" === typeof t ? t : String(t)
                }(t))in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n,
                e
            }
            const p = {
                start: "touchstart",
                move: "touchmove",
                stop: "touchend"
            }
              , f = {
                start: "mousedown",
                move: "mousemove",
                stop: "mouseup"
            };
            let m = f;
            class g extends r.Component {
                constructor() {
                    super(...arguments),
                    h(this, "dragging", !1),
                    h(this, "lastX", NaN),
                    h(this, "lastY", NaN),
                    h(this, "touchIdentifier", null),
                    h(this, "mounted", !1),
                    h(this, "handleDragStart", (e => {
                        if (this.props.onMouseDown(e),
                        !this.props.allowAnyClick && "number" === typeof e.button && 0 !== e.button)
                            return !1;
                        const t = this.findDOMNode();
                        if (!t || !t.ownerDocument || !t.ownerDocument.body)
                            throw new Error("<DraggableCore> not mounted on DragStart!");
                        const {ownerDocument: n} = t;
                        if (this.props.disabled || !(e.target instanceof n.defaultView.Node) || this.props.handle && !(0,
                        a.matchesSelectorAndParentsTo)(e.target, this.props.handle, t) || this.props.cancel && (0,
                        a.matchesSelectorAndParentsTo)(e.target, this.props.cancel, t))
                            return;
                        "touchstart" === e.type && e.preventDefault();
                        const r = (0,
                        a.getTouchIdentifier)(e);
                        this.touchIdentifier = r;
                        const i = (0,
                        s.getControlPosition)(e, r, this);
                        if (null == i)
                            return;
                        const {x: o, y: l} = i
                          , u = (0,
                        s.createCoreData)(this, o, l);
                        (0,
                        c.default)("DraggableCore: handleDragStart: %j", u),
                        (0,
                        c.default)("calling", this.props.onStart);
                        !1 !== this.props.onStart(e, u) && !1 !== this.mounted && (this.props.enableUserSelectHack && (0,
                        a.addUserSelectStyles)(n),
                        this.dragging = !0,
                        this.lastX = o,
                        this.lastY = l,
                        (0,
                        a.addEvent)(n, m.move, this.handleDrag),
                        (0,
                        a.addEvent)(n, m.stop, this.handleDragStop))
                    }
                    )),
                    h(this, "handleDrag", (e => {
                        const t = (0,
                        s.getControlPosition)(e, this.touchIdentifier, this);
                        if (null == t)
                            return;
                        let {x: n, y: r} = t;
                        if (Array.isArray(this.props.grid)) {
                            let e = n - this.lastX
                              , t = r - this.lastY;
                            if ([e,t] = (0,
                            s.snapToGrid)(this.props.grid, e, t),
                            !e && !t)
                                return;
                            n = this.lastX + e,
                            r = this.lastY + t
                        }
                        const i = (0,
                        s.createCoreData)(this, n, r);
                        (0,
                        c.default)("DraggableCore: handleDrag: %j", i);
                        if (!1 !== this.props.onDrag(e, i) && !1 !== this.mounted)
                            this.lastX = n,
                            this.lastY = r;
                        else
                            try {
                                this.handleDragStop(new MouseEvent("mouseup"))
                            } catch (o) {
                                const e = document.createEvent("MouseEvents");
                                e.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null),
                                this.handleDragStop(e)
                            }
                    }
                    )),
                    h(this, "handleDragStop", (e => {
                        if (!this.dragging)
                            return;
                        const t = (0,
                        s.getControlPosition)(e, this.touchIdentifier, this);
                        if (null == t)
                            return;
                        let {x: n, y: r} = t;
                        if (Array.isArray(this.props.grid)) {
                            let e = n - this.lastX || 0
                              , t = r - this.lastY || 0;
                            [e,t] = (0,
                            s.snapToGrid)(this.props.grid, e, t),
                            n = this.lastX + e,
                            r = this.lastY + t
                        }
                        const i = (0,
                        s.createCoreData)(this, n, r);
                        if (!1 === this.props.onStop(e, i) || !1 === this.mounted)
                            return !1;
                        const o = this.findDOMNode();
                        o && this.props.enableUserSelectHack && (0,
                        a.removeUserSelectStyles)(o.ownerDocument),
                        (0,
                        c.default)("DraggableCore: handleDragStop: %j", i),
                        this.dragging = !1,
                        this.lastX = NaN,
                        this.lastY = NaN,
                        o && ((0,
                        c.default)("DraggableCore: Removing handlers"),
                        (0,
                        a.removeEvent)(o.ownerDocument, m.move, this.handleDrag),
                        (0,
                        a.removeEvent)(o.ownerDocument, m.stop, this.handleDragStop))
                    }
                    )),
                    h(this, "onMouseDown", (e => (m = f,
                    this.handleDragStart(e)))),
                    h(this, "onMouseUp", (e => (m = f,
                    this.handleDragStop(e)))),
                    h(this, "onTouchStart", (e => (m = p,
                    this.handleDragStart(e)))),
                    h(this, "onTouchEnd", (e => (m = p,
                    this.handleDragStop(e))))
                }
                componentDidMount() {
                    this.mounted = !0;
                    const e = this.findDOMNode();
                    e && (0,
                    a.addEvent)(e, p.start, this.onTouchStart, {
                        passive: !1
                    })
                }
                componentWillUnmount() {
                    this.mounted = !1;
                    const e = this.findDOMNode();
                    if (e) {
                        const {ownerDocument: t} = e;
                        (0,
                        a.removeEvent)(t, f.move, this.handleDrag),
                        (0,
                        a.removeEvent)(t, p.move, this.handleDrag),
                        (0,
                        a.removeEvent)(t, f.stop, this.handleDragStop),
                        (0,
                        a.removeEvent)(t, p.stop, this.handleDragStop),
                        (0,
                        a.removeEvent)(e, p.start, this.onTouchStart, {
                            passive: !1
                        }),
                        this.props.enableUserSelectHack && (0,
                        a.removeUserSelectStyles)(t)
                    }
                }
                findDOMNode() {
                    var e, t;
                    return null !== (e = this.props) && void 0 !== e && e.nodeRef ? null === (t = this.props) || void 0 === t || null === (t = t.nodeRef) || void 0 === t ? void 0 : t.current : o.default.findDOMNode(this)
                }
                render() {
                    return r.cloneElement(r.Children.only(this.props.children), {
                        onMouseDown: this.onMouseDown,
                        onMouseUp: this.onMouseUp,
                        onTouchEnd: this.onTouchEnd
                    })
                }
            }
            t.default = g,
            h(g, "displayName", "DraggableCore"),
            h(g, "propTypes", {
                allowAnyClick: i.default.bool,
                children: i.default.node.isRequired,
                disabled: i.default.bool,
                enableUserSelectHack: i.default.bool,
                offsetParent: function(e, t) {
                    if (e[t] && 1 !== e[t].nodeType)
                        throw new Error("Draggable's offsetParent must be a DOM Node.")
                },
                grid: i.default.arrayOf(i.default.number),
                handle: i.default.string,
                cancel: i.default.string,
                nodeRef: i.default.object,
                onStart: i.default.func,
                onDrag: i.default.func,
                onStop: i.default.func,
                onMouseDown: i.default.func,
                scale: i.default.number,
                className: l.dontSetMe,
                style: l.dontSetMe,
                transform: l.dontSetMe
            }),
            h(g, "defaultProps", {
                allowAnyClick: !1,
                disabled: !1,
                enableUserSelectHack: !0,
                onStart: function() {},
                onDrag: function() {},
                onStop: function() {},
                onMouseDown: function() {},
                scale: 1
            })
        }
        ,
        1628: (e, t, n) => {
            "use strict";
            const {default: r, DraggableCore: i} = n(5217);
            e.exports = r,
            e.exports.default = r,
            e.exports.DraggableCore = i
        }
        ,
        9219: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.addClassName = c,
            t.addEvent = function(e, t, n, r) {
                if (!e)
                    return;
                const i = {
                    capture: !0,
                    ...r
                };
                e.addEventListener ? e.addEventListener(t, n, i) : e.attachEvent ? e.attachEvent("on" + t, n) : e["on" + t] = n
            }
            ,
            t.addUserSelectStyles = function(e) {
                if (!e)
                    return;
                let t = e.getElementById("react-draggable-style-el");
                t || (t = e.createElement("style"),
                t.type = "text/css",
                t.id = "react-draggable-style-el",
                t.innerHTML = ".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n",
                t.innerHTML += ".react-draggable-transparent-selection *::selection {all: inherit;}\n",
                e.getElementsByTagName("head")[0].appendChild(t));
                e.body && c(e.body, "react-draggable-transparent-selection")
            }
            ,
            t.createCSSTransform = function(e, t) {
                const n = l(e, t, "px");
                return {
                    [(0,
                    i.browserPrefixToKey)("transform", i.default)]: n
                }
            }
            ,
            t.createSVGTransform = function(e, t) {
                return l(e, t, "")
            }
            ,
            t.getTouch = function(e, t) {
                return e.targetTouches && (0,
                r.findInArray)(e.targetTouches, (e => t === e.identifier)) || e.changedTouches && (0,
                r.findInArray)(e.changedTouches, (e => t === e.identifier))
            }
            ,
            t.getTouchIdentifier = function(e) {
                if (e.targetTouches && e.targetTouches[0])
                    return e.targetTouches[0].identifier;
                if (e.changedTouches && e.changedTouches[0])
                    return e.changedTouches[0].identifier
            }
            ,
            t.getTranslation = l,
            t.innerHeight = function(e) {
                let t = e.clientHeight;
                const n = e.ownerDocument.defaultView.getComputedStyle(e);
                return t -= (0,
                r.int)(n.paddingTop),
                t -= (0,
                r.int)(n.paddingBottom),
                t
            }
            ,
            t.innerWidth = function(e) {
                let t = e.clientWidth;
                const n = e.ownerDocument.defaultView.getComputedStyle(e);
                return t -= (0,
                r.int)(n.paddingLeft),
                t -= (0,
                r.int)(n.paddingRight),
                t
            }
            ,
            t.matchesSelector = s,
            t.matchesSelectorAndParentsTo = function(e, t, n) {
                let r = e;
                do {
                    if (s(r, t))
                        return !0;
                    if (r === n)
                        return !1;
                    r = r.parentNode
                } while (r);
                return !1
            }
            ,
            t.offsetXYFromParent = function(e, t, n) {
                const r = t === t.ownerDocument.body ? {
                    left: 0,
                    top: 0
                } : t.getBoundingClientRect()
                  , i = (e.clientX + t.scrollLeft - r.left) / n
                  , o = (e.clientY + t.scrollTop - r.top) / n;
                return {
                    x: i,
                    y: o
                }
            }
            ,
            t.outerHeight = function(e) {
                let t = e.clientHeight;
                const n = e.ownerDocument.defaultView.getComputedStyle(e);
                return t += (0,
                r.int)(n.borderTopWidth),
                t += (0,
                r.int)(n.borderBottomWidth),
                t
            }
            ,
            t.outerWidth = function(e) {
                let t = e.clientWidth;
                const n = e.ownerDocument.defaultView.getComputedStyle(e);
                return t += (0,
                r.int)(n.borderLeftWidth),
                t += (0,
                r.int)(n.borderRightWidth),
                t
            }
            ,
            t.removeClassName = u,
            t.removeEvent = function(e, t, n, r) {
                if (!e)
                    return;
                const i = {
                    capture: !0,
                    ...r
                };
                e.removeEventListener ? e.removeEventListener(t, n, i) : e.detachEvent ? e.detachEvent("on" + t, n) : e["on" + t] = null
            }
            ,
            t.removeUserSelectStyles = function(e) {
                if (!e)
                    return;
                try {
                    if (e.body && u(e.body, "react-draggable-transparent-selection"),
                    e.selection)
                        e.selection.empty();
                    else {
                        const t = (e.defaultView || window).getSelection();
                        t && "Caret" !== t.type && t.removeAllRanges()
                    }
                } catch (t) {}
            }
            ;
            var r = n(5190)
              , i = function(e, t) {
                if (!t && e && e.__esModule)
                    return e;
                if (null === e || "object" !== typeof e && "function" !== typeof e)
                    return {
                        default: e
                    };
                var n = o(t);
                if (n && n.has(e))
                    return n.get(e);
                var r = {}
                  , i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var a in e)
                    if ("default" !== a && Object.prototype.hasOwnProperty.call(e, a)) {
                        var s = i ? Object.getOwnPropertyDescriptor(e, a) : null;
                        s && (s.get || s.set) ? Object.defineProperty(r, a, s) : r[a] = e[a]
                    }
                r.default = e,
                n && n.set(e, r);
                return r
            }(n(1228));
            function o(e) {
                if ("function" !== typeof WeakMap)
                    return null;
                var t = new WeakMap
                  , n = new WeakMap;
                return (o = function(e) {
                    return e ? n : t
                }
                )(e)
            }
            let a = "";
            function s(e, t) {
                return a || (a = (0,
                r.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], (function(t) {
                    return (0,
                    r.isFunction)(e[t])
                }
                ))),
                !!(0,
                r.isFunction)(e[a]) && e[a](t)
            }
            function l(e, t, n) {
                let {x: r, y: i} = e
                  , o = "translate(".concat(r).concat(n, ",").concat(i).concat(n, ")");
                if (t) {
                    const e = "".concat("string" === typeof t.x ? t.x : t.x + n)
                      , r = "".concat("string" === typeof t.y ? t.y : t.y + n);
                    o = "translate(".concat(e, ", ").concat(r, ")") + o
                }
                return o
            }
            function c(e, t) {
                e.classList ? e.classList.add(t) : e.className.match(new RegExp("(?:^|\\s)".concat(t, "(?!\\S)"))) || (e.className += " ".concat(t))
            }
            function u(e, t) {
                e.classList ? e.classList.remove(t) : e.className = e.className.replace(new RegExp("(?:^|\\s)".concat(t, "(?!\\S)"),"g"), "")
            }
        }
        ,
        1228: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.browserPrefixToKey = i,
            t.browserPrefixToStyle = function(e, t) {
                return t ? "-".concat(t.toLowerCase(), "-").concat(e) : e
            }
            ,
            t.default = void 0,
            t.getPrefix = r;
            const n = ["Moz", "Webkit", "O", "ms"];
            function r() {
                var e;
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "transform";
                if ("undefined" === typeof window)
                    return "";
                const r = null === (e = window.document) || void 0 === e || null === (e = e.documentElement) || void 0 === e ? void 0 : e.style;
                if (!r)
                    return "";
                if (t in r)
                    return "";
                for (let o = 0; o < n.length; o++)
                    if (i(t, n[o])in r)
                        return n[o];
                return ""
            }
            function i(e, t) {
                return t ? "".concat(t).concat(function(e) {
                    let t = ""
                      , n = !0;
                    for (let r = 0; r < e.length; r++)
                        n ? (t += e[r].toUpperCase(),
                        n = !1) : "-" === e[r] ? n = !0 : t += e[r];
                    return t
                }(e)) : e
            }
            t.default = r()
        }
        ,
        3782: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function() {
                0
            }
        }
        ,
        7616: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.canDragX = function(e) {
                return "both" === e.props.axis || "x" === e.props.axis
            }
            ,
            t.canDragY = function(e) {
                return "both" === e.props.axis || "y" === e.props.axis
            }
            ,
            t.createCoreData = function(e, t, n) {
                const i = !(0,
                r.isNum)(e.lastX)
                  , a = o(e);
                return i ? {
                    node: a,
                    deltaX: 0,
                    deltaY: 0,
                    lastX: t,
                    lastY: n,
                    x: t,
                    y: n
                } : {
                    node: a,
                    deltaX: t - e.lastX,
                    deltaY: n - e.lastY,
                    lastX: e.lastX,
                    lastY: e.lastY,
                    x: t,
                    y: n
                }
            }
            ,
            t.createDraggableData = function(e, t) {
                const n = e.props.scale;
                return {
                    node: t.node,
                    x: e.state.x + t.deltaX / n,
                    y: e.state.y + t.deltaY / n,
                    deltaX: t.deltaX / n,
                    deltaY: t.deltaY / n,
                    lastX: e.state.x,
                    lastY: e.state.y
                }
            }
            ,
            t.getBoundPosition = function(e, t, n) {
                if (!e.props.bounds)
                    return [t, n];
                let {bounds: a} = e.props;
                a = "string" === typeof a ? a : function(e) {
                    return {
                        left: e.left,
                        top: e.top,
                        right: e.right,
                        bottom: e.bottom
                    }
                }(a);
                const s = o(e);
                if ("string" === typeof a) {
                    const {ownerDocument: e} = s
                      , t = e.defaultView;
                    let n;
                    if (n = "parent" === a ? s.parentNode : e.querySelector(a),
                    !(n instanceof t.HTMLElement))
                        throw new Error('Bounds selector "' + a + '" could not find an element.');
                    const o = n
                      , l = t.getComputedStyle(s)
                      , c = t.getComputedStyle(o);
                    a = {
                        left: -s.offsetLeft + (0,
                        r.int)(c.paddingLeft) + (0,
                        r.int)(l.marginLeft),
                        top: -s.offsetTop + (0,
                        r.int)(c.paddingTop) + (0,
                        r.int)(l.marginTop),
                        right: (0,
                        i.innerWidth)(o) - (0,
                        i.outerWidth)(s) - s.offsetLeft + (0,
                        r.int)(c.paddingRight) - (0,
                        r.int)(l.marginRight),
                        bottom: (0,
                        i.innerHeight)(o) - (0,
                        i.outerHeight)(s) - s.offsetTop + (0,
                        r.int)(c.paddingBottom) - (0,
                        r.int)(l.marginBottom)
                    }
                }
                (0,
                r.isNum)(a.right) && (t = Math.min(t, a.right));
                (0,
                r.isNum)(a.bottom) && (n = Math.min(n, a.bottom));
                (0,
                r.isNum)(a.left) && (t = Math.max(t, a.left));
                (0,
                r.isNum)(a.top) && (n = Math.max(n, a.top));
                return [t, n]
            }
            ,
            t.getControlPosition = function(e, t, n) {
                const r = "number" === typeof t ? (0,
                i.getTouch)(e, t) : null;
                if ("number" === typeof t && !r)
                    return null;
                const a = o(n)
                  , s = n.props.offsetParent || a.offsetParent || a.ownerDocument.body;
                return (0,
                i.offsetXYFromParent)(r || e, s, n.props.scale)
            }
            ,
            t.snapToGrid = function(e, t, n) {
                const r = Math.round(t / e[0]) * e[0]
                  , i = Math.round(n / e[1]) * e[1];
                return [r, i]
            }
            ;
            var r = n(5190)
              , i = n(9219);
            function o(e) {
                const t = e.findDOMNode();
                if (!t)
                    throw new Error("<DraggableCore>: Unmounted during event!");
                return t
            }
        }
        ,
        5190: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.dontSetMe = function(e, t, n) {
                if (e[t])
                    return new Error("Invalid prop ".concat(t, " passed to ").concat(n, " - do not set this, set it on the child."))
            }
            ,
            t.findInArray = function(e, t) {
                for (let n = 0, r = e.length; n < r; n++)
                    if (t.apply(t, [e[n], n, e]))
                        return e[n]
            }
            ,
            t.int = function(e) {
                return parseInt(e, 10)
            }
            ,
            t.isFunction = function(e) {
                return "function" === typeof e || "[object Function]" === Object.prototype.toString.call(e)
            }
            ,
            t.isNum = function(e) {
                return "number" === typeof e && !isNaN(e)
            }
        }
        ,
        8577: (e, t) => {
            "use strict";
            var n, r = Symbol.for("react.element"), i = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), c = Symbol.for("react.context"), u = Symbol.for("react.server_context"), d = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), p = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), m = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen");
            function v(e) {
                if ("object" === typeof e && null !== e) {
                    var t = e.$$typeof;
                    switch (t) {
                    case r:
                        switch (e = e.type) {
                        case o:
                        case s:
                        case a:
                        case h:
                        case p:
                            return e;
                        default:
                            switch (e = e && e.$$typeof) {
                            case u:
                            case c:
                            case d:
                            case m:
                            case f:
                            case l:
                                return e;
                            default:
                                return t
                            }
                        }
                    case i:
                        return t
                    }
                }
            }
            n = Symbol.for("react.module.reference"),
            t.ForwardRef = d,
            t.Memo = f
        }
        ,
        6429: (e, t, n) => {
            "use strict";
            e.exports = n(8577)
        }
        ,
        1153: (e, t) => {
            "use strict";
            t.ConcurrentRoot = 1,
            t.ContinuousEventPriority = 4,
            t.DefaultEventPriority = 16,
            t.DiscreteEventPriority = 1
        }
        ,
        8473: (e, t, n) => {
            e.exports = function(e) {
                var t = {}
                  , r = n(9950)
                  , i = n(5340)
                  , o = Object.assign;
                function a(e) {
                    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)
                        t += "&args[]=" + encodeURIComponent(arguments[n]);
                    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                }
                var s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
                  , l = Symbol.for("react.element")
                  , c = Symbol.for("react.portal")
                  , u = Symbol.for("react.fragment")
                  , d = Symbol.for("react.strict_mode")
                  , h = Symbol.for("react.profiler")
                  , p = Symbol.for("react.provider")
                  , f = Symbol.for("react.context")
                  , m = Symbol.for("react.forward_ref")
                  , g = Symbol.for("react.suspense")
                  , v = Symbol.for("react.suspense_list")
                  , y = Symbol.for("react.memo")
                  , b = Symbol.for("react.lazy");
                Symbol.for("react.scope"),
                Symbol.for("react.debug_trace_mode");
                var _ = Symbol.for("react.offscreen");
                Symbol.for("react.legacy_hidden"),
                Symbol.for("react.cache"),
                Symbol.for("react.tracing_marker");
                var A = Symbol.iterator;
                function x(e) {
                    return null === e || "object" !== typeof e ? null : "function" === typeof (e = A && e[A] || e["@@iterator"]) ? e : null
                }
                function S(e) {
                    if (null == e)
                        return null;
                    if ("function" === typeof e)
                        return e.displayName || e.name || null;
                    if ("string" === typeof e)
                        return e;
                    switch (e) {
                    case u:
                        return "Fragment";
                    case c:
                        return "Portal";
                    case h:
                        return "Profiler";
                    case d:
                        return "StrictMode";
                    case g:
                        return "Suspense";
                    case v:
                        return "SuspenseList"
                    }
                    if ("object" === typeof e)
                        switch (e.$$typeof) {
                        case f:
                            return (e.displayName || "Context") + ".Consumer";
                        case p:
                            return (e._context.displayName || "Context") + ".Provider";
                        case m:
                            var t = e.render;
                            return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"),
                            e;
                        case y:
                            return null !== (t = e.displayName || null) ? t : S(e.type) || "Memo";
                        case b:
                            t = e._payload,
                            e = e._init;
                            try {
                                return S(e(t))
                            } catch (n) {}
                        }
                    return null
                }
                function w(e) {
                    var t = e.type;
                    switch (e.tag) {
                    case 24:
                        return "Cache";
                    case 9:
                        return (t.displayName || "Context") + ".Consumer";
                    case 10:
                        return (t._context.displayName || "Context") + ".Provider";
                    case 18:
                        return "DehydratedFragment";
                    case 11:
                        return e = (e = t.render).displayName || e.name || "",
                        t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef");
                    case 7:
                        return "Fragment";
                    case 5:
                        return t;
                    case 4:
                        return "Portal";
                    case 3:
                        return "Root";
                    case 6:
                        return "Text";
                    case 16:
                        return S(t);
                    case 8:
                        return t === d ? "StrictMode" : "Mode";
                    case 22:
                        return "Offscreen";
                    case 12:
                        return "Profiler";
                    case 21:
                        return "Scope";
                    case 13:
                        return "Suspense";
                    case 19:
                        return "SuspenseList";
                    case 25:
                        return "TracingMarker";
                    case 1:
                    case 0:
                    case 17:
                    case 2:
                    case 14:
                    case 15:
                        if ("function" === typeof t)
                            return t.displayName || t.name || null;
                        if ("string" === typeof t)
                            return t
                    }
                    return null
                }
                function E(e) {
                    var t = e
                      , n = e;
                    if (e.alternate)
                        for (; t.return; )
                            t = t.return;
                    else {
                        e = t;
                        do {
                            0 !== (4098 & (t = e).flags) && (n = t.return),
                            e = t.return
                        } while (e)
                    }
                    return 3 === t.tag ? n : null
                }
                function M(e) {
                    if (E(e) !== e)
                        throw Error(a(188))
                }
                function C(e) {
                    var t = e.alternate;
                    if (!t) {
                        if (null === (t = E(e)))
                            throw Error(a(188));
                        return t !== e ? null : e
                    }
                    for (var n = e, r = t; ; ) {
                        var i = n.return;
                        if (null === i)
                            break;
                        var o = i.alternate;
                        if (null === o) {
                            if (null !== (r = i.return)) {
                                n = r;
                                continue
                            }
                            break
                        }
                        if (i.child === o.child) {
                            for (o = i.child; o; ) {
                                if (o === n)
                                    return M(i),
                                    e;
                                if (o === r)
                                    return M(i),
                                    t;
                                o = o.sibling
                            }
                            throw Error(a(188))
                        }
                        if (n.return !== r.return)
                            n = i,
                            r = o;
                        else {
                            for (var s = !1, l = i.child; l; ) {
                                if (l === n) {
                                    s = !0,
                                    n = i,
                                    r = o;
                                    break
                                }
                                if (l === r) {
                                    s = !0,
                                    r = i,
                                    n = o;
                                    break
                                }
                                l = l.sibling
                            }
                            if (!s) {
                                for (l = o.child; l; ) {
                                    if (l === n) {
                                        s = !0,
                                        n = o,
                                        r = i;
                                        break
                                    }
                                    if (l === r) {
                                        s = !0,
                                        r = o,
                                        n = i;
                                        break
                                    }
                                    l = l.sibling
                                }
                                if (!s)
                                    throw Error(a(189))
                            }
                        }
                        if (n.alternate !== r)
                            throw Error(a(190))
                    }
                    if (3 !== n.tag)
                        throw Error(a(188));
                    return n.stateNode.current === n ? e : t
                }
                function T(e) {
                    return null !== (e = C(e)) ? R(e) : null
                }
                function R(e) {
                    if (5 === e.tag || 6 === e.tag)
                        return e;
                    for (e = e.child; null !== e; ) {
                        var t = R(e);
                        if (null !== t)
                            return t;
                        e = e.sibling
                    }
                    return null
                }
                function P(e) {
                    if (5 === e.tag || 6 === e.tag)
                        return e;
                    for (e = e.child; null !== e; ) {
                        if (4 !== e.tag) {
                            var t = P(e);
                            if (null !== t)
                                return t
                        }
                        e = e.sibling
                    }
                    return null
                }
                var B, I = Array.isArray, L = e.getPublicInstance, k = e.getRootHostContext, D = e.getChildHostContext, O = e.prepareForCommit, N = e.resetAfterCommit, F = e.createInstance, U = e.appendInitialChild, z = e.finalizeInitialChildren, G = e.prepareUpdate, H = e.shouldSetTextContent, j = e.createTextInstance, W = e.scheduleTimeout, V = e.cancelTimeout, X = e.noTimeout, J = e.isPrimaryRenderer, K = e.supportsMutation, q = e.supportsPersistence, Y = e.supportsHydration, Q = e.getInstanceFromNode, Z = e.preparePortalMount, $ = e.getCurrentEventPriority, ee = e.detachDeletedInstance, te = e.supportsMicrotasks, ne = e.scheduleMicrotask, re = e.supportsTestSelectors, ie = e.findFiberRoot, oe = e.getBoundingRect, ae = e.getTextContent, se = e.isHiddenSubtree, le = e.matchAccessibilityRole, ce = e.setFocusIfFocusable, ue = e.setupIntersectionObserver, de = e.appendChild, he = e.appendChildToContainer, pe = e.commitTextUpdate, fe = e.commitMount, me = e.commitUpdate, ge = e.insertBefore, ve = e.insertInContainerBefore, ye = e.removeChild, be = e.removeChildFromContainer, _e = e.resetTextContent, Ae = e.hideInstance, xe = e.hideTextInstance, Se = e.unhideInstance, we = e.unhideTextInstance, Ee = e.clearContainer, Me = e.cloneInstance, Ce = e.createContainerChildSet, Te = e.appendChildToContainerChildSet, Re = e.finalizeContainerChildren, Pe = e.replaceContainerChildren, Be = e.cloneHiddenInstance, Ie = e.cloneHiddenTextInstance, Le = e.canHydrateInstance, ke = e.canHydrateTextInstance, De = e.canHydrateSuspenseInstance, Oe = e.isSuspenseInstancePending, Ne = e.isSuspenseInstanceFallback, Fe = e.registerSuspenseInstanceRetry, Ue = e.getNextHydratableSibling, ze = e.getFirstHydratableChild, Ge = e.getFirstHydratableChildWithinContainer, He = e.getFirstHydratableChildWithinSuspenseInstance, je = e.hydrateInstance, We = e.hydrateTextInstance, Ve = e.hydrateSuspenseInstance, Xe = e.getNextHydratableInstanceAfterSuspenseInstance, Je = e.commitHydratedContainer, Ke = e.commitHydratedSuspenseInstance, qe = e.clearSuspenseBoundary, Ye = e.clearSuspenseBoundaryFromContainer, Qe = e.shouldDeleteUnhydratedTailInstances, Ze = e.didNotMatchHydratedContainerTextInstance, $e = e.didNotMatchHydratedTextInstance;
                function et(e) {
                    if (void 0 === B)
                        try {
                            throw Error()
                        } catch (n) {
                            var t = n.stack.trim().match(/\n( *(at )?)/);
                            B = t && t[1] || ""
                        }
                    return "\n" + B + e
                }
                var tt = !1;
                function nt(e, t) {
                    if (!e || tt)
                        return "";
                    tt = !0;
                    var n = Error.prepareStackTrace;
                    Error.prepareStackTrace = void 0;
                    try {
                        if (t)
                            if (t = function() {
                                throw Error()
                            }
                            ,
                            Object.defineProperty(t.prototype, "props", {
                                set: function() {
                                    throw Error()
                                }
                            }),
                            "object" === typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(t, [])
                                } catch (c) {
                                    var r = c
                                }
                                Reflect.construct(e, [], t)
                            } else {
                                try {
                                    t.call()
                                } catch (c) {
                                    r = c
                                }
                                e.call(t.prototype)
                            }
                        else {
                            try {
                                throw Error()
                            } catch (c) {
                                r = c
                            }
                            e()
                        }
                    } catch (c) {
                        if (c && r && "string" === typeof c.stack) {
                            for (var i = c.stack.split("\n"), o = r.stack.split("\n"), a = i.length - 1, s = o.length - 1; 1 <= a && 0 <= s && i[a] !== o[s]; )
                                s--;
                            for (; 1 <= a && 0 <= s; a--,
                            s--)
                                if (i[a] !== o[s]) {
                                    if (1 !== a || 1 !== s)
                                        do {
                                            if (a--,
                                            0 > --s || i[a] !== o[s]) {
                                                var l = "\n" + i[a].replace(" at new ", " at ");
                                                return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)),
                                                l
                                            }
                                        } while (1 <= a && 0 <= s);
                                    break
                                }
                        }
                    } finally {
                        tt = !1,
                        Error.prepareStackTrace = n
                    }
                    return (e = e ? e.displayName || e.name : "") ? et(e) : ""
                }
                var rt = Object.prototype.hasOwnProperty
                  , it = []
                  , ot = -1;
                function at(e) {
                    return {
                        current: e
                    }
                }
                function st(e) {
                    0 > ot || (e.current = it[ot],
                    it[ot] = null,
                    ot--)
                }
                function lt(e, t) {
                    ot++,
                    it[ot] = e.current,
                    e.current = t
                }
                var ct = {}
                  , ut = at(ct)
                  , dt = at(!1)
                  , ht = ct;
                function pt(e, t) {
                    var n = e.type.contextTypes;
                    if (!n)
                        return ct;
                    var r = e.stateNode;
                    if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
                        return r.__reactInternalMemoizedMaskedChildContext;
                    var i, o = {};
                    for (i in n)
                        o[i] = t[i];
                    return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t,
                    e.__reactInternalMemoizedMaskedChildContext = o),
                    o
                }
                function ft(e) {
                    return null !== (e = e.childContextTypes) && void 0 !== e
                }
                function mt() {
                    st(dt),
                    st(ut)
                }
                function gt(e, t, n) {
                    if (ut.current !== ct)
                        throw Error(a(168));
                    lt(ut, t),
                    lt(dt, n)
                }
                function vt(e, t, n) {
                    var r = e.stateNode;
                    if (t = t.childContextTypes,
                    "function" !== typeof r.getChildContext)
                        return n;
                    for (var i in r = r.getChildContext())
                        if (!(i in t))
                            throw Error(a(108, w(e) || "Unknown", i));
                    return o({}, n, r)
                }
                function yt(e) {
                    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || ct,
                    ht = ut.current,
                    lt(ut, e),
                    lt(dt, dt.current),
                    !0
                }
                function bt(e, t, n) {
                    var r = e.stateNode;
                    if (!r)
                        throw Error(a(169));
                    n ? (e = vt(e, t, ht),
                    r.__reactInternalMemoizedMergedChildContext = e,
                    st(dt),
                    st(ut),
                    lt(ut, e)) : st(dt),
                    lt(dt, n)
                }
                var _t = Math.clz32 ? Math.clz32 : function(e) {
                    return 0 === (e >>>= 0) ? 32 : 31 - (At(e) / xt | 0) | 0
                }
                  , At = Math.log
                  , xt = Math.LN2;
                var St = 64
                  , wt = 4194304;
                function Et(e) {
                    switch (e & -e) {
                    case 1:
                        return 1;
                    case 2:
                        return 2;
                    case 4:
                        return 4;
                    case 8:
                        return 8;
                    case 16:
                        return 16;
                    case 32:
                        return 32;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                        return 4194240 & e;
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                        return 130023424 & e;
                    case 134217728:
                        return 134217728;
                    case 268435456:
                        return 268435456;
                    case 536870912:
                        return 536870912;
                    case 1073741824:
                        return 1073741824;
                    default:
                        return e
                    }
                }
                function Mt(e, t) {
                    var n = e.pendingLanes;
                    if (0 === n)
                        return 0;
                    var r = 0
                      , i = e.suspendedLanes
                      , o = e.pingedLanes
                      , a = 268435455 & n;
                    if (0 !== a) {
                        var s = a & ~i;
                        0 !== s ? r = Et(s) : 0 !== (o &= a) && (r = Et(o))
                    } else
                        0 !== (a = n & ~i) ? r = Et(a) : 0 !== o && (r = Et(o));
                    if (0 === r)
                        return 0;
                    if (0 !== t && t !== r && 0 === (t & i) && ((i = r & -r) >= (o = t & -t) || 16 === i && 0 !== (4194240 & o)))
                        return t;
                    if (0 !== (4 & r) && (r |= 16 & n),
                    0 !== (t = e.entangledLanes))
                        for (e = e.entanglements,
                        t &= r; 0 < t; )
                            i = 1 << (n = 31 - _t(t)),
                            r |= e[n],
                            t &= ~i;
                    return r
                }
                function Ct(e, t) {
                    switch (e) {
                    case 1:
                    case 2:
                    case 4:
                        return t + 250;
                    case 8:
                    case 16:
                    case 32:
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                        return t + 5e3;
                    default:
                        return -1
                    }
                }
                function Tt(e) {
                    return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0
                }
                function Rt(e) {
                    for (var t = [], n = 0; 31 > n; n++)
                        t.push(e);
                    return t
                }
                function Pt(e, t, n) {
                    e.pendingLanes |= t,
                    536870912 !== t && (e.suspendedLanes = 0,
                    e.pingedLanes = 0),
                    (e = e.eventTimes)[t = 31 - _t(t)] = n
                }
                function Bt(e, t) {
                    var n = e.entangledLanes |= t;
                    for (e = e.entanglements; n; ) {
                        var r = 31 - _t(n)
                          , i = 1 << r;
                        i & t | e[r] & t && (e[r] |= t),
                        n &= ~i
                    }
                }
                var It = 0;
                function Lt(e) {
                    return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1
                }
                var kt = i.unstable_scheduleCallback
                  , Dt = i.unstable_cancelCallback
                  , Ot = i.unstable_shouldYield
                  , Nt = i.unstable_requestPaint
                  , Ft = i.unstable_now
                  , Ut = i.unstable_ImmediatePriority
                  , zt = i.unstable_UserBlockingPriority
                  , Gt = i.unstable_NormalPriority
                  , Ht = i.unstable_IdlePriority
                  , jt = null
                  , Wt = null;
                var Vt = "function" === typeof Object.is ? Object.is : function(e, t) {
                    return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
                }
                  , Xt = null
                  , Jt = !1
                  , Kt = !1;
                function qt(e) {
                    null === Xt ? Xt = [e] : Xt.push(e)
                }
                function Yt() {
                    if (!Kt && null !== Xt) {
                        Kt = !0;
                        var e = 0
                          , t = It;
                        try {
                            var n = Xt;
                            for (It = 1; e < n.length; e++) {
                                var r = n[e];
                                do {
                                    r = r(!0)
                                } while (null !== r)
                            }
                            Xt = null,
                            Jt = !1
                        } catch (i) {
                            throw null !== Xt && (Xt = Xt.slice(e + 1)),
                            kt(Ut, Yt),
                            i
                        } finally {
                            It = t,
                            Kt = !1
                        }
                    }
                    return null
                }
                var Qt = s.ReactCurrentBatchConfig;
                function Zt(e, t) {
                    if (Vt(e, t))
                        return !0;
                    if ("object" !== typeof e || null === e || "object" !== typeof t || null === t)
                        return !1;
                    var n = Object.keys(e)
                      , r = Object.keys(t);
                    if (n.length !== r.length)
                        return !1;
                    for (r = 0; r < n.length; r++) {
                        var i = n[r];
                        if (!rt.call(t, i) || !Vt(e[i], t[i]))
                            return !1
                    }
                    return !0
                }
                function $t(e) {
                    switch (e.tag) {
                    case 5:
                        return et(e.type);
                    case 16:
                        return et("Lazy");
                    case 13:
                        return et("Suspense");
                    case 19:
                        return et("SuspenseList");
                    case 0:
                    case 2:
                    case 15:
                        return e = nt(e.type, !1);
                    case 11:
                        return e = nt(e.type.render, !1);
                    case 1:
                        return e = nt(e.type, !0);
                    default:
                        return ""
                    }
                }
                function en(e, t) {
                    if (e && e.defaultProps) {
                        for (var n in t = o({}, t),
                        e = e.defaultProps)
                            void 0 === t[n] && (t[n] = e[n]);
                        return t
                    }
                    return t
                }
                var tn = at(null)
                  , nn = null
                  , rn = null
                  , on = null;
                function an() {
                    on = rn = nn = null
                }
                function sn(e, t, n) {
                    J ? (lt(tn, t._currentValue),
                    t._currentValue = n) : (lt(tn, t._currentValue2),
                    t._currentValue2 = n)
                }
                function ln(e) {
                    var t = tn.current;
                    st(tn),
                    J ? e._currentValue = t : e._currentValue2 = t
                }
                function cn(e, t, n) {
                    for (; null !== e; ) {
                        var r = e.alternate;
                        if ((e.childLanes & t) !== t ? (e.childLanes |= t,
                        null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t),
                        e === n)
                            break;
                        e = e.return
                    }
                }
                function un(e, t) {
                    nn = e,
                    on = rn = null,
                    null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (Oi = !0),
                    e.firstContext = null)
                }
                function dn(e) {
                    var t = J ? e._currentValue : e._currentValue2;
                    if (on !== e)
                        if (e = {
                            context: e,
                            memoizedValue: t,
                            next: null
                        },
                        null === rn) {
                            if (null === nn)
                                throw Error(a(308));
                            rn = e,
                            nn.dependencies = {
                                lanes: 0,
                                firstContext: e
                            }
                        } else
                            rn = rn.next = e;
                    return t
                }
                var hn = null
                  , pn = !1;
                function fn(e) {
                    e.updateQueue = {
                        baseState: e.memoizedState,
                        firstBaseUpdate: null,
                        lastBaseUpdate: null,
                        shared: {
                            pending: null,
                            interleaved: null,
                            lanes: 0
                        },
                        effects: null
                    }
                }
                function mn(e, t) {
                    e = e.updateQueue,
                    t.updateQueue === e && (t.updateQueue = {
                        baseState: e.baseState,
                        firstBaseUpdate: e.firstBaseUpdate,
                        lastBaseUpdate: e.lastBaseUpdate,
                        shared: e.shared,
                        effects: e.effects
                    })
                }
                function gn(e, t) {
                    return {
                        eventTime: e,
                        lane: t,
                        tag: 0,
                        payload: null,
                        callback: null,
                        next: null
                    }
                }
                function vn(e, t) {
                    var n = e.updateQueue;
                    null !== n && (n = n.shared,
                    null !== qo && 0 !== (1 & e.mode) && 0 === (2 & Ko) ? (null === (e = n.interleaved) ? (t.next = t,
                    null === hn ? hn = [n] : hn.push(n)) : (t.next = e.next,
                    e.next = t),
                    n.interleaved = t) : (null === (e = n.pending) ? t.next = t : (t.next = e.next,
                    e.next = t),
                    n.pending = t))
                }
                function yn(e, t, n) {
                    if (null !== (t = t.updateQueue) && (t = t.shared,
                    0 !== (4194240 & n))) {
                        var r = t.lanes;
                        n |= r &= e.pendingLanes,
                        t.lanes = n,
                        Bt(e, n)
                    }
                }
                function bn(e, t) {
                    var n = e.updateQueue
                      , r = e.alternate;
                    if (null !== r && n === (r = r.updateQueue)) {
                        var i = null
                          , o = null;
                        if (null !== (n = n.firstBaseUpdate)) {
                            do {
                                var a = {
                                    eventTime: n.eventTime,
                                    lane: n.lane,
                                    tag: n.tag,
                                    payload: n.payload,
                                    callback: n.callback,
                                    next: null
                                };
                                null === o ? i = o = a : o = o.next = a,
                                n = n.next
                            } while (null !== n);
                            null === o ? i = o = t : o = o.next = t
                        } else
                            i = o = t;
                        return n = {
                            baseState: r.baseState,
                            firstBaseUpdate: i,
                            lastBaseUpdate: o,
                            shared: r.shared,
                            effects: r.effects
                        },
                        void (e.updateQueue = n)
                    }
                    null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t,
                    n.lastBaseUpdate = t
                }
                function _n(e, t, n, r) {
                    var i = e.updateQueue;
                    pn = !1;
                    var a = i.firstBaseUpdate
                      , s = i.lastBaseUpdate
                      , l = i.shared.pending;
                    if (null !== l) {
                        i.shared.pending = null;
                        var c = l
                          , u = c.next;
                        c.next = null,
                        null === s ? a = u : s.next = u,
                        s = c;
                        var d = e.alternate;
                        null !== d && ((l = (d = d.updateQueue).lastBaseUpdate) !== s && (null === l ? d.firstBaseUpdate = u : l.next = u,
                        d.lastBaseUpdate = c))
                    }
                    if (null !== a) {
                        var h = i.baseState;
                        for (s = 0,
                        d = u = c = null,
                        l = a; ; ) {
                            var p = l.lane
                              , f = l.eventTime;
                            if ((r & p) === p) {
                                null !== d && (d = d.next = {
                                    eventTime: f,
                                    lane: 0,
                                    tag: l.tag,
                                    payload: l.payload,
                                    callback: l.callback,
                                    next: null
                                });
                                e: {
                                    var m = e
                                      , g = l;
                                    switch (p = t,
                                    f = n,
                                    g.tag) {
                                    case 1:
                                        if ("function" === typeof (m = g.payload)) {
                                            h = m.call(f, h, p);
                                            break e
                                        }
                                        h = m;
                                        break e;
                                    case 3:
                                        m.flags = -65537 & m.flags | 128;
                                    case 0:
                                        if (null === (p = "function" === typeof (m = g.payload) ? m.call(f, h, p) : m) || void 0 === p)
                                            break e;
                                        h = o({}, h, p);
                                        break e;
                                    case 2:
                                        pn = !0
                                    }
                                }
                                null !== l.callback && 0 !== l.lane && (e.flags |= 64,
                                null === (p = i.effects) ? i.effects = [l] : p.push(l))
                            } else
                                f = {
                                    eventTime: f,
                                    lane: p,
                                    tag: l.tag,
                                    payload: l.payload,
                                    callback: l.callback,
                                    next: null
                                },
                                null === d ? (u = d = f,
                                c = h) : d = d.next = f,
                                s |= p;
                            if (null === (l = l.next)) {
                                if (null === (l = i.shared.pending))
                                    break;
                                l = (p = l).next,
                                p.next = null,
                                i.lastBaseUpdate = p,
                                i.shared.pending = null
                            }
                        }
                        if (null === d && (c = h),
                        i.baseState = c,
                        i.firstBaseUpdate = u,
                        i.lastBaseUpdate = d,
                        null !== (t = i.shared.interleaved)) {
                            i = t;
                            do {
                                s |= i.lane,
                                i = i.next
                            } while (i !== t)
                        } else
                            null === a && (i.shared.lanes = 0);
                        na |= s,
                        e.lanes = s,
                        e.memoizedState = h
                    }
                }
                function An(e, t, n) {
                    if (e = t.effects,
                    t.effects = null,
                    null !== e)
                        for (t = 0; t < e.length; t++) {
                            var r = e[t]
                              , i = r.callback;
                            if (null !== i) {
                                if (r.callback = null,
                                r = n,
                                "function" !== typeof i)
                                    throw Error(a(191, i));
                                i.call(r)
                            }
                        }
                }
                var xn = (new r.Component).refs;
                function Sn(e, t, n, r) {
                    n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : o({}, t, n),
                    e.memoizedState = n,
                    0 === e.lanes && (e.updateQueue.baseState = n)
                }
                var wn = {
                    isMounted: function(e) {
                        return !!(e = e._reactInternals) && E(e) === e
                    },
                    enqueueSetState: function(e, t, n) {
                        e = e._reactInternals;
                        var r = Aa()
                          , i = xa(e)
                          , o = gn(r, i);
                        o.payload = t,
                        void 0 !== n && null !== n && (o.callback = n),
                        vn(e, o),
                        null !== (t = Sa(e, i, r)) && yn(t, e, i)
                    },
                    enqueueReplaceState: function(e, t, n) {
                        e = e._reactInternals;
                        var r = Aa()
                          , i = xa(e)
                          , o = gn(r, i);
                        o.tag = 1,
                        o.payload = t,
                        void 0 !== n && null !== n && (o.callback = n),
                        vn(e, o),
                        null !== (t = Sa(e, i, r)) && yn(t, e, i)
                    },
                    enqueueForceUpdate: function(e, t) {
                        e = e._reactInternals;
                        var n = Aa()
                          , r = xa(e)
                          , i = gn(n, r);
                        i.tag = 2,
                        void 0 !== t && null !== t && (i.callback = t),
                        vn(e, i),
                        null !== (t = Sa(e, r, n)) && yn(t, e, r)
                    }
                };
                function En(e, t, n, r, i, o, a) {
                    return "function" === typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, o, a) : !t.prototype || !t.prototype.isPureReactComponent || (!Zt(n, r) || !Zt(i, o))
                }
                function Mn(e, t, n) {
                    var r = !1
                      , i = ct
                      , o = t.contextType;
                    return "object" === typeof o && null !== o ? o = dn(o) : (i = ft(t) ? ht : ut.current,
                    o = (r = null !== (r = t.contextTypes) && void 0 !== r) ? pt(e, i) : ct),
                    t = new t(n,o),
                    e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null,
                    t.updater = wn,
                    e.stateNode = t,
                    t._reactInternals = e,
                    r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i,
                    e.__reactInternalMemoizedMaskedChildContext = o),
                    t
                }
                function Cn(e, t, n, r) {
                    e = t.state,
                    "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r),
                    "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r),
                    t.state !== e && wn.enqueueReplaceState(t, t.state, null)
                }
                function Tn(e, t, n, r) {
                    var i = e.stateNode;
                    i.props = n,
                    i.state = e.memoizedState,
                    i.refs = xn,
                    fn(e);
                    var o = t.contextType;
                    "object" === typeof o && null !== o ? i.context = dn(o) : (o = ft(t) ? ht : ut.current,
                    i.context = pt(e, o)),
                    i.state = e.memoizedState,
                    "function" === typeof (o = t.getDerivedStateFromProps) && (Sn(e, t, o, n),
                    i.state = e.memoizedState),
                    "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state,
                    "function" === typeof i.componentWillMount && i.componentWillMount(),
                    "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(),
                    t !== i.state && wn.enqueueReplaceState(i, i.state, null),
                    _n(e, n, i, r),
                    i.state = e.memoizedState),
                    "function" === typeof i.componentDidMount && (e.flags |= 4194308)
                }
                var Rn = []
                  , Pn = 0
                  , Bn = null
                  , In = 0
                  , Ln = []
                  , kn = 0
                  , Dn = null
                  , On = 1
                  , Nn = "";
                function Fn(e, t) {
                    Rn[Pn++] = In,
                    Rn[Pn++] = Bn,
                    Bn = e,
                    In = t
                }
                function Un(e, t, n) {
                    Ln[kn++] = On,
                    Ln[kn++] = Nn,
                    Ln[kn++] = Dn,
                    Dn = e;
                    var r = On;
                    e = Nn;
                    var i = 32 - _t(r) - 1;
                    r &= ~(1 << i),
                    n += 1;
                    var o = 32 - _t(t) + i;
                    if (30 < o) {
                        var a = i - i % 5;
                        o = (r & (1 << a) - 1).toString(32),
                        r >>= a,
                        i -= a,
                        On = 1 << 32 - _t(t) + i | n << i | r,
                        Nn = o + e
                    } else
                        On = 1 << o | n << i | r,
                        Nn = e
                }
                function zn(e) {
                    null !== e.return && (Fn(e, 1),
                    Un(e, 1, 0))
                }
                function Gn(e) {
                    for (; e === Bn; )
                        Bn = Rn[--Pn],
                        Rn[Pn] = null,
                        In = Rn[--Pn],
                        Rn[Pn] = null;
                    for (; e === Dn; )
                        Dn = Ln[--kn],
                        Ln[kn] = null,
                        Nn = Ln[--kn],
                        Ln[kn] = null,
                        On = Ln[--kn],
                        Ln[kn] = null
                }
                var Hn = null
                  , jn = null
                  , Wn = !1
                  , Vn = !1
                  , Xn = null;
                function Jn(e, t) {
                    var n = Za(5, null, null, 0);
                    n.elementType = "DELETED",
                    n.stateNode = t,
                    n.return = e,
                    null === (t = e.deletions) ? (e.deletions = [n],
                    e.flags |= 16) : t.push(n)
                }
                function Kn(e, t) {
                    switch (e.tag) {
                    case 5:
                        return null !== (t = Le(t, e.type, e.pendingProps)) && (e.stateNode = t,
                        Hn = e,
                        jn = ze(t),
                        !0);
                    case 6:
                        return null !== (t = ke(t, e.pendingProps)) && (e.stateNode = t,
                        Hn = e,
                        jn = null,
                        !0);
                    case 13:
                        if (null !== (t = De(t))) {
                            var n = null !== Dn ? {
                                id: On,
                                overflow: Nn
                            } : null;
                            return e.memoizedState = {
                                dehydrated: t,
                                treeContext: n,
                                retryLane: 1073741824
                            },
                            (n = Za(18, null, null, 0)).stateNode = t,
                            n.return = e,
                            e.child = n,
                            Hn = e,
                            jn = null,
                            !0
                        }
                        return !1;
                    default:
                        return !1
                    }
                }
                function qn(e) {
                    return 0 !== (1 & e.mode) && 0 === (128 & e.flags)
                }
                function Yn(e) {
                    if (Wn) {
                        var t = jn;
                        if (t) {
                            var n = t;
                            if (!Kn(e, t)) {
                                if (qn(e))
                                    throw Error(a(418));
                                t = Ue(n);
                                var r = Hn;
                                t && Kn(e, t) ? Jn(r, n) : (e.flags = -4097 & e.flags | 2,
                                Wn = !1,
                                Hn = e)
                            }
                        } else {
                            if (qn(e))
                                throw Error(a(418));
                            e.flags = -4097 & e.flags | 2,
                            Wn = !1,
                            Hn = e
                        }
                    }
                }
                function Qn(e) {
                    for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag; )
                        e = e.return;
                    Hn = e
                }
                function Zn(e) {
                    if (!Y || e !== Hn)
                        return !1;
                    if (!Wn)
                        return Qn(e),
                        Wn = !0,
                        !1;
                    if (3 !== e.tag && (5 !== e.tag || Qe(e.type) && !H(e.type, e.memoizedProps))) {
                        var t = jn;
                        if (t) {
                            if (qn(e)) {
                                for (e = jn; e; )
                                    e = Ue(e);
                                throw Error(a(418))
                            }
                            for (; t; )
                                Jn(e, t),
                                t = Ue(t)
                        }
                    }
                    if (Qn(e),
                    13 === e.tag) {
                        if (!Y)
                            throw Error(a(316));
                        if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null))
                            throw Error(a(317));
                        jn = Xe(e)
                    } else
                        jn = Hn ? Ue(e.stateNode) : null;
                    return !0
                }
                function $n() {
                    Y && (jn = Hn = null,
                    Vn = Wn = !1)
                }
                function er(e) {
                    null === Xn ? Xn = [e] : Xn.push(e)
                }
                function tr(e, t, n) {
                    if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) {
                        if (n._owner) {
                            if (n = n._owner) {
                                if (1 !== n.tag)
                                    throw Error(a(309));
                                var r = n.stateNode
                            }
                            if (!r)
                                throw Error(a(147, e));
                            var i = r
                              , o = "" + e;
                            return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === o ? t.ref : (t = function(e) {
                                var t = i.refs;
                                t === xn && (t = i.refs = {}),
                                null === e ? delete t[o] : t[o] = e
                            }
                            ,
                            t._stringRef = o,
                            t)
                        }
                        if ("string" !== typeof e)
                            throw Error(a(284));
                        if (!n._owner)
                            throw Error(a(290, e))
                    }
                    return e
                }
                function nr(e, t) {
                    throw e = Object.prototype.toString.call(t),
                    Error(a(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
                }
                function rr(e) {
                    return (0,
                    e._init)(e._payload)
                }
                function ir(e) {
                    function t(t, n) {
                        if (e) {
                            var r = t.deletions;
                            null === r ? (t.deletions = [n],
                            t.flags |= 16) : r.push(n)
                        }
                    }
                    function n(n, r) {
                        if (!e)
                            return null;
                        for (; null !== r; )
                            t(n, r),
                            r = r.sibling;
                        return null
                    }
                    function r(e, t) {
                        for (e = new Map; null !== t; )
                            null !== t.key ? e.set(t.key, t) : e.set(t.index, t),
                            t = t.sibling;
                        return e
                    }
                    function i(e, t) {
                        return (e = es(e, t)).index = 0,
                        e.sibling = null,
                        e
                    }
                    function o(t, n, r) {
                        return t.index = r,
                        e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2,
                        n) : r : (t.flags |= 2,
                        n) : (t.flags |= 1048576,
                        n)
                    }
                    function s(t) {
                        return e && null === t.alternate && (t.flags |= 2),
                        t
                    }
                    function d(e, t, n, r) {
                        return null === t || 6 !== t.tag ? ((t = is(n, e.mode, r)).return = e,
                        t) : ((t = i(t, n)).return = e,
                        t)
                    }
                    function h(e, t, n, r) {
                        var o = n.type;
                        return o === u ? f(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === o || "object" === typeof o && null !== o && o.$$typeof === b && rr(o) === t.type) ? ((r = i(t, n.props)).ref = tr(e, t, n),
                        r.return = e,
                        r) : ((r = ts(n.type, n.key, n.props, null, e.mode, r)).ref = tr(e, t, n),
                        r.return = e,
                        r)
                    }
                    function p(e, t, n, r) {
                        return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = os(n, e.mode, r)).return = e,
                        t) : ((t = i(t, n.children || [])).return = e,
                        t)
                    }
                    function f(e, t, n, r, o) {
                        return null === t || 7 !== t.tag ? ((t = ns(n, e.mode, r, o)).return = e,
                        t) : ((t = i(t, n)).return = e,
                        t)
                    }
                    function m(e, t, n) {
                        if ("string" === typeof t && "" !== t || "number" === typeof t)
                            return (t = is("" + t, e.mode, n)).return = e,
                            t;
                        if ("object" === typeof t && null !== t) {
                            switch (t.$$typeof) {
                            case l:
                                return (n = ts(t.type, t.key, t.props, null, e.mode, n)).ref = tr(e, null, t),
                                n.return = e,
                                n;
                            case c:
                                return (t = os(t, e.mode, n)).return = e,
                                t;
                            case b:
                                return m(e, (0,
                                t._init)(t._payload), n)
                            }
                            if (I(t) || x(t))
                                return (t = ns(t, e.mode, n, null)).return = e,
                                t;
                            nr(e, t)
                        }
                        return null
                    }
                    function g(e, t, n, r) {
                        var i = null !== t ? t.key : null;
                        if ("string" === typeof n && "" !== n || "number" === typeof n)
                            return null !== i ? null : d(e, t, "" + n, r);
                        if ("object" === typeof n && null !== n) {
                            switch (n.$$typeof) {
                            case l:
                                return n.key === i ? h(e, t, n, r) : null;
                            case c:
                                return n.key === i ? p(e, t, n, r) : null;
                            case b:
                                return g(e, t, (i = n._init)(n._payload), r)
                            }
                            if (I(n) || x(n))
                                return null !== i ? null : f(e, t, n, r, null);
                            nr(e, n)
                        }
                        return null
                    }
                    function v(e, t, n, r, i) {
                        if ("string" === typeof r && "" !== r || "number" === typeof r)
                            return d(t, e = e.get(n) || null, "" + r, i);
                        if ("object" === typeof r && null !== r) {
                            switch (r.$$typeof) {
                            case l:
                                return h(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                            case c:
                                return p(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                            case b:
                                return v(e, t, n, (0,
                                r._init)(r._payload), i)
                            }
                            if (I(r) || x(r))
                                return f(t, e = e.get(n) || null, r, i, null);
                            nr(t, r)
                        }
                        return null
                    }
                    function y(i, a, s, l) {
                        for (var c = null, u = null, d = a, h = a = 0, p = null; null !== d && h < s.length; h++) {
                            d.index > h ? (p = d,
                            d = null) : p = d.sibling;
                            var f = g(i, d, s[h], l);
                            if (null === f) {
                                null === d && (d = p);
                                break
                            }
                            e && d && null === f.alternate && t(i, d),
                            a = o(f, a, h),
                            null === u ? c = f : u.sibling = f,
                            u = f,
                            d = p
                        }
                        if (h === s.length)
                            return n(i, d),
                            Wn && Fn(i, h),
                            c;
                        if (null === d) {
                            for (; h < s.length; h++)
                                null !== (d = m(i, s[h], l)) && (a = o(d, a, h),
                                null === u ? c = d : u.sibling = d,
                                u = d);
                            return Wn && Fn(i, h),
                            c
                        }
                        for (d = r(i, d); h < s.length; h++)
                            null !== (p = v(d, i, h, s[h], l)) && (e && null !== p.alternate && d.delete(null === p.key ? h : p.key),
                            a = o(p, a, h),
                            null === u ? c = p : u.sibling = p,
                            u = p);
                        return e && d.forEach((function(e) {
                            return t(i, e)
                        }
                        )),
                        Wn && Fn(i, h),
                        c
                    }
                    function _(i, s, l, c) {
                        var u = x(l);
                        if ("function" !== typeof u)
                            throw Error(a(150));
                        if (null == (l = u.call(l)))
                            throw Error(a(151));
                        for (var d = u = null, h = s, p = s = 0, f = null, y = l.next(); null !== h && !y.done; p++,
                        y = l.next()) {
                            h.index > p ? (f = h,
                            h = null) : f = h.sibling;
                            var b = g(i, h, y.value, c);
                            if (null === b) {
                                null === h && (h = f);
                                break
                            }
                            e && h && null === b.alternate && t(i, h),
                            s = o(b, s, p),
                            null === d ? u = b : d.sibling = b,
                            d = b,
                            h = f
                        }
                        if (y.done)
                            return n(i, h),
                            Wn && Fn(i, p),
                            u;
                        if (null === h) {
                            for (; !y.done; p++,
                            y = l.next())
                                null !== (y = m(i, y.value, c)) && (s = o(y, s, p),
                                null === d ? u = y : d.sibling = y,
                                d = y);
                            return Wn && Fn(i, p),
                            u
                        }
                        for (h = r(i, h); !y.done; p++,
                        y = l.next())
                            null !== (y = v(h, i, p, y.value, c)) && (e && null !== y.alternate && h.delete(null === y.key ? p : y.key),
                            s = o(y, s, p),
                            null === d ? u = y : d.sibling = y,
                            d = y);
                        return e && h.forEach((function(e) {
                            return t(i, e)
                        }
                        )),
                        Wn && Fn(i, p),
                        u
                    }
                    return function e(r, o, a, d) {
                        if ("object" === typeof a && null !== a && a.type === u && null === a.key && (a = a.props.children),
                        "object" === typeof a && null !== a) {
                            switch (a.$$typeof) {
                            case l:
                                e: {
                                    for (var h = a.key, p = o; null !== p; ) {
                                        if (p.key === h) {
                                            if ((h = a.type) === u) {
                                                if (7 === p.tag) {
                                                    n(r, p.sibling),
                                                    (o = i(p, a.props.children)).return = r,
                                                    r = o;
                                                    break e
                                                }
                                            } else if (p.elementType === h || "object" === typeof h && null !== h && h.$$typeof === b && rr(h) === p.type) {
                                                n(r, p.sibling),
                                                (o = i(p, a.props)).ref = tr(r, p, a),
                                                o.return = r,
                                                r = o;
                                                break e
                                            }
                                            n(r, p);
                                            break
                                        }
                                        t(r, p),
                                        p = p.sibling
                                    }
                                    a.type === u ? ((o = ns(a.props.children, r.mode, d, a.key)).return = r,
                                    r = o) : ((d = ts(a.type, a.key, a.props, null, r.mode, d)).ref = tr(r, o, a),
                                    d.return = r,
                                    r = d)
                                }
                                return s(r);
                            case c:
                                e: {
                                    for (p = a.key; null !== o; ) {
                                        if (o.key === p) {
                                            if (4 === o.tag && o.stateNode.containerInfo === a.containerInfo && o.stateNode.implementation === a.implementation) {
                                                n(r, o.sibling),
                                                (o = i(o, a.children || [])).return = r,
                                                r = o;
                                                break e
                                            }
                                            n(r, o);
                                            break
                                        }
                                        t(r, o),
                                        o = o.sibling
                                    }
                                    (o = os(a, r.mode, d)).return = r,
                                    r = o
                                }
                                return s(r);
                            case b:
                                return e(r, o, (p = a._init)(a._payload), d)
                            }
                            if (I(a))
                                return y(r, o, a, d);
                            if (x(a))
                                return _(r, o, a, d);
                            nr(r, a)
                        }
                        return "string" === typeof a && "" !== a || "number" === typeof a ? (a = "" + a,
                        null !== o && 6 === o.tag ? (n(r, o.sibling),
                        (o = i(o, a)).return = r,
                        r = o) : (n(r, o),
                        (o = is(a, r.mode, d)).return = r,
                        r = o),
                        s(r)) : n(r, o)
                    }
                }
                var or = ir(!0)
                  , ar = ir(!1)
                  , sr = {}
                  , lr = at(sr)
                  , cr = at(sr)
                  , ur = at(sr);
                function dr(e) {
                    if (e === sr)
                        throw Error(a(174));
                    return e
                }
                function hr(e, t) {
                    lt(ur, t),
                    lt(cr, e),
                    lt(lr, sr),
                    e = k(t),
                    st(lr),
                    lt(lr, e)
                }
                function pr() {
                    st(lr),
                    st(cr),
                    st(ur)
                }
                function fr(e) {
                    var t = dr(ur.current)
                      , n = dr(lr.current);
                    n !== (t = D(n, e.type, t)) && (lt(cr, e),
                    lt(lr, t))
                }
                function mr(e) {
                    cr.current === e && (st(lr),
                    st(cr))
                }
                var gr = at(0);
                function vr(e) {
                    for (var t = e; null !== t; ) {
                        if (13 === t.tag) {
                            var n = t.memoizedState;
                            if (null !== n && (null === (n = n.dehydrated) || Oe(n) || Ne(n)))
                                return t
                        } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
                            if (0 !== (128 & t.flags))
                                return t
                        } else if (null !== t.child) {
                            t.child.return = t,
                            t = t.child;
                            continue
                        }
                        if (t === e)
                            break;
                        for (; null === t.sibling; ) {
                            if (null === t.return || t.return === e)
                                return null;
                            t = t.return
                        }
                        t.sibling.return = t.return,
                        t = t.sibling
                    }
                    return null
                }
                var yr = [];
                function br() {
                    for (var e = 0; e < yr.length; e++) {
                        var t = yr[e];
                        J ? t._workInProgressVersionPrimary = null : t._workInProgressVersionSecondary = null
                    }
                    yr.length = 0
                }
                var _r = s.ReactCurrentDispatcher
                  , Ar = s.ReactCurrentBatchConfig
                  , xr = 0
                  , Sr = null
                  , wr = null
                  , Er = null
                  , Mr = !1
                  , Cr = !1
                  , Tr = 0
                  , Rr = 0;
                function Pr() {
                    throw Error(a(321))
                }
                function Br(e, t) {
                    if (null === t)
                        return !1;
                    for (var n = 0; n < t.length && n < e.length; n++)
                        if (!Vt(e[n], t[n]))
                            return !1;
                    return !0
                }
                function Ir(e, t, n, r, i, o) {
                    if (xr = o,
                    Sr = t,
                    t.memoizedState = null,
                    t.updateQueue = null,
                    t.lanes = 0,
                    _r.current = null === e || null === e.memoizedState ? fi : mi,
                    e = n(r, i),
                    Cr) {
                        o = 0;
                        do {
                            if (Cr = !1,
                            Tr = 0,
                            25 <= o)
                                throw Error(a(301));
                            o += 1,
                            Er = wr = null,
                            t.updateQueue = null,
                            _r.current = gi,
                            e = n(r, i)
                        } while (Cr)
                    }
                    if (_r.current = pi,
                    t = null !== wr && null !== wr.next,
                    xr = 0,
                    Er = wr = Sr = null,
                    Mr = !1,
                    t)
                        throw Error(a(300));
                    return e
                }
                function Lr() {
                    var e = 0 !== Tr;
                    return Tr = 0,
                    e
                }
                function kr() {
                    var e = {
                        memoizedState: null,
                        baseState: null,
                        baseQueue: null,
                        queue: null,
                        next: null
                    };
                    return null === Er ? Sr.memoizedState = Er = e : Er = Er.next = e,
                    Er
                }
                function Dr() {
                    if (null === wr) {
                        var e = Sr.alternate;
                        e = null !== e ? e.memoizedState : null
                    } else
                        e = wr.next;
                    var t = null === Er ? Sr.memoizedState : Er.next;
                    if (null !== t)
                        Er = t,
                        wr = e;
                    else {
                        if (null === e)
                            throw Error(a(310));
                        e = {
                            memoizedState: (wr = e).memoizedState,
                            baseState: wr.baseState,
                            baseQueue: wr.baseQueue,
                            queue: wr.queue,
                            next: null
                        },
                        null === Er ? Sr.memoizedState = Er = e : Er = Er.next = e
                    }
                    return Er
                }
                function Or(e, t) {
                    return "function" === typeof t ? t(e) : t
                }
                function Nr(e) {
                    var t = Dr()
                      , n = t.queue;
                    if (null === n)
                        throw Error(a(311));
                    n.lastRenderedReducer = e;
                    var r = wr
                      , i = r.baseQueue
                      , o = n.pending;
                    if (null !== o) {
                        if (null !== i) {
                            var s = i.next;
                            i.next = o.next,
                            o.next = s
                        }
                        r.baseQueue = i = o,
                        n.pending = null
                    }
                    if (null !== i) {
                        o = i.next,
                        r = r.baseState;
                        var l = s = null
                          , c = null
                          , u = o;
                        do {
                            var d = u.lane;
                            if ((xr & d) === d)
                                null !== c && (c = c.next = {
                                    lane: 0,
                                    action: u.action,
                                    hasEagerState: u.hasEagerState,
                                    eagerState: u.eagerState,
                                    next: null
                                }),
                                r = u.hasEagerState ? u.eagerState : e(r, u.action);
                            else {
                                var h = {
                                    lane: d,
                                    action: u.action,
                                    hasEagerState: u.hasEagerState,
                                    eagerState: u.eagerState,
                                    next: null
                                };
                                null === c ? (l = c = h,
                                s = r) : c = c.next = h,
                                Sr.lanes |= d,
                                na |= d
                            }
                            u = u.next
                        } while (null !== u && u !== o);
                        null === c ? s = r : c.next = l,
                        Vt(r, t.memoizedState) || (Oi = !0),
                        t.memoizedState = r,
                        t.baseState = s,
                        t.baseQueue = c,
                        n.lastRenderedState = r
                    }
                    if (null !== (e = n.interleaved)) {
                        i = e;
                        do {
                            o = i.lane,
                            Sr.lanes |= o,
                            na |= o,
                            i = i.next
                        } while (i !== e)
                    } else
                        null === i && (n.lanes = 0);
                    return [t.memoizedState, n.dispatch]
                }
                function Fr(e) {
                    var t = Dr()
                      , n = t.queue;
                    if (null === n)
                        throw Error(a(311));
                    n.lastRenderedReducer = e;
                    var r = n.dispatch
                      , i = n.pending
                      , o = t.memoizedState;
                    if (null !== i) {
                        n.pending = null;
                        var s = i = i.next;
                        do {
                            o = e(o, s.action),
                            s = s.next
                        } while (s !== i);
                        Vt(o, t.memoizedState) || (Oi = !0),
                        t.memoizedState = o,
                        null === t.baseQueue && (t.baseState = o),
                        n.lastRenderedState = o
                    }
                    return [o, r]
                }
                function Ur() {}
                function zr(e, t) {
                    var n = Sr
                      , r = Dr()
                      , i = t()
                      , o = !Vt(r.memoizedState, i);
                    if (o && (r.memoizedState = i,
                    Oi = !0),
                    r = r.queue,
                    Qr(jr.bind(null, n, r, e), [e]),
                    r.getSnapshot !== t || o || null !== Er && 1 & Er.memoizedState.tag) {
                        if (n.flags |= 2048,
                        Xr(9, Hr.bind(null, n, r, i, t), void 0, null),
                        null === qo)
                            throw Error(a(349));
                        0 !== (30 & xr) || Gr(n, t, i)
                    }
                    return i
                }
                function Gr(e, t, n) {
                    e.flags |= 16384,
                    e = {
                        getSnapshot: t,
                        value: n
                    },
                    null === (t = Sr.updateQueue) ? (t = {
                        lastEffect: null,
                        stores: null
                    },
                    Sr.updateQueue = t,
                    t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e)
                }
                function Hr(e, t, n, r) {
                    t.value = n,
                    t.getSnapshot = r,
                    Wr(t) && Sa(e, 1, -1)
                }
                function jr(e, t, n) {
                    return n((function() {
                        Wr(t) && Sa(e, 1, -1)
                    }
                    ))
                }
                function Wr(e) {
                    var t = e.getSnapshot;
                    e = e.value;
                    try {
                        var n = t();
                        return !Vt(e, n)
                    } catch (r) {
                        return !0
                    }
                }
                function Vr(e) {
                    var t = kr();
                    return "function" === typeof e && (e = e()),
                    t.memoizedState = t.baseState = e,
                    e = {
                        pending: null,
                        interleaved: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: Or,
                        lastRenderedState: e
                    },
                    t.queue = e,
                    e = e.dispatch = li.bind(null, Sr, e),
                    [t.memoizedState, e]
                }
                function Xr(e, t, n, r) {
                    return e = {
                        tag: e,
                        create: t,
                        destroy: n,
                        deps: r,
                        next: null
                    },
                    null === (t = Sr.updateQueue) ? (t = {
                        lastEffect: null,
                        stores: null
                    },
                    Sr.updateQueue = t,
                    t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next,
                    n.next = e,
                    e.next = r,
                    t.lastEffect = e),
                    e
                }
                function Jr() {
                    return Dr().memoizedState
                }
                function Kr(e, t, n, r) {
                    var i = kr();
                    Sr.flags |= e,
                    i.memoizedState = Xr(1 | t, n, void 0, void 0 === r ? null : r)
                }
                function qr(e, t, n, r) {
                    var i = Dr();
                    r = void 0 === r ? null : r;
                    var o = void 0;
                    if (null !== wr) {
                        var a = wr.memoizedState;
                        if (o = a.destroy,
                        null !== r && Br(r, a.deps))
                            return void (i.memoizedState = Xr(t, n, o, r))
                    }
                    Sr.flags |= e,
                    i.memoizedState = Xr(1 | t, n, o, r)
                }
                function Yr(e, t) {
                    return Kr(8390656, 8, e, t)
                }
                function Qr(e, t) {
                    return qr(2048, 8, e, t)
                }
                function Zr(e, t) {
                    return qr(4, 2, e, t)
                }
                function $r(e, t) {
                    return qr(4, 4, e, t)
                }
                function ei(e, t) {
                    return "function" === typeof t ? (e = e(),
                    t(e),
                    function() {
                        t(null)
                    }
                    ) : null !== t && void 0 !== t ? (e = e(),
                    t.current = e,
                    function() {
                        t.current = null
                    }
                    ) : void 0
                }
                function ti(e, t, n) {
                    return n = null !== n && void 0 !== n ? n.concat([e]) : null,
                    qr(4, 4, ei.bind(null, t, e), n)
                }
                function ni() {}
                function ri(e, t) {
                    var n = Dr();
                    t = void 0 === t ? null : t;
                    var r = n.memoizedState;
                    return null !== r && null !== t && Br(t, r[1]) ? r[0] : (n.memoizedState = [e, t],
                    e)
                }
                function ii(e, t) {
                    var n = Dr();
                    t = void 0 === t ? null : t;
                    var r = n.memoizedState;
                    return null !== r && null !== t && Br(t, r[1]) ? r[0] : (e = e(),
                    n.memoizedState = [e, t],
                    e)
                }
                function oi(e, t) {
                    var n = It;
                    It = 0 !== n && 4 > n ? n : 4,
                    e(!0);
                    var r = Ar.transition;
                    Ar.transition = {};
                    try {
                        e(!1),
                        t()
                    } finally {
                        It = n,
                        Ar.transition = r
                    }
                }
                function ai() {
                    return Dr().memoizedState
                }
                function si(e, t, n) {
                    var r = xa(e);
                    n = {
                        lane: r,
                        action: n,
                        hasEagerState: !1,
                        eagerState: null,
                        next: null
                    },
                    ci(e) ? ui(t, n) : (di(e, t, n),
                    null !== (e = Sa(e, r, n = Aa())) && hi(e, t, r))
                }
                function li(e, t, n) {
                    var r = xa(e)
                      , i = {
                        lane: r,
                        action: n,
                        hasEagerState: !1,
                        eagerState: null,
                        next: null
                    };
                    if (ci(e))
                        ui(t, i);
                    else {
                        di(e, t, i);
                        var o = e.alternate;
                        if (0 === e.lanes && (null === o || 0 === o.lanes) && null !== (o = t.lastRenderedReducer))
                            try {
                                var a = t.lastRenderedState
                                  , s = o(a, n);
                                if (i.hasEagerState = !0,
                                i.eagerState = s,
                                Vt(s, a))
                                    return
                            } catch (l) {}
                        null !== (e = Sa(e, r, n = Aa())) && hi(e, t, r)
                    }
                }
                function ci(e) {
                    var t = e.alternate;
                    return e === Sr || null !== t && t === Sr
                }
                function ui(e, t) {
                    Cr = Mr = !0;
                    var n = e.pending;
                    null === n ? t.next = t : (t.next = n.next,
                    n.next = t),
                    e.pending = t
                }
                function di(e, t, n) {
                    null !== qo && 0 !== (1 & e.mode) && 0 === (2 & Ko) ? (null === (e = t.interleaved) ? (n.next = n,
                    null === hn ? hn = [t] : hn.push(t)) : (n.next = e.next,
                    e.next = n),
                    t.interleaved = n) : (null === (e = t.pending) ? n.next = n : (n.next = e.next,
                    e.next = n),
                    t.pending = n)
                }
                function hi(e, t, n) {
                    if (0 !== (4194240 & n)) {
                        var r = t.lanes;
                        n |= r &= e.pendingLanes,
                        t.lanes = n,
                        Bt(e, n)
                    }
                }
                var pi = {
                    readContext: dn,
                    useCallback: Pr,
                    useContext: Pr,
                    useEffect: Pr,
                    useImperativeHandle: Pr,
                    useInsertionEffect: Pr,
                    useLayoutEffect: Pr,
                    useMemo: Pr,
                    useReducer: Pr,
                    useRef: Pr,
                    useState: Pr,
                    useDebugValue: Pr,
                    useDeferredValue: Pr,
                    useTransition: Pr,
                    useMutableSource: Pr,
                    useSyncExternalStore: Pr,
                    useId: Pr,
                    unstable_isNewReconciler: !1
                }
                  , fi = {
                    readContext: dn,
                    useCallback: function(e, t) {
                        return kr().memoizedState = [e, void 0 === t ? null : t],
                        e
                    },
                    useContext: dn,
                    useEffect: Yr,
                    useImperativeHandle: function(e, t, n) {
                        return n = null !== n && void 0 !== n ? n.concat([e]) : null,
                        Kr(4194308, 4, ei.bind(null, t, e), n)
                    },
                    useLayoutEffect: function(e, t) {
                        return Kr(4194308, 4, e, t)
                    },
                    useInsertionEffect: function(e, t) {
                        return Kr(4, 2, e, t)
                    },
                    useMemo: function(e, t) {
                        var n = kr();
                        return t = void 0 === t ? null : t,
                        e = e(),
                        n.memoizedState = [e, t],
                        e
                    },
                    useReducer: function(e, t, n) {
                        var r = kr();
                        return t = void 0 !== n ? n(t) : t,
                        r.memoizedState = r.baseState = t,
                        e = {
                            pending: null,
                            interleaved: null,
                            lanes: 0,
                            dispatch: null,
                            lastRenderedReducer: e,
                            lastRenderedState: t
                        },
                        r.queue = e,
                        e = e.dispatch = si.bind(null, Sr, e),
                        [r.memoizedState, e]
                    },
                    useRef: function(e) {
                        return e = {
                            current: e
                        },
                        kr().memoizedState = e
                    },
                    useState: Vr,
                    useDebugValue: ni,
                    useDeferredValue: function(e) {
                        var t = Vr(e)
                          , n = t[0]
                          , r = t[1];
                        return Yr((function() {
                            var t = Ar.transition;
                            Ar.transition = {};
                            try {
                                r(e)
                            } finally {
                                Ar.transition = t
                            }
                        }
                        ), [e]),
                        n
                    },
                    useTransition: function() {
                        var e = Vr(!1)
                          , t = e[0];
                        return e = oi.bind(null, e[1]),
                        kr().memoizedState = e,
                        [t, e]
                    },
                    useMutableSource: function() {},
                    useSyncExternalStore: function(e, t, n) {
                        var r = Sr
                          , i = kr();
                        if (Wn) {
                            if (void 0 === n)
                                throw Error(a(407));
                            n = n()
                        } else {
                            if (n = t(),
                            null === qo)
                                throw Error(a(349));
                            0 !== (30 & xr) || Gr(r, t, n)
                        }
                        i.memoizedState = n;
                        var o = {
                            value: n,
                            getSnapshot: t
                        };
                        return i.queue = o,
                        Yr(jr.bind(null, r, o, e), [e]),
                        r.flags |= 2048,
                        Xr(9, Hr.bind(null, r, o, n, t), void 0, null),
                        n
                    },
                    useId: function() {
                        var e = kr()
                          , t = qo.identifierPrefix;
                        if (Wn) {
                            var n = Nn;
                            t = ":" + t + "R" + (n = (On & ~(1 << 32 - _t(On) - 1)).toString(32) + n),
                            0 < (n = Tr++) && (t += "H" + n.toString(32)),
                            t += ":"
                        } else
                            t = ":" + t + "r" + (n = Rr++).toString(32) + ":";
                        return e.memoizedState = t
                    },
                    unstable_isNewReconciler: !1
                }
                  , mi = {
                    readContext: dn,
                    useCallback: ri,
                    useContext: dn,
                    useEffect: Qr,
                    useImperativeHandle: ti,
                    useInsertionEffect: Zr,
                    useLayoutEffect: $r,
                    useMemo: ii,
                    useReducer: Nr,
                    useRef: Jr,
                    useState: function() {
                        return Nr(Or)
                    },
                    useDebugValue: ni,
                    useDeferredValue: function(e) {
                        var t = Nr(Or)
                          , n = t[0]
                          , r = t[1];
                        return Qr((function() {
                            var t = Ar.transition;
                            Ar.transition = {};
                            try {
                                r(e)
                            } finally {
                                Ar.transition = t
                            }
                        }
                        ), [e]),
                        n
                    },
                    useTransition: function() {
                        return [Nr(Or)[0], Dr().memoizedState]
                    },
                    useMutableSource: Ur,
                    useSyncExternalStore: zr,
                    useId: ai,
                    unstable_isNewReconciler: !1
                }
                  , gi = {
                    readContext: dn,
                    useCallback: ri,
                    useContext: dn,
                    useEffect: Qr,
                    useImperativeHandle: ti,
                    useInsertionEffect: Zr,
                    useLayoutEffect: $r,
                    useMemo: ii,
                    useReducer: Fr,
                    useRef: Jr,
                    useState: function() {
                        return Fr(Or)
                    },
                    useDebugValue: ni,
                    useDeferredValue: function(e) {
                        var t = Fr(Or)
                          , n = t[0]
                          , r = t[1];
                        return Qr((function() {
                            var t = Ar.transition;
                            Ar.transition = {};
                            try {
                                r(e)
                            } finally {
                                Ar.transition = t
                            }
                        }
                        ), [e]),
                        n
                    },
                    useTransition: function() {
                        return [Fr(Or)[0], Dr().memoizedState]
                    },
                    useMutableSource: Ur,
                    useSyncExternalStore: zr,
                    useId: ai,
                    unstable_isNewReconciler: !1
                };
                function vi(e, t) {
                    try {
                        var n = ""
                          , r = t;
                        do {
                            n += $t(r),
                            r = r.return
                        } while (r);
                        var i = n
                    } catch (o) {
                        i = "\nError generating stack: " + o.message + "\n" + o.stack
                    }
                    return {
                        value: e,
                        source: t,
                        stack: i
                    }
                }
                function yi(e, t) {
                    try {
                        console.error(t.value)
                    } catch (n) {
                        setTimeout((function() {
                            throw n
                        }
                        ))
                    }
                }
                var bi, _i, Ai, xi, Si = "function" === typeof WeakMap ? WeakMap : Map;
                function wi(e, t, n) {
                    (n = gn(-1, n)).tag = 3,
                    n.payload = {
                        element: null
                    };
                    var r = t.value;
                    return n.callback = function() {
                        da || (da = !0,
                        ha = r),
                        yi(0, t)
                    }
                    ,
                    n
                }
                function Ei(e, t, n) {
                    (n = gn(-1, n)).tag = 3;
                    var r = e.type.getDerivedStateFromError;
                    if ("function" === typeof r) {
                        var i = t.value;
                        n.payload = function() {
                            return r(i)
                        }
                        ,
                        n.callback = function() {
                            yi(0, t)
                        }
                    }
                    var o = e.stateNode;
                    return null !== o && "function" === typeof o.componentDidCatch && (n.callback = function() {
                        yi(0, t),
                        "function" !== typeof r && (null === pa ? pa = new Set([this]) : pa.add(this));
                        var e = t.stack;
                        this.componentDidCatch(t.value, {
                            componentStack: null !== e ? e : ""
                        })
                    }
                    ),
                    n
                }
                function Mi(e, t, n) {
                    var r = e.pingCache;
                    if (null === r) {
                        r = e.pingCache = new Si;
                        var i = new Set;
                        r.set(t, i)
                    } else
                        void 0 === (i = r.get(t)) && (i = new Set,
                        r.set(t, i));
                    i.has(n) || (i.add(n),
                    e = Xa.bind(null, e, t, n),
                    t.then(e, e))
                }
                function Ci(e) {
                    do {
                        var t;
                        if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated),
                        t)
                            return e;
                        e = e.return
                    } while (null !== e);
                    return null
                }
                function Ti(e, t, n, r, i) {
                    return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128,
                    n.flags |= 131072,
                    n.flags &= -52805,
                    1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = gn(-1, 1)).tag = 2,
                    vn(n, t))),
                    n.lanes |= 1),
                    e) : (e.flags |= 65536,
                    e.lanes = i,
                    e)
                }
                function Ri(e) {
                    e.flags |= 4
                }
                function Pi(e, t) {
                    if (null !== e && e.child === t.child)
                        return !0;
                    if (0 !== (16 & t.flags))
                        return !1;
                    for (e = t.child; null !== e; ) {
                        if (0 !== (12854 & e.flags) || 0 !== (12854 & e.subtreeFlags))
                            return !1;
                        e = e.sibling
                    }
                    return !0
                }
                if (K)
                    bi = function(e, t) {
                        for (var n = t.child; null !== n; ) {
                            if (5 === n.tag || 6 === n.tag)
                                U(e, n.stateNode);
                            else if (4 !== n.tag && null !== n.child) {
                                n.child.return = n,
                                n = n.child;
                                continue
                            }
                            if (n === t)
                                break;
                            for (; null === n.sibling; ) {
                                if (null === n.return || n.return === t)
                                    return;
                                n = n.return
                            }
                            n.sibling.return = n.return,
                            n = n.sibling
                        }
                    }
                    ,
                    _i = function() {}
                    ,
                    Ai = function(e, t, n, r, i) {
                        if ((e = e.memoizedProps) !== r) {
                            var o = t.stateNode
                              , a = dr(lr.current);
                            n = G(o, n, e, r, i, a),
                            (t.updateQueue = n) && Ri(t)
                        }
                    }
                    ,
                    xi = function(e, t, n, r) {
                        n !== r && Ri(t)
                    }
                    ;
                else if (q) {
                    bi = function(e, t, n, r) {
                        for (var i = t.child; null !== i; ) {
                            if (5 === i.tag) {
                                var o = i.stateNode;
                                n && r && (o = Be(o, i.type, i.memoizedProps, i)),
                                U(e, o)
                            } else if (6 === i.tag)
                                o = i.stateNode,
                                n && r && (o = Ie(o, i.memoizedProps, i)),
                                U(e, o);
                            else if (4 !== i.tag)
                                if (22 === i.tag && null !== i.memoizedState)
                                    null !== (o = i.child) && (o.return = i),
                                    bi(e, i, !0, !0);
                                else if (null !== i.child) {
                                    i.child.return = i,
                                    i = i.child;
                                    continue
                                }
                            if (i === t)
                                break;
                            for (; null === i.sibling; ) {
                                if (null === i.return || i.return === t)
                                    return;
                                i = i.return
                            }
                            i.sibling.return = i.return,
                            i = i.sibling
                        }
                    }
                    ;
                    var Bi = function(e, t, n, r) {
                        for (var i = t.child; null !== i; ) {
                            if (5 === i.tag) {
                                var o = i.stateNode;
                                n && r && (o = Be(o, i.type, i.memoizedProps, i)),
                                Te(e, o)
                            } else if (6 === i.tag)
                                o = i.stateNode,
                                n && r && (o = Ie(o, i.memoizedProps, i)),
                                Te(e, o);
                            else if (4 !== i.tag)
                                if (22 === i.tag && null !== i.memoizedState)
                                    null !== (o = i.child) && (o.return = i),
                                    Bi(e, i, !0, !0);
                                else if (null !== i.child) {
                                    i.child.return = i,
                                    i = i.child;
                                    continue
                                }
                            if (i === t)
                                break;
                            for (; null === i.sibling; ) {
                                if (null === i.return || i.return === t)
                                    return;
                                i = i.return
                            }
                            i.sibling.return = i.return,
                            i = i.sibling
                        }
                    };
                    _i = function(e, t) {
                        var n = t.stateNode;
                        if (!Pi(e, t)) {
                            e = n.containerInfo;
                            var r = Ce(e);
                            Bi(r, t, !1, !1),
                            n.pendingChildren = r,
                            Ri(t),
                            Re(e, r)
                        }
                    }
                    ,
                    Ai = function(e, t, n, r, i) {
                        var o = e.stateNode
                          , a = e.memoizedProps;
                        if ((e = Pi(e, t)) && a === r)
                            t.stateNode = o;
                        else {
                            var s = t.stateNode
                              , l = dr(lr.current)
                              , c = null;
                            a !== r && (c = G(s, n, a, r, i, l)),
                            e && null === c ? t.stateNode = o : (o = Me(o, c, n, a, r, t, e, s),
                            z(o, n, r, i, l) && Ri(t),
                            t.stateNode = o,
                            e ? Ri(t) : bi(o, t, !1, !1))
                        }
                    }
                    ,
                    xi = function(e, t, n, r) {
                        n !== r ? (e = dr(ur.current),
                        n = dr(lr.current),
                        t.stateNode = j(r, e, n, t),
                        Ri(t)) : t.stateNode = e.stateNode
                    }
                } else
                    _i = function() {}
                    ,
                    Ai = function() {}
                    ,
                    xi = function() {}
                    ;
                function Ii(e, t) {
                    if (!Wn)
                        switch (e.tailMode) {
                        case "hidden":
                            t = e.tail;
                            for (var n = null; null !== t; )
                                null !== t.alternate && (n = t),
                                t = t.sibling;
                            null === n ? e.tail = null : n.sibling = null;
                            break;
                        case "collapsed":
                            n = e.tail;
                            for (var r = null; null !== n; )
                                null !== n.alternate && (r = n),
                                n = n.sibling;
                            null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null
                        }
                }
                function Li(e) {
                    var t = null !== e.alternate && e.alternate.child === e.child
                      , n = 0
                      , r = 0;
                    if (t)
                        for (var i = e.child; null !== i; )
                            n |= i.lanes | i.childLanes,
                            r |= 14680064 & i.subtreeFlags,
                            r |= 14680064 & i.flags,
                            i.return = e,
                            i = i.sibling;
                    else
                        for (i = e.child; null !== i; )
                            n |= i.lanes | i.childLanes,
                            r |= i.subtreeFlags,
                            r |= i.flags,
                            i.return = e,
                            i = i.sibling;
                    return e.subtreeFlags |= r,
                    e.childLanes = n,
                    t
                }
                function ki(e, t, n) {
                    var r = t.pendingProps;
                    switch (Gn(t),
                    t.tag) {
                    case 2:
                    case 16:
                    case 15:
                    case 0:
                    case 11:
                    case 7:
                    case 8:
                    case 12:
                    case 9:
                    case 14:
                        return Li(t),
                        null;
                    case 1:
                    case 17:
                        return ft(t.type) && mt(),
                        Li(t),
                        null;
                    case 3:
                        return r = t.stateNode,
                        pr(),
                        st(dt),
                        st(ut),
                        br(),
                        r.pendingContext && (r.context = r.pendingContext,
                        r.pendingContext = null),
                        null !== e && null !== e.child || (Zn(t) ? Ri(t) : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024,
                        null !== Xn && (Ta(Xn),
                        Xn = null))),
                        _i(e, t),
                        Li(t),
                        null;
                    case 5:
                        mr(t),
                        n = dr(ur.current);
                        var i = t.type;
                        if (null !== e && null != t.stateNode)
                            Ai(e, t, i, r, n),
                            e.ref !== t.ref && (t.flags |= 512,
                            t.flags |= 2097152);
                        else {
                            if (!r) {
                                if (null === t.stateNode)
                                    throw Error(a(166));
                                return Li(t),
                                null
                            }
                            if (e = dr(lr.current),
                            Zn(t)) {
                                if (!Y)
                                    throw Error(a(175));
                                e = je(t.stateNode, t.type, t.memoizedProps, n, e, t, !Vn),
                                t.updateQueue = e,
                                null !== e && Ri(t)
                            } else {
                                var o = F(i, r, n, e, t);
                                bi(o, t, !1, !1),
                                t.stateNode = o,
                                z(o, i, r, n, e) && Ri(t)
                            }
                            null !== t.ref && (t.flags |= 512,
                            t.flags |= 2097152)
                        }
                        return Li(t),
                        null;
                    case 6:
                        if (e && null != t.stateNode)
                            xi(e, t, e.memoizedProps, r);
                        else {
                            if ("string" !== typeof r && null === t.stateNode)
                                throw Error(a(166));
                            if (e = dr(ur.current),
                            n = dr(lr.current),
                            Zn(t)) {
                                if (!Y)
                                    throw Error(a(176));
                                if (e = t.stateNode,
                                r = t.memoizedProps,
                                (n = We(e, r, t, !Vn)) && null !== (i = Hn))
                                    switch (o = 0 !== (1 & i.mode),
                                    i.tag) {
                                    case 3:
                                        Ze(i.stateNode.containerInfo, e, r, o);
                                        break;
                                    case 5:
                                        $e(i.type, i.memoizedProps, i.stateNode, e, r, o)
                                    }
                                n && Ri(t)
                            } else
                                t.stateNode = j(r, e, n, t)
                        }
                        return Li(t),
                        null;
                    case 13:
                        if (st(gr),
                        r = t.memoizedState,
                        Wn && null !== jn && 0 !== (1 & t.mode) && 0 === (128 & t.flags)) {
                            for (e = jn; e; )
                                e = Ue(e);
                            return $n(),
                            t.flags |= 98560,
                            t
                        }
                        if (null !== r && null !== r.dehydrated) {
                            if (r = Zn(t),
                            null === e) {
                                if (!r)
                                    throw Error(a(318));
                                if (!Y)
                                    throw Error(a(344));
                                if (!(e = null !== (e = t.memoizedState) ? e.dehydrated : null))
                                    throw Error(a(317));
                                Ve(e, t)
                            } else
                                $n(),
                                0 === (128 & t.flags) && (t.memoizedState = null),
                                t.flags |= 4;
                            return Li(t),
                            null
                        }
                        return null !== Xn && (Ta(Xn),
                        Xn = null),
                        0 !== (128 & t.flags) ? (t.lanes = n,
                        t) : (r = null !== r,
                        n = !1,
                        null === e ? Zn(t) : n = null !== e.memoizedState,
                        r && !n && (t.child.flags |= 8192,
                        0 !== (1 & t.mode) && (null === e || 0 !== (1 & gr.current) ? 0 === ea && (ea = 3) : Oa())),
                        null !== t.updateQueue && (t.flags |= 4),
                        Li(t),
                        null);
                    case 4:
                        return pr(),
                        _i(e, t),
                        null === e && Z(t.stateNode.containerInfo),
                        Li(t),
                        null;
                    case 10:
                        return ln(t.type._context),
                        Li(t),
                        null;
                    case 19:
                        if (st(gr),
                        null === (i = t.memoizedState))
                            return Li(t),
                            null;
                        if (r = 0 !== (128 & t.flags),
                        null === (o = i.rendering))
                            if (r)
                                Ii(i, !1);
                            else {
                                if (0 !== ea || null !== e && 0 !== (128 & e.flags))
                                    for (e = t.child; null !== e; ) {
                                        if (null !== (o = vr(e))) {
                                            for (t.flags |= 128,
                                            Ii(i, !1),
                                            null !== (e = o.updateQueue) && (t.updateQueue = e,
                                            t.flags |= 4),
                                            t.subtreeFlags = 0,
                                            e = n,
                                            r = t.child; null !== r; )
                                                i = e,
                                                (n = r).flags &= 14680066,
                                                null === (o = n.alternate) ? (n.childLanes = 0,
                                                n.lanes = i,
                                                n.child = null,
                                                n.subtreeFlags = 0,
                                                n.memoizedProps = null,
                                                n.memoizedState = null,
                                                n.updateQueue = null,
                                                n.dependencies = null,
                                                n.stateNode = null) : (n.childLanes = o.childLanes,
                                                n.lanes = o.lanes,
                                                n.child = o.child,
                                                n.subtreeFlags = 0,
                                                n.deletions = null,
                                                n.memoizedProps = o.memoizedProps,
                                                n.memoizedState = o.memoizedState,
                                                n.updateQueue = o.updateQueue,
                                                n.type = o.type,
                                                i = o.dependencies,
                                                n.dependencies = null === i ? null : {
                                                    lanes: i.lanes,
                                                    firstContext: i.firstContext
                                                }),
                                                r = r.sibling;
                                            return lt(gr, 1 & gr.current | 2),
                                            t.child
                                        }
                                        e = e.sibling
                                    }
                                null !== i.tail && Ft() > la && (t.flags |= 128,
                                r = !0,
                                Ii(i, !1),
                                t.lanes = 4194304)
                            }
                        else {
                            if (!r)
                                if (null !== (e = vr(o))) {
                                    if (t.flags |= 128,
                                    r = !0,
                                    null !== (e = e.updateQueue) && (t.updateQueue = e,
                                    t.flags |= 4),
                                    Ii(i, !0),
                                    null === i.tail && "hidden" === i.tailMode && !o.alternate && !Wn)
                                        return Li(t),
                                        null
                                } else
                                    2 * Ft() - i.renderingStartTime > la && 1073741824 !== n && (t.flags |= 128,
                                    r = !0,
                                    Ii(i, !1),
                                    t.lanes = 4194304);
                            i.isBackwards ? (o.sibling = t.child,
                            t.child = o) : (null !== (e = i.last) ? e.sibling = o : t.child = o,
                            i.last = o)
                        }
                        return null !== i.tail ? (t = i.tail,
                        i.rendering = t,
                        i.tail = t.sibling,
                        i.renderingStartTime = Ft(),
                        t.sibling = null,
                        e = gr.current,
                        lt(gr, r ? 1 & e | 2 : 1 & e),
                        t) : (Li(t),
                        null);
                    case 22:
                    case 23:
                        return Ia(),
                        r = null !== t.memoizedState,
                        null !== e && null !== e.memoizedState !== r && (t.flags |= 8192),
                        r && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Zo) && (Li(t),
                        K && 6 & t.subtreeFlags && (t.flags |= 8192)) : Li(t),
                        null;
                    case 24:
                    case 25:
                        return null
                    }
                    throw Error(a(156, t.tag))
                }
                var Di = s.ReactCurrentOwner
                  , Oi = !1;
                function Ni(e, t, n, r) {
                    t.child = null === e ? ar(t, null, n, r) : or(t, e.child, n, r)
                }
                function Fi(e, t, n, r, i) {
                    n = n.render;
                    var o = t.ref;
                    return un(t, i),
                    r = Ir(e, t, n, r, o, i),
                    n = Lr(),
                    null === e || Oi ? (Wn && n && zn(t),
                    t.flags |= 1,
                    Ni(e, t, r, i),
                    t.child) : (t.updateQueue = e.updateQueue,
                    t.flags &= -2053,
                    e.lanes &= ~i,
                    io(e, t, i))
                }
                function Ui(e, t, n, r, i) {
                    if (null === e) {
                        var o = n.type;
                        return "function" !== typeof o || $a(o) || void 0 !== o.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = ts(n.type, null, r, t, t.mode, i)).ref = t.ref,
                        e.return = t,
                        t.child = e) : (t.tag = 15,
                        t.type = o,
                        zi(e, t, o, r, i))
                    }
                    if (o = e.child,
                    0 === (e.lanes & i)) {
                        var a = o.memoizedProps;
                        if ((n = null !== (n = n.compare) ? n : Zt)(a, r) && e.ref === t.ref)
                            return io(e, t, i)
                    }
                    return t.flags |= 1,
                    (e = es(o, r)).ref = t.ref,
                    e.return = t,
                    t.child = e
                }
                function zi(e, t, n, r, i) {
                    if (null !== e && Zt(e.memoizedProps, r) && e.ref === t.ref) {
                        if (Oi = !1,
                        0 === (e.lanes & i))
                            return t.lanes = e.lanes,
                            io(e, t, i);
                        0 !== (131072 & e.flags) && (Oi = !0)
                    }
                    return ji(e, t, n, r, i)
                }
                function Gi(e, t, n) {
                    var r = t.pendingProps
                      , i = r.children
                      , o = null !== e ? e.memoizedState : null;
                    if ("hidden" === r.mode)
                        if (0 === (1 & t.mode))
                            t.memoizedState = {
                                baseLanes: 0,
                                cachePool: null
                            },
                            lt($o, Zo),
                            Zo |= n;
                        else {
                            if (0 === (1073741824 & n))
                                return e = null !== o ? o.baseLanes | n : n,
                                t.lanes = t.childLanes = 1073741824,
                                t.memoizedState = {
                                    baseLanes: e,
                                    cachePool: null
                                },
                                t.updateQueue = null,
                                lt($o, Zo),
                                Zo |= e,
                                null;
                            t.memoizedState = {
                                baseLanes: 0,
                                cachePool: null
                            },
                            r = null !== o ? o.baseLanes : n,
                            lt($o, Zo),
                            Zo |= r
                        }
                    else
                        null !== o ? (r = o.baseLanes | n,
                        t.memoizedState = null) : r = n,
                        lt($o, Zo),
                        Zo |= r;
                    return Ni(e, t, i, n),
                    t.child
                }
                function Hi(e, t) {
                    var n = t.ref;
                    (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512,
                    t.flags |= 2097152)
                }
                function ji(e, t, n, r, i) {
                    var o = ft(n) ? ht : ut.current;
                    return o = pt(t, o),
                    un(t, i),
                    n = Ir(e, t, n, r, o, i),
                    r = Lr(),
                    null === e || Oi ? (Wn && r && zn(t),
                    t.flags |= 1,
                    Ni(e, t, n, i),
                    t.child) : (t.updateQueue = e.updateQueue,
                    t.flags &= -2053,
                    e.lanes &= ~i,
                    io(e, t, i))
                }
                function Wi(e, t, n, r, i) {
                    if (ft(n)) {
                        var o = !0;
                        yt(t)
                    } else
                        o = !1;
                    if (un(t, i),
                    null === t.stateNode)
                        null !== e && (e.alternate = null,
                        t.alternate = null,
                        t.flags |= 2),
                        Mn(t, n, r),
                        Tn(t, n, r, i),
                        r = !0;
                    else if (null === e) {
                        var a = t.stateNode
                          , s = t.memoizedProps;
                        a.props = s;
                        var l = a.context
                          , c = n.contextType;
                        "object" === typeof c && null !== c ? c = dn(c) : c = pt(t, c = ft(n) ? ht : ut.current);
                        var u = n.getDerivedStateFromProps
                          , d = "function" === typeof u || "function" === typeof a.getSnapshotBeforeUpdate;
                        d || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== r || l !== c) && Cn(t, a, r, c),
                        pn = !1;
                        var h = t.memoizedState;
                        a.state = h,
                        _n(t, r, a, i),
                        l = t.memoizedState,
                        s !== r || h !== l || dt.current || pn ? ("function" === typeof u && (Sn(t, n, u, r),
                        l = t.memoizedState),
                        (s = pn || En(t, n, s, r, h, l, c)) ? (d || "function" !== typeof a.UNSAFE_componentWillMount && "function" !== typeof a.componentWillMount || ("function" === typeof a.componentWillMount && a.componentWillMount(),
                        "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount()),
                        "function" === typeof a.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308),
                        t.memoizedProps = r,
                        t.memoizedState = l),
                        a.props = r,
                        a.state = l,
                        a.context = c,
                        r = s) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308),
                        r = !1)
                    } else {
                        a = t.stateNode,
                        mn(e, t),
                        s = t.memoizedProps,
                        c = t.type === t.elementType ? s : en(t.type, s),
                        a.props = c,
                        d = t.pendingProps,
                        h = a.context,
                        "object" === typeof (l = n.contextType) && null !== l ? l = dn(l) : l = pt(t, l = ft(n) ? ht : ut.current);
                        var p = n.getDerivedStateFromProps;
                        (u = "function" === typeof p || "function" === typeof a.getSnapshotBeforeUpdate) || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== d || h !== l) && Cn(t, a, r, l),
                        pn = !1,
                        h = t.memoizedState,
                        a.state = h,
                        _n(t, r, a, i);
                        var f = t.memoizedState;
                        s !== d || h !== f || dt.current || pn ? ("function" === typeof p && (Sn(t, n, p, r),
                        f = t.memoizedState),
                        (c = pn || En(t, n, c, r, h, f, l) || !1) ? (u || "function" !== typeof a.UNSAFE_componentWillUpdate && "function" !== typeof a.componentWillUpdate || ("function" === typeof a.componentWillUpdate && a.componentWillUpdate(r, f, l),
                        "function" === typeof a.UNSAFE_componentWillUpdate && a.UNSAFE_componentWillUpdate(r, f, l)),
                        "function" === typeof a.componentDidUpdate && (t.flags |= 4),
                        "function" === typeof a.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4),
                        "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024),
                        t.memoizedProps = r,
                        t.memoizedState = f),
                        a.props = r,
                        a.state = f,
                        a.context = l,
                        r = c) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4),
                        "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024),
                        r = !1)
                    }
                    return Vi(e, t, n, r, o, i)
                }
                function Vi(e, t, n, r, i, o) {
                    Hi(e, t);
                    var a = 0 !== (128 & t.flags);
                    if (!r && !a)
                        return i && bt(t, n, !1),
                        io(e, t, o);
                    r = t.stateNode,
                    Di.current = t;
                    var s = a && "function" !== typeof n.getDerivedStateFromError ? null : r.render();
                    return t.flags |= 1,
                    null !== e && a ? (t.child = or(t, e.child, null, o),
                    t.child = or(t, null, s, o)) : Ni(e, t, s, o),
                    t.memoizedState = r.state,
                    i && bt(t, n, !0),
                    t.child
                }
                function Xi(e) {
                    var t = e.stateNode;
                    t.pendingContext ? gt(0, t.pendingContext, t.pendingContext !== t.context) : t.context && gt(0, t.context, !1),
                    hr(e, t.containerInfo)
                }
                function Ji(e, t, n, r, i) {
                    return $n(),
                    er(i),
                    t.flags |= 256,
                    Ni(e, t, n, r),
                    t.child
                }
                var Ki = {
                    dehydrated: null,
                    treeContext: null,
                    retryLane: 0
                };
                function qi(e) {
                    return {
                        baseLanes: e,
                        cachePool: null
                    }
                }
                function Yi(e, t, n) {
                    var r, i = t.pendingProps, o = gr.current, s = !1, l = 0 !== (128 & t.flags);
                    if ((r = l) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & o)),
                    r ? (s = !0,
                    t.flags &= -129) : null !== e && null === e.memoizedState || (o |= 1),
                    lt(gr, 1 & o),
                    null === e)
                        return Yn(t),
                        null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : Ne(e) ? t.lanes = 8 : t.lanes = 1073741824,
                        null) : (o = i.children,
                        e = i.fallback,
                        s ? (i = t.mode,
                        s = t.child,
                        o = {
                            mode: "hidden",
                            children: o
                        },
                        0 === (1 & i) && null !== s ? (s.childLanes = 0,
                        s.pendingProps = o) : s = rs(o, i, 0, null),
                        e = ns(e, i, n, null),
                        s.return = t,
                        e.return = t,
                        s.sibling = e,
                        t.child = s,
                        t.child.memoizedState = qi(n),
                        t.memoizedState = Ki,
                        e) : Qi(t, o));
                    if (null !== (o = e.memoizedState)) {
                        if (null !== (r = o.dehydrated)) {
                            if (l)
                                return 256 & t.flags ? (t.flags &= -257,
                                eo(e, t, n, Error(a(422)))) : null !== t.memoizedState ? (t.child = e.child,
                                t.flags |= 128,
                                null) : (s = i.fallback,
                                o = t.mode,
                                i = rs({
                                    mode: "visible",
                                    children: i.children
                                }, o, 0, null),
                                (s = ns(s, o, n, null)).flags |= 2,
                                i.return = t,
                                s.return = t,
                                i.sibling = s,
                                t.child = i,
                                0 !== (1 & t.mode) && or(t, e.child, null, n),
                                t.child.memoizedState = qi(n),
                                t.memoizedState = Ki,
                                s);
                            if (0 === (1 & t.mode))
                                t = eo(e, t, n, null);
                            else if (Ne(r))
                                t = eo(e, t, n, Error(a(419)));
                            else if (i = 0 !== (n & e.childLanes),
                            Oi || i) {
                                if (null !== (i = qo)) {
                                    switch (n & -n) {
                                    case 4:
                                        s = 2;
                                        break;
                                    case 16:
                                        s = 8;
                                        break;
                                    case 64:
                                    case 128:
                                    case 256:
                                    case 512:
                                    case 1024:
                                    case 2048:
                                    case 4096:
                                    case 8192:
                                    case 16384:
                                    case 32768:
                                    case 65536:
                                    case 131072:
                                    case 262144:
                                    case 524288:
                                    case 1048576:
                                    case 2097152:
                                    case 4194304:
                                    case 8388608:
                                    case 16777216:
                                    case 33554432:
                                    case 67108864:
                                        s = 32;
                                        break;
                                    case 536870912:
                                        s = 268435456;
                                        break;
                                    default:
                                        s = 0
                                    }
                                    0 !== (i = 0 !== (s & (i.suspendedLanes | n)) ? 0 : s) && i !== o.retryLane && (o.retryLane = i,
                                    Sa(e, i, -1))
                                }
                                Oa(),
                                t = eo(e, t, n, Error(a(421)))
                            } else
                                Oe(r) ? (t.flags |= 128,
                                t.child = e.child,
                                t = Ka.bind(null, e),
                                Fe(r, t),
                                t = null) : (n = o.treeContext,
                                Y && (jn = He(r),
                                Hn = t,
                                Wn = !0,
                                Xn = null,
                                Vn = !1,
                                null !== n && (Ln[kn++] = On,
                                Ln[kn++] = Nn,
                                Ln[kn++] = Dn,
                                On = n.id,
                                Nn = n.overflow,
                                Dn = t)),
                                (t = Qi(t, t.pendingProps.children)).flags |= 4096);
                            return t
                        }
                        return s ? (i = $i(e, t, i.children, i.fallback, n),
                        s = t.child,
                        o = e.child.memoizedState,
                        s.memoizedState = null === o ? qi(n) : {
                            baseLanes: o.baseLanes | n,
                            cachePool: null
                        },
                        s.childLanes = e.childLanes & ~n,
                        t.memoizedState = Ki,
                        i) : (n = Zi(e, t, i.children, n),
                        t.memoizedState = null,
                        n)
                    }
                    return s ? (i = $i(e, t, i.children, i.fallback, n),
                    s = t.child,
                    o = e.child.memoizedState,
                    s.memoizedState = null === o ? qi(n) : {
                        baseLanes: o.baseLanes | n,
                        cachePool: null
                    },
                    s.childLanes = e.childLanes & ~n,
                    t.memoizedState = Ki,
                    i) : (n = Zi(e, t, i.children, n),
                    t.memoizedState = null,
                    n)
                }
                function Qi(e, t) {
                    return (t = rs({
                        mode: "visible",
                        children: t
                    }, e.mode, 0, null)).return = e,
                    e.child = t
                }
                function Zi(e, t, n, r) {
                    var i = e.child;
                    return e = i.sibling,
                    n = es(i, {
                        mode: "visible",
                        children: n
                    }),
                    0 === (1 & t.mode) && (n.lanes = r),
                    n.return = t,
                    n.sibling = null,
                    null !== e && (null === (r = t.deletions) ? (t.deletions = [e],
                    t.flags |= 16) : r.push(e)),
                    t.child = n
                }
                function $i(e, t, n, r, i) {
                    var o = t.mode
                      , a = (e = e.child).sibling
                      , s = {
                        mode: "hidden",
                        children: n
                    };
                    return 0 === (1 & o) && t.child !== e ? ((n = t.child).childLanes = 0,
                    n.pendingProps = s,
                    t.deletions = null) : (n = es(e, s)).subtreeFlags = 14680064 & e.subtreeFlags,
                    null !== a ? r = es(a, r) : (r = ns(r, o, i, null)).flags |= 2,
                    r.return = t,
                    n.return = t,
                    n.sibling = r,
                    t.child = n,
                    r
                }
                function eo(e, t, n, r) {
                    return null !== r && er(r),
                    or(t, e.child, null, n),
                    (e = Qi(t, t.pendingProps.children)).flags |= 2,
                    t.memoizedState = null,
                    e
                }
                function to(e, t, n) {
                    e.lanes |= t;
                    var r = e.alternate;
                    null !== r && (r.lanes |= t),
                    cn(e.return, t, n)
                }
                function no(e, t, n, r, i) {
                    var o = e.memoizedState;
                    null === o ? e.memoizedState = {
                        isBackwards: t,
                        rendering: null,
                        renderingStartTime: 0,
                        last: r,
                        tail: n,
                        tailMode: i
                    } : (o.isBackwards = t,
                    o.rendering = null,
                    o.renderingStartTime = 0,
                    o.last = r,
                    o.tail = n,
                    o.tailMode = i)
                }
                function ro(e, t, n) {
                    var r = t.pendingProps
                      , i = r.revealOrder
                      , o = r.tail;
                    if (Ni(e, t, r.children, n),
                    0 !== (2 & (r = gr.current)))
                        r = 1 & r | 2,
                        t.flags |= 128;
                    else {
                        if (null !== e && 0 !== (128 & e.flags))
                            e: for (e = t.child; null !== e; ) {
                                if (13 === e.tag)
                                    null !== e.memoizedState && to(e, n, t);
                                else if (19 === e.tag)
                                    to(e, n, t);
                                else if (null !== e.child) {
                                    e.child.return = e,
                                    e = e.child;
                                    continue
                                }
                                if (e === t)
                                    break e;
                                for (; null === e.sibling; ) {
                                    if (null === e.return || e.return === t)
                                        break e;
                                    e = e.return
                                }
                                e.sibling.return = e.return,
                                e = e.sibling
                            }
                        r &= 1
                    }
                    if (lt(gr, r),
                    0 === (1 & t.mode))
                        t.memoizedState = null;
                    else
                        switch (i) {
                        case "forwards":
                            for (n = t.child,
                            i = null; null !== n; )
                                null !== (e = n.alternate) && null === vr(e) && (i = n),
                                n = n.sibling;
                            null === (n = i) ? (i = t.child,
                            t.child = null) : (i = n.sibling,
                            n.sibling = null),
                            no(t, !1, i, n, o);
                            break;
                        case "backwards":
                            for (n = null,
                            i = t.child,
                            t.child = null; null !== i; ) {
                                if (null !== (e = i.alternate) && null === vr(e)) {
                                    t.child = i;
                                    break
                                }
                                e = i.sibling,
                                i.sibling = n,
                                n = i,
                                i = e
                            }
                            no(t, !0, n, null, o);
                            break;
                        case "together":
                            no(t, !1, null, null, void 0);
                            break;
                        default:
                            t.memoizedState = null
                        }
                    return t.child
                }
                function io(e, t, n) {
                    if (null !== e && (t.dependencies = e.dependencies),
                    na |= t.lanes,
                    0 === (n & t.childLanes))
                        return null;
                    if (null !== e && t.child !== e.child)
                        throw Error(a(153));
                    if (null !== t.child) {
                        for (n = es(e = t.child, e.pendingProps),
                        t.child = n,
                        n.return = t; null !== e.sibling; )
                            e = e.sibling,
                            (n = n.sibling = es(e, e.pendingProps)).return = t;
                        n.sibling = null
                    }
                    return t.child
                }
                function oo(e, t) {
                    switch (Gn(t),
                    t.tag) {
                    case 1:
                        return ft(t.type) && mt(),
                        65536 & (e = t.flags) ? (t.flags = -65537 & e | 128,
                        t) : null;
                    case 3:
                        return pr(),
                        st(dt),
                        st(ut),
                        br(),
                        0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128,
                        t) : null;
                    case 5:
                        return mr(t),
                        null;
                    case 13:
                        if (st(gr),
                        null !== (e = t.memoizedState) && null !== e.dehydrated) {
                            if (null === t.alternate)
                                throw Error(a(340));
                            $n()
                        }
                        return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128,
                        t) : null;
                    case 19:
                        return st(gr),
                        null;
                    case 4:
                        return pr(),
                        null;
                    case 10:
                        return ln(t.type._context),
                        null;
                    case 22:
                    case 23:
                        return Ia(),
                        null;
                    default:
                        return null
                    }
                }
                var ao = !1
                  , so = !1
                  , lo = "function" === typeof WeakSet ? WeakSet : Set
                  , co = null;
                function uo(e, t) {
                    var n = e.ref;
                    if (null !== n)
                        if ("function" === typeof n)
                            try {
                                n(null)
                            } catch (r) {
                                Va(e, t, r)
                            }
                        else
                            n.current = null
                }
                function ho(e, t, n) {
                    try {
                        n()
                    } catch (r) {
                        Va(e, t, r)
                    }
                }
                var po = !1;
                function fo(e, t, n) {
                    var r = t.updateQueue;
                    if (null !== (r = null !== r ? r.lastEffect : null)) {
                        var i = r = r.next;
                        do {
                            if ((i.tag & e) === e) {
                                var o = i.destroy;
                                i.destroy = void 0,
                                void 0 !== o && ho(t, n, o)
                            }
                            i = i.next
                        } while (i !== r)
                    }
                }
                function mo(e, t) {
                    if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) {
                        var n = t = t.next;
                        do {
                            if ((n.tag & e) === e) {
                                var r = n.create;
                                n.destroy = r()
                            }
                            n = n.next
                        } while (n !== t)
                    }
                }
                function go(e) {
                    var t = e.ref;
                    if (null !== t) {
                        var n = e.stateNode;
                        if (5 === e.tag)
                            e = L(n);
                        else
                            e = n;
                        "function" === typeof t ? t(e) : t.current = e
                    }
                }
                function vo(e, t, n) {
                    if (Wt && "function" === typeof Wt.onCommitFiberUnmount)
                        try {
                            Wt.onCommitFiberUnmount(jt, t)
                        } catch (a) {}
                    switch (t.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        if (null !== (e = t.updateQueue) && null !== (e = e.lastEffect)) {
                            var r = e = e.next;
                            do {
                                var i = r
                                  , o = i.destroy;
                                i = i.tag,
                                void 0 !== o && (0 !== (2 & i) || 0 !== (4 & i)) && ho(t, n, o),
                                r = r.next
                            } while (r !== e)
                        }
                        break;
                    case 1:
                        if (uo(t, n),
                        "function" === typeof (e = t.stateNode).componentWillUnmount)
                            try {
                                e.props = t.memoizedProps,
                                e.state = t.memoizedState,
                                e.componentWillUnmount()
                            } catch (a) {
                                Va(t, n, a)
                            }
                        break;
                    case 5:
                        uo(t, n);
                        break;
                    case 4:
                        K ? Eo(e, t, n) : q && q && (t = t.stateNode.containerInfo,
                        n = Ce(t),
                        Pe(t, n))
                    }
                }
                function yo(e, t, n) {
                    for (var r = t; ; )
                        if (vo(e, r, n),
                        null === r.child || K && 4 === r.tag) {
                            if (r === t)
                                break;
                            for (; null === r.sibling; ) {
                                if (null === r.return || r.return === t)
                                    return;
                                r = r.return
                            }
                            r.sibling.return = r.return,
                            r = r.sibling
                        } else
                            r.child.return = r,
                            r = r.child
                }
                function bo(e) {
                    var t = e.alternate;
                    null !== t && (e.alternate = null,
                    bo(t)),
                    e.child = null,
                    e.deletions = null,
                    e.sibling = null,
                    5 === e.tag && (null !== (t = e.stateNode) && ee(t)),
                    e.stateNode = null,
                    e.return = null,
                    e.dependencies = null,
                    e.memoizedProps = null,
                    e.memoizedState = null,
                    e.pendingProps = null,
                    e.stateNode = null,
                    e.updateQueue = null
                }
                function _o(e) {
                    return 5 === e.tag || 3 === e.tag || 4 === e.tag
                }
                function Ao(e) {
                    e: for (; ; ) {
                        for (; null === e.sibling; ) {
                            if (null === e.return || _o(e.return))
                                return null;
                            e = e.return
                        }
                        for (e.sibling.return = e.return,
                        e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag; ) {
                            if (2 & e.flags)
                                continue e;
                            if (null === e.child || 4 === e.tag)
                                continue e;
                            e.child.return = e,
                            e = e.child
                        }
                        if (!(2 & e.flags))
                            return e.stateNode
                    }
                }
                function xo(e) {
                    if (K) {
                        e: {
                            for (var t = e.return; null !== t; ) {
                                if (_o(t))
                                    break e;
                                t = t.return
                            }
                            throw Error(a(160))
                        }
                        var n = t;
                        switch (n.tag) {
                        case 5:
                            t = n.stateNode,
                            32 & n.flags && (_e(t),
                            n.flags &= -33),
                            wo(e, n = Ao(e), t);
                            break;
                        case 3:
                        case 4:
                            t = n.stateNode.containerInfo,
                            So(e, n = Ao(e), t);
                            break;
                        default:
                            throw Error(a(161))
                        }
                    }
                }
                function So(e, t, n) {
                    var r = e.tag;
                    if (5 === r || 6 === r)
                        e = e.stateNode,
                        t ? ve(n, e, t) : he(n, e);
                    else if (4 !== r && null !== (e = e.child))
                        for (So(e, t, n),
                        e = e.sibling; null !== e; )
                            So(e, t, n),
                            e = e.sibling
                }
                function wo(e, t, n) {
                    var r = e.tag;
                    if (5 === r || 6 === r)
                        e = e.stateNode,
                        t ? ge(n, e, t) : de(n, e);
                    else if (4 !== r && null !== (e = e.child))
                        for (wo(e, t, n),
                        e = e.sibling; null !== e; )
                            wo(e, t, n),
                            e = e.sibling
                }
                function Eo(e, t, n) {
                    for (var r, i, o = t, s = !1; ; ) {
                        if (!s) {
                            s = o.return;
                            e: for (; ; ) {
                                if (null === s)
                                    throw Error(a(160));
                                switch (r = s.stateNode,
                                s.tag) {
                                case 5:
                                    i = !1;
                                    break e;
                                case 3:
                                case 4:
                                    r = r.containerInfo,
                                    i = !0;
                                    break e
                                }
                                s = s.return
                            }
                            s = !0
                        }
                        if (5 === o.tag || 6 === o.tag)
                            yo(e, o, n),
                            i ? be(r, o.stateNode) : ye(r, o.stateNode);
                        else if (18 === o.tag)
                            i ? Ye(r, o.stateNode) : qe(r, o.stateNode);
                        else if (4 === o.tag) {
                            if (null !== o.child) {
                                r = o.stateNode.containerInfo,
                                i = !0,
                                o.child.return = o,
                                o = o.child;
                                continue
                            }
                        } else if (vo(e, o, n),
                        null !== o.child) {
                            o.child.return = o,
                            o = o.child;
                            continue
                        }
                        if (o === t)
                            break;
                        for (; null === o.sibling; ) {
                            if (null === o.return || o.return === t)
                                return;
                            4 === (o = o.return).tag && (s = !1)
                        }
                        o.sibling.return = o.return,
                        o = o.sibling
                    }
                }
                function Mo(e, t) {
                    if (K) {
                        switch (t.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            return fo(3, t, t.return),
                            mo(3, t),
                            void fo(5, t, t.return);
                        case 1:
                        case 12:
                        case 17:
                            return;
                        case 5:
                            var n = t.stateNode;
                            if (null != n) {
                                var r = t.memoizedProps;
                                e = null !== e ? e.memoizedProps : r;
                                var i = t.type
                                  , o = t.updateQueue;
                                t.updateQueue = null,
                                null !== o && me(n, o, i, e, r, t)
                            }
                            return;
                        case 6:
                            if (null === t.stateNode)
                                throw Error(a(162));
                            return n = t.memoizedProps,
                            void pe(t.stateNode, null !== e ? e.memoizedProps : n, n);
                        case 3:
                            return void (Y && null !== e && e.memoizedState.isDehydrated && Je(t.stateNode.containerInfo));
                        case 13:
                        case 19:
                            return void Co(t)
                        }
                        throw Error(a(163))
                    }
                    switch (t.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        return fo(3, t, t.return),
                        mo(3, t),
                        void fo(5, t, t.return);
                    case 12:
                    case 22:
                    case 23:
                        return;
                    case 13:
                    case 19:
                        return void Co(t);
                    case 3:
                        Y && null !== e && e.memoizedState.isDehydrated && Je(t.stateNode.containerInfo)
                    }
                    e: if (q) {
                        switch (t.tag) {
                        case 1:
                        case 5:
                        case 6:
                            break e;
                        case 3:
                        case 4:
                            t = t.stateNode,
                            Pe(t.containerInfo, t.pendingChildren);
                            break e
                        }
                        throw Error(a(163))
                    }
                }
                function Co(e) {
                    var t = e.updateQueue;
                    if (null !== t) {
                        e.updateQueue = null;
                        var n = e.stateNode;
                        null === n && (n = e.stateNode = new lo),
                        t.forEach((function(t) {
                            var r = qa.bind(null, e, t);
                            n.has(t) || (n.add(t),
                            t.then(r, r))
                        }
                        ))
                    }
                }
                function To(e, t, n) {
                    co = e,
                    Ro(e, t, n)
                }
                function Ro(e, t, n) {
                    for (var r = 0 !== (1 & e.mode); null !== co; ) {
                        var i = co
                          , o = i.child;
                        if (22 === i.tag && r) {
                            var a = null !== i.memoizedState || ao;
                            if (!a) {
                                var s = i.alternate
                                  , l = null !== s && null !== s.memoizedState || so;
                                s = ao;
                                var c = so;
                                if (ao = a,
                                (so = l) && !c)
                                    for (co = i; null !== co; )
                                        l = (a = co).child,
                                        22 === a.tag && null !== a.memoizedState ? Io(i) : null !== l ? (l.return = a,
                                        co = l) : Io(i);
                                for (; null !== o; )
                                    co = o,
                                    Ro(o, t, n),
                                    o = o.sibling;
                                co = i,
                                ao = s,
                                so = c
                            }
                            Po(e)
                        } else
                            0 !== (8772 & i.subtreeFlags) && null !== o ? (o.return = i,
                            co = o) : Po(e)
                    }
                }
                function Po(e) {
                    for (; null !== co; ) {
                        var t = co;
                        if (0 !== (8772 & t.flags)) {
                            var n = t.alternate;
                            try {
                                if (0 !== (8772 & t.flags))
                                    switch (t.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        so || mo(5, t);
                                        break;
                                    case 1:
                                        var r = t.stateNode;
                                        if (4 & t.flags && !so)
                                            if (null === n)
                                                r.componentDidMount();
                                            else {
                                                var i = t.elementType === t.type ? n.memoizedProps : en(t.type, n.memoizedProps);
                                                r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                                            }
                                        var o = t.updateQueue;
                                        null !== o && An(t, o, r);
                                        break;
                                    case 3:
                                        var s = t.updateQueue;
                                        if (null !== s) {
                                            if (n = null,
                                            null !== t.child)
                                                switch (t.child.tag) {
                                                case 5:
                                                    n = L(t.child.stateNode);
                                                    break;
                                                case 1:
                                                    n = t.child.stateNode
                                                }
                                            An(t, s, n)
                                        }
                                        break;
                                    case 5:
                                        var l = t.stateNode;
                                        null === n && 4 & t.flags && fe(l, t.type, t.memoizedProps, t);
                                        break;
                                    case 6:
                                    case 4:
                                    case 12:
                                    case 19:
                                    case 17:
                                    case 21:
                                    case 22:
                                    case 23:
                                        break;
                                    case 13:
                                        if (Y && null === t.memoizedState) {
                                            var c = t.alternate;
                                            if (null !== c) {
                                                var u = c.memoizedState;
                                                if (null !== u) {
                                                    var d = u.dehydrated;
                                                    null !== d && Ke(d)
                                                }
                                            }
                                        }
                                        break;
                                    default:
                                        throw Error(a(163))
                                    }
                                so || 512 & t.flags && go(t)
                            } catch (h) {
                                Va(t, t.return, h)
                            }
                        }
                        if (t === e) {
                            co = null;
                            break
                        }
                        if (null !== (n = t.sibling)) {
                            n.return = t.return,
                            co = n;
                            break
                        }
                        co = t.return
                    }
                }
                function Bo(e) {
                    for (; null !== co; ) {
                        var t = co;
                        if (t === e) {
                            co = null;
                            break
                        }
                        var n = t.sibling;
                        if (null !== n) {
                            n.return = t.return,
                            co = n;
                            break
                        }
                        co = t.return
                    }
                }
                function Io(e) {
                    for (; null !== co; ) {
                        var t = co;
                        try {
                            switch (t.tag) {
                            case 0:
                            case 11:
                            case 15:
                                var n = t.return;
                                try {
                                    mo(4, t)
                                } catch (l) {
                                    Va(t, n, l)
                                }
                                break;
                            case 1:
                                var r = t.stateNode;
                                if ("function" === typeof r.componentDidMount) {
                                    var i = t.return;
                                    try {
                                        r.componentDidMount()
                                    } catch (l) {
                                        Va(t, i, l)
                                    }
                                }
                                var o = t.return;
                                try {
                                    go(t)
                                } catch (l) {
                                    Va(t, o, l)
                                }
                                break;
                            case 5:
                                var a = t.return;
                                try {
                                    go(t)
                                } catch (l) {
                                    Va(t, a, l)
                                }
                            }
                        } catch (l) {
                            Va(t, t.return, l)
                        }
                        if (t === e) {
                            co = null;
                            break
                        }
                        var s = t.sibling;
                        if (null !== s) {
                            s.return = t.return,
                            co = s;
                            break
                        }
                        co = t.return
                    }
                }
                var Lo = 0
                  , ko = 1
                  , Do = 2
                  , Oo = 3
                  , No = 4;
                if ("function" === typeof Symbol && Symbol.for) {
                    var Fo = Symbol.for;
                    Lo = Fo("selector.component"),
                    ko = Fo("selector.has_pseudo_class"),
                    Do = Fo("selector.role"),
                    Oo = Fo("selector.test_id"),
                    No = Fo("selector.text")
                }
                function Uo(e) {
                    var t = Q(e);
                    if (null != t) {
                        if ("string" !== typeof t.memoizedProps["data-testname"])
                            throw Error(a(364));
                        return t
                    }
                    if (null === (e = ie(e)))
                        throw Error(a(362));
                    return e.stateNode.current
                }
                function zo(e, t) {
                    switch (t.$$typeof) {
                    case Lo:
                        if (e.type === t.value)
                            return !0;
                        break;
                    case ko:
                        e: {
                            t = t.value,
                            e = [e, 0];
                            for (var n = 0; n < e.length; ) {
                                var r = e[n++]
                                  , i = e[n++]
                                  , o = t[i];
                                if (5 !== r.tag || !se(r)) {
                                    for (; null != o && zo(r, o); )
                                        o = t[++i];
                                    if (i === t.length) {
                                        t = !0;
                                        break e
                                    }
                                    for (r = r.child; null !== r; )
                                        e.push(r, i),
                                        r = r.sibling
                                }
                            }
                            t = !1
                        }
                        return t;
                    case Do:
                        if (5 === e.tag && le(e.stateNode, t.value))
                            return !0;
                        break;
                    case No:
                        if ((5 === e.tag || 6 === e.tag) && (null !== (e = ae(e)) && 0 <= e.indexOf(t.value)))
                            return !0;
                        break;
                    case Oo:
                        if (5 === e.tag && ("string" === typeof (e = e.memoizedProps["data-testname"]) && e.toLowerCase() === t.value.toLowerCase()))
                            return !0;
                        break;
                    default:
                        throw Error(a(365))
                    }
                    return !1
                }
                function Go(e) {
                    switch (e.$$typeof) {
                    case Lo:
                        return "<" + (S(e.value) || "Unknown") + ">";
                    case ko:
                        return ":has(" + (Go(e) || "") + ")";
                    case Do:
                        return '[role="' + e.value + '"]';
                    case No:
                        return '"' + e.value + '"';
                    case Oo:
                        return '[data-testname="' + e.value + '"]';
                    default:
                        throw Error(a(365))
                    }
                }
                function Ho(e, t) {
                    var n = [];
                    e = [e, 0];
                    for (var r = 0; r < e.length; ) {
                        var i = e[r++]
                          , o = e[r++]
                          , a = t[o];
                        if (5 !== i.tag || !se(i)) {
                            for (; null != a && zo(i, a); )
                                a = t[++o];
                            if (o === t.length)
                                n.push(i);
                            else
                                for (i = i.child; null !== i; )
                                    e.push(i, o),
                                    i = i.sibling
                        }
                    }
                    return n
                }
                function jo(e, t) {
                    if (!re)
                        throw Error(a(363));
                    e = Ho(e = Uo(e), t),
                    t = [],
                    e = Array.from(e);
                    for (var n = 0; n < e.length; ) {
                        var r = e[n++];
                        if (5 === r.tag)
                            se(r) || t.push(r.stateNode);
                        else
                            for (r = r.child; null !== r; )
                                e.push(r),
                                r = r.sibling
                    }
                    return t
                }
                var Wo = Math.ceil
                  , Vo = s.ReactCurrentDispatcher
                  , Xo = s.ReactCurrentOwner
                  , Jo = s.ReactCurrentBatchConfig
                  , Ko = 0
                  , qo = null
                  , Yo = null
                  , Qo = 0
                  , Zo = 0
                  , $o = at(0)
                  , ea = 0
                  , ta = null
                  , na = 0
                  , ra = 0
                  , ia = 0
                  , oa = null
                  , aa = null
                  , sa = 0
                  , la = 1 / 0;
                function ca() {
                    la = Ft() + 500
                }
                var ua, da = !1, ha = null, pa = null, fa = !1, ma = null, ga = 0, va = 0, ya = null, ba = -1, _a = 0;
                function Aa() {
                    return 0 !== (6 & Ko) ? Ft() : -1 !== ba ? ba : ba = Ft()
                }
                function xa(e) {
                    return 0 === (1 & e.mode) ? 1 : 0 !== (2 & Ko) && 0 !== Qo ? Qo & -Qo : null !== Qt.transition ? (0 === _a && (e = St,
                    0 === (4194240 & (St <<= 1)) && (St = 64),
                    _a = e),
                    _a) : 0 !== (e = It) ? e : $()
                }
                function Sa(e, t, n) {
                    if (50 < va)
                        throw va = 0,
                        ya = null,
                        Error(a(185));
                    var r = wa(e, t);
                    return null === r ? null : (Pt(r, t, n),
                    0 !== (2 & Ko) && r === qo || (r === qo && (0 === (2 & Ko) && (ra |= t),
                    4 === ea && Ra(r, Qo)),
                    Ea(r, n),
                    1 === t && 0 === Ko && 0 === (1 & e.mode) && (ca(),
                    Jt && Yt())),
                    r)
                }
                function wa(e, t) {
                    e.lanes |= t;
                    var n = e.alternate;
                    for (null !== n && (n.lanes |= t),
                    n = e,
                    e = e.return; null !== e; )
                        e.childLanes |= t,
                        null !== (n = e.alternate) && (n.childLanes |= t),
                        n = e,
                        e = e.return;
                    return 3 === n.tag ? n.stateNode : null
                }
                function Ea(e, t) {
                    var n = e.callbackNode;
                    !function(e, t) {
                        for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o; ) {
                            var a = 31 - _t(o)
                              , s = 1 << a
                              , l = i[a];
                            -1 === l ? 0 !== (s & n) && 0 === (s & r) || (i[a] = Ct(s, t)) : l <= t && (e.expiredLanes |= s),
                            o &= ~s
                        }
                    }(e, t);
                    var r = Mt(e, e === qo ? Qo : 0);
                    if (0 === r)
                        null !== n && Dt(n),
                        e.callbackNode = null,
                        e.callbackPriority = 0;
                    else if (t = r & -r,
                    e.callbackPriority !== t) {
                        if (null != n && Dt(n),
                        1 === t)
                            0 === e.tag ? function(e) {
                                Jt = !0,
                                qt(e)
                            }(Pa.bind(null, e)) : qt(Pa.bind(null, e)),
                            te ? ne((function() {
                                0 === Ko && Yt()
                            }
                            )) : kt(Ut, Yt),
                            n = null;
                        else {
                            switch (Lt(r)) {
                            case 1:
                                n = Ut;
                                break;
                            case 4:
                                n = zt;
                                break;
                            case 16:
                            default:
                                n = Gt;
                                break;
                            case 536870912:
                                n = Ht
                            }
                            n = Ya(n, Ma.bind(null, e))
                        }
                        e.callbackPriority = t,
                        e.callbackNode = n
                    }
                }
                function Ma(e, t) {
                    if (ba = -1,
                    _a = 0,
                    0 !== (6 & Ko))
                        throw Error(a(327));
                    var n = e.callbackNode;
                    if (ja() && e.callbackNode !== n)
                        return null;
                    var r = Mt(e, e === qo ? Qo : 0);
                    if (0 === r)
                        return null;
                    if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t)
                        t = Na(e, r);
                    else {
                        t = r;
                        var i = Ko;
                        Ko |= 2;
                        var o = Da();
                        for (qo === e && Qo === t || (ca(),
                        La(e, t)); ; )
                            try {
                                Ua();
                                break
                            } catch (l) {
                                ka(e, l)
                            }
                        an(),
                        Vo.current = o,
                        Ko = i,
                        null !== Yo ? t = 0 : (qo = null,
                        Qo = 0,
                        t = ea)
                    }
                    if (0 !== t) {
                        if (2 === t && (0 !== (i = Tt(e)) && (r = i,
                        t = Ca(e, i))),
                        1 === t)
                            throw n = ta,
                            La(e, 0),
                            Ra(e, r),
                            Ea(e, Ft()),
                            n;
                        if (6 === t)
                            Ra(e, r);
                        else {
                            if (i = e.current.alternate,
                            0 === (30 & r) && !function(e) {
                                for (var t = e; ; ) {
                                    if (16384 & t.flags) {
                                        var n = t.updateQueue;
                                        if (null !== n && null !== (n = n.stores))
                                            for (var r = 0; r < n.length; r++) {
                                                var i = n[r]
                                                  , o = i.getSnapshot;
                                                i = i.value;
                                                try {
                                                    if (!Vt(o(), i))
                                                        return !1
                                                } catch (s) {
                                                    return !1
                                                }
                                            }
                                    }
                                    if (n = t.child,
                                    16384 & t.subtreeFlags && null !== n)
                                        n.return = t,
                                        t = n;
                                    else {
                                        if (t === e)
                                            break;
                                        for (; null === t.sibling; ) {
                                            if (null === t.return || t.return === e)
                                                return !0;
                                            t = t.return
                                        }
                                        t.sibling.return = t.return,
                                        t = t.sibling
                                    }
                                }
                                return !0
                            }(i) && (2 === (t = Na(e, r)) && (0 !== (o = Tt(e)) && (r = o,
                            t = Ca(e, o))),
                            1 === t))
                                throw n = ta,
                                La(e, 0),
                                Ra(e, r),
                                Ea(e, Ft()),
                                n;
                            switch (e.finishedWork = i,
                            e.finishedLanes = r,
                            t) {
                            case 0:
                            case 1:
                                throw Error(a(345));
                            case 2:
                            case 5:
                                Ha(e, aa);
                                break;
                            case 3:
                                if (Ra(e, r),
                                (130023424 & r) === r && 10 < (t = sa + 500 - Ft())) {
                                    if (0 !== Mt(e, 0))
                                        break;
                                    if (((i = e.suspendedLanes) & r) !== r) {
                                        Aa(),
                                        e.pingedLanes |= e.suspendedLanes & i;
                                        break
                                    }
                                    e.timeoutHandle = W(Ha.bind(null, e, aa), t);
                                    break
                                }
                                Ha(e, aa);
                                break;
                            case 4:
                                if (Ra(e, r),
                                (4194240 & r) === r)
                                    break;
                                for (t = e.eventTimes,
                                i = -1; 0 < r; ) {
                                    var s = 31 - _t(r);
                                    o = 1 << s,
                                    (s = t[s]) > i && (i = s),
                                    r &= ~o
                                }
                                if (r = i,
                                10 < (r = (120 > (r = Ft() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Wo(r / 1960)) - r)) {
                                    e.timeoutHandle = W(Ha.bind(null, e, aa), r);
                                    break
                                }
                                Ha(e, aa);
                                break;
                            default:
                                throw Error(a(329))
                            }
                        }
                    }
                    return Ea(e, Ft()),
                    e.callbackNode === n ? Ma.bind(null, e) : null
                }
                function Ca(e, t) {
                    var n = oa;
                    return e.current.memoizedState.isDehydrated && (La(e, t).flags |= 256),
                    2 !== (e = Na(e, t)) && (t = aa,
                    aa = n,
                    null !== t && Ta(t)),
                    e
                }
                function Ta(e) {
                    null === aa ? aa = e : aa.push.apply(aa, e)
                }
                function Ra(e, t) {
                    for (t &= ~ia,
                    t &= ~ra,
                    e.suspendedLanes |= t,
                    e.pingedLanes &= ~t,
                    e = e.expirationTimes; 0 < t; ) {
                        var n = 31 - _t(t)
                          , r = 1 << n;
                        e[n] = -1,
                        t &= ~r
                    }
                }
                function Pa(e) {
                    if (0 !== (6 & Ko))
                        throw Error(a(327));
                    ja();
                    var t = Mt(e, 0);
                    if (0 === (1 & t))
                        return Ea(e, Ft()),
                        null;
                    var n = Na(e, t);
                    if (0 !== e.tag && 2 === n) {
                        var r = Tt(e);
                        0 !== r && (t = r,
                        n = Ca(e, r))
                    }
                    if (1 === n)
                        throw n = ta,
                        La(e, 0),
                        Ra(e, t),
                        Ea(e, Ft()),
                        n;
                    if (6 === n)
                        throw Error(a(345));
                    return e.finishedWork = e.current.alternate,
                    e.finishedLanes = t,
                    Ha(e, aa),
                    Ea(e, Ft()),
                    null
                }
                function Ba(e) {
                    null !== ma && 0 === ma.tag && 0 === (6 & Ko) && ja();
                    var t = Ko;
                    Ko |= 1;
                    var n = Jo.transition
                      , r = It;
                    try {
                        if (Jo.transition = null,
                        It = 1,
                        e)
                            return e()
                    } finally {
                        It = r,
                        Jo.transition = n,
                        0 === (6 & (Ko = t)) && Yt()
                    }
                }
                function Ia() {
                    Zo = $o.current,
                    st($o)
                }
                function La(e, t) {
                    e.finishedWork = null,
                    e.finishedLanes = 0;
                    var n = e.timeoutHandle;
                    if (n !== X && (e.timeoutHandle = X,
                    V(n)),
                    null !== Yo)
                        for (n = Yo.return; null !== n; ) {
                            var r = n;
                            switch (Gn(r),
                            r.tag) {
                            case 1:
                                null !== (r = r.type.childContextTypes) && void 0 !== r && mt();
                                break;
                            case 3:
                                pr(),
                                st(dt),
                                st(ut),
                                br();
                                break;
                            case 5:
                                mr(r);
                                break;
                            case 4:
                                pr();
                                break;
                            case 13:
                            case 19:
                                st(gr);
                                break;
                            case 10:
                                ln(r.type._context);
                                break;
                            case 22:
                            case 23:
                                Ia()
                            }
                            n = n.return
                        }
                    if (qo = e,
                    Yo = e = es(e.current, null),
                    Qo = Zo = t,
                    ea = 0,
                    ta = null,
                    ia = ra = na = 0,
                    aa = oa = null,
                    null !== hn) {
                        for (t = 0; t < hn.length; t++)
                            if (null !== (r = (n = hn[t]).interleaved)) {
                                n.interleaved = null;
                                var i = r.next
                                  , o = n.pending;
                                if (null !== o) {
                                    var a = o.next;
                                    o.next = i,
                                    r.next = a
                                }
                                n.pending = r
                            }
                        hn = null
                    }
                    return e
                }
                function ka(e, t) {
                    for (; ; ) {
                        var n = Yo;
                        try {
                            if (an(),
                            _r.current = pi,
                            Mr) {
                                for (var r = Sr.memoizedState; null !== r; ) {
                                    var i = r.queue;
                                    null !== i && (i.pending = null),
                                    r = r.next
                                }
                                Mr = !1
                            }
                            if (xr = 0,
                            Er = wr = Sr = null,
                            Cr = !1,
                            Tr = 0,
                            Xo.current = null,
                            null === n || null === n.return) {
                                ea = 1,
                                ta = t,
                                Yo = null;
                                break
                            }
                            e: {
                                var o = e
                                  , s = n.return
                                  , l = n
                                  , c = t;
                                if (t = Qo,
                                l.flags |= 32768,
                                null !== c && "object" === typeof c && "function" === typeof c.then) {
                                    var u = c
                                      , d = l
                                      , h = d.tag;
                                    if (0 === (1 & d.mode) && (0 === h || 11 === h || 15 === h)) {
                                        var p = d.alternate;
                                        p ? (d.updateQueue = p.updateQueue,
                                        d.memoizedState = p.memoizedState,
                                        d.lanes = p.lanes) : (d.updateQueue = null,
                                        d.memoizedState = null)
                                    }
                                    var f = Ci(s);
                                    if (null !== f) {
                                        f.flags &= -257,
                                        Ti(f, s, l, 0, t),
                                        1 & f.mode && Mi(o, u, t),
                                        c = u;
                                        var m = (t = f).updateQueue;
                                        if (null === m) {
                                            var g = new Set;
                                            g.add(c),
                                            t.updateQueue = g
                                        } else
                                            m.add(c);
                                        break e
                                    }
                                    if (0 === (1 & t)) {
                                        Mi(o, u, t),
                                        Oa();
                                        break e
                                    }
                                    c = Error(a(426))
                                } else if (Wn && 1 & l.mode) {
                                    var v = Ci(s);
                                    if (null !== v) {
                                        0 === (65536 & v.flags) && (v.flags |= 256),
                                        Ti(v, s, l, 0, t),
                                        er(c);
                                        break e
                                    }
                                }
                                o = c,
                                4 !== ea && (ea = 2),
                                null === oa ? oa = [o] : oa.push(o),
                                c = vi(c, l),
                                l = s;
                                do {
                                    switch (l.tag) {
                                    case 3:
                                        l.flags |= 65536,
                                        t &= -t,
                                        l.lanes |= t,
                                        bn(l, wi(0, c, t));
                                        break e;
                                    case 1:
                                        o = c;
                                        var y = l.type
                                          , b = l.stateNode;
                                        if (0 === (128 & l.flags) && ("function" === typeof y.getDerivedStateFromError || null !== b && "function" === typeof b.componentDidCatch && (null === pa || !pa.has(b)))) {
                                            l.flags |= 65536,
                                            t &= -t,
                                            l.lanes |= t,
                                            bn(l, Ei(l, o, t));
                                            break e
                                        }
                                    }
                                    l = l.return
                                } while (null !== l)
                            }
                            Ga(n)
                        } catch (_) {
                            t = _,
                            Yo === n && null !== n && (Yo = n = n.return);
                            continue
                        }
                        break
                    }
                }
                function Da() {
                    var e = Vo.current;
                    return Vo.current = pi,
                    null === e ? pi : e
                }
                function Oa() {
                    0 !== ea && 3 !== ea && 2 !== ea || (ea = 4),
                    null === qo || 0 === (268435455 & na) && 0 === (268435455 & ra) || Ra(qo, Qo)
                }
                function Na(e, t) {
                    var n = Ko;
                    Ko |= 2;
                    var r = Da();
                    for (qo === e && Qo === t || La(e, t); ; )
                        try {
                            Fa();
                            break
                        } catch (i) {
                            ka(e, i)
                        }
                    if (an(),
                    Ko = n,
                    Vo.current = r,
                    null !== Yo)
                        throw Error(a(261));
                    return qo = null,
                    Qo = 0,
                    ea
                }
                function Fa() {
                    for (; null !== Yo; )
                        za(Yo)
                }
                function Ua() {
                    for (; null !== Yo && !Ot(); )
                        za(Yo)
                }
                function za(e) {
                    var t = ua(e.alternate, e, Zo);
                    e.memoizedProps = e.pendingProps,
                    null === t ? Ga(e) : Yo = t,
                    Xo.current = null
                }
                function Ga(e) {
                    var t = e;
                    do {
                        var n = t.alternate;
                        if (e = t.return,
                        0 === (32768 & t.flags)) {
                            if (null !== (n = ki(n, t, Zo)))
                                return void (Yo = n)
                        } else {
                            if (null !== (n = oo(n, t)))
                                return n.flags &= 32767,
                                void (Yo = n);
                            if (null === e)
                                return ea = 6,
                                void (Yo = null);
                            e.flags |= 32768,
                            e.subtreeFlags = 0,
                            e.deletions = null
                        }
                        if (null !== (t = t.sibling))
                            return void (Yo = t);
                        Yo = t = e
                    } while (null !== t);
                    0 === ea && (ea = 5)
                }
                function Ha(e, t) {
                    var n = It
                      , r = Jo.transition;
                    try {
                        Jo.transition = null,
                        It = 1,
                        function(e, t, n) {
                            do {
                                ja()
                            } while (null !== ma);
                            if (0 !== (6 & Ko))
                                throw Error(a(327));
                            var r = e.finishedWork
                              , i = e.finishedLanes;
                            if (null === r)
                                return null;
                            if (e.finishedWork = null,
                            e.finishedLanes = 0,
                            r === e.current)
                                throw Error(a(177));
                            e.callbackNode = null,
                            e.callbackPriority = 0;
                            var o = r.lanes | r.childLanes;
                            if (function(e, t) {
                                var n = e.pendingLanes & ~t;
                                e.pendingLanes = t,
                                e.suspendedLanes = 0,
                                e.pingedLanes = 0,
                                e.expiredLanes &= t,
                                e.mutableReadLanes &= t,
                                e.entangledLanes &= t,
                                t = e.entanglements;
                                var r = e.eventTimes;
                                for (e = e.expirationTimes; 0 < n; ) {
                                    var i = 31 - _t(n)
                                      , o = 1 << i;
                                    t[i] = 0,
                                    r[i] = -1,
                                    e[i] = -1,
                                    n &= ~o
                                }
                            }(e, o),
                            e === qo && (Yo = qo = null,
                            Qo = 0),
                            0 === (2064 & r.subtreeFlags) && 0 === (2064 & r.flags) || fa || (fa = !0,
                            Ya(Gt, (function() {
                                return ja(),
                                null
                            }
                            ))),
                            o = 0 !== (15990 & r.flags),
                            0 !== (15990 & r.subtreeFlags) || o) {
                                o = Jo.transition,
                                Jo.transition = null;
                                var s = It;
                                It = 1;
                                var l = Ko;
                                Ko |= 4,
                                Xo.current = null,
                                function(e, t) {
                                    for (O(e.containerInfo),
                                    co = t; null !== co; )
                                        if (t = (e = co).child,
                                        0 !== (1028 & e.subtreeFlags) && null !== t)
                                            t.return = e,
                                            co = t;
                                        else
                                            for (; null !== co; ) {
                                                e = co;
                                                try {
                                                    var n = e.alternate;
                                                    if (0 !== (1024 & e.flags))
                                                        switch (e.tag) {
                                                        case 0:
                                                        case 11:
                                                        case 15:
                                                        case 5:
                                                        case 6:
                                                        case 4:
                                                        case 17:
                                                            break;
                                                        case 1:
                                                            if (null !== n) {
                                                                var r = n.memoizedProps
                                                                  , i = n.memoizedState
                                                                  , o = e.stateNode
                                                                  , s = o.getSnapshotBeforeUpdate(e.elementType === e.type ? r : en(e.type, r), i);
                                                                o.__reactInternalSnapshotBeforeUpdate = s
                                                            }
                                                            break;
                                                        case 3:
                                                            K && Ee(e.stateNode.containerInfo);
                                                            break;
                                                        default:
                                                            throw Error(a(163))
                                                        }
                                                } catch (l) {
                                                    Va(e, e.return, l)
                                                }
                                                if (null !== (t = e.sibling)) {
                                                    t.return = e.return,
                                                    co = t;
                                                    break
                                                }
                                                co = e.return
                                            }
                                    n = po,
                                    po = !1
                                }(e, r),
                                function(e, t) {
                                    for (co = t; null !== co; ) {
                                        var n = (t = co).deletions;
                                        if (null !== n)
                                            for (var r = 0; r < n.length; r++) {
                                                var i = n[r];
                                                try {
                                                    var o = e;
                                                    K ? Eo(o, i, t) : yo(o, i, t);
                                                    var a = i.alternate;
                                                    null !== a && (a.return = null),
                                                    i.return = null
                                                } catch (A) {
                                                    Va(i, t, A)
                                                }
                                            }
                                        if (n = t.child,
                                        0 !== (12854 & t.subtreeFlags) && null !== n)
                                            n.return = t,
                                            co = n;
                                        else
                                            for (; null !== co; ) {
                                                t = co;
                                                try {
                                                    var s = t.flags;
                                                    if (32 & s && K && _e(t.stateNode),
                                                    512 & s) {
                                                        var l = t.alternate;
                                                        if (null !== l) {
                                                            var c = l.ref;
                                                            null !== c && ("function" === typeof c ? c(null) : c.current = null)
                                                        }
                                                    }
                                                    if (8192 & s)
                                                        switch (t.tag) {
                                                        case 13:
                                                            if (null !== t.memoizedState) {
                                                                var u = t.alternate;
                                                                null !== u && null !== u.memoizedState || (sa = Ft())
                                                            }
                                                            break;
                                                        case 22:
                                                            var d = null !== t.memoizedState
                                                              , h = t.alternate
                                                              , p = null !== h && null !== h.memoizedState;
                                                            if (n = t,
                                                            K)
                                                                e: if (r = n,
                                                                i = d,
                                                                o = null,
                                                                K)
                                                                    for (var f = r; ; ) {
                                                                        if (5 === f.tag) {
                                                                            if (null === o) {
                                                                                o = f;
                                                                                var m = f.stateNode;
                                                                                i ? Ae(m) : Se(f.stateNode, f.memoizedProps)
                                                                            }
                                                                        } else if (6 === f.tag) {
                                                                            if (null === o) {
                                                                                var g = f.stateNode;
                                                                                i ? xe(g) : we(g, f.memoizedProps)
                                                                            }
                                                                        } else if ((22 !== f.tag && 23 !== f.tag || null === f.memoizedState || f === r) && null !== f.child) {
                                                                            f.child.return = f,
                                                                            f = f.child;
                                                                            continue
                                                                        }
                                                                        if (f === r)
                                                                            break;
                                                                        for (; null === f.sibling; ) {
                                                                            if (null === f.return || f.return === r)
                                                                                break e;
                                                                            o === f && (o = null),
                                                                            f = f.return
                                                                        }
                                                                        o === f && (o = null),
                                                                        f.sibling.return = f.return,
                                                                        f = f.sibling
                                                                    }
                                                            if (d && !p && 0 !== (1 & n.mode)) {
                                                                co = n;
                                                                for (var v = n.child; null !== v; ) {
                                                                    for (n = co = v; null !== co; ) {
                                                                        var y = (r = co).child;
                                                                        switch (r.tag) {
                                                                        case 0:
                                                                        case 11:
                                                                        case 14:
                                                                        case 15:
                                                                            fo(4, r, r.return);
                                                                            break;
                                                                        case 1:
                                                                            uo(r, r.return);
                                                                            var b = r.stateNode;
                                                                            if ("function" === typeof b.componentWillUnmount) {
                                                                                var _ = r.return;
                                                                                try {
                                                                                    b.props = r.memoizedProps,
                                                                                    b.state = r.memoizedState,
                                                                                    b.componentWillUnmount()
                                                                                } catch (A) {
                                                                                    Va(r, _, A)
                                                                                }
                                                                            }
                                                                            break;
                                                                        case 5:
                                                                            uo(r, r.return);
                                                                            break;
                                                                        case 22:
                                                                            if (null !== r.memoizedState) {
                                                                                Bo(n);
                                                                                continue
                                                                            }
                                                                        }
                                                                        null !== y ? (y.return = r,
                                                                        co = y) : Bo(n)
                                                                    }
                                                                    v = v.sibling
                                                                }
                                                            }
                                                        }
                                                    switch (4102 & s) {
                                                    case 2:
                                                        xo(t),
                                                        t.flags &= -3;
                                                        break;
                                                    case 6:
                                                        xo(t),
                                                        t.flags &= -3,
                                                        Mo(t.alternate, t);
                                                        break;
                                                    case 4096:
                                                        t.flags &= -4097;
                                                        break;
                                                    case 4100:
                                                        t.flags &= -4097,
                                                        Mo(t.alternate, t);
                                                        break;
                                                    case 4:
                                                        Mo(t.alternate, t)
                                                    }
                                                } catch (A) {
                                                    Va(t, t.return, A)
                                                }
                                                if (null !== (n = t.sibling)) {
                                                    n.return = t.return,
                                                    co = n;
                                                    break
                                                }
                                                co = t.return
                                            }
                                    }
                                }(e, r),
                                N(e.containerInfo),
                                e.current = r,
                                To(r, e, i),
                                Nt(),
                                Ko = l,
                                It = s,
                                Jo.transition = o
                            } else
                                e.current = r;
                            if (fa && (fa = !1,
                            ma = e,
                            ga = i),
                            o = e.pendingLanes,
                            0 === o && (pa = null),
                            function(e) {
                                if (Wt && "function" === typeof Wt.onCommitFiberRoot)
                                    try {
                                        Wt.onCommitFiberRoot(jt, e, void 0, 128 === (128 & e.current.flags))
                                    } catch (t) {}
                            }(r.stateNode),
                            Ea(e, Ft()),
                            null !== t)
                                for (n = e.onRecoverableError,
                                r = 0; r < t.length; r++)
                                    n(t[r]);
                            if (da)
                                throw da = !1,
                                e = ha,
                                ha = null,
                                e;
                            0 !== (1 & ga) && 0 !== e.tag && ja(),
                            o = e.pendingLanes,
                            0 !== (1 & o) ? e === ya ? va++ : (va = 0,
                            ya = e) : va = 0,
                            Yt()
                        }(e, t, n)
                    } finally {
                        Jo.transition = r,
                        It = n
                    }
                    return null
                }
                function ja() {
                    if (null !== ma) {
                        var e = Lt(ga)
                          , t = Jo.transition
                          , n = It;
                        try {
                            if (Jo.transition = null,
                            It = 16 > e ? 16 : e,
                            null === ma)
                                var r = !1;
                            else {
                                if (e = ma,
                                ma = null,
                                ga = 0,
                                0 !== (6 & Ko))
                                    throw Error(a(331));
                                var i = Ko;
                                for (Ko |= 4,
                                co = e.current; null !== co; ) {
                                    var o = co
                                      , s = o.child;
                                    if (0 !== (16 & co.flags)) {
                                        var l = o.deletions;
                                        if (null !== l) {
                                            for (var c = 0; c < l.length; c++) {
                                                var u = l[c];
                                                for (co = u; null !== co; ) {
                                                    var d = co;
                                                    switch (d.tag) {
                                                    case 0:
                                                    case 11:
                                                    case 15:
                                                        fo(8, d, o)
                                                    }
                                                    var h = d.child;
                                                    if (null !== h)
                                                        h.return = d,
                                                        co = h;
                                                    else
                                                        for (; null !== co; ) {
                                                            var p = (d = co).sibling
                                                              , f = d.return;
                                                            if (bo(d),
                                                            d === u) {
                                                                co = null;
                                                                break
                                                            }
                                                            if (null !== p) {
                                                                p.return = f,
                                                                co = p;
                                                                break
                                                            }
                                                            co = f
                                                        }
                                                }
                                            }
                                            var m = o.alternate;
                                            if (null !== m) {
                                                var g = m.child;
                                                if (null !== g) {
                                                    m.child = null;
                                                    do {
                                                        var v = g.sibling;
                                                        g.sibling = null,
                                                        g = v
                                                    } while (null !== g)
                                                }
                                            }
                                            co = o
                                        }
                                    }
                                    if (0 !== (2064 & o.subtreeFlags) && null !== s)
                                        s.return = o,
                                        co = s;
                                    else
                                        e: for (; null !== co; ) {
                                            if (0 !== (2048 & (o = co).flags))
                                                switch (o.tag) {
                                                case 0:
                                                case 11:
                                                case 15:
                                                    fo(9, o, o.return)
                                                }
                                            var y = o.sibling;
                                            if (null !== y) {
                                                y.return = o.return,
                                                co = y;
                                                break e
                                            }
                                            co = o.return
                                        }
                                }
                                var b = e.current;
                                for (co = b; null !== co; ) {
                                    var _ = (s = co).child;
                                    if (0 !== (2064 & s.subtreeFlags) && null !== _)
                                        _.return = s,
                                        co = _;
                                    else
                                        e: for (s = b; null !== co; ) {
                                            if (0 !== (2048 & (l = co).flags))
                                                try {
                                                    switch (l.tag) {
                                                    case 0:
                                                    case 11:
                                                    case 15:
                                                        mo(9, l)
                                                    }
                                                } catch (x) {
                                                    Va(l, l.return, x)
                                                }
                                            if (l === s) {
                                                co = null;
                                                break e
                                            }
                                            var A = l.sibling;
                                            if (null !== A) {
                                                A.return = l.return,
                                                co = A;
                                                break e
                                            }
                                            co = l.return
                                        }
                                }
                                if (Ko = i,
                                Yt(),
                                Wt && "function" === typeof Wt.onPostCommitFiberRoot)
                                    try {
                                        Wt.onPostCommitFiberRoot(jt, e)
                                    } catch (x) {}
                                r = !0
                            }
                            return r
                        } finally {
                            It = n,
                            Jo.transition = t
                        }
                    }
                    return !1
                }
                function Wa(e, t, n) {
                    vn(e, t = wi(0, t = vi(n, t), 1)),
                    t = Aa(),
                    null !== (e = wa(e, 1)) && (Pt(e, 1, t),
                    Ea(e, t))
                }
                function Va(e, t, n) {
                    if (3 === e.tag)
                        Wa(e, e, n);
                    else
                        for (; null !== t; ) {
                            if (3 === t.tag) {
                                Wa(t, e, n);
                                break
                            }
                            if (1 === t.tag) {
                                var r = t.stateNode;
                                if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === pa || !pa.has(r))) {
                                    vn(t, e = Ei(t, e = vi(n, e), 1)),
                                    e = Aa(),
                                    null !== (t = wa(t, 1)) && (Pt(t, 1, e),
                                    Ea(t, e));
                                    break
                                }
                            }
                            t = t.return
                        }
                }
                function Xa(e, t, n) {
                    var r = e.pingCache;
                    null !== r && r.delete(t),
                    t = Aa(),
                    e.pingedLanes |= e.suspendedLanes & n,
                    qo === e && (Qo & n) === n && (4 === ea || 3 === ea && (130023424 & Qo) === Qo && 500 > Ft() - sa ? La(e, 0) : ia |= n),
                    Ea(e, t)
                }
                function Ja(e, t) {
                    0 === t && (0 === (1 & e.mode) ? t = 1 : (t = wt,
                    0 === (130023424 & (wt <<= 1)) && (wt = 4194304)));
                    var n = Aa();
                    null !== (e = wa(e, t)) && (Pt(e, t, n),
                    Ea(e, n))
                }
                function Ka(e) {
                    var t = e.memoizedState
                      , n = 0;
                    null !== t && (n = t.retryLane),
                    Ja(e, n)
                }
                function qa(e, t) {
                    var n = 0;
                    switch (e.tag) {
                    case 13:
                        var r = e.stateNode
                          , i = e.memoizedState;
                        null !== i && (n = i.retryLane);
                        break;
                    case 19:
                        r = e.stateNode;
                        break;
                    default:
                        throw Error(a(314))
                    }
                    null !== r && r.delete(t),
                    Ja(e, n)
                }
                function Ya(e, t) {
                    return kt(e, t)
                }
                function Qa(e, t, n, r) {
                    this.tag = e,
                    this.key = n,
                    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
                    this.index = 0,
                    this.ref = null,
                    this.pendingProps = t,
                    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
                    this.mode = r,
                    this.subtreeFlags = this.flags = 0,
                    this.deletions = null,
                    this.childLanes = this.lanes = 0,
                    this.alternate = null
                }
                function Za(e, t, n, r) {
                    return new Qa(e,t,n,r)
                }
                function $a(e) {
                    return !(!(e = e.prototype) || !e.isReactComponent)
                }
                function es(e, t) {
                    var n = e.alternate;
                    return null === n ? ((n = Za(e.tag, t, e.key, e.mode)).elementType = e.elementType,
                    n.type = e.type,
                    n.stateNode = e.stateNode,
                    n.alternate = e,
                    e.alternate = n) : (n.pendingProps = t,
                    n.type = e.type,
                    n.flags = 0,
                    n.subtreeFlags = 0,
                    n.deletions = null),
                    n.flags = 14680064 & e.flags,
                    n.childLanes = e.childLanes,
                    n.lanes = e.lanes,
                    n.child = e.child,
                    n.memoizedProps = e.memoizedProps,
                    n.memoizedState = e.memoizedState,
                    n.updateQueue = e.updateQueue,
                    t = e.dependencies,
                    n.dependencies = null === t ? null : {
                        lanes: t.lanes,
                        firstContext: t.firstContext
                    },
                    n.sibling = e.sibling,
                    n.index = e.index,
                    n.ref = e.ref,
                    n
                }
                function ts(e, t, n, r, i, o) {
                    var s = 2;
                    if (r = e,
                    "function" === typeof e)
                        $a(e) && (s = 1);
                    else if ("string" === typeof e)
                        s = 5;
                    else
                        e: switch (e) {
                        case u:
                            return ns(n.children, i, o, t);
                        case d:
                            s = 8,
                            i |= 8;
                            break;
                        case h:
                            return (e = Za(12, n, t, 2 | i)).elementType = h,
                            e.lanes = o,
                            e;
                        case g:
                            return (e = Za(13, n, t, i)).elementType = g,
                            e.lanes = o,
                            e;
                        case v:
                            return (e = Za(19, n, t, i)).elementType = v,
                            e.lanes = o,
                            e;
                        case _:
                            return rs(n, i, o, t);
                        default:
                            if ("object" === typeof e && null !== e)
                                switch (e.$$typeof) {
                                case p:
                                    s = 10;
                                    break e;
                                case f:
                                    s = 9;
                                    break e;
                                case m:
                                    s = 11;
                                    break e;
                                case y:
                                    s = 14;
                                    break e;
                                case b:
                                    s = 16,
                                    r = null;
                                    break e
                                }
                            throw Error(a(130, null == e ? e : typeof e, ""))
                        }
                    return (t = Za(s, n, t, i)).elementType = e,
                    t.type = r,
                    t.lanes = o,
                    t
                }
                function ns(e, t, n, r) {
                    return (e = Za(7, e, r, t)).lanes = n,
                    e
                }
                function rs(e, t, n, r) {
                    return (e = Za(22, e, r, t)).elementType = _,
                    e.lanes = n,
                    e.stateNode = {},
                    e
                }
                function is(e, t, n) {
                    return (e = Za(6, e, null, t)).lanes = n,
                    e
                }
                function os(e, t, n) {
                    return (t = Za(4, null !== e.children ? e.children : [], e.key, t)).lanes = n,
                    t.stateNode = {
                        containerInfo: e.containerInfo,
                        pendingChildren: null,
                        implementation: e.implementation
                    },
                    t
                }
                function as(e, t, n, r, i) {
                    this.tag = t,
                    this.containerInfo = e,
                    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
                    this.timeoutHandle = X,
                    this.callbackNode = this.pendingContext = this.context = null,
                    this.callbackPriority = 0,
                    this.eventTimes = Rt(0),
                    this.expirationTimes = Rt(-1),
                    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
                    this.entanglements = Rt(0),
                    this.identifierPrefix = r,
                    this.onRecoverableError = i,
                    Y && (this.mutableSourceEagerHydrationData = null)
                }
                function ss(e, t, n, r, i, o, a, s, l) {
                    return e = new as(e,t,n,s,l),
                    1 === t ? (t = 1,
                    !0 === o && (t |= 8)) : t = 0,
                    o = Za(3, null, null, t),
                    e.current = o,
                    o.stateNode = e,
                    o.memoizedState = {
                        element: r,
                        isDehydrated: n,
                        cache: null,
                        transitions: null
                    },
                    fn(o),
                    e
                }
                function ls(e) {
                    if (!e)
                        return ct;
                    e: {
                        if (E(e = e._reactInternals) !== e || 1 !== e.tag)
                            throw Error(a(170));
                        var t = e;
                        do {
                            switch (t.tag) {
                            case 3:
                                t = t.stateNode.context;
                                break e;
                            case 1:
                                if (ft(t.type)) {
                                    t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                                    break e
                                }
                            }
                            t = t.return
                        } while (null !== t);
                        throw Error(a(171))
                    }
                    if (1 === e.tag) {
                        var n = e.type;
                        if (ft(n))
                            return vt(e, n, t)
                    }
                    return t
                }
                function cs(e) {
                    var t = e._reactInternals;
                    if (void 0 === t) {
                        if ("function" === typeof e.render)
                            throw Error(a(188));
                        throw e = Object.keys(e).join(","),
                        Error(a(268, e))
                    }
                    return null === (e = T(t)) ? null : e.stateNode
                }
                function us(e, t) {
                    if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
                        var n = e.retryLane;
                        e.retryLane = 0 !== n && n < t ? n : t
                    }
                }
                function ds(e, t) {
                    us(e, t),
                    (e = e.alternate) && us(e, t)
                }
                function hs(e) {
                    return null === (e = T(e)) ? null : e.stateNode
                }
                function ps() {
                    return null
                }
                return ua = function(e, t, n) {
                    if (null !== e)
                        if (e.memoizedProps !== t.pendingProps || dt.current)
                            Oi = !0;
                        else {
                            if (0 === (e.lanes & n) && 0 === (128 & t.flags))
                                return Oi = !1,
                                function(e, t, n) {
                                    switch (t.tag) {
                                    case 3:
                                        Xi(t),
                                        $n();
                                        break;
                                    case 5:
                                        fr(t);
                                        break;
                                    case 1:
                                        ft(t.type) && yt(t);
                                        break;
                                    case 4:
                                        hr(t, t.stateNode.containerInfo);
                                        break;
                                    case 10:
                                        sn(0, t.type._context, t.memoizedProps.value);
                                        break;
                                    case 13:
                                        var r = t.memoizedState;
                                        if (null !== r)
                                            return null !== r.dehydrated ? (lt(gr, 1 & gr.current),
                                            t.flags |= 128,
                                            null) : 0 !== (n & t.child.childLanes) ? Yi(e, t, n) : (lt(gr, 1 & gr.current),
                                            null !== (e = io(e, t, n)) ? e.sibling : null);
                                        lt(gr, 1 & gr.current);
                                        break;
                                    case 19:
                                        if (r = 0 !== (n & t.childLanes),
                                        0 !== (128 & e.flags)) {
                                            if (r)
                                                return ro(e, t, n);
                                            t.flags |= 128
                                        }
                                        var i = t.memoizedState;
                                        if (null !== i && (i.rendering = null,
                                        i.tail = null,
                                        i.lastEffect = null),
                                        lt(gr, gr.current),
                                        r)
                                            break;
                                        return null;
                                    case 22:
                                    case 23:
                                        return t.lanes = 0,
                                        Gi(e, t, n)
                                    }
                                    return io(e, t, n)
                                }(e, t, n);
                            Oi = 0 !== (131072 & e.flags)
                        }
                    else
                        Oi = !1,
                        Wn && 0 !== (1048576 & t.flags) && Un(t, In, t.index);
                    switch (t.lanes = 0,
                    t.tag) {
                    case 2:
                        var r = t.type;
                        null !== e && (e.alternate = null,
                        t.alternate = null,
                        t.flags |= 2),
                        e = t.pendingProps;
                        var i = pt(t, ut.current);
                        un(t, n),
                        i = Ir(null, t, r, e, i, n);
                        var o = Lr();
                        return t.flags |= 1,
                        "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof ? (t.tag = 1,
                        t.memoizedState = null,
                        t.updateQueue = null,
                        ft(r) ? (o = !0,
                        yt(t)) : o = !1,
                        t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null,
                        fn(t),
                        i.updater = wn,
                        t.stateNode = i,
                        i._reactInternals = t,
                        Tn(t, r, e, n),
                        t = Vi(null, t, r, !0, o, n)) : (t.tag = 0,
                        Wn && o && zn(t),
                        Ni(null, t, i, n),
                        t = t.child),
                        t;
                    case 16:
                        r = t.elementType;
                        e: {
                            switch (null !== e && (e.alternate = null,
                            t.alternate = null,
                            t.flags |= 2),
                            e = t.pendingProps,
                            r = (i = r._init)(r._payload),
                            t.type = r,
                            i = t.tag = function(e) {
                                if ("function" === typeof e)
                                    return $a(e) ? 1 : 0;
                                if (void 0 !== e && null !== e) {
                                    if ((e = e.$$typeof) === m)
                                        return 11;
                                    if (e === y)
                                        return 14
                                }
                                return 2
                            }(r),
                            e = en(r, e),
                            i) {
                            case 0:
                                t = ji(null, t, r, e, n);
                                break e;
                            case 1:
                                t = Wi(null, t, r, e, n);
                                break e;
                            case 11:
                                t = Fi(null, t, r, e, n);
                                break e;
                            case 14:
                                t = Ui(null, t, r, en(r.type, e), n);
                                break e
                            }
                            throw Error(a(306, r, ""))
                        }
                        return t;
                    case 0:
                        return r = t.type,
                        i = t.pendingProps,
                        ji(e, t, r, i = t.elementType === r ? i : en(r, i), n);
                    case 1:
                        return r = t.type,
                        i = t.pendingProps,
                        Wi(e, t, r, i = t.elementType === r ? i : en(r, i), n);
                    case 3:
                        e: {
                            if (Xi(t),
                            null === e)
                                throw Error(a(387));
                            r = t.pendingProps,
                            i = (o = t.memoizedState).element,
                            mn(e, t),
                            _n(t, r, null, n);
                            var s = t.memoizedState;
                            if (r = s.element,
                            Y && o.isDehydrated) {
                                if (o = {
                                    element: r,
                                    isDehydrated: !1,
                                    cache: s.cache,
                                    transitions: s.transitions
                                },
                                t.updateQueue.baseState = o,
                                t.memoizedState = o,
                                256 & t.flags) {
                                    t = Ji(e, t, r, n, i = Error(a(423)));
                                    break e
                                }
                                if (r !== i) {
                                    t = Ji(e, t, r, n, i = Error(a(424)));
                                    break e
                                }
                                for (Y && (jn = Ge(t.stateNode.containerInfo),
                                Hn = t,
                                Wn = !0,
                                Xn = null,
                                Vn = !1),
                                n = ar(t, null, r, n),
                                t.child = n; n; )
                                    n.flags = -3 & n.flags | 4096,
                                    n = n.sibling
                            } else {
                                if ($n(),
                                r === i) {
                                    t = io(e, t, n);
                                    break e
                                }
                                Ni(e, t, r, n)
                            }
                            t = t.child
                        }
                        return t;
                    case 5:
                        return fr(t),
                        null === e && Yn(t),
                        r = t.type,
                        i = t.pendingProps,
                        o = null !== e ? e.memoizedProps : null,
                        s = i.children,
                        H(r, i) ? s = null : null !== o && H(r, o) && (t.flags |= 32),
                        Hi(e, t),
                        Ni(e, t, s, n),
                        t.child;
                    case 6:
                        return null === e && Yn(t),
                        null;
                    case 13:
                        return Yi(e, t, n);
                    case 4:
                        return hr(t, t.stateNode.containerInfo),
                        r = t.pendingProps,
                        null === e ? t.child = or(t, null, r, n) : Ni(e, t, r, n),
                        t.child;
                    case 11:
                        return r = t.type,
                        i = t.pendingProps,
                        Fi(e, t, r, i = t.elementType === r ? i : en(r, i), n);
                    case 7:
                        return Ni(e, t, t.pendingProps, n),
                        t.child;
                    case 8:
                    case 12:
                        return Ni(e, t, t.pendingProps.children, n),
                        t.child;
                    case 10:
                        e: {
                            if (r = t.type._context,
                            i = t.pendingProps,
                            o = t.memoizedProps,
                            sn(0, r, s = i.value),
                            null !== o)
                                if (Vt(o.value, s)) {
                                    if (o.children === i.children && !dt.current) {
                                        t = io(e, t, n);
                                        break e
                                    }
                                } else
                                    for (null !== (o = t.child) && (o.return = t); null !== o; ) {
                                        var l = o.dependencies;
                                        if (null !== l) {
                                            s = o.child;
                                            for (var c = l.firstContext; null !== c; ) {
                                                if (c.context === r) {
                                                    if (1 === o.tag) {
                                                        (c = gn(-1, n & -n)).tag = 2;
                                                        var u = o.updateQueue;
                                                        if (null !== u) {
                                                            var d = (u = u.shared).pending;
                                                            null === d ? c.next = c : (c.next = d.next,
                                                            d.next = c),
                                                            u.pending = c
                                                        }
                                                    }
                                                    o.lanes |= n,
                                                    null !== (c = o.alternate) && (c.lanes |= n),
                                                    cn(o.return, n, t),
                                                    l.lanes |= n;
                                                    break
                                                }
                                                c = c.next
                                            }
                                        } else if (10 === o.tag)
                                            s = o.type === t.type ? null : o.child;
                                        else if (18 === o.tag) {
                                            if (null === (s = o.return))
                                                throw Error(a(341));
                                            s.lanes |= n,
                                            null !== (l = s.alternate) && (l.lanes |= n),
                                            cn(s, n, t),
                                            s = o.sibling
                                        } else
                                            s = o.child;
                                        if (null !== s)
                                            s.return = o;
                                        else
                                            for (s = o; null !== s; ) {
                                                if (s === t) {
                                                    s = null;
                                                    break
                                                }
                                                if (null !== (o = s.sibling)) {
                                                    o.return = s.return,
                                                    s = o;
                                                    break
                                                }
                                                s = s.return
                                            }
                                        o = s
                                    }
                            Ni(e, t, i.children, n),
                            t = t.child
                        }
                        return t;
                    case 9:
                        return i = t.type,
                        r = t.pendingProps.children,
                        un(t, n),
                        r = r(i = dn(i)),
                        t.flags |= 1,
                        Ni(e, t, r, n),
                        t.child;
                    case 14:
                        return i = en(r = t.type, t.pendingProps),
                        Ui(e, t, r, i = en(r.type, i), n);
                    case 15:
                        return zi(e, t, t.type, t.pendingProps, n);
                    case 17:
                        return r = t.type,
                        i = t.pendingProps,
                        i = t.elementType === r ? i : en(r, i),
                        null !== e && (e.alternate = null,
                        t.alternate = null,
                        t.flags |= 2),
                        t.tag = 1,
                        ft(r) ? (e = !0,
                        yt(t)) : e = !1,
                        un(t, n),
                        Mn(t, r, i),
                        Tn(t, r, i, n),
                        Vi(null, t, r, !0, e, n);
                    case 19:
                        return ro(e, t, n);
                    case 22:
                        return Gi(e, t, n)
                    }
                    throw Error(a(156, t.tag))
                }
                ,
                t.attemptContinuousHydration = function(e) {
                    13 === e.tag && (Sa(e, 134217728, Aa()),
                    ds(e, 134217728))
                }
                ,
                t.attemptHydrationAtCurrentPriority = function(e) {
                    if (13 === e.tag) {
                        var t = Aa()
                          , n = xa(e);
                        Sa(e, n, t),
                        ds(e, n)
                    }
                }
                ,
                t.attemptSynchronousHydration = function(e) {
                    switch (e.tag) {
                    case 3:
                        var t = e.stateNode;
                        if (t.current.memoizedState.isDehydrated) {
                            var n = Et(t.pendingLanes);
                            0 !== n && (Bt(t, 1 | n),
                            Ea(t, Ft()),
                            0 === (6 & Ko) && (ca(),
                            Yt()))
                        }
                        break;
                    case 13:
                        var r = Aa();
                        Ba((function() {
                            return Sa(e, 1, r)
                        }
                        )),
                        ds(e, 1)
                    }
                }
                ,
                t.batchedUpdates = function(e, t) {
                    var n = Ko;
                    Ko |= 1;
                    try {
                        return e(t)
                    } finally {
                        0 === (Ko = n) && (ca(),
                        Jt && Yt())
                    }
                }
                ,
                t.createComponentSelector = function(e) {
                    return {
                        $$typeof: Lo,
                        value: e
                    }
                }
                ,
                t.createContainer = function(e, t, n, r, i, o, a) {
                    return ss(e, t, !1, null, 0, r, 0, o, a)
                }
                ,
                t.createHasPseudoClassSelector = function(e) {
                    return {
                        $$typeof: ko,
                        value: e
                    }
                }
                ,
                t.createHydrationContainer = function(e, t, n, r, i, o, a, s, l) {
                    return (e = ss(n, r, !0, e, 0, o, 0, s, l)).context = ls(null),
                    n = e.current,
                    (o = gn(r = Aa(), i = xa(n))).callback = void 0 !== t && null !== t ? t : null,
                    vn(n, o),
                    e.current.lanes = i,
                    Pt(e, i, r),
                    Ea(e, r),
                    e
                }
                ,
                t.createPortal = function(e, t, n) {
                    var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
                    return {
                        $$typeof: c,
                        key: null == r ? null : "" + r,
                        children: e,
                        containerInfo: t,
                        implementation: n
                    }
                }
                ,
                t.createRoleSelector = function(e) {
                    return {
                        $$typeof: Do,
                        value: e
                    }
                }
                ,
                t.createTestNameSelector = function(e) {
                    return {
                        $$typeof: Oo,
                        value: e
                    }
                }
                ,
                t.createTextSelector = function(e) {
                    return {
                        $$typeof: No,
                        value: e
                    }
                }
                ,
                t.deferredUpdates = function(e) {
                    var t = It
                      , n = Jo.transition;
                    try {
                        return Jo.transition = null,
                        It = 16,
                        e()
                    } finally {
                        It = t,
                        Jo.transition = n
                    }
                }
                ,
                t.discreteUpdates = function(e, t, n, r, i) {
                    var o = It
                      , a = Jo.transition;
                    try {
                        return Jo.transition = null,
                        It = 1,
                        e(t, n, r, i)
                    } finally {
                        It = o,
                        Jo.transition = a,
                        0 === Ko && ca()
                    }
                }
                ,
                t.findAllNodes = jo,
                t.findBoundingRects = function(e, t) {
                    if (!re)
                        throw Error(a(363));
                    t = jo(e, t),
                    e = [];
                    for (var n = 0; n < t.length; n++)
                        e.push(oe(t[n]));
                    for (t = e.length - 1; 0 < t; t--)
                        for (var r = (n = e[t]).x, i = r + n.width, o = n.y, s = o + n.height, l = t - 1; 0 <= l; l--)
                            if (t !== l) {
                                var c = e[l]
                                  , u = c.x
                                  , d = u + c.width
                                  , h = c.y
                                  , p = h + c.height;
                                if (r >= u && o >= h && i <= d && s <= p) {
                                    e.splice(t, 1);
                                    break
                                }
                                if (!(r !== u || n.width !== c.width || p < o || h > s)) {
                                    h > o && (c.height += h - o,
                                    c.y = o),
                                    p < s && (c.height = s - h),
                                    e.splice(t, 1);
                                    break
                                }
                                if (!(o !== h || n.height !== c.height || d < r || u > i)) {
                                    u > r && (c.width += u - r,
                                    c.x = r),
                                    d < i && (c.width = i - u),
                                    e.splice(t, 1);
                                    break
                                }
                            }
                    return e
                }
                ,
                t.findHostInstance = cs,
                t.findHostInstanceWithNoPortals = function(e) {
                    return null === (e = null !== (e = C(e)) ? P(e) : null) ? null : e.stateNode
                }
                ,
                t.findHostInstanceWithWarning = function(e) {
                    return cs(e)
                }
                ,
                t.flushControlled = function(e) {
                    var t = Ko;
                    Ko |= 1;
                    var n = Jo.transition
                      , r = It;
                    try {
                        Jo.transition = null,
                        It = 1,
                        e()
                    } finally {
                        It = r,
                        Jo.transition = n,
                        0 === (Ko = t) && (ca(),
                        Yt())
                    }
                }
                ,
                t.flushPassiveEffects = ja,
                t.flushSync = Ba,
                t.focusWithin = function(e, t) {
                    if (!re)
                        throw Error(a(363));
                    for (t = Ho(e = Uo(e), t),
                    t = Array.from(t),
                    e = 0; e < t.length; ) {
                        var n = t[e++];
                        if (!se(n)) {
                            if (5 === n.tag && ce(n.stateNode))
                                return !0;
                            for (n = n.child; null !== n; )
                                t.push(n),
                                n = n.sibling
                        }
                    }
                    return !1
                }
                ,
                t.getCurrentUpdatePriority = function() {
                    return It
                }
                ,
                t.getFindAllNodesFailureDescription = function(e, t) {
                    if (!re)
                        throw Error(a(363));
                    var n = 0
                      , r = [];
                    e = [Uo(e), 0];
                    for (var i = 0; i < e.length; ) {
                        var o = e[i++]
                          , s = e[i++]
                          , l = t[s];
                        if ((5 !== o.tag || !se(o)) && (zo(o, l) && (r.push(Go(l)),
                        ++s > n && (n = s)),
                        s < t.length))
                            for (o = o.child; null !== o; )
                                e.push(o, s),
                                o = o.sibling
                    }
                    if (n < t.length) {
                        for (e = []; n < t.length; n++)
                            e.push(Go(t[n]));
                        return "findAllNodes was able to match part of the selector:\n  " + r.join(" > ") + "\n\nNo matching component was found for:\n  " + e.join(" > ")
                    }
                    return null
                }
                ,
                t.getPublicRootInstance = function(e) {
                    return (e = e.current).child ? 5 === e.child.tag ? L(e.child.stateNode) : e.child.stateNode : null
                }
                ,
                t.injectIntoDevTools = function(e) {
                    if (e = {
                        bundleType: e.bundleType,
                        version: e.version,
                        rendererPackageName: e.rendererPackageName,
                        rendererConfig: e.rendererConfig,
                        overrideHookState: null,
                        overrideHookStateDeletePath: null,
                        overrideHookStateRenamePath: null,
                        overrideProps: null,
                        overridePropsDeletePath: null,
                        overridePropsRenamePath: null,
                        setErrorHandler: null,
                        setSuspenseHandler: null,
                        scheduleUpdate: null,
                        currentDispatcherRef: s.ReactCurrentDispatcher,
                        findHostInstanceByFiber: hs,
                        findFiberByHostInstance: e.findFiberByHostInstance || ps,
                        findHostInstancesForRefresh: null,
                        scheduleRefresh: null,
                        scheduleRoot: null,
                        setRefreshHandler: null,
                        getCurrentFiber: null,
                        reconcilerVersion: "18.0.0-fc46dba67-20220329"
                    },
                    "undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)
                        e = !1;
                    else {
                        var t = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                        if (t.isDisabled || !t.supportsFiber)
                            e = !0;
                        else {
                            try {
                                jt = t.inject(e),
                                Wt = t
                            } catch (n) {}
                            e = !!t.checkDCE
                        }
                    }
                    return e
                }
                ,
                t.isAlreadyRendering = function() {
                    return !1
                }
                ,
                t.observeVisibleRects = function(e, t, n, r) {
                    if (!re)
                        throw Error(a(363));
                    e = jo(e, t);
                    var i = ue(e, n, r).disconnect;
                    return {
                        disconnect: function() {
                            i()
                        }
                    }
                }
                ,
                t.registerMutableSourceForHydration = function(e, t) {
                    var n = t._getVersion;
                    n = n(t._source),
                    null == e.mutableSourceEagerHydrationData ? e.mutableSourceEagerHydrationData = [t, n] : e.mutableSourceEagerHydrationData.push(t, n)
                }
                ,
                t.runWithPriority = function(e, t) {
                    var n = It;
                    try {
                        return It = e,
                        t()
                    } finally {
                        It = n
                    }
                }
                ,
                t.shouldError = function() {
                    return null
                }
                ,
                t.shouldSuspend = function() {
                    return !1
                }
                ,
                t.updateContainer = function(e, t, n, r) {
                    var i = t.current
                      , o = Aa()
                      , a = xa(i);
                    return n = ls(n),
                    null === t.context ? t.context = n : t.pendingContext = n,
                    (t = gn(o, a)).payload = {
                        element: e
                    },
                    null !== (r = void 0 === r ? null : r) && (t.callback = r),
                    vn(i, t),
                    null !== (e = Sa(i, a, o)) && yn(e, i, a),
                    a
                }
                ,
                t
            }
        }
        ,
        3878: (e, t, n) => {
            "use strict";
            e.exports = n(1153)
        }
        ,
        9235: (e, t, n) => {
            "use strict";
            e.exports = n(8473)
        }
        ,
        2654: (e, t, n) => {
            "use strict";
            var r = n(9950)
              , i = Symbol.for("react.element")
              , o = Symbol.for("react.fragment")
              , a = Object.prototype.hasOwnProperty
              , s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
              , l = {
                key: !0,
                ref: !0,
                __self: !0,
                __source: !0
            };
            function c(e, t, n) {
                var r, o = {}, c = null, u = null;
                for (r in void 0 !== n && (c = "" + n),
                void 0 !== t.key && (c = "" + t.key),
                void 0 !== t.ref && (u = t.ref),
                t)
                    a.call(t, r) && !l.hasOwnProperty(r) && (o[r] = t[r]);
                if (e && e.defaultProps)
                    for (r in t = e.defaultProps)
                        void 0 === o[r] && (o[r] = t[r]);
                return {
                    $$typeof: i,
                    type: e,
                    key: c,
                    ref: u,
                    props: o,
                    _owner: s.current
                }
            }
            t.Fragment = o,
            t.jsx = c,
            t.jsxs = c
        }
        ,
        2049: (e, t) => {
            "use strict";
            var n = Symbol.for("react.element")
              , r = Symbol.for("react.portal")
              , i = Symbol.for("react.fragment")
              , o = Symbol.for("react.strict_mode")
              , a = Symbol.for("react.profiler")
              , s = Symbol.for("react.provider")
              , l = Symbol.for("react.context")
              , c = Symbol.for("react.forward_ref")
              , u = Symbol.for("react.suspense")
              , d = Symbol.for("react.memo")
              , h = Symbol.for("react.lazy")
              , p = Symbol.iterator;
            var f = {
                isMounted: function() {
                    return !1
                },
                enqueueForceUpdate: function() {},
                enqueueReplaceState: function() {},
                enqueueSetState: function() {}
            }
              , m = Object.assign
              , g = {};
            function v(e, t, n) {
                this.props = e,
                this.context = t,
                this.refs = g,
                this.updater = n || f
            }
            function y() {}
            function b(e, t, n) {
                this.props = e,
                this.context = t,
                this.refs = g,
                this.updater = n || f
            }
            v.prototype.isReactComponent = {},
            v.prototype.setState = function(e, t) {
                if ("object" !== typeof e && "function" !== typeof e && null != e)
                    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
                this.updater.enqueueSetState(this, e, t, "setState")
            }
            ,
            v.prototype.forceUpdate = function(e) {
                this.updater.enqueueForceUpdate(this, e, "forceUpdate")
            }
            ,
            y.prototype = v.prototype;
            var _ = b.prototype = new y;
            _.constructor = b,
            m(_, v.prototype),
            _.isPureReactComponent = !0;
            var A = Array.isArray
              , x = Object.prototype.hasOwnProperty
              , S = {
                current: null
            }
              , w = {
                key: !0,
                ref: !0,
                __self: !0,
                __source: !0
            };
            function E(e, t, r) {
                var i, o = {}, a = null, s = null;
                if (null != t)
                    for (i in void 0 !== t.ref && (s = t.ref),
                    void 0 !== t.key && (a = "" + t.key),
                    t)
                        x.call(t, i) && !w.hasOwnProperty(i) && (o[i] = t[i]);
                var l = arguments.length - 2;
                if (1 === l)
                    o.children = r;
                else if (1 < l) {
                    for (var c = Array(l), u = 0; u < l; u++)
                        c[u] = arguments[u + 2];
                    o.children = c
                }
                if (e && e.defaultProps)
                    for (i in l = e.defaultProps)
                        void 0 === o[i] && (o[i] = l[i]);
                return {
                    $$typeof: n,
                    type: e,
                    key: a,
                    ref: s,
                    props: o,
                    _owner: S.current
                }
            }
            function M(e) {
                return "object" === typeof e && null !== e && e.$$typeof === n
            }
            var C = /\/+/g;
            function T(e, t) {
                return "object" === typeof e && null !== e && null != e.key ? function(e) {
                    var t = {
                        "=": "=0",
                        ":": "=2"
                    };
                    return "$" + e.replace(/[=:]/g, (function(e) {
                        return t[e]
                    }
                    ))
                }("" + e.key) : t.toString(36)
            }
            function R(e, t, i, o, a) {
                var s = typeof e;
                "undefined" !== s && "boolean" !== s || (e = null);
                var l = !1;
                if (null === e)
                    l = !0;
                else
                    switch (s) {
                    case "string":
                    case "number":
                        l = !0;
                        break;
                    case "object":
                        switch (e.$$typeof) {
                        case n:
                        case r:
                            l = !0
                        }
                    }
                if (l)
                    return a = a(l = e),
                    e = "" === o ? "." + T(l, 0) : o,
                    A(a) ? (i = "",
                    null != e && (i = e.replace(C, "$&/") + "/"),
                    R(a, t, i, "", (function(e) {
                        return e
                    }
                    ))) : null != a && (M(a) && (a = function(e, t) {
                        return {
                            $$typeof: n,
                            type: e.type,
                            key: t,
                            ref: e.ref,
                            props: e.props,
                            _owner: e._owner
                        }
                    }(a, i + (!a.key || l && l.key === a.key ? "" : ("" + a.key).replace(C, "$&/") + "/") + e)),
                    t.push(a)),
                    1;
                if (l = 0,
                o = "" === o ? "." : o + ":",
                A(e))
                    for (var c = 0; c < e.length; c++) {
                        var u = o + T(s = e[c], c);
                        l += R(s, t, i, u, a)
                    }
                else if (u = function(e) {
                    return null === e || "object" !== typeof e ? null : "function" === typeof (e = p && e[p] || e["@@iterator"]) ? e : null
                }(e),
                "function" === typeof u)
                    for (e = u.call(e),
                    c = 0; !(s = e.next()).done; )
                        l += R(s = s.value, t, i, u = o + T(s, c++), a);
                else if ("object" === s)
                    throw t = String(e),
                    Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
                return l
            }
            function P(e, t, n) {
                if (null == e)
                    return e;
                var r = []
                  , i = 0;
                return R(e, r, "", "", (function(e) {
                    return t.call(n, e, i++)
                }
                )),
                r
            }
            function B(e) {
                if (-1 === e._status) {
                    var t = e._result;
                    (t = t()).then((function(t) {
                        0 !== e._status && -1 !== e._status || (e._status = 1,
                        e._result = t)
                    }
                    ), (function(t) {
                        0 !== e._status && -1 !== e._status || (e._status = 2,
                        e._result = t)
                    }
                    )),
                    -1 === e._status && (e._status = 0,
                    e._result = t)
                }
                if (1 === e._status)
                    return e._result.default;
                throw e._result
            }
            var I = {
                current: null
            }
              , L = {
                transition: null
            }
              , k = {
                ReactCurrentDispatcher: I,
                ReactCurrentBatchConfig: L,
                ReactCurrentOwner: S
            };
            function D() {
                throw Error("act(...) is not supported in production builds of React.")
            }
            t.Children = {
                map: P,
                forEach: function(e, t, n) {
                    P(e, (function() {
                        t.apply(this, arguments)
                    }
                    ), n)
                },
                count: function(e) {
                    var t = 0;
                    return P(e, (function() {
                        t++
                    }
                    )),
                    t
                },
                toArray: function(e) {
                    return P(e, (function(e) {
                        return e
                    }
                    )) || []
                },
                only: function(e) {
                    if (!M(e))
                        throw Error("React.Children.only expected to receive a single React element child.");
                    return e
                }
            },
            t.Component = v,
            t.Fragment = i,
            t.Profiler = a,
            t.PureComponent = b,
            t.StrictMode = o,
            t.Suspense = u,
            t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = k,
            t.act = D,
            t.cloneElement = function(e, t, r) {
                if (null === e || void 0 === e)
                    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
                var i = m({}, e.props)
                  , o = e.key
                  , a = e.ref
                  , s = e._owner;
                if (null != t) {
                    if (void 0 !== t.ref && (a = t.ref,
                    s = S.current),
                    void 0 !== t.key && (o = "" + t.key),
                    e.type && e.type.defaultProps)
                        var l = e.type.defaultProps;
                    for (c in t)
                        x.call(t, c) && !w.hasOwnProperty(c) && (i[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c])
                }
                var c = arguments.length - 2;
                if (1 === c)
                    i.children = r;
                else if (1 < c) {
                    l = Array(c);
                    for (var u = 0; u < c; u++)
                        l[u] = arguments[u + 2];
                    i.children = l
                }
                return {
                    $$typeof: n,
                    type: e.type,
                    key: o,
                    ref: a,
                    props: i,
                    _owner: s
                }
            }
            ,
            t.createContext = function(e) {
                return (e = {
                    $$typeof: l,
                    _currentValue: e,
                    _currentValue2: e,
                    _threadCount: 0,
                    Provider: null,
                    Consumer: null,
                    _defaultValue: null,
                    _globalName: null
                }).Provider = {
                    $$typeof: s,
                    _context: e
                },
                e.Consumer = e
            }
            ,
            t.createElement = E,
            t.createFactory = function(e) {
                var t = E.bind(null, e);
                return t.type = e,
                t
            }
            ,
            t.createRef = function() {
                return {
                    current: null
                }
            }
            ,
            t.forwardRef = function(e) {
                return {
                    $$typeof: c,
                    render: e
                }
            }
            ,
            t.isValidElement = M,
            t.lazy = function(e) {
                return {
                    $$typeof: h,
                    _payload: {
                        _status: -1,
                        _result: e
                    },
                    _init: B
                }
            }
            ,
            t.memo = function(e, t) {
                return {
                    $$typeof: d,
                    type: e,
                    compare: void 0 === t ? null : t
                }
            }
            ,
            t.startTransition = function(e) {
                var t = L.transition;
                L.transition = {};
                try {
                    e()
                } finally {
                    L.transition = t
                }
            }
            ,
            t.unstable_act = D,
            t.useCallback = function(e, t) {
                return I.current.useCallback(e, t)
            }
            ,
            t.useContext = function(e) {
                return I.current.useContext(e)
            }
            ,
            t.useDebugValue = function() {}
            ,
            t.useDeferredValue = function(e) {
                return I.current.useDeferredValue(e)
            }
            ,
            t.useEffect = function(e, t) {
                return I.current.useEffect(e, t)
            }
            ,
            t.useId = function() {
                return I.current.useId()
            }
            ,
            t.useImperativeHandle = function(e, t, n) {
                return I.current.useImperativeHandle(e, t, n)
            }
            ,
            t.useInsertionEffect = function(e, t) {
                return I.current.useInsertionEffect(e, t)
            }
            ,
            t.useLayoutEffect = function(e, t) {
                return I.current.useLayoutEffect(e, t)
            }
            ,
            t.useMemo = function(e, t) {
                return I.current.useMemo(e, t)
            }
            ,
            t.useReducer = function(e, t, n) {
                return I.current.useReducer(e, t, n)
            }
            ,
            t.useRef = function(e) {
                return I.current.useRef(e)
            }
            ,
            t.useState = function(e) {
                return I.current.useState(e)
            }
            ,
            t.useSyncExternalStore = function(e, t, n) {
                return I.current.useSyncExternalStore(e, t, n)
            }
            ,
            t.useTransition = function() {
                return I.current.useTransition()
            }
            ,
            t.version = "18.3.1"
        }
        ,
        9950: (e, t, n) => {
            "use strict";
            e.exports = n(2049)
        }
        ,
        4414: (e, t, n) => {
            "use strict";
            e.exports = n(2654)
        }
        ,
        1761: (e, t) => {
            "use strict";
            function n(e, t) {
                var n = e.length;
                e.push(t);
                e: for (; 0 < n; ) {
                    var r = n - 1 >>> 1
                      , i = e[r];
                    if (!(0 < o(i, t)))
                        break e;
                    e[r] = t,
                    e[n] = i,
                    n = r
                }
            }
            function r(e) {
                return 0 === e.length ? null : e[0]
            }
            function i(e) {
                if (0 === e.length)
                    return null;
                var t = e[0]
                  , n = e.pop();
                if (n !== t) {
                    e[0] = n;
                    e: for (var r = 0, i = e.length, a = i >>> 1; r < a; ) {
                        var s = 2 * (r + 1) - 1
                          , l = e[s]
                          , c = s + 1
                          , u = e[c];
                        if (0 > o(l, n))
                            c < i && 0 > o(u, l) ? (e[r] = u,
                            e[c] = n,
                            r = c) : (e[r] = l,
                            e[s] = n,
                            r = s);
                        else {
                            if (!(c < i && 0 > o(u, n)))
                                break e;
                            e[r] = u,
                            e[c] = n,
                            r = c
                        }
                    }
                }
                return t
            }
            function o(e, t) {
                var n = e.sortIndex - t.sortIndex;
                return 0 !== n ? n : e.id - t.id
            }
            if ("object" === typeof performance && "function" === typeof performance.now) {
                var a = performance;
                t.unstable_now = function() {
                    return a.now()
                }
            } else {
                var s = Date
                  , l = s.now();
                t.unstable_now = function() {
                    return s.now() - l
                }
            }
            var c = []
              , u = []
              , d = 1
              , h = null
              , p = 3
              , f = !1
              , m = !1
              , g = !1
              , v = "function" === typeof setTimeout ? setTimeout : null
              , y = "function" === typeof clearTimeout ? clearTimeout : null
              , b = "undefined" !== typeof setImmediate ? setImmediate : null;
            function _(e) {
                for (var t = r(u); null !== t; ) {
                    if (null === t.callback)
                        i(u);
                    else {
                        if (!(t.startTime <= e))
                            break;
                        i(u),
                        t.sortIndex = t.expirationTime,
                        n(c, t)
                    }
                    t = r(u)
                }
            }
            function A(e) {
                if (g = !1,
                _(e),
                !m)
                    if (null !== r(c))
                        m = !0,
                        L(x);
                    else {
                        var t = r(u);
                        null !== t && k(A, t.startTime - e)
                    }
            }
            function x(e, n) {
                m = !1,
                g && (g = !1,
                y(M),
                M = -1),
                f = !0;
                var o = p;
                try {
                    for (_(n),
                    h = r(c); null !== h && (!(h.expirationTime > n) || e && !R()); ) {
                        var a = h.callback;
                        if ("function" === typeof a) {
                            h.callback = null,
                            p = h.priorityLevel;
                            var s = a(h.expirationTime <= n);
                            n = t.unstable_now(),
                            "function" === typeof s ? h.callback = s : h === r(c) && i(c),
                            _(n)
                        } else
                            i(c);
                        h = r(c)
                    }
                    if (null !== h)
                        var l = !0;
                    else {
                        var d = r(u);
                        null !== d && k(A, d.startTime - n),
                        l = !1
                    }
                    return l
                } finally {
                    h = null,
                    p = o,
                    f = !1
                }
            }
            "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
            var S, w = !1, E = null, M = -1, C = 5, T = -1;
            function R() {
                return !(t.unstable_now() - T < C)
            }
            function P() {
                if (null !== E) {
                    var e = t.unstable_now();
                    T = e;
                    var n = !0;
                    try {
                        n = E(!0, e)
                    } finally {
                        n ? S() : (w = !1,
                        E = null)
                    }
                } else
                    w = !1
            }
            if ("function" === typeof b)
                S = function() {
                    b(P)
                }
                ;
            else if ("undefined" !== typeof MessageChannel) {
                var B = new MessageChannel
                  , I = B.port2;
                B.port1.onmessage = P,
                S = function() {
                    I.postMessage(null)
                }
            } else
                S = function() {
                    v(P, 0)
                }
                ;
            function L(e) {
                E = e,
                w || (w = !0,
                S())
            }
            function k(e, n) {
                M = v((function() {
                    e(t.unstable_now())
                }
                ), n)
            }
            t.unstable_IdlePriority = 5,
            t.unstable_ImmediatePriority = 1,
            t.unstable_LowPriority = 4,
            t.unstable_NormalPriority = 3,
            t.unstable_Profiling = null,
            t.unstable_UserBlockingPriority = 2,
            t.unstable_cancelCallback = function(e) {
                e.callback = null
            }
            ,
            t.unstable_continueExecution = function() {
                m || f || (m = !0,
                L(x))
            }
            ,
            t.unstable_forceFrameRate = function(e) {
                0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < e ? Math.floor(1e3 / e) : 5
            }
            ,
            t.unstable_getCurrentPriorityLevel = function() {
                return p
            }
            ,
            t.unstable_getFirstCallbackNode = function() {
                return r(c)
            }
            ,
            t.unstable_next = function(e) {
                switch (p) {
                case 1:
                case 2:
                case 3:
                    var t = 3;
                    break;
                default:
                    t = p
                }
                var n = p;
                p = t;
                try {
                    return e()
                } finally {
                    p = n
                }
            }
            ,
            t.unstable_pauseExecution = function() {}
            ,
            t.unstable_requestPaint = function() {}
            ,
            t.unstable_runWithPriority = function(e, t) {
                switch (e) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                default:
                    e = 3
                }
                var n = p;
                p = e;
                try {
                    return t()
                } finally {
                    p = n
                }
            }
            ,
            t.unstable_scheduleCallback = function(e, i, o) {
                var a = t.unstable_now();
                switch ("object" === typeof o && null !== o ? o = "number" === typeof (o = o.delay) && 0 < o ? a + o : a : o = a,
                e) {
                case 1:
                    var s = -1;
                    break;
                case 2:
                    s = 250;
                    break;
                case 5:
                    s = 1073741823;
                    break;
                case 4:
                    s = 1e4;
                    break;
                default:
                    s = 5e3
                }
                return e = {
                    id: d++,
                    callback: i,
                    priorityLevel: e,
                    startTime: o,
                    expirationTime: s = o + s,
                    sortIndex: -1
                },
                o > a ? (e.sortIndex = o,
                n(u, e),
                null === r(c) && e === r(u) && (g ? (y(M),
                M = -1) : g = !0,
                k(A, o - a))) : (e.sortIndex = s,
                n(c, e),
                m || f || (m = !0,
                L(x))),
                e
            }
            ,
            t.unstable_shouldYield = R,
            t.unstable_wrapCallback = function(e) {
                var t = p;
                return function() {
                    var n = p;
                    p = t;
                    try {
                        return e.apply(this, arguments)
                    } finally {
                        p = n
                    }
                }
            }
        }
        ,
        5340: (e, t, n) => {
            "use strict";
            e.exports = n(1761)
        }
        ,
        403: e => {
            e.exports = function(e, t, n, r) {
                var i = n ? n.call(r, e, t) : void 0;
                if (void 0 !== i)
                    return !!i;
                if (e === t)
                    return !0;
                if ("object" !== typeof e || !e || "object" !== typeof t || !t)
                    return !1;
                var o = Object.keys(e)
                  , a = Object.keys(t);
                if (o.length !== a.length)
                    return !1;
                for (var s = Object.prototype.hasOwnProperty.bind(t), l = 0; l < o.length; l++) {
                    var c = o[l];
                    if (!s(c))
                        return !1;
                    var u = e[c]
                      , d = t[c];
                    if (!1 === (i = n ? n.call(r, u, d, c) : void 0) || void 0 === i && u !== d)
                        return !1
                }
                return !0
            }
        }
        ,
        1672: (e, t, n) => {
            "use strict";
            var r = n(9950);
            var i = "function" === typeof Object.is ? Object.is : function(e, t) {
                return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
            }
              , o = r.useSyncExternalStore
              , a = r.useRef
              , s = r.useEffect
              , l = r.useMemo
              , c = r.useDebugValue;
            t.useSyncExternalStoreWithSelector = function(e, t, n, r, u) {
                var d = a(null);
                if (null === d.current) {
                    var h = {
                        hasValue: !1,
                        value: null
                    };
                    d.current = h
                } else
                    h = d.current;
                d = l((function() {
                    function e(e) {
                        if (!s) {
                            if (s = !0,
                            o = e,
                            e = r(e),
                            void 0 !== u && h.hasValue) {
                                var t = h.value;
                                if (u(t, e))
                                    return a = t
                            }
                            return a = e
                        }
                        if (t = a,
                        i(o, e))
                            return t;
                        var n = r(e);
                        return void 0 !== u && u(t, n) ? t : (o = e,
                        a = n)
                    }
                    var o, a, s = !1, l = void 0 === n ? null : n;
                    return [function() {
                        return e(t())
                    }
                    , null === l ? void 0 : function() {
                        return e(l())
                    }
                    ]
                }
                ), [t, n, r, u]);
                var p = o(e, d[0], d[1]);
                return s((function() {
                    h.hasValue = !0,
                    h.value = p
                }
                ), [p]),
                c(p),
                p
            }
        }
        ,
        7256: (e, t, n) => {
            "use strict";
            e.exports = n(1672)
        }
        ,
        7413: e => {
            e.exports = {
                area: !0,
                base: !0,
                br: !0,
                col: !0,
                embed: !0,
                hr: !0,
                img: !0,
                input: !0,
                link: !0,
                meta: !0,
                param: !0,
                source: !0,
                track: !0,
                wbr: !0
            }
        }
        ,
        4634: e => {
            function t() {
                return e.exports = t = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var r in n)
                            ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
                    }
                    return e
                }
                ,
                e.exports.__esModule = !0,
                e.exports.default = e.exports,
                t.apply(null, arguments)
            }
            e.exports = t,
            e.exports.__esModule = !0,
            e.exports.default = e.exports
        }
        ,
        4994: e => {
            e.exports = function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            ,
            e.exports.__esModule = !0,
            e.exports.default = e.exports
        }
        ,
        4893: e => {
            e.exports = function(e, t) {
                if (null == e)
                    return {};
                var n = {};
                for (var r in e)
                    if ({}.hasOwnProperty.call(e, r)) {
                        if (t.includes(r))
                            continue;
                        n[r] = e[r]
                    }
                return n
            }
            ,
            e.exports.__esModule = !0,
            e.exports.default = e.exports
        }
        ,
        8168: (e, t, n) => {
            "use strict";
            function r() {
                return r = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var r in n)
                            ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
                    }
                    return e
                }
                ,
                r.apply(null, arguments)
            }
            n.d(t, {
                A: () => r
            })
        }
        ,
        8587: (e, t, n) => {
            "use strict";
            function r(e, t) {
                if (null == e)
                    return {};
                var n = {};
                for (var r in e)
                    if ({}.hasOwnProperty.call(e, r)) {
                        if (t.includes(r))
                            continue;
                        n[r] = e[r]
                    }
                return n
            }
            n.d(t, {
                A: () => r
            })
        }
        ,
        533: (e, t, n) => {
            "use strict";
            function r(e) {
                var t, n, i = "";
                if ("string" == typeof e || "number" == typeof e)
                    i += e;
                else if ("object" == typeof e)
                    if (Array.isArray(e)) {
                        var o = e.length;
                        for (t = 0; t < o; t++)
                            e[t] && (n = r(e[t])) && (i && (i += " "),
                            i += n)
                    } else
                        for (n in e)
                            e[n] && (i && (i += " "),
                            i += n);
                return i
            }
            n.d(t, {
                A: () => i
            });
            const i = function() {
                for (var e, t, n = 0, i = "", o = arguments.length; n < o; n++)
                    (e = arguments[n]) && (t = r(e)) && (i && (i += " "),
                    i += t);
                return i
            }
        }
    }
      , __webpack_module_cache__ = {};
    function __webpack_require__(e) {
        var t = __webpack_module_cache__[e];
        if (void 0 !== t)
            return t.exports;
        var n = __webpack_module_cache__[e] = {
            exports: {}
        };
        return __webpack_modules__[e](n, n.exports, __webpack_require__),
        n.exports
    }
    __webpack_require__.m = __webpack_modules__,
    __webpack_require__.n = e => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return __webpack_require__.d(t, {
            a: t
        }),
        t
    }
    ,
    ( () => {
        var e, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__;
        __webpack_require__.t = function(n, r) {
            if (1 & r && (n = this(n)),
            8 & r)
                return n;
            if ("object" === typeof n && n) {
                if (4 & r && n.__esModule)
                    return n;
                if (16 & r && "function" === typeof n.then)
                    return n
            }
            var i = Object.create(null);
            __webpack_require__.r(i);
            var o = {};
            e = e || [null, t({}), t([]), t(t)];
            for (var a = 2 & r && n; "object" == typeof a && !~e.indexOf(a); a = t(a))
                Object.getOwnPropertyNames(a).forEach((e => o[e] = () => n[e]));
            return o.default = () => n,
            __webpack_require__.d(i, o),
            i
        }
    }
    )(),
    __webpack_require__.d = (e, t) => {
        for (var n in t)
            __webpack_require__.o(t, n) && !__webpack_require__.o(e, n) && Object.defineProperty(e, n, {
                enumerable: !0,
                get: t[n]
            })
    }
    ,
    __webpack_require__.f = {},
    __webpack_require__.e = e => Promise.all(Object.keys(__webpack_require__.f).reduce(( (t, n) => (__webpack_require__.f[n](e, t),
    t)), [])),
    __webpack_require__.u = e => "static/js/" + e + ".2bd8af74.chunk.js",
    __webpack_require__.miniCssF = e => {}
    ,
    __webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
    ( () => {
        var e = {}
          , t = "react-wallet-live:";
        __webpack_require__.l = (n, r, i, o) => {
            if (e[n])
                e[n].push(r);
            else {
                var a, s;
                if (void 0 !== i)
                    for (var l = document.getElementsByTagName("script"), c = 0; c < l.length; c++) {
                        var u = l[c];
                        if (u.getAttribute("src") == n || u.getAttribute("data-webpack") == t + i) {
                            a = u;
                            break
                        }
                    }
                a || (s = !0,
                (a = document.createElement("script")).charset = "utf-8",
                a.timeout = 120,
                __webpack_require__.nc && a.setAttribute("nonce", __webpack_require__.nc),
                a.setAttribute("data-webpack", t + i),
                a.src = n),
                e[n] = [r];
                var d = (t, r) => {
                    a.onerror = a.onload = null,
                    clearTimeout(h);
                    var i = e[n];
                    if (delete e[n],
                    a.parentNode && a.parentNode.removeChild(a),
                    i && i.forEach((e => e(r))),
                    t)
                        return t(r)
                }
                  , h = setTimeout(d.bind(null, void 0, {
                    type: "timeout",
                    target: a
                }), 12e4);
                a.onerror = d.bind(null, a.onerror),
                a.onload = d.bind(null, a.onload),
                s && document.head.appendChild(a)
            }
        }
    }
    )(),
    __webpack_require__.r = e => {
        "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ,
    __webpack_require__.p = "/",
    ( () => {
        var e = {
            792: 0
        };
        __webpack_require__.f.j = (t, n) => {
            var r = __webpack_require__.o(e, t) ? e[t] : void 0;
            if (0 !== r)
                if (r)
                    n.push(r[2]);
                else {
                    var i = new Promise(( (n, i) => r = e[t] = [n, i]));
                    n.push(r[2] = i);
                    var o = __webpack_require__.p + __webpack_require__.u(t)
                      , a = new Error;
                    __webpack_require__.l(o, (n => {
                        if (__webpack_require__.o(e, t) && (0 !== (r = e[t]) && (e[t] = void 0),
                        r)) {
                            var i = n && ("load" === n.type ? "missing" : n.type)
                              , o = n && n.target && n.target.src;
                            a.message = "Loading chunk " + t + " failed.\n(" + i + ": " + o + ")",
                            a.name = "ChunkLoadError",
                            a.type = i,
                            a.request = o,
                            r[1](a)
                        }
                    }
                    ), "chunk-" + t, t)
                }
        }
        ;
        var t = (t, n) => {
            var r, i, o = n[0], a = n[1], s = n[2], l = 0;
            if (o.some((t => 0 !== e[t]))) {
                for (r in a)
                    __webpack_require__.o(a, r) && (__webpack_require__.m[r] = a[r]);
                if (s)
                    s(__webpack_require__)
            }
            for (t && t(n); l < o.length; l++)
                i = o[l],
                __webpack_require__.o(e, i) && e[i] && e[i][0](),
                e[i] = 0
        }
          , n = self.webpackChunkreact_wallet_live = self.webpackChunkreact_wallet_live || [];
        n.forEach(t.bind(null, 0)),
        n.push = t.bind(null, n.push.bind(n))
    }
    )(),
    __webpack_require__.nc = void 0;
    var __webpack_exports__ = {};
    ( () => {
        "use strict";
        var e = {};
        __webpack_require__.r(e),
        __webpack_require__.d(e, {
            ACESFilmicToneMapping: () => Vh,
            AddEquation: () => uh,
            AddOperation: () => zh,
            AdditiveAnimationBlendMode: () => Ef,
            AdditiveBlending: () => ah,
            AlphaFormat: () => Ep,
            AlwaysCompare: () => pm,
            AlwaysDepth: () => Bh,
            AlwaysStencilFunc: () => om,
            AmbientLight: () => JE,
            AnimationAction: () => OM,
            AnimationClip: () => vE,
            AnimationLoader: () => ME,
            AnimationMixer: () => FM,
            AnimationObjectGroup: () => DM,
            AnimationUtils: () => iE,
            ArcCurve: () => xS,
            ArrayCamera: () => RA,
            ArrowHelper: () => RC,
            AttachedBindMode: () => Jh,
            Audio: () => _M,
            AudioAnalyser: () => MM,
            AudioContext: () => sM,
            AudioListener: () => bM,
            AudioLoader: () => lM,
            AxesHelper: () => PC,
            BackSide: () => th,
            BasicDepthPacking: () => Bf,
            BasicShadowMap: () => Yd,
            BatchedMesh: () => qx,
            Bone: () => bx,
            BooleanKeyframeTrack: () => uE,
            Box2: () => YM,
            Box3: () => wg,
            Box3Helper: () => wC,
            BoxGeometry: () => Dy,
            BoxHelper: () => SC,
            BufferAttribute: () => Qv,
            BufferGeometry: () => my,
            BufferGeometryLoader: () => eM,
            ByteType: () => mp,
            Cache: () => bE,
            Camera: () => Gy,
            CameraHelper: () => _C,
            CanvasTexture: () => bS,
            CapsuleGeometry: () => jS,
            CatmullRomCurve3: () => TS,
            CineonToneMapping: () => Wh,
            CircleGeometry: () => WS,
            ClampToEdgeWrapping: () => np,
            Clock: () => pM,
            Color: () => Uv,
            ColorKeyframeTrack: () => dE,
            ColorManagement: () => ng,
            CompressedArrayTexture: () => vS,
            CompressedCubeTexture: () => yS,
            CompressedTexture: () => gS,
            CompressedTextureLoader: () => CE,
            ConeGeometry: () => XS,
            ConstantAlphaFactor: () => Th,
            ConstantColorFactor: () => Mh,
            CubeCamera: () => Wy,
            CubeReflectionMapping: () => Yh,
            CubeRefractionMapping: () => Qh,
            CubeTexture: () => Vy,
            CubeTextureLoader: () => RE,
            CubeUVReflectionMapping: () => ep,
            CubicBezierCurve: () => IS,
            CubicBezierCurve3: () => LS,
            CubicInterpolant: () => aE,
            CullFaceBack: () => Jd,
            CullFaceFront: () => Kd,
            CullFaceFrontBack: () => qd,
            CullFaceNone: () => Xd,
            Curve: () => _S,
            CurvePath: () => zS,
            CustomBlending: () => ch,
            CustomToneMapping: () => Xh,
            CylinderGeometry: () => VS,
            Cylindrical: () => KM,
            Data3DTexture: () => vg,
            DataArrayTexture: () => mg,
            DataTexture: () => _x,
            DataTextureLoader: () => PE,
            DataUtils: () => Kv,
            DecrementStencilOp: () => Kf,
            DecrementWrapStencilOp: () => Yf,
            DefaultLoadingManager: () => AE,
            DepthFormat: () => Rp,
            DepthStencilFormat: () => Pp,
            DepthTexture: () => Ub,
            DetachedBindMode: () => Kh,
            DirectionalLight: () => XE,
            DirectionalLightHelper: () => vC,
            DiscreteInterpolant: () => lE,
            DisplayP3ColorSpace: () => Ff,
            DodecahedronGeometry: () => KS,
            DoubleSide: () => nh,
            DstAlphaFactor: () => Ah,
            DstColorFactor: () => Sh,
            DynamicCopyUsage: () => Am,
            DynamicDrawUsage: () => mm,
            DynamicReadUsage: () => ym,
            EdgesGeometry: () => $S,
            EllipseCurve: () => AS,
            EqualCompare: () => lm,
            EqualDepth: () => kh,
            EqualStencilFunc: () => em,
            EquirectangularReflectionMapping: () => Zh,
            EquirectangularRefractionMapping: () => $h,
            Euler: () => sv,
            EventDispatcher: () => Tm,
            ExtrudeGeometry: () => Rw,
            FileLoader: () => EE,
            Float16BufferAttribute: () => oy,
            Float32BufferAttribute: () => ay,
            Float64BufferAttribute: () => sy,
            FloatType: () => _p,
            Fog: () => UA,
            FogExp2: () => FA,
            FramebufferTexture: () => mS,
            FrontSide: () => eh,
            Frustum: () => $y,
            GLBufferAttribute: () => jM,
            GLSL1: () => Sm,
            GLSL3: () => wm,
            GreaterCompare: () => um,
            GreaterDepth: () => Oh,
            GreaterEqualCompare: () => hm,
            GreaterEqualDepth: () => Dh,
            GreaterEqualStencilFunc: () => im,
            GreaterStencilFunc: () => nm,
            GridHelper: () => hC,
            Group: () => PA,
            HalfFloatType: () => Ap,
            HemisphereLight: () => LE,
            HemisphereLightHelper: () => dC,
            IcosahedronGeometry: () => Bw,
            ImageBitmapLoader: () => oM,
            ImageLoader: () => TE,
            ImageUtils: () => ag,
            IncrementStencilOp: () => Jf,
            IncrementWrapStencilOp: () => qf,
            InstancedBufferAttribute: () => wx,
            InstancedBufferGeometry: () => $E,
            InstancedInterleavedBuffer: () => HM,
            InstancedMesh: () => Ix,
            Int16BufferAttribute: () => ty,
            Int32BufferAttribute: () => ry,
            Int8BufferAttribute: () => Zv,
            IntType: () => yp,
            InterleavedBuffer: () => GA,
            InterleavedBufferAttribute: () => jA,
            Interpolant: () => oE,
            InterpolateDiscrete: () => yf,
            InterpolateLinear: () => bf,
            InterpolateSmooth: () => _f,
            InvertStencilOp: () => Qf,
            KeepStencilOp: () => Vf,
            KeyframeTrack: () => cE,
            LOD: () => lx,
            LatheGeometry: () => HS,
            Layers: () => lv,
            LessCompare: () => sm,
            LessDepth: () => Ih,
            LessEqualCompare: () => cm,
            LessEqualDepth: () => Lh,
            LessEqualStencilFunc: () => tm,
            LessStencilFunc: () => $f,
            Light: () => IE,
            LightProbe: () => YE,
            Line: () => nS,
            Line3: () => $M,
            LineBasicMaterial: () => Yx,
            LineCurve: () => kS,
            LineCurve3: () => DS,
            LineDashedMaterial: () => Zw,
            LineLoop: () => aS,
            LineSegments: () => oS,
            LinearDisplayP3ColorSpace: () => Uf,
            LinearEncoding: () => Rf,
            LinearFilter: () => cp,
            LinearInterpolant: () => sE,
            LinearMipMapLinearFilter: () => pp,
            LinearMipMapNearestFilter: () => dp,
            LinearMipmapLinearFilter: () => hp,
            LinearMipmapNearestFilter: () => up,
            LinearSRGBColorSpace: () => Nf,
            LinearToneMapping: () => Hh,
            LinearTransfer: () => zf,
            Loader: () => xE,
            LoaderUtils: () => ZE,
            LoadingManager: () => _E,
            LoopOnce: () => mf,
            LoopPingPong: () => vf,
            LoopRepeat: () => gf,
            LuminanceAlphaFormat: () => Tp,
            LuminanceFormat: () => Cp,
            MOUSE: () => Wd,
            Material: () => Hv,
            MaterialLoader: () => QE,
            MathUtils: () => Gm,
            Matrix3: () => jm,
            Matrix4: () => Qg,
            MaxEquation: () => fh,
            Mesh: () => Ly,
            MeshBasicMaterial: () => jv,
            MeshDepthMaterial: () => SA,
            MeshDistanceMaterial: () => wA,
            MeshLambertMaterial: () => Yw,
            MeshMatcapMaterial: () => Qw,
            MeshNormalMaterial: () => qw,
            MeshPhongMaterial: () => Jw,
            MeshPhysicalMaterial: () => Xw,
            MeshStandardMaterial: () => Vw,
            MeshToonMaterial: () => Kw,
            MinEquation: () => ph,
            MirroredRepeatWrapping: () => rp,
            MixOperation: () => Uh,
            MultiplyBlending: () => lh,
            MultiplyOperation: () => Fh,
            NearestFilter: () => ip,
            NearestMipMapLinearFilter: () => lp,
            NearestMipMapNearestFilter: () => ap,
            NearestMipmapLinearFilter: () => sp,
            NearestMipmapNearestFilter: () => op,
            NeverCompare: () => am,
            NeverDepth: () => Ph,
            NeverStencilFunc: () => Zf,
            NoBlending: () => ih,
            NoColorSpace: () => Df,
            NoToneMapping: () => Gh,
            NormalAnimationBlendMode: () => wf,
            NormalBlending: () => oh,
            NotEqualCompare: () => dm,
            NotEqualDepth: () => Nh,
            NotEqualStencilFunc: () => rm,
            NumberKeyframeTrack: () => hE,
            Object3D: () => xv,
            ObjectLoader: () => tM,
            ObjectSpaceNormalMap: () => kf,
            OctahedronGeometry: () => Iw,
            OneFactor: () => gh,
            OneMinusConstantAlphaFactor: () => Rh,
            OneMinusConstantColorFactor: () => Ch,
            OneMinusDstAlphaFactor: () => xh,
            OneMinusDstColorFactor: () => wh,
            OneMinusSrcAlphaFactor: () => _h,
            OneMinusSrcColorFactor: () => yh,
            OrthographicCamera: () => pb,
            P3Primaries: () => jf,
            PCFShadowMap: () => Qd,
            PCFSoftShadowMap: () => Zd,
            PMREMGenerator: () => wb,
            Path: () => GS,
            PerspectiveCamera: () => Hy,
            Plane: () => Yy,
            PlaneGeometry: () => nb,
            PlaneHelper: () => EC,
            PointLight: () => WE,
            PointLightHelper: () => sC,
            Points: () => hS,
            PointsMaterial: () => sS,
            PolarGridHelper: () => pC,
            PolyhedronGeometry: () => JS,
            PositionalAudio: () => EM,
            PropertyBinding: () => kM,
            PropertyMixer: () => CM,
            QuadraticBezierCurve: () => OS,
            QuadraticBezierCurve3: () => NS,
            Quaternion: () => _g,
            QuaternionKeyframeTrack: () => fE,
            QuaternionLinearInterpolant: () => pE,
            RED_GREEN_RGTC2_Format: () => pf,
            RED_RGTC1_Format: () => df,
            REVISION: () => jd,
            RGBADepthPacking: () => If,
            RGBAFormat: () => Mp,
            RGBAIntegerFormat: () => Dp,
            RGBA_ASTC_10x10_Format: () => of,
            RGBA_ASTC_10x5_Format: () => tf,
            RGBA_ASTC_10x6_Format: () => nf,
            RGBA_ASTC_10x8_Format: () => rf,
            RGBA_ASTC_12x10_Format: () => af,
            RGBA_ASTC_12x12_Format: () => sf,
            RGBA_ASTC_4x4_Format: () => Jp,
            RGBA_ASTC_5x4_Format: () => Kp,
            RGBA_ASTC_5x5_Format: () => qp,
            RGBA_ASTC_6x5_Format: () => Yp,
            RGBA_ASTC_6x6_Format: () => Qp,
            RGBA_ASTC_8x5_Format: () => Zp,
            RGBA_ASTC_8x6_Format: () => $p,
            RGBA_ASTC_8x8_Format: () => ef,
            RGBA_BPTC_Format: () => lf,
            RGBA_ETC2_EAC_Format: () => Xp,
            RGBA_PVRTC_2BPPV1_Format: () => jp,
            RGBA_PVRTC_4BPPV1_Format: () => Hp,
            RGBA_S3TC_DXT1_Format: () => Np,
            RGBA_S3TC_DXT3_Format: () => Fp,
            RGBA_S3TC_DXT5_Format: () => Up,
            RGB_BPTC_SIGNED_Format: () => cf,
            RGB_BPTC_UNSIGNED_Format: () => uf,
            RGB_ETC1_Format: () => Wp,
            RGB_ETC2_Format: () => Vp,
            RGB_PVRTC_2BPPV1_Format: () => Gp,
            RGB_PVRTC_4BPPV1_Format: () => zp,
            RGB_S3TC_DXT1_Format: () => Op,
            RGFormat: () => Lp,
            RGIntegerFormat: () => kp,
            RawShaderMaterial: () => Ww,
            Ray: () => Yg,
            Raycaster: () => WM,
            Rec709Primaries: () => Hf,
            RectAreaLight: () => KE,
            RedFormat: () => Bp,
            RedIntegerFormat: () => Ip,
            ReinhardToneMapping: () => jh,
            RenderTarget: () => pg,
            RepeatWrapping: () => tp,
            ReplaceStencilOp: () => Xf,
            ReverseSubtractEquation: () => hh,
            RingGeometry: () => Lw,
            SIGNED_RED_GREEN_RGTC2_Format: () => ff,
            SIGNED_RED_RGTC1_Format: () => hf,
            SRGBColorSpace: () => Of,
            SRGBTransfer: () => Gf,
            Scene: () => zA,
            ShaderChunk: () => rb,
            ShaderLib: () => ob,
            ShaderMaterial: () => zy,
            ShadowMaterial: () => jw,
            Shape: () => ew,
            ShapeGeometry: () => kw,
            ShapePath: () => BC,
            ShapeUtils: () => Mw,
            ShortType: () => gp,
            Skeleton: () => Sx,
            SkeletonHelper: () => oC,
            SkinnedMesh: () => yx,
            Source: () => lg,
            Sphere: () => Hg,
            SphereGeometry: () => Dw,
            Spherical: () => JM,
            SphericalHarmonics3: () => qE,
            SplineCurve: () => FS,
            SpotLight: () => UE,
            SpotLightHelper: () => tC,
            Sprite: () => ix,
            SpriteMaterial: () => WA,
            SrcAlphaFactor: () => bh,
            SrcAlphaSaturateFactor: () => Eh,
            SrcColorFactor: () => vh,
            StaticCopyUsage: () => _m,
            StaticDrawUsage: () => fm,
            StaticReadUsage: () => vm,
            StereoCamera: () => hM,
            StreamCopyUsage: () => xm,
            StreamDrawUsage: () => gm,
            StreamReadUsage: () => bm,
            StringKeyframeTrack: () => mE,
            SubtractEquation: () => dh,
            SubtractiveBlending: () => sh,
            TOUCH: () => Vd,
            TangentSpaceNormalMap: () => Lf,
            TetrahedronGeometry: () => Ow,
            Texture: () => dg,
            TextureLoader: () => BE,
            TorusGeometry: () => Nw,
            TorusKnotGeometry: () => Fw,
            Triangle: () => kv,
            TriangleFanDrawMode: () => Tf,
            TriangleStripDrawMode: () => Cf,
            TrianglesDrawMode: () => Mf,
            TubeGeometry: () => Uw,
            TwoPassDoubleSide: () => rh,
            UVMapping: () => qh,
            Uint16BufferAttribute: () => ny,
            Uint32BufferAttribute: () => iy,
            Uint8BufferAttribute: () => $v,
            Uint8ClampedBufferAttribute: () => ey,
            Uniform: () => UM,
            UniformsGroup: () => GM,
            UniformsLib: () => ib,
            UniformsUtils: () => Uy,
            UnsignedByteType: () => fp,
            UnsignedInt248Type: () => wp,
            UnsignedIntType: () => bp,
            UnsignedShort4444Type: () => xp,
            UnsignedShort5551Type: () => Sp,
            UnsignedShortType: () => vp,
            VSMShadowMap: () => $d,
            Vector2: () => Hm,
            Vector3: () => Ag,
            Vector4: () => hg,
            VectorKeyframeTrack: () => gE,
            VideoTexture: () => fS,
            WebGL1Renderer: () => NA,
            WebGL3DRenderTarget: () => yg,
            WebGLArrayRenderTarget: () => gg,
            WebGLCoordinateSystem: () => Mm,
            WebGLCubeRenderTarget: () => Xy,
            WebGLMultipleRenderTargets: () => bg,
            WebGLRenderTarget: () => fg,
            WebGLRenderer: () => OA,
            WebGLUtils: () => TA,
            WebGPUCoordinateSystem: () => Cm,
            WireframeGeometry: () => zw,
            WrapAroundEnding: () => Sf,
            ZeroCurvatureEnding: () => Af,
            ZeroFactor: () => mh,
            ZeroSlopeEnding: () => xf,
            ZeroStencilOp: () => Wf,
            _SRGBAFormat: () => Em,
            createCanvasElement: () => qm,
            sRGBEncoding: () => Pf
        });
        var t = __webpack_require__(9950)
          , n = __webpack_require__(1352)
          , r = __webpack_require__(7256)
          , i = t
          , o = Symbol.for("react-redux-context")
          , a = "undefined" !== typeof globalThis ? globalThis : {};
        function s() {
            if (!i.createContext)
                return {};
            const e = a[o] ?? (a[o] = new Map);
            let t = e.get(i.createContext);
            return t || (t = i.createContext(null),
            e.set(i.createContext, t)),
            t
        }
        var l = s()
          , c = () => {
            throw new Error("uSES not initialized!")
        }
        ;
        function u() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l;
            return function() {
                return i.useContext(e)
            }
        }
        var d = u()
          , h = c
          , p = (e, t) => e === t;
        function f() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l;
            const t = e === l ? d : u(e)
              , n = function(e) {
                let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                const {equalityFn: r=p, devModeChecks: o={}} = "function" === typeof n ? {
                    equalityFn: n
                } : n;
                const {store: a, subscription: s, getServerState: l, stabilityCheck: c, identityFunctionCheck: u} = t()
                  , d = (i.useRef(!0),
                i.useCallback({
                    [e.name]: t => e(t)
                }[e.name], [e, c, o.stabilityCheck]))
                  , f = h(s.addNestedSub, a.getState, l || a.getState, d, r);
                return i.useDebugValue(f),
                f
            };
            return Object.assign(n, {
                withTypes: () => n
            }),
            n
        }
        var m = f();
        Symbol.for("react.element"),
        Symbol.for("react.portal"),
        Symbol.for("react.fragment"),
        Symbol.for("react.strict_mode"),
        Symbol.for("react.profiler"),
        Symbol.for("react.provider"),
        Symbol.for("react.context"),
        Symbol.for("react.server_context"),
        Symbol.for("react.forward_ref"),
        Symbol.for("react.suspense"),
        Symbol.for("react.suspense_list"),
        Symbol.for("react.memo"),
        Symbol.for("react.lazy"),
        Symbol.for("react.offscreen"),
        Symbol.for("react.client.reference");
        function g(e) {
            e()
        }
        var v = {
            notify() {},
            get: () => []
        };
        function y(e, t) {
            let n, r = v, i = 0, o = !1;
            function a() {
                c.onStateChange && c.onStateChange()
            }
            function s() {
                i++,
                n || (n = t ? t.addNestedSub(a) : e.subscribe(a),
                r = function() {
                    let e = null
                      , t = null;
                    return {
                        clear() {
                            e = null,
                            t = null
                        },
                        notify() {
                            g(( () => {
                                let t = e;
                                for (; t; )
                                    t.callback(),
                                    t = t.next
                            }
                            ))
                        },
                        get() {
                            const t = [];
                            let n = e;
                            for (; n; )
                                t.push(n),
                                n = n.next;
                            return t
                        },
                        subscribe(n) {
                            let r = !0;
                            const i = t = {
                                callback: n,
                                next: null,
                                prev: t
                            };
                            return i.prev ? i.prev.next = i : e = i,
                            function() {
                                r && null !== e && (r = !1,
                                i.next ? i.next.prev = i.prev : t = i.prev,
                                i.prev ? i.prev.next = i.next : e = i.next)
                            }
                        }
                    }
                }())
            }
            function l() {
                i--,
                n && 0 === i && (n(),
                n = void 0,
                r.clear(),
                r = v)
            }
            const c = {
                addNestedSub: function(e) {
                    s();
                    const t = r.subscribe(e);
                    let n = !1;
                    return () => {
                        n || (n = !0,
                        t(),
                        l())
                    }
                },
                notifyNestedSubs: function() {
                    r.notify()
                },
                handleChangeWrapper: a,
                isSubscribed: function() {
                    return o
                },
                trySubscribe: function() {
                    o || (o = !0,
                    s())
                },
                tryUnsubscribe: function() {
                    o && (o = !1,
                    l())
                },
                getListeners: () => r
            };
            return c
        }
        var b = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement)
          , _ = "undefined" !== typeof navigator && "ReactNative" === navigator.product
          , A = b || _ ? i.useLayoutEffect : i.useEffect;
        Object.defineProperty,
        Object.getOwnPropertyNames,
        Object.getOwnPropertySymbols,
        Object.getOwnPropertyDescriptor,
        Object.getPrototypeOf,
        Object.prototype;
        var x = function(e) {
            let {store: t, context: n, children: r, serverState: o, stabilityCheck: a="once", identityFunctionCheck: s="once"} = e;
            const c = i.useMemo(( () => {
                const e = y(t);
                return {
                    store: t,
                    subscription: e,
                    getServerState: o ? () => o : void 0,
                    stabilityCheck: a,
                    identityFunctionCheck: s
                }
            }
            ), [t, o, a, s])
              , u = i.useMemo(( () => t.getState()), [t]);
            A(( () => {
                const {subscription: e} = c;
                return e.onStateChange = e.notifyNestedSubs,
                e.trySubscribe(),
                u !== t.getState() && e.notifyNestedSubs(),
                () => {
                    e.tryUnsubscribe(),
                    e.onStateChange = void 0
                }
            }
            ), [c, u]);
            const d = n || l;
            return i.createElement(d.Provider, {
                value: c
            }, r)
        };
        function S() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l;
            const t = e === l ? d : u(e)
              , n = () => {
                const {store: e} = t();
                return e
            }
            ;
            return Object.assign(n, {
                withTypes: () => n
            }),
            n
        }
        var w = S();
        function E() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l;
            const t = e === l ? w : S(e)
              , n = () => t().dispatch;
            return Object.assign(n, {
                withTypes: () => n
            }),
            n
        }
        var M, C = E();
        function T(e) {
            return `Minified Redux error #${e}; visit https://redux.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `
        }
        M = r.useSyncExternalStoreWithSelector,
        h = M,
        (e => {
            0
        }
        )(t.useSyncExternalStore);
        var R = ( () => "function" === typeof Symbol && Symbol.observable || "@@observable")()
          , P = () => Math.random().toString(36).substring(7).split("").join(".")
          , B = {
            INIT: `@@redux/INIT${P()}`,
            REPLACE: `@@redux/REPLACE${P()}`,
            PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${P()}`
        };
        function I(e) {
            if ("object" !== typeof e || null === e)
                return !1;
            let t = e;
            for (; null !== Object.getPrototypeOf(t); )
                t = Object.getPrototypeOf(t);
            return Object.getPrototypeOf(e) === t || null === Object.getPrototypeOf(e)
        }
        function L(e, t, n) {
            if ("function" !== typeof e)
                throw new Error(T(2));
            if ("function" === typeof t && "function" === typeof n || "function" === typeof n && "function" === typeof arguments[3])
                throw new Error(T(0));
            if ("function" === typeof t && "undefined" === typeof n && (n = t,
            t = void 0),
            "undefined" !== typeof n) {
                if ("function" !== typeof n)
                    throw new Error(T(1));
                return n(L)(e, t)
            }
            let r = e
              , i = t
              , o = new Map
              , a = o
              , s = 0
              , l = !1;
            function c() {
                a === o && (a = new Map,
                o.forEach(( (e, t) => {
                    a.set(t, e)
                }
                )))
            }
            function u() {
                if (l)
                    throw new Error(T(3));
                return i
            }
            function d(e) {
                if ("function" !== typeof e)
                    throw new Error(T(4));
                if (l)
                    throw new Error(T(5));
                let t = !0;
                c();
                const n = s++;
                return a.set(n, e),
                function() {
                    if (t) {
                        if (l)
                            throw new Error(T(6));
                        t = !1,
                        c(),
                        a.delete(n),
                        o = null
                    }
                }
            }
            function h(e) {
                if (!I(e))
                    throw new Error(T(7));
                if ("undefined" === typeof e.type)
                    throw new Error(T(8));
                if ("string" !== typeof e.type)
                    throw new Error(T(17));
                if (l)
                    throw new Error(T(9));
                try {
                    l = !0,
                    i = r(i, e)
                } finally {
                    l = !1
                }
                return (o = a).forEach((e => {
                    e()
                }
                )),
                e
            }
            h({
                type: B.INIT
            });
            return {
                dispatch: h,
                subscribe: d,
                getState: u,
                replaceReducer: function(e) {
                    if ("function" !== typeof e)
                        throw new Error(T(10));
                    r = e,
                    h({
                        type: B.REPLACE
                    })
                },
                [R]: function() {
                    const e = d;
                    return {
                        subscribe(t) {
                            if ("object" !== typeof t || null === t)
                                throw new Error(T(11));
                            function n() {
                                const e = t;
                                e.next && e.next(u())
                            }
                            n();
                            return {
                                unsubscribe: e(n)
                            }
                        },
                        [R]() {
                            return this
                        }
                    }
                }
            }
        }
        function k(e) {
            const t = Object.keys(e)
              , n = {};
            for (let a = 0; a < t.length; a++) {
                const r = t[a];
                0,
                "function" === typeof e[r] && (n[r] = e[r])
            }
            const r = Object.keys(n);
            let i;
            try {
                !function(e) {
                    Object.keys(e).forEach((t => {
                        const n = e[t];
                        if ("undefined" === typeof n(void 0, {
                            type: B.INIT
                        }))
                            throw new Error(T(12));
                        if ("undefined" === typeof n(void 0, {
                            type: B.PROBE_UNKNOWN_ACTION()
                        }))
                            throw new Error(T(13))
                    }
                    ))
                }(n)
            } catch (o) {
                i = o
            }
            return function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , t = arguments.length > 1 ? arguments[1] : void 0;
                if (i)
                    throw i;
                let o = !1;
                const a = {};
                for (let i = 0; i < r.length; i++) {
                    const s = r[i]
                      , l = n[s]
                      , c = e[s]
                      , u = l(c, t);
                    if ("undefined" === typeof u) {
                        t && t.type;
                        throw new Error(T(14))
                    }
                    a[s] = u,
                    o = o || u !== c
                }
                return o = o || r.length !== Object.keys(e).length,
                o ? a : e
            }
        }
        function D() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                t[n] = arguments[n];
            return 0 === t.length ? e => e : 1 === t.length ? t[0] : t.reduce(( (e, t) => function() {
                return e(t(...arguments))
            }
            ))
        }
        function O(e) {
            return t => {
                let {dispatch: n, getState: r} = t;
                return t => i => "function" === typeof i ? i(n, r, e) : t(i)
            }
        }
        var N = O()
          , F = O
          , U = Symbol.for("immer-nothing")
          , z = Symbol.for("immer-draftable")
          , G = Symbol.for("immer-state");
        function H(e) {
            throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)
        }
        var j = Object.getPrototypeOf;
        function W(e) {
            return !!e && !!e[G]
        }
        function V(e) {
            return !!e && (J(e) || Array.isArray(e) || !!e[z] || !!e.constructor?.[z] || Z(e) || $(e))
        }
        var X = Object.prototype.constructor.toString();
        function J(e) {
            if (!e || "object" !== typeof e)
                return !1;
            const t = j(e);
            if (null === t)
                return !0;
            const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
            return n === Object || "function" == typeof n && Function.toString.call(n) === X
        }
        function K(e, t) {
            0 === q(e) ? Reflect.ownKeys(e).forEach((n => {
                t(n, e[n], e)
            }
            )) : e.forEach(( (n, r) => t(r, n, e)))
        }
        function q(e) {
            const t = e[G];
            return t ? t.type_ : Array.isArray(e) ? 1 : Z(e) ? 2 : $(e) ? 3 : 0
        }
        function Y(e, t) {
            return 2 === q(e) ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t)
        }
        function Q(e, t, n) {
            const r = q(e);
            2 === r ? e.set(t, n) : 3 === r ? e.add(n) : e[t] = n
        }
        function Z(e) {
            return e instanceof Map
        }
        function $(e) {
            return e instanceof Set
        }
        function ee(e) {
            return e.copy_ || e.base_
        }
        function te(e, t) {
            if (Z(e))
                return new Map(e);
            if ($(e))
                return new Set(e);
            if (Array.isArray(e))
                return Array.prototype.slice.call(e);
            const n = J(e);
            if (!0 === t || "class_only" === t && !n) {
                const t = Object.getOwnPropertyDescriptors(e);
                delete t[G];
                let n = Reflect.ownKeys(t);
                for (let r = 0; r < n.length; r++) {
                    const i = n[r]
                      , o = t[i];
                    !1 === o.writable && (o.writable = !0,
                    o.configurable = !0),
                    (o.get || o.set) && (t[i] = {
                        configurable: !0,
                        writable: !0,
                        enumerable: o.enumerable,
                        value: e[i]
                    })
                }
                return Object.create(j(e), t)
            }
            {
                const t = j(e);
                if (null !== t && n)
                    return {
                        ...e
                    };
                const r = Object.create(t);
                return Object.assign(r, e)
            }
        }
        function ne(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return ie(e) || W(e) || !V(e) || (q(e) > 1 && (e.set = e.add = e.clear = e.delete = re),
            Object.freeze(e),
            t && Object.entries(e).forEach((e => {
                let[t,n] = e;
                return ne(n, !0)
            }
            ))),
            e
        }
        function re() {
            H(2)
        }
        function ie(e) {
            return Object.isFrozen(e)
        }
        var oe, ae = {};
        function se(e) {
            const t = ae[e];
            return t || H(0),
            t
        }
        function le() {
            return oe
        }
        function ce(e, t) {
            t && (se("Patches"),
            e.patches_ = [],
            e.inversePatches_ = [],
            e.patchListener_ = t)
        }
        function ue(e) {
            de(e),
            e.drafts_.forEach(pe),
            e.drafts_ = null
        }
        function de(e) {
            e === oe && (oe = e.parent_)
        }
        function he(e) {
            return oe = {
                drafts_: [],
                parent_: oe,
                immer_: e,
                canAutoFreeze_: !0,
                unfinalizedDrafts_: 0
            }
        }
        function pe(e) {
            const t = e[G];
            0 === t.type_ || 1 === t.type_ ? t.revoke_() : t.revoked_ = !0
        }
        function fe(e, t) {
            t.unfinalizedDrafts_ = t.drafts_.length;
            const n = t.drafts_[0];
            return void 0 !== e && e !== n ? (n[G].modified_ && (ue(t),
            H(4)),
            V(e) && (e = me(t, e),
            t.parent_ || ve(t, e)),
            t.patches_ && se("Patches").generateReplacementPatches_(n[G].base_, e, t.patches_, t.inversePatches_)) : e = me(t, n, []),
            ue(t),
            t.patches_ && t.patchListener_(t.patches_, t.inversePatches_),
            e !== U ? e : void 0
        }
        function me(e, t, n) {
            if (ie(t))
                return t;
            const r = t[G];
            if (!r)
                return K(t, ( (i, o) => ge(e, r, t, i, o, n))),
                t;
            if (r.scope_ !== e)
                return t;
            if (!r.modified_)
                return ve(e, r.base_, !0),
                r.base_;
            if (!r.finalized_) {
                r.finalized_ = !0,
                r.scope_.unfinalizedDrafts_--;
                const t = r.copy_;
                let i = t
                  , o = !1;
                3 === r.type_ && (i = new Set(t),
                t.clear(),
                o = !0),
                K(i, ( (i, a) => ge(e, r, t, i, a, n, o))),
                ve(e, t, !1),
                n && e.patches_ && se("Patches").generatePatches_(r, n, e.patches_, e.inversePatches_)
            }
            return r.copy_
        }
        function ge(e, t, n, r, i, o, a) {
            if (W(i)) {
                const a = me(e, i, o && t && 3 !== t.type_ && !Y(t.assigned_, r) ? o.concat(r) : void 0);
                if (Q(n, r, a),
                !W(a))
                    return;
                e.canAutoFreeze_ = !1
            } else
                a && n.add(i);
            if (V(i) && !ie(i)) {
                if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
                    return;
                me(e, i),
                t && t.scope_.parent_ || "symbol" === typeof r || !Object.prototype.propertyIsEnumerable.call(n, r) || ve(e, i)
            }
        }
        function ve(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && ne(t, n)
        }
        var ye = {
            get(e, t) {
                if (t === G)
                    return e;
                const n = ee(e);
                if (!Y(n, t))
                    return function(e, t, n) {
                        const r = Ae(t, n);
                        return r ? "value"in r ? r.value : r.get?.call(e.draft_) : void 0
                    }(e, n, t);
                const r = n[t];
                return e.finalized_ || !V(r) ? r : r === _e(e.base_, t) ? (Se(e),
                e.copy_[t] = we(r, e)) : r
            },
            has: (e, t) => t in ee(e),
            ownKeys: e => Reflect.ownKeys(ee(e)),
            set(e, t, n) {
                const r = Ae(ee(e), t);
                if (r?.set)
                    return r.set.call(e.draft_, n),
                    !0;
                if (!e.modified_) {
                    const r = _e(ee(e), t)
                      , a = r?.[G];
                    if (a && a.base_ === n)
                        return e.copy_[t] = n,
                        e.assigned_[t] = !1,
                        !0;
                    if (((i = n) === (o = r) ? 0 !== i || 1 / i === 1 / o : i !== i && o !== o) && (void 0 !== n || Y(e.base_, t)))
                        return !0;
                    Se(e),
                    xe(e)
                }
                var i, o;
                return e.copy_[t] === n && (void 0 !== n || t in e.copy_) || Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n,
                e.assigned_[t] = !0),
                !0
            },
            deleteProperty: (e, t) => (void 0 !== _e(e.base_, t) || t in e.base_ ? (e.assigned_[t] = !1,
            Se(e),
            xe(e)) : delete e.assigned_[t],
            e.copy_ && delete e.copy_[t],
            !0),
            getOwnPropertyDescriptor(e, t) {
                const n = ee(e)
                  , r = Reflect.getOwnPropertyDescriptor(n, t);
                return r ? {
                    writable: !0,
                    configurable: 1 !== e.type_ || "length" !== t,
                    enumerable: r.enumerable,
                    value: n[t]
                } : r
            },
            defineProperty() {
                H(11)
            },
            getPrototypeOf: e => j(e.base_),
            setPrototypeOf() {
                H(12)
            }
        }
          , be = {};
        function _e(e, t) {
            const n = e[G];
            return (n ? ee(n) : e)[t]
        }
        function Ae(e, t) {
            if (!(t in e))
                return;
            let n = j(e);
            for (; n; ) {
                const e = Object.getOwnPropertyDescriptor(n, t);
                if (e)
                    return e;
                n = j(n)
            }
        }
        function xe(e) {
            e.modified_ || (e.modified_ = !0,
            e.parent_ && xe(e.parent_))
        }
        function Se(e) {
            e.copy_ || (e.copy_ = te(e.base_, e.scope_.immer_.useStrictShallowCopy_))
        }
        K(ye, ( (e, t) => {
            be[e] = function() {
                return arguments[0] = arguments[0][0],
                t.apply(this, arguments)
            }
        }
        )),
        be.deleteProperty = function(e, t) {
            return be.set.call(this, e, t, void 0)
        }
        ,
        be.set = function(e, t, n) {
            return ye.set.call(this, e[0], t, n, e[0])
        }
        ;
        function we(e, t) {
            const n = Z(e) ? se("MapSet").proxyMap_(e, t) : $(e) ? se("MapSet").proxySet_(e, t) : function(e, t) {
                const n = Array.isArray(e)
                  , r = {
                    type_: n ? 1 : 0,
                    scope_: t ? t.scope_ : le(),
                    modified_: !1,
                    finalized_: !1,
                    assigned_: {},
                    parent_: t,
                    base_: e,
                    draft_: null,
                    copy_: null,
                    revoke_: null,
                    isManual_: !1
                };
                let i = r
                  , o = ye;
                n && (i = [r],
                o = be);
                const {revoke: a, proxy: s} = Proxy.revocable(i, o);
                return r.draft_ = s,
                r.revoke_ = a,
                s
            }(e, t);
            return (t ? t.scope_ : le()).drafts_.push(n),
            n
        }
        function Ee(e) {
            if (!V(e) || ie(e))
                return e;
            const t = e[G];
            let n;
            if (t) {
                if (!t.modified_)
                    return t.base_;
                t.finalized_ = !0,
                n = te(e, t.scope_.immer_.useStrictShallowCopy_)
            } else
                n = te(e, !0);
            return K(n, ( (e, t) => {
                Q(n, e, Ee(t))
            }
            )),
            t && (t.finalized_ = !1),
            n
        }
        var Me = new class {
            constructor(e) {
                var t = this;
                this.autoFreeze_ = !0,
                this.useStrictShallowCopy_ = !1,
                this.produce = (e, t, n) => {
                    if ("function" === typeof e && "function" !== typeof t) {
                        const n = t;
                        t = e;
                        const r = this;
                        return function() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : n;
                            for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
                                o[a - 1] = arguments[a];
                            return r.produce(e, (e => t.call(this, e, ...o)))
                        }
                    }
                    let r;
                    if ("function" !== typeof t && H(6),
                    void 0 !== n && "function" !== typeof n && H(7),
                    V(e)) {
                        const i = he(this)
                          , o = we(e, void 0);
                        let a = !0;
                        try {
                            r = t(o),
                            a = !1
                        } finally {
                            a ? ue(i) : de(i)
                        }
                        return ce(i, n),
                        fe(r, i)
                    }
                    if (!e || "object" !== typeof e) {
                        if (r = t(e),
                        void 0 === r && (r = e),
                        r === U && (r = void 0),
                        this.autoFreeze_ && ne(r, !0),
                        n) {
                            const t = []
                              , i = [];
                            se("Patches").generateReplacementPatches_(e, r, t, i),
                            n(t, i)
                        }
                        return r
                    }
                    H(1)
                }
                ,
                this.produceWithPatches = (e, n) => {
                    if ("function" === typeof e)
                        return function(n) {
                            for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
                                i[o - 1] = arguments[o];
                            return t.produceWithPatches(n, (t => e(t, ...i)))
                        }
                        ;
                    let r, i;
                    return [this.produce(e, n, ( (e, t) => {
                        r = e,
                        i = t
                    }
                    )), r, i]
                }
                ,
                "boolean" === typeof e?.autoFreeze && this.setAutoFreeze(e.autoFreeze),
                "boolean" === typeof e?.useStrictShallowCopy && this.setUseStrictShallowCopy(e.useStrictShallowCopy)
            }
            createDraft(e) {
                V(e) || H(8),
                W(e) && (e = function(e) {
                    W(e) || H(10);
                    return Ee(e)
                }(e));
                const t = he(this)
                  , n = we(e, void 0);
                return n[G].isManual_ = !0,
                de(t),
                n
            }
            finishDraft(e, t) {
                const n = e && e[G];
                n && n.isManual_ || H(9);
                const {scope_: r} = n;
                return ce(r, t),
                fe(void 0, r)
            }
            setAutoFreeze(e) {
                this.autoFreeze_ = e
            }
            setUseStrictShallowCopy(e) {
                this.useStrictShallowCopy_ = e
            }
            applyPatches(e, t) {
                let n;
                for (n = t.length - 1; n >= 0; n--) {
                    const r = t[n];
                    if (0 === r.path.length && "replace" === r.op) {
                        e = r.value;
                        break
                    }
                }
                n > -1 && (t = t.slice(n + 1));
                const r = se("Patches").applyPatches_;
                return W(e) ? r(e, t) : this.produce(e, (e => r(e, t)))
            }
        }
          , Ce = Me.produce;
        Me.produceWithPatches.bind(Me),
        Me.setAutoFreeze.bind(Me),
        Me.setUseStrictShallowCopy.bind(Me),
        Me.applyPatches.bind(Me),
        Me.createDraft.bind(Me),
        Me.finishDraft.bind(Me);
        var Te = "undefined" !== typeof window && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
            if (0 !== arguments.length)
                return "object" === typeof arguments[0] ? D : D.apply(null, arguments)
        }
        ;
        "undefined" !== typeof window && window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__;
        function Re(e, t) {
            function n() {
                if (t) {
                    let n = t(...arguments);
                    if (!n)
                        throw new Error(Ve(0));
                    return {
                        type: e,
                        payload: n.payload,
                        ..."meta"in n && {
                            meta: n.meta
                        },
                        ..."error"in n && {
                            error: n.error
                        }
                    }
                }
                return {
                    type: e,
                    payload: arguments.length <= 0 ? void 0 : arguments[0]
                }
            }
            return n.toString = () => `${e}`,
            n.type = e,
            n.match = t => function(e) {
                return I(e) && "type"in e && "string" === typeof e.type
            }(t) && t.type === e,
            n
        }
        var Pe = class e extends Array {
            constructor() {
                super(...arguments),
                Object.setPrototypeOf(this, e.prototype)
            }
            static get[Symbol.species]() {
                return e
            }
            concat() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                return super.concat.apply(this, t)
            }
            prepend() {
                for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
                    n[r] = arguments[r];
                return 1 === n.length && Array.isArray(n[0]) ? new e(...n[0].concat(this)) : new e(...n.concat(this))
            }
        }
        ;
        function Be(e) {
            return V(e) ? Ce(e, ( () => {}
            )) : e
        }
        function Ie(e, t, n) {
            if (e.has(t)) {
                let r = e.get(t);
                return n.update && (r = n.update(r, t, e),
                e.set(t, r)),
                r
            }
            if (!n.insert)
                throw new Error(Ve(10));
            const r = n.insert(t, e);
            return e.set(t, r),
            r
        }
        var Le = "RTK_autoBatch"
          , ke = e => t => {
            setTimeout(t, e)
        }
          , De = "undefined" !== typeof window && window.requestAnimationFrame ? window.requestAnimationFrame : ke(10)
          , Oe = e => function(t) {
            const {autoBatch: n=!0} = t ?? {};
            let r = new Pe(e);
            return n && r.push(function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                    type: "raf"
                };
                return t => function() {
                    const n = t(...arguments);
                    let r = !0
                      , i = !1
                      , o = !1;
                    const a = new Set
                      , s = "tick" === e.type ? queueMicrotask : "raf" === e.type ? De : "callback" === e.type ? e.queueNotification : ke(e.timeout)
                      , l = () => {
                        o = !1,
                        i && (i = !1,
                        a.forEach((e => e())))
                    }
                    ;
                    return Object.assign({}, n, {
                        subscribe(e) {
                            const t = n.subscribe(( () => r && e()));
                            return a.add(e),
                            () => {
                                t(),
                                a.delete(e)
                            }
                        },
                        dispatch(e) {
                            try {
                                return r = !e?.meta?.[Le],
                                i = !r,
                                i && (o || (o = !0,
                                s(l))),
                                n.dispatch(e)
                            } finally {
                                r = !0
                            }
                        }
                    })
                }
            }("object" === typeof n ? n : void 0)),
            r
        }
        ;
        function Ne(e) {
            const t = {}
              , n = [];
            let r;
            const i = {
                addCase(e, n) {
                    const r = "string" === typeof e ? e : e.type;
                    if (!r)
                        throw new Error(Ve(28));
                    if (r in t)
                        throw new Error(Ve(29));
                    return t[r] = n,
                    i
                },
                addMatcher: (e, t) => (n.push({
                    matcher: e,
                    reducer: t
                }),
                i),
                addDefaultCase: e => (r = e,
                i)
            };
            return e(i),
            [t, n, r]
        }
        var Fe = Symbol.for("rtk-slice-createasyncthunk");
        function Ue(e, t) {
            return `${e}/${t}`
        }
        function ze() {
            let {creators: e} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const t = e?.asyncThunk?.[Fe];
            return function(e) {
                const {name: n, reducerPath: r=n} = e;
                if (!n)
                    throw new Error(Ve(11));
                const i = ("function" === typeof e.reducers ? e.reducers(function() {
                    function e(e, t) {
                        return {
                            _reducerDefinitionType: "asyncThunk",
                            payloadCreator: e,
                            ...t
                        }
                    }
                    return e.withTypes = () => e,
                    {
                        reducer: e => Object.assign({
                            [e.name]() {
                                return e(...arguments)
                            }
                        }[e.name], {
                            _reducerDefinitionType: "reducer"
                        }),
                        preparedReducer: (e, t) => ({
                            _reducerDefinitionType: "reducerWithPrepare",
                            prepare: e,
                            reducer: t
                        }),
                        asyncThunk: e
                    }
                }()) : e.reducers) || {}
                  , o = Object.keys(i)
                  , a = {
                    sliceCaseReducersByName: {},
                    sliceCaseReducersByType: {},
                    actionCreators: {},
                    sliceMatchers: []
                }
                  , s = {
                    addCase(e, t) {
                        const n = "string" === typeof e ? e : e.type;
                        if (!n)
                            throw new Error(Ve(12));
                        if (n in a.sliceCaseReducersByType)
                            throw new Error(Ve(13));
                        return a.sliceCaseReducersByType[n] = t,
                        s
                    },
                    addMatcher: (e, t) => (a.sliceMatchers.push({
                        matcher: e,
                        reducer: t
                    }),
                    s),
                    exposeAction: (e, t) => (a.actionCreators[e] = t,
                    s),
                    exposeCaseReducer: (e, t) => (a.sliceCaseReducersByName[e] = t,
                    s)
                };
                function l() {
                    const [t={},n=[],r] = "function" === typeof e.extraReducers ? Ne(e.extraReducers) : [e.extraReducers]
                      , i = {
                        ...t,
                        ...a.sliceCaseReducersByType
                    };
                    return function(e, t) {
                        let n, [r,i,o] = Ne(t);
                        if ("function" === typeof e)
                            n = () => Be(e());
                        else {
                            const t = Be(e);
                            n = () => t
                        }
                        function a() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : n()
                              , t = arguments.length > 1 ? arguments[1] : void 0
                              , a = [r[t.type], ...i.filter((e => {
                                let {matcher: n} = e;
                                return n(t)
                            }
                            )).map((e => {
                                let {reducer: t} = e;
                                return t
                            }
                            ))];
                            return 0 === a.filter((e => !!e)).length && (a = [o]),
                            a.reduce(( (e, n) => {
                                if (n) {
                                    if (W(e)) {
                                        const r = n(e, t);
                                        return void 0 === r ? e : r
                                    }
                                    if (V(e))
                                        return Ce(e, (e => n(e, t)));
                                    {
                                        const r = n(e, t);
                                        if (void 0 === r) {
                                            if (null === e)
                                                return e;
                                            throw Error("A case reducer on a non-draftable value must not return undefined")
                                        }
                                        return r
                                    }
                                }
                                return e
                            }
                            ), e)
                        }
                        return a.getInitialState = n,
                        a
                    }(e.initialState, (e => {
                        for (let t in i)
                            e.addCase(t, i[t]);
                        for (let t of a.sliceMatchers)
                            e.addMatcher(t.matcher, t.reducer);
                        for (let t of n)
                            e.addMatcher(t.matcher, t.reducer);
                        r && e.addDefaultCase(r)
                    }
                    ))
                }
                o.forEach((r => {
                    const o = i[r]
                      , a = {
                        reducerName: r,
                        type: Ue(n, r),
                        createNotation: "function" === typeof e.reducers
                    };
                    !function(e) {
                        return "asyncThunk" === e._reducerDefinitionType
                    }(o) ? function(e, t, n) {
                        let r, i, {type: o, reducerName: a, createNotation: s} = e;
                        if ("reducer"in t) {
                            if (s && !function(e) {
                                return "reducerWithPrepare" === e._reducerDefinitionType
                            }(t))
                                throw new Error(Ve(17));
                            r = t.reducer,
                            i = t.prepare
                        } else
                            r = t;
                        n.addCase(o, r).exposeCaseReducer(a, r).exposeAction(a, i ? Re(o, i) : Re(o))
                    }(a, o, s) : function(e, t, n, r) {
                        let {type: i, reducerName: o} = e;
                        if (!r)
                            throw new Error(Ve(18));
                        const {payloadCreator: a, fulfilled: s, pending: l, rejected: c, settled: u, options: d} = t
                          , h = r(i, a, d);
                        n.exposeAction(o, h),
                        s && n.addCase(h.fulfilled, s);
                        l && n.addCase(h.pending, l);
                        c && n.addCase(h.rejected, c);
                        u && n.addMatcher(h.settled, u);
                        n.exposeCaseReducer(o, {
                            fulfilled: s || je,
                            pending: l || je,
                            rejected: c || je,
                            settled: u || je
                        })
                    }(a, o, s, t)
                }
                ));
                const c = e => e
                  , u = new Map;
                let d;
                function h(e, t) {
                    return d || (d = l()),
                    d(e, t)
                }
                function p() {
                    return d || (d = l()),
                    d.getInitialState()
                }
                function f(t) {
                    let n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    function r(e) {
                        let r = e[t];
                        return "undefined" === typeof r && n && (r = p()),
                        r
                    }
                    function i() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c;
                        const r = Ie(u, n, {
                            insert: () => new WeakMap
                        });
                        return Ie(r, t, {
                            insert: () => {
                                const r = {};
                                for (const [i,o] of Object.entries(e.selectors ?? {}))
                                    r[i] = Ge(o, t, p, n);
                                return r
                            }
                        })
                    }
                    return {
                        reducerPath: t,
                        getSelectors: i,
                        get selectors() {
                            return i(r)
                        },
                        selectSlice: r
                    }
                }
                const m = {
                    name: n,
                    reducer: h,
                    actions: a.actionCreators,
                    caseReducers: a.sliceCaseReducersByName,
                    getInitialState: p,
                    ...f(r),
                    injectInto(e) {
                        let {reducerPath: t, ...n} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        const i = t ?? r;
                        return e.inject({
                            reducerPath: i,
                            reducer: h
                        }, n),
                        {
                            ...m,
                            ...f(i, !0)
                        }
                    }
                };
                return m
            }
        }
        function Ge(e, t, n, r) {
            function i(i) {
                let o = t(i);
                "undefined" === typeof o && r && (o = n());
                for (var a = arguments.length, s = new Array(a > 1 ? a - 1 : 0), l = 1; l < a; l++)
                    s[l - 1] = arguments[l];
                return e(o, ...s)
            }
            return i.unwrapped = e,
            i
        }
        var He = ze();
        function je() {}
        var {assign: We} = Object;
        Symbol.for("rtk-state-proxy-original");
        function Ve(e) {
            return `Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `
        }
        const Xe = He({
            name: "App",
            initialState: {
                isMenuDialog: !1,
                isBoxDialog: !1,
                boxMsg: "",
                swfFile: "null.swf",
                phase: null,
                showStars: !0,
                stars: 0,
                isChangeStars: !1,
                isWelcomeVoice: !1
            },
            reducers: {
                setMenuDialog: (e, t) => {
                    e.isMenuDialog = t.payload
                }
                ,
                setBoxDialog: (e, t) => {
                    e.isBoxDialog = t.payload
                }
                ,
                setBoxMsg: (e, t) => {
                    e.boxMsg = t.payload
                }
                ,
                setSwfFile: (e, t) => {
                    e.swfFile = t.payload
                }
                ,
                setPhase: (e, t) => {
                    e.phase = t.payload
                }
                ,
                setShowStars: (e, t) => {
                    e.showStars = t.payload
                }
                ,
                setStars: (e, t) => {
                    e.stars = t.payload
                }
                ,
                setIsChangeStars: (e, t) => {
                    e.isChangeStars = t.payload
                }
                ,
                setWelcomeVoice: (e, t) => {
                    e.isWelcomeVoice = t.payload
                }
            }
        })
          , {setMenuDialog: Je, setBoxDialog: Ke, setBoxMsg: qe, setSwfFile: Ye, setPhase: Qe, setShowStars: Ze, setStars: $e, setIsChangeStars: et, setWelcomeVoice: tt} = Xe.actions
          , nt = function(e) {
            const t = function(e) {
                const {thunk: t=!0, immutableCheck: n=!0, serializableCheck: r=!0, actionCreatorCheck: i=!0} = e ?? {};
                let o = new Pe;
                return t && ("boolean" === typeof t ? o.push(N) : o.push(F(t.extraArgument))),
                o
            }
              , {reducer: n, middleware: r, devTools: i=!0, preloadedState: o, enhancers: a} = e || {};
            let s, l;
            if ("function" === typeof n)
                s = n;
            else {
                if (!I(n))
                    throw new Error(Ve(1));
                s = k(n)
            }
            l = "function" === typeof r ? r(t) : t();
            let c = D;
            i && (c = Te({
                trace: !1,
                ..."object" === typeof i && i
            }));
            const u = function() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                return e => (n, r) => {
                    const i = e(n, r);
                    let o = () => {
                        throw new Error(T(15))
                    }
                    ;
                    const a = {
                        getState: i.getState,
                        dispatch: function(e) {
                            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
                                n[r - 1] = arguments[r];
                            return o(e, ...n)
                        }
                    }
                      , s = t.map((e => e(a)));
                    return o = D(...s)(i.dispatch),
                    {
                        ...i,
                        dispatch: o
                    }
                }
            }(...l)
              , d = Oe(u);
            return L(s, o, c(..."function" === typeof a ? a(d) : d()))
        }({
            reducer: {
                app: Xe.reducer
            }
        });
        var rt = __webpack_require__(8168)
          , it = __webpack_require__(8587);
        function ot(e) {
            var t, n, r = "";
            if ("string" == typeof e || "number" == typeof e)
                r += e;
            else if ("object" == typeof e)
                if (Array.isArray(e)) {
                    var i = e.length;
                    for (t = 0; t < i; t++)
                        e[t] && (n = ot(e[t])) && (r && (r += " "),
                        r += n)
                } else
                    for (n in e)
                        e[n] && (r && (r += " "),
                        r += n);
            return r
        }
        const at = function() {
            for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)
                (e = arguments[n]) && (t = ot(e)) && (r && (r += " "),
                r += t);
            return r
        };
        var st = __webpack_require__(8661)
          , lt = __webpack_require__(505)
          , ct = __webpack_require__(237)
          , ut = __webpack_require__(2860)
          , dt = __webpack_require__(7576);
        const ht = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            const n = t.useContext(dt.T);
            return n && (r = n,
            0 !== Object.keys(r).length) ? n : e;
            var r
        }
          , pt = (0,
        ut.A)();
        const ft = function() {
            return ht(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pt)
        };
        var mt = __webpack_require__(4414);
        const gt = ["className", "component"];
        var vt = __webpack_require__(4501)
          , yt = __webpack_require__(7775)
          , bt = __webpack_require__(7550)
          , _t = __webpack_require__(1763);
        const At = (0,
        _t.A)("MuiBox", ["root"])
          , xt = (0,
        yt.A)()
          , St = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const {themeId: n, defaultTheme: r, defaultClassName: i="MuiBox-root", generateClassName: o} = e
              , a = (0,
            st.default)("div", {
                shouldForwardProp: e => "theme" !== e && "sx" !== e && "as" !== e
            })(lt.A);
            return t.forwardRef((function(e, t) {
                const s = ft(r)
                  , l = (0,
                ct.A)(e)
                  , {className: c, component: u="div"} = l
                  , d = (0,
                it.A)(l, gt);
                return (0,
                mt.jsx)(a, (0,
                rt.A)({
                    as: u,
                    ref: t,
                    className: at(c, o ? o(i) : i),
                    theme: n && s[n] || s
                }, d))
            }
            ))
        }({
            themeId: bt.A,
            defaultTheme: xt,
            defaultClassName: At.root,
            generateClassName: vt.A.generate
        });
        var wt = __webpack_require__(533)
          , Et = __webpack_require__(8465)
          , Mt = __webpack_require__(9254)
          , Ct = __webpack_require__(8463)
          , Tt = __webpack_require__(1676)
          , Rt = __webpack_require__(9269);
        const Pt = e => {
            let t;
            return t = e < 1 ? 5.11916 * e ** 2 : 4.5 * Math.log(e + 1) + 2,
            (t / 100).toFixed(2)
        }
        ;
        var Bt = __webpack_require__(423);
        function It(e) {
            return (0,
            Bt.Ay)("MuiPaper", e)
        }
        (0,
        _t.A)("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
        const Lt = ["className", "component", "elevation", "square", "variant"]
          , kt = (0,
        Mt.Ay)("div", {
            name: "MuiPaper",
            slot: "Root",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.root, t[n.variant], !n.square && t.rounded, "elevation" === n.variant && t[`elevation${n.elevation}`]]
            }
        })((e => {
            let {theme: t, ownerState: n} = e;
            var r;
            return (0,
            rt.A)({
                backgroundColor: (t.vars || t).palette.background.paper,
                color: (t.vars || t).palette.text.primary,
                transition: t.transitions.create("box-shadow")
            }, !n.square && {
                borderRadius: t.shape.borderRadius
            }, "outlined" === n.variant && {
                border: `1px solid ${(t.vars || t).palette.divider}`
            }, "elevation" === n.variant && (0,
            rt.A)({
                boxShadow: (t.vars || t).shadows[n.elevation]
            }, !t.vars && "dark" === t.palette.mode && {
                backgroundImage: `linear-gradient(${(0,
                Rt.X4)("#fff", Pt(n.elevation))}, ${(0,
                Rt.X4)("#fff", Pt(n.elevation))})`
            }, t.vars && {
                backgroundImage: null == (r = t.vars.overlays) ? void 0 : r[n.elevation]
            }))
        }
        ))
          , Dt = t.forwardRef((function(e, t) {
            const n = (0,
            Ct.b)({
                props: e,
                name: "MuiPaper"
            })
              , {className: r, component: i="div", elevation: o=1, square: a=!1, variant: s="elevation"} = n
              , l = (0,
            it.A)(n, Lt)
              , c = (0,
            rt.A)({}, n, {
                component: i,
                elevation: o,
                square: a,
                variant: s
            })
              , u = (e => {
                const {square: t, elevation: n, variant: r, classes: i} = e
                  , o = {
                    root: ["root", r, !t && "rounded", "elevation" === r && `elevation${n}`]
                };
                return (0,
                Et.A)(o, It, i)
            }
            )(c);
            return (0,
            mt.jsx)(kt, (0,
            rt.A)({
                as: i,
                ownerState: c,
                className: (0,
                wt.A)(u.root, r),
                ref: t
            }, l))
        }
        ));
        function Ot(e) {
            return (0,
            Bt.Ay)("MuiAppBar", e)
        }
        (0,
        _t.A)("MuiAppBar", ["root", "positionFixed", "positionAbsolute", "positionSticky", "positionStatic", "positionRelative", "colorDefault", "colorPrimary", "colorSecondary", "colorInherit", "colorTransparent", "colorError", "colorInfo", "colorSuccess", "colorWarning"]);
        const Nt = ["className", "color", "enableColorOnDark", "position"]
          , Ft = (e, t) => e ? `${null == e ? void 0 : e.replace(")", "")}, ${t})` : t
          , Ut = (0,
        Mt.Ay)(Dt, {
            name: "MuiAppBar",
            slot: "Root",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.root, t[`position${(0,
                Tt.A)(n.position)}`], t[`color${(0,
                Tt.A)(n.color)}`]]
            }
        })((e => {
            let {theme: t, ownerState: n} = e;
            const r = "light" === t.palette.mode ? t.palette.grey[100] : t.palette.grey[900];
            return (0,
            rt.A)({
                display: "flex",
                flexDirection: "column",
                width: "100%",
                boxSizing: "border-box",
                flexShrink: 0
            }, "fixed" === n.position && {
                position: "fixed",
                zIndex: (t.vars || t).zIndex.appBar,
                top: 0,
                left: "auto",
                right: 0,
                "@media print": {
                    position: "absolute"
                }
            }, "absolute" === n.position && {
                position: "absolute",
                zIndex: (t.vars || t).zIndex.appBar,
                top: 0,
                left: "auto",
                right: 0
            }, "sticky" === n.position && {
                position: "sticky",
                zIndex: (t.vars || t).zIndex.appBar,
                top: 0,
                left: "auto",
                right: 0
            }, "static" === n.position && {
                position: "static"
            }, "relative" === n.position && {
                position: "relative"
            }, !t.vars && (0,
            rt.A)({}, "default" === n.color && {
                backgroundColor: r,
                color: t.palette.getContrastText(r)
            }, n.color && "default" !== n.color && "inherit" !== n.color && "transparent" !== n.color && {
                backgroundColor: t.palette[n.color].main,
                color: t.palette[n.color].contrastText
            }, "inherit" === n.color && {
                color: "inherit"
            }, "dark" === t.palette.mode && !n.enableColorOnDark && {
                backgroundColor: null,
                color: null
            }, "transparent" === n.color && (0,
            rt.A)({
                backgroundColor: "transparent",
                color: "inherit"
            }, "dark" === t.palette.mode && {
                backgroundImage: "none"
            })), t.vars && (0,
            rt.A)({}, "default" === n.color && {
                "--AppBar-background": n.enableColorOnDark ? t.vars.palette.AppBar.defaultBg : Ft(t.vars.palette.AppBar.darkBg, t.vars.palette.AppBar.defaultBg),
                "--AppBar-color": n.enableColorOnDark ? t.vars.palette.text.primary : Ft(t.vars.palette.AppBar.darkColor, t.vars.palette.text.primary)
            }, n.color && !n.color.match(/^(default|inherit|transparent)$/) && {
                "--AppBar-background": n.enableColorOnDark ? t.vars.palette[n.color].main : Ft(t.vars.palette.AppBar.darkBg, t.vars.palette[n.color].main),
                "--AppBar-color": n.enableColorOnDark ? t.vars.palette[n.color].contrastText : Ft(t.vars.palette.AppBar.darkColor, t.vars.palette[n.color].contrastText)
            }, !["inherit", "transparent"].includes(n.color) && {
                backgroundColor: "var(--AppBar-background)"
            }, {
                color: "inherit" === n.color ? "inherit" : "var(--AppBar-color)"
            }, "transparent" === n.color && {
                backgroundImage: "none",
                backgroundColor: "transparent",
                color: "inherit"
            }))
        }
        ))
          , zt = t.forwardRef((function(e, t) {
            const n = (0,
            Ct.b)({
                props: e,
                name: "MuiAppBar"
            })
              , {className: r, color: i="primary", enableColorOnDark: o=!1, position: a="fixed"} = n
              , s = (0,
            it.A)(n, Nt)
              , l = (0,
            rt.A)({}, n, {
                color: i,
                position: a,
                enableColorOnDark: o
            })
              , c = (e => {
                const {color: t, position: n, classes: r} = e
                  , i = {
                    root: ["root", `color${(0,
                    Tt.A)(t)}`, `position${(0,
                    Tt.A)(n)}`]
                };
                return (0,
                Et.A)(i, Ot, r)
            }
            )(l);
            return (0,
            mt.jsx)(Ut, (0,
            rt.A)({
                square: !0,
                component: "header",
                ownerState: l,
                elevation: 4,
                className: (0,
                wt.A)(c.root, r, "fixed" === a && "mui-fixed"),
                ref: t
            }, s))
        }
        ));
        var Gt = __webpack_require__(1628)
          , Ht = __webpack_require__.n(Gt)
          , jt = __webpack_require__(3528)
          , Wt = __webpack_require__.n(jt)
          , Vt = "undefined" != typeof self ? self : {};
        function Xt(e, t) {
            e: {
                for (var n = ["CLOSURE_FLAGS"], r = Vt, i = 0; i < n.length; i++)
                    if (null == (r = r[n[i]])) {
                        n = null;
                        break e
                    }
                n = r
            }
            return null != (e = n && n[e]) ? e : t
        }
        function Jt() {
            throw Error("Invalid UTF8")
        }
        function Kt(e, t) {
            return t = String.fromCharCode.apply(null, t),
            null == e ? t : e + t
        }
        let qt, Yt;
        const Qt = "undefined" != typeof TextDecoder;
        let Zt;
        const $t = "undefined" != typeof TextEncoder;
        function en(e) {
            if ($t)
                e = (Zt ||= new TextEncoder).encode(e);
            else {
                let n = 0;
                const r = new Uint8Array(3 * e.length);
                for (let i = 0; i < e.length; i++) {
                    var t = e.charCodeAt(i);
                    if (t < 128)
                        r[n++] = t;
                    else {
                        if (t < 2048)
                            r[n++] = t >> 6 | 192;
                        else {
                            if (t >= 55296 && t <= 57343) {
                                if (t <= 56319 && i < e.length) {
                                    const o = e.charCodeAt(++i);
                                    if (o >= 56320 && o <= 57343) {
                                        t = 1024 * (t - 55296) + o - 56320 + 65536,
                                        r[n++] = t >> 18 | 240,
                                        r[n++] = t >> 12 & 63 | 128,
                                        r[n++] = t >> 6 & 63 | 128,
                                        r[n++] = 63 & t | 128;
                                        continue
                                    }
                                    i--
                                }
                                t = 65533
                            }
                            r[n++] = t >> 12 | 224,
                            r[n++] = t >> 6 & 63 | 128
                        }
                        r[n++] = 63 & t | 128
                    }
                }
                e = n === r.length ? r : r.subarray(0, n)
            }
            return e
        }
        var tn, nn = Xt(610401301, !1), rn = Xt(653718497, Xt(1, !0));
        const on = Vt.navigator;
        function an(e) {
            return !!nn && !!tn && tn.brands.some((t => {
                let {brand: n} = t;
                return n && -1 != n.indexOf(e)
            }
            ))
        }
        function sn(e) {
            var t;
            return (t = Vt.navigator) && (t = t.userAgent) || (t = ""),
            -1 != t.indexOf(e)
        }
        function ln() {
            return !!nn && !!tn && tn.brands.length > 0
        }
        function cn() {
            return ln() ? an("Chromium") : (sn("Chrome") || sn("CriOS")) && !(!ln() && sn("Edge")) || sn("Silk")
        }
        function un(e) {
            return un[" "](e),
            e
        }
        tn = on && on.userAgentData || null,
        un[" "] = function() {}
        ;
        var dn = !ln() && (sn("Trident") || sn("MSIE"));
        !sn("Android") || cn(),
        cn(),
        sn("Safari") && (cn() || !ln() && sn("Coast") || !ln() && sn("Opera") || !ln() && sn("Edge") || (ln() ? an("Microsoft Edge") : sn("Edg/")) || ln() && an("Opera"));
        var hn = {}
          , pn = null;
        function fn() {
            if (!pn) {
                pn = {};
                for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), t = ["+/=", "+/", "-_=", "-_.", "-_"], n = 0; n < 5; n++) {
                    var r = e.concat(t[n].split(""));
                    hn[n] = r;
                    for (var i = 0; i < r.length; i++) {
                        var o = r[i];
                        void 0 === pn[o] && (pn[o] = i)
                    }
                }
            }
        }
        var mn = "undefined" != typeof Uint8Array
          , gn = !dn && "function" == typeof btoa;
        function vn(e) {
            if (!gn) {
                var t;
                void 0 === t && (t = 0),
                fn(),
                t = hn[t];
                var n = Array(Math.floor(e.length / 3))
                  , r = t[64] || "";
                let l = 0
                  , c = 0;
                for (; l < e.length - 2; l += 3) {
                    var i = e[l]
                      , o = e[l + 1]
                      , a = e[l + 2]
                      , s = t[i >> 2];
                    i = t[(3 & i) << 4 | o >> 4],
                    o = t[(15 & o) << 2 | a >> 6],
                    a = t[63 & a],
                    n[c++] = s + i + o + a
                }
                switch (s = 0,
                a = r,
                e.length - l) {
                case 2:
                    a = t[(15 & (s = e[l + 1])) << 2] || r;
                case 1:
                    e = e[l],
                    n[c] = t[e >> 2] + t[(3 & e) << 4 | s >> 4] + a + r
                }
                return n.join("")
            }
            for (t = "",
            n = 0,
            r = e.length - 10240; n < r; )
                t += String.fromCharCode.apply(null, e.subarray(n, n += 10240));
            return t += String.fromCharCode.apply(null, n ? e.subarray(n) : e),
            btoa(t)
        }
        const yn = /[-_.]/g
          , bn = {
            "-": "+",
            _: "/",
            ".": "="
        };
        function _n(e) {
            return bn[e] || ""
        }
        function An(e) {
            if (!gn)
                return function(e) {
                    var t = e.length
                      , n = 3 * t / 4;
                    n % 3 ? n = Math.floor(n) : -1 != "=.".indexOf(e[t - 1]) && (n = -1 != "=.".indexOf(e[t - 2]) ? n - 2 : n - 1);
                    var r = new Uint8Array(n)
                      , i = 0;
                    return function(e, t) {
                        function n(t) {
                            for (; r < e.length; ) {
                                var n = e.charAt(r++)
                                  , i = pn[n];
                                if (null != i)
                                    return i;
                                if (!/^[\s\xa0]*$/.test(n))
                                    throw Error("Unknown base64 encoding at char: " + n)
                            }
                            return t
                        }
                        fn();
                        for (var r = 0; ; ) {
                            var i = n(-1)
                              , o = n(0)
                              , a = n(64)
                              , s = n(64);
                            if (64 === s && -1 === i)
                                break;
                            t(i << 2 | o >> 4),
                            64 != a && (t(o << 4 & 240 | a >> 2),
                            64 != s && t(a << 6 & 192 | s))
                        }
                    }(e, (function(e) {
                        r[i++] = e
                    }
                    )),
                    i !== n ? r.subarray(0, i) : r
                }(e);
            yn.test(e) && (e = e.replace(yn, _n)),
            e = atob(e);
            const t = new Uint8Array(e.length);
            for (let n = 0; n < e.length; n++)
                t[n] = e.charCodeAt(n);
            return t
        }
        function xn(e) {
            return mn && null != e && e instanceof Uint8Array
        }
        var Sn = {};
        let wn;
        function En(e) {
            if (e !== Sn)
                throw Error("illegal external caller")
        }
        function Mn() {
            return wn ||= new Tn(null,Sn)
        }
        function Cn(e) {
            En(Sn);
            var t = e.g;
            return null == (t = null == t || xn(t) ? t : "string" == typeof t ? An(t) : null) ? t : e.g = t
        }
        var Tn = class {
            constructor(e, t) {
                if (En(t),
                this.g = e,
                null != e && 0 === e.length)
                    throw Error("ByteString should be constructed with non-empty values")
            }
            h() {
                return new Uint8Array(Cn(this) || 0)
            }
        }
        ;
        function Rn(e, t) {
            e.__closure__error__context__984382 || (e.__closure__error__context__984382 = {}),
            e.__closure__error__context__984382.severity = t
        }
        let Pn;
        function Bn() {
            const e = Error();
            Rn(e, "incident"),
            function(e) {
                Vt.setTimeout(( () => {
                    throw e
                }
                ), 0)
            }(e)
        }
        function In(e) {
            return Rn(e = Error(e), "warning"),
            e
        }
        function Ln() {
            return "function" == typeof BigInt
        }
        function kn(e) {
            return Array.prototype.slice.call(e)
        }
        var Dn = "function" == typeof Symbol && "symbol" == typeof Symbol();
        function On(e) {
            return "function" == typeof Symbol && "symbol" == typeof Symbol() ? Symbol() : e
        }
        var Nn = On()
          , Fn = On("0di")
          , Un = On("2ex")
          , zn = On("1oa")
          , Gn = On("0dg")
          , Hn = Dn ? (e, t) => {
            e[Nn] |= t
        }
        : (e, t) => {
            void 0 !== e.G ? e.G |= t : Object.defineProperties(e, {
                G: {
                    value: t,
                    configurable: !0,
                    writable: !0,
                    enumerable: !1
                }
            })
        }
          , jn = Dn ? (e, t) => {
            e[Nn] &= ~t
        }
        : (e, t) => {
            void 0 !== e.G && (e.G &= ~t)
        }
          , Wn = Dn ? e => 0 | e[Nn] : e => 0 | e.G
          , Vn = Dn ? e => e[Nn] : e => e.G
          , Xn = Dn ? (e, t) => {
            e[Nn] = t
        }
        : (e, t) => {
            void 0 !== e.G ? e.G = t : Object.defineProperties(e, {
                G: {
                    value: t,
                    configurable: !0,
                    writable: !0,
                    enumerable: !1
                }
            })
        }
        ;
        function Jn(e) {
            return Hn(e, 34),
            e
        }
        function Kn(e, t) {
            Xn(t, -30975 & e)
        }
        function qn(e, t) {
            Xn(t, -30941 & e | 34)
        }
        var Yn, Qn = {}, Zn = {};
        function $n(e) {
            return !(!e || "object" != typeof e || e.Ja !== Zn)
        }
        function er(e) {
            return null !== e && "object" == typeof e && !Array.isArray(e) && e.constructor === Object
        }
        function tr(e, t, n) {
            if (null != e)
                if ("string" == typeof e)
                    e = e ? new Tn(e,Sn) : Mn();
                else if (e.constructor !== Tn)
                    if (xn(e))
                        e = e.length ? new Tn(n ? e : new Uint8Array(e),Sn) : Mn();
                    else {
                        if (!t)
                            throw Error();
                        e = void 0
                    }
            return e
        }
        function nr(e) {
            return !(!Array.isArray(e) || e.length) && !!(1 & Wn(e))
        }
        const rr = [];
        function ir(e) {
            if (2 & e)
                throw Error()
        }
        Xn(rr, 55),
        Yn = Object.freeze(rr);
        class or {
            constructor(e, t, n) {
                this.l = 0,
                this.g = e,
                this.h = t,
                this.m = n
            }
            next() {
                if (this.l < this.g.length) {
                    const e = this.g[this.l++];
                    return {
                        done: !1,
                        value: this.h ? this.h.call(this.m, e) : e
                    }
                }
                return {
                    done: !0,
                    value: void 0
                }
            }
            [Symbol.iterator]() {
                return new or(this.g,this.h,this.m)
            }
        }
        let ar;
        function sr(e, t) {
            (t = ar ? t[ar] : void 0) && (e[ar] = kn(t))
        }
        var lr = Object.freeze({})
          , cr = Object.freeze({})
          , ur = Object.freeze({});
        function dr(e) {
            return e.Qa = !0,
            e
        }
        var hr = dr((e => "number" == typeof e))
          , pr = dr((e => "string" == typeof e))
          , fr = dr((e => "boolean" == typeof e))
          , mr = "function" == typeof Vt.BigInt && "bigint" == typeof Vt.BigInt(0)
          , gr = dr((e => mr ? e >= yr && e <= _r : "-" === e[0] ? Ar(e, vr) : Ar(e, br)));
        const vr = Number.MIN_SAFE_INTEGER.toString()
          , yr = mr ? BigInt(Number.MIN_SAFE_INTEGER) : void 0
          , br = Number.MAX_SAFE_INTEGER.toString()
          , _r = mr ? BigInt(Number.MAX_SAFE_INTEGER) : void 0;
        function Ar(e, t) {
            if (e.length > t.length)
                return !1;
            if (e.length < t.length || e === t)
                return !0;
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                  , i = t[n];
                if (r > i)
                    return !1;
                if (r < i)
                    return !0
            }
        }
        const xr = "function" == typeof Uint8Array.prototype.slice;
        let Sr, wr = 0, Er = 0;
        function Mr(e) {
            const t = e >>> 0;
            wr = t,
            Er = (e - t) / 4294967296 >>> 0
        }
        function Cr(e) {
            if (e < 0) {
                Mr(-e);
                const [t,n] = kr(wr, Er);
                wr = t >>> 0,
                Er = n >>> 0
            } else
                Mr(e)
        }
        function Tr(e) {
            const t = Sr ||= new DataView(new ArrayBuffer(8));
            t.setFloat32(0, +e, !0),
            Er = 0,
            wr = t.getUint32(0, !0)
        }
        function Rr(e, t) {
            return 4294967296 * t + (e >>> 0)
        }
        function Pr(e, t) {
            const n = 2147483648 & t;
            return n && (t = ~t >>> 0,
            0 == (e = 1 + ~e >>> 0) && (t = t + 1 >>> 0)),
            e = Rr(e, t),
            n ? -e : e
        }
        function Br(e, t) {
            if (e >>>= 0,
            (t >>>= 0) <= 2097151)
                var n = "" + (4294967296 * t + e);
            else
                Ln() ? n = "" + (BigInt(t) << BigInt(32) | BigInt(e)) : (e = (16777215 & e) + 6777216 * (n = 16777215 & (e >>> 24 | t << 8)) + 6710656 * (t = t >> 16 & 65535),
                n += 8147497 * t,
                t *= 2,
                e >= 1e7 && (n += e / 1e7 >>> 0,
                e %= 1e7),
                n >= 1e7 && (t += n / 1e7 >>> 0,
                n %= 1e7),
                n = t + Ir(n) + Ir(e));
            return n
        }
        function Ir(e) {
            return e = String(e),
            "0000000".slice(e.length) + e
        }
        function Lr(e) {
            if (e.length < 16)
                Cr(Number(e));
            else if (Ln())
                e = BigInt(e),
                wr = Number(e & BigInt(4294967295)) >>> 0,
                Er = Number(e >> BigInt(32) & BigInt(4294967295));
            else {
                const t = +("-" === e[0]);
                Er = wr = 0;
                const n = e.length;
                for (let r = t, i = (n - t) % 6 + t; i <= n; r = i,
                i += 6) {
                    const t = Number(e.slice(r, i));
                    Er *= 1e6,
                    wr = 1e6 * wr + t,
                    wr >= 4294967296 && (Er += Math.trunc(wr / 4294967296),
                    Er >>>= 0,
                    wr >>>= 0)
                }
                if (t) {
                    const [e,t] = kr(wr, Er);
                    wr = e,
                    Er = t
                }
            }
        }
        function kr(e, t) {
            return t = ~t,
            e ? e = 1 + ~e : t += 1,
            [e, t]
        }
        function Dr(e) {
            return null == e || "number" == typeof e ? e : "NaN" === e || "Infinity" === e || "-Infinity" === e ? Number(e) : void 0
        }
        function Or(e) {
            return null == e || "boolean" == typeof e ? e : "number" == typeof e ? !!e : void 0
        }
        const Nr = /^-?([1-9][0-9]*|0)(\.[0-9]+)?$/;
        function Fr(e) {
            const t = typeof e;
            switch (t) {
            case "bigint":
                return !0;
            case "number":
                return Number.isFinite(e)
            }
            return "string" === t && Nr.test(e)
        }
        function Ur(e) {
            if (null == e)
                return e;
            if ("string" == typeof e) {
                if (!e)
                    return;
                e = +e
            }
            return "number" == typeof e && Number.isFinite(e) ? 0 | e : void 0
        }
        function zr(e) {
            if (null == e)
                return e;
            if ("string" == typeof e) {
                if (!e)
                    return;
                e = +e
            }
            return "number" == typeof e && Number.isFinite(e) ? e >>> 0 : void 0
        }
        function Gr(e) {
            return "-" !== e[0] && (e.length < 20 || 20 === e.length && Number(e.substring(0, 6)) < 184467)
        }
        function Hr(e) {
            return e = Math.trunc(e),
            Number.isSafeInteger(e) || (Cr(e),
            e = Pr(wr, Er)),
            e
        }
        function jr(e) {
            var t = Math.trunc(Number(e));
            if (Number.isSafeInteger(t))
                return String(t);
            if (-1 !== (t = e.indexOf(".")) && (e = e.substring(0, t)),
            !("-" === e[0] ? e.length < 20 || 20 === e.length && Number(e.substring(0, 7)) > -922337 : e.length < 19 || 19 === e.length && Number(e.substring(0, 6)) < 922337))
                if (Lr(e),
                e = wr,
                2147483648 & (t = Er))
                    if (Ln())
                        e = "" + (BigInt(0 | t) << BigInt(32) | BigInt(e >>> 0));
                    else {
                        const [n,r] = kr(e, t);
                        e = "-" + Br(n, r)
                    }
                else
                    e = Br(e, t);
            return e
        }
        function Wr(e) {
            return null == e ? e : "bigint" == typeof e ? (gr(e) ? e = Number(e) : (e = BigInt.asIntN(64, e),
            e = gr(e) ? Number(e) : String(e)),
            e) : Fr(e) ? "number" == typeof e ? Hr(e) : jr(e) : void 0
        }
        function Vr(e) {
            if ("string" != typeof e)
                throw Error();
            return e
        }
        function Xr(e) {
            if (null != e && "string" != typeof e)
                throw Error();
            return e
        }
        function Jr(e) {
            return null == e || "string" == typeof e ? e : void 0
        }
        function Kr(e, t, n, r) {
            if (null != e && "object" == typeof e && e.X === Qn)
                return e;
            if (!Array.isArray(e))
                return n ? 2 & r ? (e = t[Fn]) ? t = e : (Jn((e = new t).u),
                t = t[Fn] = e) : t = new t : t = void 0,
                t;
            let i = n = Wn(e);
            return 0 === i && (i |= 32 & r),
            i |= 2 & r,
            i !== n && Xn(e, i),
            new t(e)
        }
        function qr(e, t, n) {
            if (t)
                e: {
                    if (!Fr(t = e))
                        throw In("int64");
                    switch (typeof t) {
                    case "string":
                        t = jr(t);
                        break e;
                    case "bigint":
                        if (e = t = BigInt.asIntN(64, t),
                        pr(e)) {
                            if (!/^\s*(?:-?[1-9]\d*|0)?\s*$/.test(e))
                                throw Error(String(e))
                        } else if (hr(e) && !Number.isSafeInteger(e))
                            throw Error(String(e));
                        t = mr ? BigInt(t) : fr(t) ? t ? "1" : "0" : pr(t) ? t.trim() || "0" : String(t);
                        break e;
                    default:
                        t = Hr(t)
                    }
                }
            else
                t = Wr(e);
            return "string" == typeof (n = null == (e = t) ? n ? 0 : void 0 : e) && (t = +n,
            Number.isSafeInteger(t)) ? t : n
        }
        function Yr(e) {
            if (void 0 === $r && ($r = "function" == typeof Proxy ? si(Proxy) : null),
            !$r || !ai())
                return e;
            let t = Qr?.get(e);
            return t || (Math.random() > .01 ? e : (function(e) {
                if (void 0 === ti) {
                    const e = new $r([],{});
                    ti = 1 === Array.prototype.concat.call([], e).length
                }
                ti && "function" == typeof Symbol && Symbol.isConcatSpreadable && (e[Symbol.isConcatSpreadable] = !0)
            }(e),
            t = new $r(e,{
                set: (e, t, n) => (Bn(),
                e[t] = n,
                !0)
            }),
            function(e, t) {
                (Qr ||= new ei).set(e, t),
                (Zr ||= new ei).set(t, e)
            }(e, t),
            t))
        }
        let Qr, Zr, $r, ei, ti, ni, ri, ii, oi;
        function ai() {
            return void 0 === ei && (ei = "function" == typeof WeakMap ? si(WeakMap) : null),
            ei
        }
        function si(e) {
            try {
                return -1 !== e.toString().indexOf("[native code]") ? e : null
            } catch {
                return null
            }
        }
        function li(e, t, n) {
            if (ai()) {
                if (ni?.get(t)?.get(e)) {
                    if (n)
                        return
                } else if (Math.random() > .01)
                    return;
                var r = e.length;
                n = {
                    length: r
                };
                for (var i = 0; i < Math.min(r, 10); i++) {
                    if (r <= 10)
                        var o = i;
                    else {
                        o = r / 10;
                        const e = Math.floor(i * o);
                        o = e + Math.floor(Math.random() * (Math.floor((i + 1) * o) - e))
                    }
                    n[o] = e[o]
                }
                ui(e, n) ? ((i = (r = ni ||= new ei).get(t)) || (i = new ei,
                r.set(t, i)),
                i.set(e, n)) : (Bn(),
                hi(e, t))
            }
        }
        function ci(e, t) {
            const n = ni?.get(t)?.get(e);
            n && !ui(e, n) && (Bn(),
            hi(e, t))
        }
        function ui(e, t) {
            if (e.length !== t.length)
                return !1;
            for (const i in t) {
                var n, r = Number(i);
                if ((n = Number.isInteger(r)) && (n = e[r],
                r = t[r],
                n = !(Number.isNaN(n) ? Number.isNaN(r) : n === r)),
                n)
                    return !1
            }
            return !0
        }
        function di(e) {
            if (e && ni?.has(e)) {
                var t = e.u;
                if (t)
                    for (let n = 0; n < t.length; n++) {
                        const r = t[n];
                        if (n === t.length - 1 && er(r))
                            for (const t in r) {
                                const n = r[t];
                                Array.isArray(n) && ci(n, e)
                            }
                        else
                            Array.isArray(r) && ci(r, e)
                    }
            }
        }
        function hi(e, t) {
            ni?.get(t)?.delete(e)
        }
        function pi(e, t, n) {
            return e = fi(e, t[0], t[1], n ? 1 : 2),
            t !== ii && n && Hn(e, 16384),
            e
        }
        function fi(e, t, n, r) {
            if (r = r ?? 0,
            null == e && (e = ri),
            ri = void 0,
            null == e) {
                var i = 96;
                n ? (e = [n],
                i |= 512) : e = [],
                t && (i = -33521665 & i | (1023 & t) << 15)
            } else {
                if (!Array.isArray(e))
                    throw Error("narr");
                if (2048 & (i = Wn(e)))
                    throw Error("farr");
                if (64 & i)
                    return e;
                if (1 === r || 2 === r || (i |= 64),
                n && (i |= 512,
                n !== e[0]))
                    throw Error("mid");
                e: {
                    if (r = (n = e).length) {
                        const e = r - 1;
                        if (er(n[e])) {
                            if ((t = e - (+!!(512 & (i |= 256)) - 1)) >= 1024)
                                throw Error("pvtlmt");
                            i = -33521665 & i | (1023 & t) << 15;
                            break e
                        }
                    }
                    if (t) {
                        if ((t = Math.max(t, r - (+!!(512 & i) - 1))) > 1024)
                            throw Error("spvt");
                        i = -33521665 & i | (1023 & t) << 15
                    }
                }
            }
            return Xn(e, i),
            e
        }
        const mi = {};
        let gi = function() {
            try {
                return un(new class extends Map {
                    constructor() {
                        super()
                    }
                }
                ),
                !1
            } catch {
                return !0
            }
        }();
        class vi {
            constructor() {
                this.g = new Map
            }
            get(e) {
                return this.g.get(e)
            }
            set(e, t) {
                return this.g.set(e, t),
                this.size = this.g.size,
                this
            }
            delete(e) {
                return e = this.g.delete(e),
                this.size = this.g.size,
                e
            }
            clear() {
                this.g.clear(),
                this.size = this.g.size
            }
            has(e) {
                return this.g.has(e)
            }
            entries() {
                return this.g.entries()
            }
            keys() {
                return this.g.keys()
            }
            values() {
                return this.g.values()
            }
            forEach(e, t) {
                return this.g.forEach(e, t)
            }
            [Symbol.iterator]() {
                return this.entries()
            }
        }
        const yi = gi ? (Object.setPrototypeOf(vi.prototype, Map.prototype),
        Object.defineProperties(vi.prototype, {
            size: {
                value: 0,
                configurable: !0,
                enumerable: !0,
                writable: !0
            }
        }),
        vi) : class extends Map {
            constructor() {
                super()
            }
        }
        ;
        function bi(e) {
            return e
        }
        function _i(e) {
            if (2 & e.M)
                throw Error("Cannot mutate an immutable Map")
        }
        var Ai = class extends yi {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : bi
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : bi;
                super();
                let i = Wn(e);
                i |= 64,
                Xn(e, i),
                this.M = i,
                this.T = t,
                this.S = n,
                this.Z = this.T ? xi : r;
                for (let o = 0; o < e.length; o++) {
                    const a = e[o]
                      , s = n(a[0], !1, !0);
                    let l = a[1];
                    t ? void 0 === l && (l = null) : l = r(a[1], !1, !0, void 0, void 0, i),
                    super.set(s, l)
                }
            }
            pa() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Si;
                if (0 !== this.size)
                    return this.Y(e)
            }
            Y() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Si;
                const t = []
                  , n = super.entries();
                for (var r; !(r = n.next()).done; )
                    (r = r.value)[0] = e(r[0]),
                    r[1] = e(r[1]),
                    t.push(r);
                return t
            }
            clear() {
                _i(this),
                super.clear()
            }
            delete(e) {
                return _i(this),
                super.delete(this.S(e, !0, !1))
            }
            entries() {
                var e = this.oa();
                return new or(e,wi,this)
            }
            keys() {
                return this.Ia()
            }
            values() {
                var e = this.oa();
                return new or(e,Ai.prototype.get,this)
            }
            forEach(e, t) {
                super.forEach(( (n, r) => {
                    e.call(t, this.get(r), r, this)
                }
                ))
            }
            set(e, t) {
                return _i(this),
                null == (e = this.S(e, !0, !1)) ? this : null == t ? (super.delete(e),
                this) : super.set(e, this.Z(t, !0, !0, this.T, !1, this.M))
            }
            Oa(e) {
                const t = this.S(e[0], !1, !0);
                e = e[1],
                e = this.T ? void 0 === e ? null : e : this.Z(e, !1, !0, void 0, !1, this.M),
                super.set(t, e)
            }
            has(e) {
                return super.has(this.S(e, !1, !1))
            }
            get(e) {
                e = this.S(e, !1, !1);
                const t = super.get(e);
                if (void 0 !== t) {
                    var n = this.T;
                    return n ? ((n = this.Z(t, !1, !0, n, this.ta, this.M)) !== t && super.set(e, n),
                    n) : t
                }
            }
            oa() {
                return Array.from(super.keys())
            }
            Ia() {
                return super.keys()
            }
            [Symbol.iterator]() {
                return this.entries()
            }
        }
        ;
        function xi(e, t, n, r, i, o) {
            return e = Kr(e, r, n, o),
            i && (e = ki(e)),
            e
        }
        function Si(e) {
            return e
        }
        function wi(e) {
            return [e, this.get(e)]
        }
        let Ei;
        function Mi() {
            return Ei ||= new Ai(Jn([]),void 0,void 0,void 0,mi)
        }
        function Ci(e, t, n, r, i) {
            if (null != e) {
                if (Array.isArray(e))
                    e = nr(e) ? void 0 : i && 2 & Wn(e) ? e : Ti(e, t, n, void 0 !== r, i);
                else if (er(e)) {
                    const o = {};
                    for (let a in e)
                        o[a] = Ci(e[a], t, n, r, i);
                    e = o
                } else
                    e = t(e, r);
                return e
            }
        }
        function Ti(e, t, n, r, i) {
            const o = r || n ? Wn(e) : 0;
            r = r ? !!(32 & o) : void 0;
            const a = kn(e);
            for (let s = 0; s < a.length; s++)
                a[s] = Ci(a[s], t, n, r, i);
            return n && (sr(a, e),
            n(o, a)),
            a
        }
        function Ri(e) {
            return Ci(e, Pi, void 0, void 0, !1)
        }
        function Pi(e) {
            return e.X === Qn ? e.toJSON() : e instanceof Ai ? e.pa(Ri) : function(e) {
                switch (typeof e) {
                case "number":
                    return isFinite(e) ? e : String(e);
                case "bigint":
                    return gr(e) ? Number(e) : String(e);
                case "boolean":
                    return e ? 1 : 0;
                case "object":
                    if (e)
                        if (Array.isArray(e)) {
                            if (nr(e))
                                return
                        } else {
                            if (xn(e))
                                return vn(e);
                            if (e instanceof Tn) {
                                const t = e.g;
                                return null == t ? "" : "string" == typeof t ? t : e.g = vn(t)
                            }
                            if (e instanceof Ai)
                                return e.pa()
                        }
                }
                return e
            }(e)
        }
        function Bi(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : qn;
            if (null != e) {
                if (mn && e instanceof Uint8Array)
                    return t ? e : new Uint8Array(e);
                if (Array.isArray(e)) {
                    var r = Wn(e);
                    return 2 & r ? e : (t &&= 0 === r || !!(32 & r) && !(64 & r || !(16 & r)),
                    t ? (Xn(e, -12293 & r | 34),
                    e) : Ti(e, Bi, 4 & r ? qn : n, !0, !0))
                }
                return e.X === Qn ? (n = e.u,
                e = 2 & (r = Vn(n)) ? e : Ii(e, n, r, !0)) : e instanceof Ai && !(2 & e.M) && (n = Jn(e.Y(Bi)),
                e = new Ai(n,e.T,e.S,e.Z)),
                e
            }
        }
        function Ii(e, t, n, r) {
            return di(e),
            e = e.constructor,
            ri = t = Li(t, n, r),
            t = new e(t),
            ri = void 0,
            t
        }
        function Li(e, t, n) {
            const r = n || 2 & t ? qn : Kn
              , i = !!(32 & t);
            return e = function(e, t, n) {
                const r = kn(e);
                var i = r.length;
                const o = 256 & t ? r[i - 1] : void 0;
                for (i += o ? -1 : 0,
                t = 512 & t ? 1 : 0; t < i; t++)
                    r[t] = n(r[t]);
                if (o) {
                    t = r[t] = {};
                    for (const e in o)
                        t[e] = n(o[e])
                }
                return sr(r, e),
                r
            }(e, t, (e => Bi(e, i, r))),
            Hn(e, 32 | (n ? 2 : 0)),
            e
        }
        function ki(e) {
            const t = e.u
              , n = Vn(t);
            return 2 & n ? Ii(e, t, n, !1) : e
        }
        function Di(e, t, n, r) {
            return !(4 & t) || null != n && (!r && 0 === n && (4096 & t || 8192 & t) && (e.constructor[Gn] = 1 + (0 | e.constructor[Gn])) < 5 && Bn(),
            0 !== n && !(n & t))
        }
        function Oi(e, t) {
            return Fi(e = e.u, Vn(e), t)
        }
        function Ni(e, t, n, r) {
            if (!((t = r + (+!!(512 & t) - 1)) < 0 || t >= e.length || t >= n))
                return e[t]
        }
        function Fi(e, t, n, r) {
            if (-1 === n)
                return null;
            const i = t >> 15 & 1023 || 536870912;
            if (!(n >= i)) {
                var o = e.length;
                return r && 256 & t && null != (r = e[o - 1][n]) ? (Ni(e, t, i, n) && null != Un && ((t = (e = Pn ??= {})[Un] || 0) >= 4 || (e[Un] = t + 1,
                Bn())),
                r) : Ni(e, t, i, n)
            }
            return 256 & t ? e[e.length - 1][n] : void 0
        }
        function Ui(e, t, n) {
            const r = e.u;
            let i = Vn(r);
            return ir(i),
            zi(r, i, t, n),
            e
        }
        function zi(e, t, n, r) {
            const i = t >> 15 & 1023 || 536870912;
            if (n >= i) {
                let o, a = t;
                if (256 & t)
                    o = e[e.length - 1];
                else {
                    if (null == r)
                        return a;
                    o = e[i + (+!!(512 & t) - 1)] = {},
                    a |= 256
                }
                return o[n] = r,
                n < i && (e[n + (+!!(512 & t) - 1)] = void 0),
                a !== t && Xn(e, a),
                a
            }
            return e[n + (+!!(512 & t) - 1)] = r,
            256 & t && n in (e = e[e.length - 1]) && delete e[n],
            t
        }
        function Gi(e, t, n, r, i) {
            var o = 2 & t;
            i = Fi(e, t, n, i),
            Array.isArray(i) || (i = Yn);
            const a = !(2 & r);
            r = !(1 & r);
            const s = !!(32 & t);
            let l = Wn(i);
            return 0 !== l || !s || o || a ? 1 & l || (l |= 1,
            Xn(i, l)) : (l |= 33,
            Xn(i, l)),
            o ? (e = !1,
            2 & l || (Jn(i),
            e = !!(4 & l)),
            (r || e) && Object.freeze(i)) : (o = !!(2 & l) || !!(2048 & l),
            r && o ? (i = kn(i),
            o = 1,
            s && !a && (o |= 32),
            Xn(i, o),
            zi(e, t, n, i)) : a && 32 & l && !o && jn(i, 32)),
            i
        }
        function Hi(e, t) {
            e = e.u;
            let n = Vn(e);
            const r = Fi(e, n, t)
              , i = Dr(r);
            return null != i && i !== r && zi(e, n, t, i),
            i
        }
        function ji(e) {
            e = e.u;
            let t = Vn(e);
            const n = Fi(e, t, 1)
              , r = tr(n, !0, !!(34 & t));
            return null != r && r !== n && zi(e, t, 1, r),
            r
        }
        function Wi() {
            return void 0 === lr ? 2 : 5
        }
        function Vi(e, t, n, r, i, o) {
            const a = e.u;
            let s = Vn(a);
            r = 2 & s ? 1 : r,
            o = !!o,
            i = Xi(a, s, t, i);
            var l = Wn(i)
              , c = i;
            if (ci(c, e),
            2 !== r && 1 !== r || hi(c, e),
            Di(e, l, void 0, o)) {
                4 & l && (i = kn(i),
                l = lo(l, s),
                s = zi(a, s, t, i));
                let e = c = 0;
                for (; c < i.length; c++) {
                    const t = n(i[c]);
                    null != t && (i[e++] = t)
                }
                e < c && (i.length = e),
                l = -4097 & (l = Ji(l, s)) | 20,
                Xn(i, l &= -8193),
                2 & l && Object.freeze(i)
            }
            let u;
            return 1 === r || 4 === r && 32 & l ? Ki(l) || (e = l,
            (l |= 2) !== e && Xn(i, l),
            Object.freeze(i)) : (n = 5 === r && (!!(32 & l) || Ki(l) || !!Qr?.get(i)),
            (2 === r || n) && Ki(l) && (i = kn(i),
            l = co(l = lo(l, s), s, o),
            Xn(i, l),
            s = zi(a, s, t, i)),
            Ki(l) || (t = l,
            (l = co(l, s, o)) !== t && Xn(i, l)),
            n ? (u = Yr(i),
            li(i, e, !0)) : 2 !== r || o || Qr?.delete(i)),
            u || i
        }
        function Xi(e, t, n, r) {
            return e = Fi(e, t, n, r),
            Array.isArray(e) ? e : Yn
        }
        function Ji(e, t) {
            return 0 === e && (e = lo(e, t)),
            1 | e
        }
        function Ki(e) {
            return !!(2 & e) && !!(4 & e) || !!(2048 & e)
        }
        function qi(e) {
            e = kn(e);
            for (let t = 0; t < e.length; t++) {
                const n = e[t] = kn(e[t]);
                Array.isArray(n[1]) && (n[1] = Jn(n[1]))
            }
            return e
        }
        function Yi(e, t, n, r) {
            e = e.u;
            let i = Vn(e);
            ir(i),
            zi(e, i, t, ("0" === r ? 0 === Number(n) : n === r) ? void 0 : n)
        }
        function Qi(e, t) {
            var n = bl;
            return eo(Zi(e = e.u), e, Vn(e), n) === t ? t : -1
        }
        function Zi(e) {
            if (Dn)
                return e[zn] ?? (e[zn] = new Map);
            if (zn in e)
                return e[zn];
            const t = new Map;
            return Object.defineProperty(e, zn, {
                value: t
            }),
            t
        }
        function $i(e, t, n, r) {
            const i = Zi(e)
              , o = eo(i, e, t, n);
            return o !== r && (o && (t = zi(e, t, o)),
            i.set(n, r)),
            t
        }
        function eo(e, t, n, r) {
            let i = e.get(r);
            if (null != i)
                return i;
            i = 0;
            for (let o = 0; o < r.length; o++) {
                const e = r[o];
                null != Fi(t, n, e) && (0 !== i && (n = zi(t, n, i)),
                i = e)
            }
            return e.set(r, i),
            i
        }
        function to(e, t, n, r) {
            let i, o = Vn(e);
            if (null != (r = Fi(e, o, n, r)) && r.X === Qn)
                return (t = ki(r)) !== r && zi(e, o, n, t),
                t.u;
            if (Array.isArray(r)) {
                const e = Wn(r);
                i = 2 & e ? pi(Li(r, e, !1), t, !0) : 64 & e ? r : pi(i, t, !0)
            } else
                i = pi(void 0, t, !0);
            return i !== r && zi(e, o, n, i),
            i
        }
        function no(e, t, n, r) {
            e = e.u;
            let i = Vn(e);
            return (t = Kr(r = Fi(e, i, n, r), t, !1, i)) !== r && null != t && zi(e, i, n, t),
            t
        }
        function ro(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            if (null == (t = no(e, t, n, r)))
                return t;
            if (e = e.u,
            !(2 & (r = Vn(e)))) {
                const i = ki(t);
                i !== t && zi(e, r, n, t = i)
            }
            return t
        }
        function io(e, t, n, r, i, o, a) {
            const s = e.u;
            var l = !!(2 & t);
            i = l ? 1 : i,
            o = !!o,
            a &&= !l,
            l = Xi(s, t, r);
            var c = Wn(l)
              , u = l;
            if (ci(u, e),
            2 !== i && 1 !== i || hi(u, e),
            !(u = !!(4 & c))) {
                var d = l
                  , h = t;
                const e = !!(2 & (c = Ji(c, t)));
                e && (h |= 2);
                let r = !e
                  , i = !0
                  , o = 0
                  , a = 0;
                for (; o < d.length; o++) {
                    const t = Kr(d[o], n, !1, h);
                    if (t instanceof n) {
                        if (!e) {
                            const e = !!(2 & Wn(t.u));
                            r &&= !e,
                            i &&= e
                        }
                        d[a++] = t
                    }
                }
                a < o && (d.length = a),
                c |= 4,
                c = i ? 16 | c : -17 & c,
                Xn(d, c = r ? 8 | c : -9 & c),
                e && Object.freeze(d)
            }
            if (a && !(8 & c || !l.length && (1 === i || 4 === i && 32 & c))) {
                for (Ki(c) ? (l = kn(l),
                c = lo(c, t),
                t = zi(s, t, r, l)) : hi(l, e),
                n = l,
                a = c,
                d = 0; d < n.length; d++)
                    (c = n[d]) !== (h = ki(c)) && (n[d] = h);
                a |= 8,
                a = n.length ? -17 & a : 16 | a,
                Xn(n, a),
                c = a
            }
            let p;
            return 1 === i || 4 === i && 32 & c ? Ki(c) || (e = c,
            (c |= !l.length || 16 & c && (!u || 32 & c) ? 2 : 2048) !== e && Xn(l, c),
            Object.freeze(l)) : (u = 5 === i && (!!(32 & c) || Ki(c) || !!Qr?.get(l)),
            (2 === i || u) && Ki(c) && (l = kn(l),
            c = co(c = lo(c, t), t, o),
            Xn(l, c),
            t = zi(s, t, r, l)),
            Ki(c) || (r = c,
            (c = co(c, t, o)) !== r && Xn(l, c)),
            u ? (p = Yr(l),
            li(l, e, !0)) : 2 !== i || o || Qr?.delete(l)),
            p || l
        }
        function oo(e, t, n) {
            const r = Vn(e.u);
            return io(e, r, t, n, Wi(), !1, !(2 & r))
        }
        function ao(e, t, n, r) {
            return null == r && (r = void 0),
            Ui(e, n, r)
        }
        function so(e, t, n, r) {
            null == r && (r = void 0);
            e: {
                e = e.u;
                let i = Vn(e);
                if (ir(i),
                null == r) {
                    const r = Zi(e);
                    if (eo(r, e, i, n) !== t)
                        break e;
                    r.set(n, 0)
                } else
                    i = $i(e, i, n, t);
                zi(e, i, t, r)
            }
        }
        function lo(e, t) {
            return -2049 & (2 & t ? 2 | e : -3 & e) | 32
        }
        function co(e, t, n) {
            return 32 & t && n || (e &= -33),
            e
        }
        function uo(e, t, n, r) {
            const i = Vn(e.u);
            ir(i),
            e = io(e, i, n, t, 2, !0),
            r = null != r ? r : new n,
            e.push(r),
            2 & Wn(r.u) ? jn(e, 8) : jn(e, 16)
        }
        function ho(e, t) {
            return e ?? t
        }
        function po(e, t) {
            return Ur(Oi(e, t))
        }
        function fo(e, t) {
            return ho(Hi(e, t), 0)
        }
        function mo(e, t) {
            return ho(Jr(Oi(e, t)), "")
        }
        function go(e, t, n) {
            if (null != n && "boolean" != typeof n)
                throw e = typeof n,
                Error(`Expected boolean but got ${"object" != e ? e : n ? Array.isArray(n) ? "array" : e : "null"}: ${n}`);
            Ui(e, t, n)
        }
        function vo(e, t, n) {
            if (null != n) {
                if ("number" != typeof n)
                    throw In("int32");
                if (!Number.isFinite(n))
                    throw In("int32");
                n |= 0
            }
            Ui(e, t, n)
        }
        function yo(e, t, n) {
            if (null != n && "number" != typeof n)
                throw Error(`Value of float/double field must be a number, found ${typeof n}: ${n}`);
            Ui(e, t, n)
        }
        function bo(e, t, n) {
            {
                const s = e.u;
                let l = Vn(s);
                if (ir(l),
                null == n)
                    zi(s, l, t);
                else {
                    n = Zr?.get(n) || n;
                    var r, i = Wn(n), o = i, a = !!(2 & i) || Object.isFrozen(n);
                    if ((r = !a) && ((r = void 0 === ur) || (r = !!rn && void 0 !== cr)),
                    Di(e, i)) {
                        i = 21,
                        a && (n = kn(n),
                        o = 0,
                        i = co(i = lo(i, l), l, !0));
                        for (let e = 0; e < n.length; e++)
                            n[e] = Vr(n[e])
                    }
                    r ? (n = kn(n),
                    o = 0,
                    i = co(i = lo(i, l), l, !0)) : a || li(n, e),
                    i !== o && Xn(n, i),
                    zi(s, l, t, n)
                }
            }
        }
        function _o(e, t, n) {
            ir(Vn(e.u)),
            Vi(e, t, Jr, 2, void 0, !0).push(Vr(n))
        }
        function Ao(e, t) {
            return Error(`Invalid wire type: ${e} (at position ${t})`)
        }
        function xo() {
            return Error("Failed to read varint, encoding is invalid.")
        }
        function So(e, t) {
            return Error(`Tried to read past the end of the data ${t} > ${e}`)
        }
        function wo(e) {
            if ("string" == typeof e)
                return {
                    buffer: An(e),
                    O: !1
                };
            if (Array.isArray(e))
                return {
                    buffer: new Uint8Array(e),
                    O: !1
                };
            if (e.constructor === Uint8Array)
                return {
                    buffer: e,
                    O: !1
                };
            if (e.constructor === ArrayBuffer)
                return {
                    buffer: new Uint8Array(e),
                    O: !1
                };
            if (e.constructor === Tn)
                return {
                    buffer: Cn(e) || new Uint8Array(0),
                    O: !0
                };
            if (e instanceof Uint8Array)
                return {
                    buffer: new Uint8Array(e.buffer,e.byteOffset,e.byteLength),
                    O: !1
                };
            throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")
        }
        function Eo(e, t) {
            let n, r = 0, i = 0, o = 0;
            const a = e.h;
            let s = e.g;
            do {
                n = a[s++],
                r |= (127 & n) << o,
                o += 7
            } while (o < 32 && 128 & n);
            for (o > 32 && (i |= (127 & n) >> 4),
            o = 3; o < 32 && 128 & n; o += 7)
                n = a[s++],
                i |= (127 & n) << o;
            if (Lo(e, s),
            n < 128)
                return t(r >>> 0, i >>> 0);
            throw xo()
        }
        function Mo(e) {
            let t = 0
              , n = e.g;
            const r = n + 10
              , i = e.h;
            for (; n < r; ) {
                const r = i[n++];
                if (t |= r,
                0 == (128 & r))
                    return Lo(e, n),
                    !!(127 & t)
            }
            throw xo()
        }
        function Co(e) {
            const t = e.h;
            let n = e.g
              , r = t[n++]
              , i = 127 & r;
            if (128 & r && (r = t[n++],
            i |= (127 & r) << 7,
            128 & r && (r = t[n++],
            i |= (127 & r) << 14,
            128 & r && (r = t[n++],
            i |= (127 & r) << 21,
            128 & r && (r = t[n++],
            i |= r << 28,
            128 & r && 128 & t[n++] && 128 & t[n++] && 128 & t[n++] && 128 & t[n++] && 128 & t[n++])))))
                throw xo();
            return Lo(e, n),
            i
        }
        function To(e) {
            return Co(e) >>> 0
        }
        function Ro(e) {
            var t = e.h;
            const n = e.g
              , r = t[n]
              , i = t[n + 1]
              , o = t[n + 2];
            return t = t[n + 3],
            Lo(e, e.g + 4),
            (r | i << 8 | o << 16 | t << 24) >>> 0
        }
        function Po(e) {
            var t = Ro(e);
            e = 2 * (t >> 31) + 1;
            const n = t >>> 23 & 255;
            return t &= 8388607,
            255 == n ? t ? NaN : e * (1 / 0) : 0 == n ? 1401298464324817e-60 * e * t : e * Math.pow(2, n - 150) * (t + 8388608)
        }
        function Bo(e) {
            return Co(e)
        }
        function Io(e, t) {
            let {ca: n=!1} = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            e.ca = n,
            t && (t = wo(t),
            e.h = t.buffer,
            e.m = t.O,
            e.j = 0,
            e.l = e.h.length,
            e.g = e.j)
        }
        function Lo(e, t) {
            if (e.g = t,
            t > e.l)
                throw So(e.l, t)
        }
        function ko(e, t) {
            if (t < 0)
                throw Error(`Tried to read a negative byte length: ${t}`);
            const n = e.g
              , r = n + t;
            if (r > e.l)
                throw So(t, e.l - n);
            return e.g = r,
            n
        }
        function Do(e, t) {
            if (0 == t)
                return Mn();
            var n = ko(e, t);
            return e.ca && e.m ? n = e.h.subarray(n, n + t) : (e = e.h,
            n = n === (t = n + t) ? new Uint8Array(0) : xr ? e.slice(n, t) : new Uint8Array(e.subarray(n, t))),
            0 == n.length ? Mn() : new Tn(n,Sn)
        }
        Ai.prototype.toJSON = void 0,
        Ai.prototype.Ja = Zn;
        var Oo = [];
        function No(e) {
            var t = e.g;
            if (t.g == t.l)
                return !1;
            e.l = e.g.g;
            var n = To(e.g);
            if (t = n >>> 3,
            !((n &= 7) >= 0 && n <= 5))
                throw Ao(n, e.l);
            if (t < 1)
                throw Error(`Invalid field number: ${t} (at position ${e.l})`);
            return e.m = t,
            e.h = n,
            !0
        }
        function Fo(e) {
            switch (e.h) {
            case 0:
                0 != e.h ? Fo(e) : Mo(e.g);
                break;
            case 1:
                Lo(e = e.g, e.g + 8);
                break;
            case 2:
                if (2 != e.h)
                    Fo(e);
                else {
                    var t = To(e.g);
                    Lo(e = e.g, e.g + t)
                }
                break;
            case 5:
                Lo(e = e.g, e.g + 4);
                break;
            case 3:
                for (t = e.m; ; ) {
                    if (!No(e))
                        throw Error("Unmatched start-group tag: stream EOF");
                    if (4 == e.h) {
                        if (e.m != t)
                            throw Error("Unmatched end-group tag");
                        break
                    }
                    Fo(e)
                }
                break;
            default:
                throw Ao(e.h, e.l)
            }
        }
        function Uo(e, t, n) {
            const r = e.g.l
              , i = To(e.g)
              , o = e.g.g + i;
            let a = o - r;
            if (a <= 0 && (e.g.l = o,
            n(t, e, void 0, void 0, void 0),
            a = o - e.g.g),
            a)
                throw Error(`Message parsing ended unexpectedly. Expected to read ${i} bytes, instead read ${i - a} bytes, either the data ended unexpectedly or the message misreported its own length`);
            return e.g.g = o,
            e.g.l = r,
            t
        }
        function zo(e) {
            var t = To(e.g)
              , n = ko(e = e.g, t);
            if (e = e.h,
            Qt) {
                var r, i = e;
                (r = Yt) || (r = Yt = new TextDecoder("utf-8",{
                    fatal: !0
                })),
                t = n + t,
                i = 0 === n && t === i.length ? i : i.subarray(n, t);
                try {
                    var o = r.decode(i)
                } catch (e) {
                    if (void 0 === qt) {
                        try {
                            r.decode(new Uint8Array([128]))
                        } catch (e) {}
                        try {
                            r.decode(new Uint8Array([97])),
                            qt = !0
                        } catch (e) {
                            qt = !1
                        }
                    }
                    throw !qt && (Yt = void 0),
                    e
                }
            } else {
                t = (o = n) + t,
                n = [];
                let s, l = null;
                for (; o < t; ) {
                    var a = e[o++];
                    a < 128 ? n.push(a) : a < 224 ? o >= t ? Jt() : (s = e[o++],
                    a < 194 || 128 != (192 & s) ? (o--,
                    Jt()) : n.push((31 & a) << 6 | 63 & s)) : a < 240 ? o >= t - 1 ? Jt() : (s = e[o++],
                    128 != (192 & s) || 224 === a && s < 160 || 237 === a && s >= 160 || 128 != (192 & (r = e[o++])) ? (o--,
                    Jt()) : n.push((15 & a) << 12 | (63 & s) << 6 | 63 & r)) : a <= 244 ? o >= t - 2 ? Jt() : (s = e[o++],
                    128 != (192 & s) || s - 144 + (a << 28) >> 30 != 0 || 128 != (192 & (r = e[o++])) || 128 != (192 & (i = e[o++])) ? (o--,
                    Jt()) : (a = (7 & a) << 18 | (63 & s) << 12 | (63 & r) << 6 | 63 & i,
                    a -= 65536,
                    n.push(55296 + (a >> 10 & 1023), 56320 + (1023 & a)))) : Jt(),
                    n.length >= 8192 && (l = Kt(l, n),
                    n.length = 0)
                }
                o = Kt(l, n)
            }
            return o
        }
        function Go(e) {
            const t = To(e.g);
            return Do(e.g, t)
        }
        function Ho(e, t, n) {
            var r = To(e.g);
            for (r = e.g.g + r; e.g.g < r; )
                n.push(t(e.g))
        }
        var jo = [];
        let Wo;
        function Vo(e, t, n) {
            t.g ? t.m(e, t.g, t.h, n, !0) : t.m(e, t.h, n, !0)
        }
        var Xo = class {
            constructor(e, t) {
                this.u = fi(e, t)
            }
            toJSON() {
                return Jo(this)
            }
            l() {
                var e = fc;
                return e.g ? e.l(this, e.g, e.h, !0) : e.l(this, e.h, e.defaultValue, !0)
            }
            clone() {
                const e = this.u;
                return Ii(this, e, Vn(e), !1)
            }
            O() {
                return !!(2 & Wn(this.u))
            }
        }
        ;
        function Jo(e) {
            di(e),
            e = Wo ? e.u : Ti(e.u, Pi, void 0, void 0, !1);
            {
                var t = !Wo;
                let c = e.length;
                if (c) {
                    var n = e[c - 1]
                      , r = er(n);
                    r ? c-- : n = void 0;
                    var i = e;
                    if (r) {
                        e: {
                            var o, a = n, s = !1;
                            if (a)
                                for (let e in a)
                                    isNaN(+e) ? (o ??= {})[e] = a[e] : (r = a[e],
                                    Array.isArray(r) && (nr(r) || $n(r) && 0 === r.size) && (r = null),
                                    null == r && (s = !0),
                                    null != r && ((o ??= {})[e] = r));
                            if (s || (o = a),
                            o)
                                for (let e in o) {
                                    s = o;
                                    break e
                                }
                            s = null
                        }
                        a = null == s ? null != n : s !== n
                    }
                    for (; c > 0 && (null == (o = i[c - 1]) || nr(o) || $n(o) && 0 === o.size); c--)
                        var l = !0;
                    (i !== e || a || l) && (t ? (l || a || s) && (i.length = c) : i = Array.prototype.slice.call(i, 0, c),
                    s && i.push(s)),
                    l = i
                } else
                    l = e
            }
            return l
        }
        function Ko(e) {
            return e ? /^\d+$/.test(e) ? (Lr(e),
            new qo(wr,Er)) : null : Yo ||= new qo(0,0)
        }
        Xo.prototype.X = Qn,
        Xo.prototype.toString = function() {
            try {
                return Wo = !0,
                Jo(this).toString()
            } finally {
                Wo = !1
            }
        }
        ;
        var qo = class {
            constructor(e, t) {
                this.h = e >>> 0,
                this.g = t >>> 0
            }
        }
        ;
        let Yo;
        function Qo(e) {
            return e ? /^-?\d+$/.test(e) ? (Lr(e),
            new Zo(wr,Er)) : null : $o ||= new Zo(0,0)
        }
        var Zo = class {
            constructor(e, t) {
                this.h = e >>> 0,
                this.g = t >>> 0
            }
        }
        ;
        let $o;
        function ea(e, t, n) {
            for (; n > 0 || t > 127; )
                e.g.push(127 & t | 128),
                t = (t >>> 7 | n << 25) >>> 0,
                n >>>= 7;
            e.g.push(t)
        }
        function ta(e, t) {
            for (; t > 127; )
                e.g.push(127 & t | 128),
                t >>>= 7;
            e.g.push(t)
        }
        function na(e, t) {
            if (t >= 0)
                ta(e, t);
            else {
                for (let n = 0; n < 9; n++)
                    e.g.push(127 & t | 128),
                    t >>= 7;
                e.g.push(1)
            }
        }
        function ra(e, t) {
            e.g.push(t >>> 0 & 255),
            e.g.push(t >>> 8 & 255),
            e.g.push(t >>> 16 & 255),
            e.g.push(t >>> 24 & 255)
        }
        function ia(e, t) {
            0 !== t.length && (e.l.push(t),
            e.h += t.length)
        }
        function oa(e, t, n) {
            ta(e.g, 8 * t + n)
        }
        function aa(e, t) {
            return oa(e, t, 2),
            t = e.g.end(),
            ia(e, t),
            t.push(e.h),
            t
        }
        function sa(e, t) {
            var n = t.pop();
            for (n = e.h + e.g.length() - n; n > 127; )
                t.push(127 & n | 128),
                n >>>= 7,
                e.h++;
            t.push(n),
            e.h++
        }
        function la(e, t, n) {
            oa(e, t, 2),
            ta(e.g, n.length),
            ia(e, e.g.end()),
            ia(e, n)
        }
        function ca(e, t, n, r) {
            null != n && (t = aa(e, t),
            r(n, e),
            sa(e, t))
        }
        function ua() {
            const e = class {
                constructor() {
                    throw Error()
                }
            }
            ;
            return Object.setPrototypeOf(e, e.prototype),
            e
        }
        var da = ua()
          , ha = ua()
          , pa = ua()
          , fa = ua()
          , ma = ua()
          , ga = ua()
          , va = ua()
          , ya = ua()
          , ba = class {
            constructor(e, t, n) {
                this.g = e,
                this.h = t,
                e = da,
                this.l = !!e && n === e || !1
            }
        }
        ;
        function _a(e, t) {
            return new ba(e,t,da)
        }
        function Aa(e, t, n, r, i) {
            ca(e, n, Ia(t, r), i)
        }
        const xa = _a((function(e, t, n, r, i) {
            return 2 === e.h && (Uo(e, to(t, r, n), i),
            !0)
        }
        ), Aa)
          , Sa = _a((function(e, t, n, r, i) {
            return 2 === e.h && (Uo(e, to(t, r, n, !0), i),
            !0)
        }
        ), Aa);
        var wa = Symbol()
          , Ea = Symbol()
          , Ma = Symbol()
          , Ca = Symbol();
        let Ta, Ra;
        function Pa(e, t, n, r) {
            var i = r[e];
            if (i)
                return i;
            (i = {}).W = function(e) {
                switch (typeof e) {
                case "boolean":
                    return ii ||= [0, void 0, !0];
                case "number":
                    return e > 0 ? void 0 : 0 === e ? oi ||= [0, void 0] : [-e, void 0];
                case "string":
                    return [0, e];
                case "object":
                    return e
                }
            }(r[0]);
            var o = r[1];
            let a = 1;
            o && o.constructor === Object && (i.ia = o,
            "function" == typeof (o = r[++a]) && (i.na = !0,
            Ta ??= o,
            Ra ??= r[a + 1],
            o = r[a += 2]));
            const s = {};
            for (; o && Array.isArray(o) && o.length && "number" == typeof o[0] && o[0] > 0; ) {
                for (var l = 0; l < o.length; l++)
                    s[o[l]] = o;
                o = r[++a]
            }
            for (l = 1; void 0 !== o; ) {
                let e;
                "number" == typeof o && (l += o,
                o = r[++a]);
                var c = void 0;
                if (o instanceof ba ? e = o : (e = xa,
                a--),
                e?.l) {
                    o = r[++a],
                    c = r;
                    var u = a;
                    "function" == typeof o && (o = o(),
                    c[u] = o),
                    c = o
                }
                for (u = l + 1,
                "number" == typeof (o = r[++a]) && o < 0 && (u -= o,
                o = r[++a]); l < u; l++) {
                    const r = s[l];
                    c ? n(i, l, e, c, r) : t(i, l, e, r)
                }
            }
            return r[e] = i
        }
        function Ba(e) {
            return Array.isArray(e) ? e[0]instanceof ba ? e : [Sa, e] : [e, void 0]
        }
        function Ia(e, t) {
            return e instanceof Xo ? (di(e),
            e.u) : Array.isArray(e) ? pi(e, t, !1) : void 0
        }
        function La(e, t, n, r) {
            const i = n.g;
            e[t] = r ? (e, t, n) => i(e, t, n, r) : i
        }
        function ka(e, t, n, r, i) {
            const o = n.g;
            let a, s;
            e[t] = (e, t, n) => o(e, t, n, s ||= Pa(Ea, La, ka, r).W, a ||= Da(r), i)
        }
        function Da(e) {
            let t = e[Ma];
            if (null != t)
                return t;
            const n = Pa(Ea, La, ka, e);
            return t = n.na ? (e, t) => Ta(e, t, n) : (e, t) => {
                const r = Vn(e);
                for (; No(t) && 4 != t.h; ) {
                    var i = t.m
                      , o = n[i];
                    if (null == o) {
                        var a = n.ia;
                        a && (a = a[i]) && null != (a = Oa(a)) && (o = n[i] = a)
                    }
                    null != o && o(t, e, i) || (i = (o = t).l,
                    Fo(o),
                    o.ha ? o = void 0 : (a = o.g.g - i,
                    o.g.g = i,
                    o = Do(o.g, a)),
                    i = e,
                    o && (ar ||= Symbol(),
                    (a = i[ar]) ? a.push(o) : i[ar] = [o]))
                }
                return 16384 & r && Jn(e),
                !0
            }
            ,
            e[Ma] = t
        }
        function Oa(e) {
            const t = (e = Ba(e))[0].g;
            if (e = e[1]) {
                const n = Da(e)
                  , r = Pa(Ea, La, ka, e).W;
                return (e, i, o) => t(e, i, o, r, n)
            }
            return t
        }
        function Na(e, t, n) {
            e[t] = n.h
        }
        function Fa(e, t, n, r) {
            let i, o;
            const a = n.h;
            e[t] = (e, t, n) => a(e, t, n, o ||= Pa(wa, Na, Fa, r).W, i ||= Ua(r))
        }
        function Ua(e) {
            let t = e[Ca];
            if (!t) {
                const n = Pa(wa, Na, Fa, e);
                t = (e, t) => za(e, t, n),
                e[Ca] = t
            }
            return t
        }
        function za(e, t, n) {
            for (var r = Wn(e), i = +!!(512 & r) - 1, o = e.length, a = 512 & r ? 1 : 0, s = o + (256 & r ? -1 : 0); a < s; a++) {
                const r = e[a];
                if (null == r)
                    continue;
                const o = a - i
                  , s = Ga(n, o);
                s && s(t, r, o)
            }
            if (256 & r) {
                r = e[o - 1];
                for (const e in r)
                    i = +e,
                    Number.isNaN(i) || null != (o = r[i]) && (s = Ga(n, i)) && s(t, o, i)
            }
            if (e = ar ? e[ar] : void 0)
                for (ia(t, t.g.end()),
                n = 0; n < e.length; n++)
                    ia(t, Cn(e[n]) || new Uint8Array(0))
        }
        function Ga(e, t) {
            var n = e[t];
            if (n)
                return n;
            if ((n = e.ia) && (n = n[t])) {
                var r = (n = Ba(n))[0].h;
                if (n = n[1]) {
                    const t = Ua(n)
                      , i = Pa(wa, Na, Fa, n).W;
                    n = e.na ? Ra(i, t) : (e, n, o) => r(e, n, o, i, t)
                } else
                    n = r;
                return e[t] = n
            }
        }
        function Ha(e, t) {
            if (Array.isArray(t)) {
                var n = Wn(t);
                if (4 & n)
                    return t;
                for (var r = 0, i = 0; r < t.length; r++) {
                    const n = e(t[r]);
                    null != n && (t[i++] = n)
                }
                return i < r && (t.length = i),
                Xn(t, -12289 & n | 5),
                2 & n && Object.freeze(t),
                t
            }
        }
        function ja(e, t, n) {
            return new ba(e,t,n)
        }
        function Wa(e, t, n) {
            return new ba(e,t,n)
        }
        function Va(e, t, n) {
            zi(e, Vn(e), t, n)
        }
        var Xa = _a((function(e, t, n, r, i) {
            return 2 === e.h && (e = Uo(e, pi([void 0, void 0], r, !0), i),
            ir(r = Vn(t)),
            (i = Fi(t, r, n))instanceof Ai ? 0 != (2 & i.M) ? ((i = i.Y()).push(e),
            zi(t, r, n, i)) : i.Oa(e) : Array.isArray(i) ? (2 & Wn(i) && zi(t, r, n, i = qi(i)),
            i.push(e)) : zi(t, r, n, [e]),
            !0)
        }
        ), (function(e, t, n, r, i) {
            if (t instanceof Ai)
                t.forEach(( (t, o) => {
                    ca(e, n, pi([o, t], r, !1), i)
                }
                ));
            else if (Array.isArray(t))
                for (let o = 0; o < t.length; o++) {
                    const a = t[o];
                    Array.isArray(a) && ca(e, n, pi(a, r, !1), i)
                }
        }
        ));
        function Ja(e, t, n) {
            if (t = function(e) {
                if (null == e)
                    return e;
                const t = typeof e;
                if ("bigint" === t)
                    return String(BigInt.asIntN(64, e));
                if (Fr(e)) {
                    if ("string" === t)
                        return jr(e);
                    if ("number" === t)
                        return Hr(e)
                }
            }(t),
            null != t && ("string" == typeof t && Qo(t),
            null != t))
                switch (oa(e, n, 0),
                typeof t) {
                case "number":
                    e = e.g,
                    Cr(t),
                    ea(e, wr, Er);
                    break;
                case "bigint":
                    n = BigInt.asUintN(64, t),
                    n = new Zo(Number(n & BigInt(4294967295)),Number(n >> BigInt(32))),
                    ea(e.g, n.h, n.g);
                    break;
                default:
                    n = Qo(t),
                    ea(e.g, n.h, n.g)
                }
        }
        function Ka(e, t, n) {
            null != (t = Ur(t)) && null != t && (oa(e, n, 0),
            na(e.g, t))
        }
        function qa(e, t, n) {
            null != (t = Or(t)) && (oa(e, n, 0),
            e.g.g.push(t ? 1 : 0))
        }
        function Ya(e, t, n) {
            null != (t = Jr(t)) && la(e, n, en(t))
        }
        function Qa(e, t, n, r, i) {
            ca(e, n, Ia(t, r), i)
        }
        function Za(e, t, n) {
            null != (t = null == t || "string" == typeof t || xn(t) || t instanceof Tn ? t : void 0) && la(e, n, wo(t).buffer)
        }
        function $a(e, t, n) {
            return (5 === e.h || 2 === e.h) && (t = Gi(t, Vn(t), n, 2, !1),
            2 == e.h ? Ho(e, Po, t) : t.push(Po(e.g)),
            !0)
        }
        var es = ja((function(e, t, n) {
            if (1 !== e.h)
                return !1;
            var r = e.g;
            e = Ro(r);
            const i = Ro(r);
            r = 2 * (i >> 31) + 1;
            const o = i >>> 20 & 2047;
            return e = 4294967296 * (1048575 & i) + e,
            Va(t, n, 2047 == o ? e ? NaN : r * (1 / 0) : 0 == o ? 5e-324 * r * e : r * Math.pow(2, o - 1075) * (e + 4503599627370496)),
            !0
        }
        ), (function(e, t, n) {
            null != (t = Dr(t)) && (oa(e, n, 1),
            e = e.g,
            (n = Sr ||= new DataView(new ArrayBuffer(8))).setFloat64(0, +t, !0),
            wr = n.getUint32(0, !0),
            Er = n.getUint32(4, !0),
            ra(e, wr),
            ra(e, Er))
        }
        ), ua())
          , ts = ja((function(e, t, n) {
            return 5 === e.h && (Va(t, n, Po(e.g)),
            !0)
        }
        ), (function(e, t, n) {
            null != (t = Dr(t)) && (oa(e, n, 5),
            e = e.g,
            Tr(t),
            ra(e, wr))
        }
        ), ga)
          , ns = Wa($a, (function(e, t, n) {
            if (null != (t = Ha(Dr, t)))
                for (let a = 0; a < t.length; a++) {
                    var r = e
                      , i = n
                      , o = t[a];
                    null != o && (oa(r, i, 5),
                    r = r.g,
                    Tr(o),
                    ra(r, wr))
                }
        }
        ), ga)
          , rs = Wa($a, (function(e, t, n) {
            if (null != (t = Ha(Dr, t)) && t.length) {
                oa(e, n, 2),
                ta(e.g, 4 * t.length);
                for (let r = 0; r < t.length; r++)
                    n = e.g,
                    Tr(t[r]),
                    ra(n, wr)
            }
        }
        ), ga)
          , is = ja((function(e, t, n) {
            return 0 === e.h && (Va(t, n, Eo(e.g, Pr)),
            !0)
        }
        ), Ja, ma)
          , os = ja((function(e, t, n) {
            return 0 === e.h && (Va(t, n, 0 === (e = Eo(e.g, Pr)) ? void 0 : e),
            !0)
        }
        ), Ja, ma)
          , as = ja((function(e, t, n) {
            return 0 === e.h && (Va(t, n, Eo(e.g, Rr)),
            !0)
        }
        ), (function(e, t, n) {
            if (null != (t = function(e) {
                if (null == e)
                    return e;
                var t = typeof e;
                if ("bigint" === t)
                    return String(BigInt.asUintN(64, e));
                if (Fr(e)) {
                    if ("string" === t)
                        return t = Math.trunc(Number(e)),
                        Number.isSafeInteger(t) && t >= 0 ? e = String(t) : (-1 !== (t = e.indexOf(".")) && (e = e.substring(0, t)),
                        Gr(e) || (Lr(e),
                        e = Br(wr, Er))),
                        e;
                    if ("number" === t)
                        return (e = Math.trunc(e)) >= 0 && Number.isSafeInteger(e) ? e : function(e) {
                            if (e < 0) {
                                Cr(e);
                                const t = Br(wr, Er);
                                return e = Number(t),
                                Number.isSafeInteger(e) ? e : t
                            }
                            return Gr(String(e)) ? e : (Cr(e),
                            Rr(wr, Er))
                        }(e)
                }
            }(t)) && ("string" == typeof t && Ko(t),
            null != t))
                switch (oa(e, n, 0),
                typeof t) {
                case "number":
                    e = e.g,
                    Cr(t),
                    ea(e, wr, Er);
                    break;
                case "bigint":
                    n = BigInt.asUintN(64, t),
                    n = new qo(Number(n & BigInt(4294967295)),Number(n >> BigInt(32))),
                    ea(e.g, n.h, n.g);
                    break;
                default:
                    n = Ko(t),
                    ea(e.g, n.h, n.g)
                }
        }
        ), ua())
          , ss = ja((function(e, t, n) {
            return 0 === e.h && (Va(t, n, Co(e.g)),
            !0)
        }
        ), Ka, fa)
          , ls = Wa((function(e, t, n) {
            return (0 === e.h || 2 === e.h) && (t = Gi(t, Vn(t), n, 2, !1),
            2 == e.h ? Ho(e, Co, t) : t.push(Co(e.g)),
            !0)
        }
        ), (function(e, t, n) {
            if (null != (t = Ha(Ur, t)) && t.length) {
                n = aa(e, n);
                for (let n = 0; n < t.length; n++)
                    na(e.g, t[n]);
                sa(e, n)
            }
        }
        ), fa)
          , cs = ja((function(e, t, n) {
            return 0 === e.h && (Va(t, n, 0 === (e = Co(e.g)) ? void 0 : e),
            !0)
        }
        ), Ka, fa)
          , us = ja((function(e, t, n) {
            return 0 === e.h && (Va(t, n, Mo(e.g)),
            !0)
        }
        ), qa, ha)
          , ds = ja((function(e, t, n) {
            return 0 === e.h && (Va(t, n, !1 === (e = Mo(e.g)) ? void 0 : e),
            !0)
        }
        ), qa, ha)
          , hs = Wa((function(e, t, n) {
            if (2 !== e.h)
                return !1;
            e = zo(e);
            const r = Vn(t);
            return ir(r),
            Gi(t, r, n, 2).push(e),
            !0
        }
        ), (function(e, t, n) {
            if (null != (t = Ha(Jr, t)))
                for (let a = 0; a < t.length; a++) {
                    var r = e
                      , i = n
                      , o = t[a];
                    null != o && la(r, i, en(o))
                }
        }
        ), pa)
          , ps = ja((function(e, t, n) {
            return 2 === e.h && (Va(t, n, "" === (e = zo(e)) ? void 0 : e),
            !0)
        }
        ), Ya, pa)
          , fs = ja((function(e, t, n) {
            return 2 === e.h && (Va(t, n, zo(e)),
            !0)
        }
        ), Ya, pa)
          , ms = function(e, t) {
            return new ba(e,t,arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : da)
        }((function(e, t, n, r, i) {
            if (2 !== e.h)
                return !1;
            r = pi(void 0, r, !0);
            let o = Vn(t);
            ir(o);
            let a = Gi(t, o, n, 3);
            return o = Vn(t),
            4 & Wn(a) && (a = kn(a),
            Xn(a, -2079 & Wn(a) | 1),
            zi(t, o, n, a)),
            a.push(r),
            Uo(e, r, i),
            !0
        }
        ), (function(e, t, n, r, i) {
            if (Array.isArray(t))
                for (let o = 0; o < t.length; o++)
                    Qa(e, t[o], n, r, i)
        }
        ))
          , gs = _a((function(e, t, n, r, i, o) {
            return 2 === e.h && ($i(t, Wn(t), o, n),
            Uo(e, t = to(t, r, n), i),
            !0)
        }
        ), Qa)
          , vs = ja((function(e, t, n) {
            return 2 === e.h && (Va(t, n, Go(e)),
            !0)
        }
        ), Za, va)
          , ys = Wa((function(e, t, n) {
            return (0 === e.h || 2 === e.h) && (t = Gi(t, Vn(t), n, 2, !1),
            2 == e.h ? Ho(e, To, t) : t.push(To(e.g)),
            !0)
        }
        ), (function(e, t, n) {
            if (null != (t = Ha(zr, t)))
                for (let a = 0; a < t.length; a++) {
                    var r = e
                      , i = n
                      , o = t[a];
                    null != o && (oa(r, i, 0),
                    ta(r.g, o))
                }
        }
        ), ua())
          , bs = ja((function(e, t, n) {
            return 0 === e.h && (Va(t, n, Co(e.g)),
            !0)
        }
        ), (function(e, t, n) {
            null != (t = Ur(t)) && (t = parseInt(t, 10),
            oa(e, n, 0),
            na(e.g, t))
        }
        ), ya);
        class _s {
            constructor(e, t) {
                this.h = e,
                this.g = t,
                this.l = ro,
                this.m = ao,
                this.defaultValue = void 0
            }
        }
        function As(e, t) {
            return new _s(e,t)
        }
        function xs(e, t) {
            return (n, r) => {
                if (jo.length) {
                    const e = jo.pop();
                    e.o(r),
                    Io(e.g, n, r),
                    n = e
                } else
                    n = new class {
                        constructor(e, t) {
                            if (Oo.length) {
                                const n = Oo.pop();
                                Io(n, e, t),
                                e = n
                            } else
                                e = new class {
                                    constructor(e, t) {
                                        this.h = null,
                                        this.m = !1,
                                        this.g = this.l = this.j = 0,
                                        Io(this, e, t)
                                    }
                                    clear() {
                                        this.h = null,
                                        this.m = !1,
                                        this.g = this.l = this.j = 0,
                                        this.ca = !1
                                    }
                                }
                                (e,t);
                            this.g = e,
                            this.l = this.g.g,
                            this.h = this.m = -1,
                            this.o(t)
                        }
                        o() {
                            let {ha: e=!1} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            this.ha = e
                        }
                    }
                    (n,r);
                try {
                    const r = new e
                      , o = r.u;
                    Da(t)(o, n);
                    var i = r
                } finally {
                    n.g.clear(),
                    n.m = -1,
                    n.h = -1,
                    jo.length < 100 && jo.push(n)
                }
                return i
            }
        }
        function Ss(e) {
            return function() {
                di(this);
                const t = new class {
                    constructor() {
                        this.l = [],
                        this.h = 0,
                        this.g = new class {
                            constructor() {
                                this.g = []
                            }
                            length() {
                                return this.g.length
                            }
                            end() {
                                const e = this.g;
                                return this.g = [],
                                e
                            }
                        }
                    }
                }
                ;
                za(this.u, t, Pa(wa, Na, Fa, e)),
                ia(t, t.g.end());
                const n = new Uint8Array(t.h)
                  , r = t.l
                  , i = r.length;
                let o = 0;
                for (let e = 0; e < i; e++) {
                    const t = r[e];
                    n.set(t, o),
                    o += t.length
                }
                return t.l = [n],
                n
            }
        }
        var ws = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , Es = [0, ps, ja((function(e, t, n) {
            return 2 === e.h && (Va(t, n, (e = Go(e)) === Mn() ? void 0 : e),
            !0)
        }
        ), (function(e, t, n) {
            if (null != t) {
                if (t instanceof Xo) {
                    const r = t.Ra;
                    return void (r && (t = r(t),
                    null != t && la(e, n, wo(t).buffer)))
                }
                if (Array.isArray(t))
                    return
            }
            Za(e, t, n)
        }
        ), va)];
        let Ms, Cs = globalThis.trustedTypes;
        function Ts(e) {
            void 0 === Ms && (Ms = function() {
                let e = null;
                if (!Cs)
                    return e;
                try {
                    const t = e => e;
                    e = Cs.createPolicy("goog#html", {
                        createHTML: t,
                        createScript: t,
                        createScriptURL: t
                    })
                } catch (e) {}
                return e
            }());
            var t = Ms;
            return new class {
                constructor(e) {
                    this.g = e
                }
                toString() {
                    return this.g + ""
                }
            }
            (t ? t.createScriptURL(e) : e)
        }
        function Rs(e) {
            if (0 === (arguments.length <= 1 ? 0 : arguments.length - 1))
                return Ts(e[0]);
            let t = e[0];
            for (let n = 0; n < (arguments.length <= 1 ? 0 : arguments.length - 1); n++)
                t += encodeURIComponent(n + 1 < 1 || arguments.length <= n + 1 ? void 0 : arguments[n + 1]) + e[n + 1];
            return Ts(t)
        }
        var Ps = [0, ss, bs, us, -1, ls, bs, -1]
          , Bs = class extends Xo {
            constructor() {
                super()
            }
        }
          , Is = [0, us, fs, us, bs, -1, Wa((function(e, t, n) {
            return (0 === e.h || 2 === e.h) && (t = Gi(t, Vn(t), n, 2, !1),
            2 == e.h ? Ho(e, Bo, t) : t.push(Co(e.g)),
            !0)
        }
        ), (function(e, t, n) {
            if (null != (t = Ha(Ur, t)) && t.length) {
                n = aa(e, n);
                for (let n = 0; n < t.length; n++)
                    na(e.g, t[n]);
                sa(e, n)
            }
        }
        ), ya), fs, -1, [0, us, -1], bs, us, -1]
          , Ls = [0, fs, -2]
          , ks = class extends Xo {
            constructor() {
                super()
            }
        }
          , Ds = [0]
          , Os = [0, ss, us, 1, us, -3]
          , Ns = class extends Xo {
            constructor(e) {
                super(e, 2)
            }
        }
          , Fs = {};
        Fs[336783863] = [0, fs, us, -1, ss, [0, [1, 2, 3, 4, 5, 6, 7], gs, Ds, gs, Is, gs, Ls, gs, Os, gs, Ps, gs, [0, fs, -2], gs, [0, fs, bs]], [0, fs], us, [0, [1, 3], [2, 4], gs, [0, ls], -1, gs, [0, hs], -1, ms, [0, fs, -1]], fs];
        var Us = [0, os, -1, ds, -3, os, ls, ps, cs, os, -1, ds, cs, ds, -2, ps];
        function zs(e, t) {
            Yi(e, 2, Xr(t), "")
        }
        function Gs(e, t) {
            _o(e, 3, t)
        }
        function Hs(e, t) {
            _o(e, 4, t)
        }
        var js = class extends Xo {
            constructor(e) {
                super(e, 500)
            }
            o(e) {
                return ao(this, 0, 7, e)
            }
        }
          , Ws = [-1, {}]
          , Vs = [0, fs, 1, Ws]
          , Xs = [0, fs, hs, Ws];
        function Js(e, t) {
            uo(e, 1, js, t)
        }
        function Ks(e, t) {
            _o(e, 10, t)
        }
        function qs(e, t) {
            _o(e, 15, t)
        }
        var Ys = class extends Xo {
            constructor(e) {
                super(e, 500)
            }
            o(e) {
                return ao(this, 0, 1001, e)
            }
        }
          , Qs = [-500, ms, [-500, ps, -1, hs, -3, [-2, Fs, us], ms, Es, cs, -1, Vs, Xs, ms, [0, ps, ds], ps, Us, cs, hs, 987, hs], 4, ms, [-500, fs, -1, [-1, {}], 998, fs], ms, [-500, fs, hs, -1, [-2, {}, us], 997, hs, -1], cs, ms, [-500, fs, hs, Ws, 998, hs], hs, cs, Vs, Xs, ms, [0, ps, -1, Ws], hs, -2, Us, ps, -1, ds, 979, Ws, ms, Es];
        Ys.prototype.g = Ss(Qs);
        var Zs = xs(Ys, Qs)
          , $s = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , el = class extends Xo {
            constructor(e) {
                super(e)
            }
            g() {
                return oo(this, $s, 1)
            }
        }
          , tl = [0, ms, [0, ss, ts, fs, -1]]
          , nl = xs(el, tl)
          , rl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , il = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , ol = class extends Xo {
            constructor(e) {
                super(e)
            }
            h() {
                return ro(this, rl, 2)
            }
            g() {
                return oo(this, il, 5)
            }
        }
          , al = xs(class extends Xo {
            constructor(e) {
                super(e)
            }
        }
        , [0, hs, ls, rs, [0, bs, [0, ss, -3], [0, ts, -3], [0, ss, -1, [0, ms, [0, ss, -2]]], ms, [0, ts, -1, fs, ts]], fs, -1, is, ms, [0, ss, ts], hs, is])
          , sl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , ll = xs(class extends Xo {
            constructor(e) {
                super(e)
            }
        }
        , [0, ms, [0, ts, -4]])
          , cl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , ul = xs(class extends Xo {
            constructor(e) {
                super(e)
            }
        }
        , [0, ms, [0, ts, -4]])
          , dl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , hl = [0, ss, -1, rs, bs]
          , pl = class extends Xo {
            constructor() {
                super()
            }
        }
        ;
        pl.prototype.g = Ss([0, ts, -4, is]);
        var fl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , ml = xs(class extends Xo {
            constructor(e) {
                super(e)
            }
        }
        , [0, ms, [0, 1, ss, fs, tl], is])
          , gl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , vl = class extends Xo {
            constructor(e) {
                super(e)
            }
            qa() {
                const e = ji(this);
                return null == e ? Mn() : e
            }
        }
          , yl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , bl = [1, 2]
          , _l = xs(class extends Xo {
            constructor(e) {
                super(e)
            }
        }
        , [0, ms, [0, bl, gs, [0, rs], gs, [0, vs], ss, fs], is])
          , Al = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , xl = [0, fs, ss, ts, hs, -1]
          , Sl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , wl = [0, us, -1]
          , El = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , Ml = [1, 2, 3, 4, 5]
          , Cl = class extends Xo {
            constructor(e) {
                super(e)
            }
            g() {
                return null != ji(this)
            }
            h() {
                return null != Jr(Oi(this, 2))
            }
        }
          , Tl = class extends Xo {
            constructor(e) {
                super(e)
            }
            g() {
                return Or(Oi(this, 2)) ?? !1
            }
        }
          , Rl = [0, vs, fs, [0, ss, is, -1], [0, as, is]]
          , Pl = [0, Rl, us, [0, Ml, gs, Os, gs, Is, gs, Ps, gs, Ds, gs, Ls], bs]
          , Bl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , Il = [0, Pl, ts, -1, ss]
          , Ll = As(502141897, Bl);
        Fs[502141897] = Il;
        var kl = xs(class extends Xo {
            constructor(e) {
                super(e)
            }
        }
        , [0, [0, bs, -1, ns, ys], hl])
          , Dl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , Ol = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , Nl = [0, Pl, ts, [0, Pl], us]
          , Fl = [0, Pl, Il, Nl, ts, [0, [0, Rl]]]
          , Ul = As(508968150, Ol);
        Fs[508968150] = Fl,
        Fs[508968149] = Nl;
        var zl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , Gl = As(513916220, zl);
        Fs[513916220] = [0, Pl, Fl, ss];
        var Hl = class extends Xo {
            constructor(e) {
                super(e)
            }
            h() {
                return ro(this, Al, 2)
            }
            g() {
                Ui(this, 2)
            }
        }
          , jl = [0, Pl, xl];
        Fs[478825465] = jl;
        var Wl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , Vl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , Xl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , Jl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , Kl = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , ql = [0, Pl, [0, Pl], jl, -1]
          , Yl = [0, Pl, ts, ss]
          , Ql = [0, Pl, ts]
          , Zl = [0, Pl, Yl, Ql, ts]
          , $l = As(479097054, Kl);
        Fs[479097054] = [0, Pl, Zl, ql],
        Fs[463370452] = ql,
        Fs[464864288] = Yl;
        var ec = As(462713202, Jl);
        Fs[462713202] = Zl,
        Fs[474472470] = Ql;
        var tc = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , nc = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , rc = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , ic = class extends Xo {
            constructor() {
                super()
            }
        }
          , oc = [0, Pl, ts, -1, ss]
          , ac = [0, Pl, ts, us];
        ic.prototype.g = Ss([0, Pl, Ql, [0, Pl], Il, Nl, oc, ac]);
        var sc = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , lc = As(456383383, sc);
        Fs[456383383] = [0, Pl, xl];
        var cc = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , uc = As(476348187, cc);
        Fs[476348187] = [0, Pl, wl];
        var dc = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , hc = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , pc = [0, bs, -1]
          , fc = As(458105876, class extends Xo {
            constructor(e) {
                super(e)
            }
            g() {
                var e = this.u;
                const t = Vn(e)
                  , n = 2 & t;
                return e = function(e, t, n) {
                    var r = hc;
                    const i = 2 & t;
                    let o = !1;
                    if (null == n) {
                        if (i)
                            return Mi();
                        n = []
                    } else if (n.constructor === Ai) {
                        if (0 == (2 & n.M) || i)
                            return n;
                        n = n.Y()
                    } else
                        Array.isArray(n) ? o = !!(2 & Wn(n)) : n = [];
                    if (i) {
                        if (!n.length)
                            return Mi();
                        o || (o = !0,
                        Jn(n))
                    } else
                        o && (o = !1,
                        n = qi(n));
                    return o || (64 & Wn(n) ? jn(n, 32) : 32 & t && Hn(n, 32)),
                    zi(e, t, 2, r = new Ai(n,r,qr,void 0)),
                    r
                }(e, t, Fi(e, t, 2)),
                !n && hc && (e.ta = !0),
                e
            }
        }
        );
        Fs[458105876] = [0, pc, Xa, [!0, is, [0, fs, -1, hs]]];
        var mc = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , gc = As(458105758, mc);
        Fs[458105758] = [0, Pl, fs, pc];
        var vc = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , yc = As(443442058, vc);
        Fs[443442058] = [0, Pl, fs, ss, ts, hs, -1],
        Fs[514774813] = oc;
        var bc = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , _c = As(516587230, bc);
        function Ac(e, t) {
            return t = t ? t.clone() : new Al,
            void 0 !== e.displayNamesLocale ? Ui(t, 1, Xr(e.displayNamesLocale)) : void 0 === e.displayNamesLocale && Ui(t, 1),
            void 0 !== e.maxResults ? vo(t, 2, e.maxResults) : "maxResults"in e && Ui(t, 2),
            void 0 !== e.scoreThreshold ? yo(t, 3, e.scoreThreshold) : "scoreThreshold"in e && Ui(t, 3),
            void 0 !== e.categoryAllowlist ? bo(t, 4, e.categoryAllowlist) : "categoryAllowlist"in e && Ui(t, 4),
            void 0 !== e.categoryDenylist ? bo(t, 5, e.categoryDenylist) : "categoryDenylist"in e && Ui(t, 5),
            t
        }
        function xc(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1
              , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
            return {
                categories: e.map((e => ({
                    index: ho(po(e, 1), 0) ?? -1,
                    score: fo(e, 2) ?? 0,
                    categoryName: mo(e, 3) ?? "",
                    displayName: mo(e, 4) ?? ""
                }))),
                headIndex: t,
                headName: n
            }
        }
        function Sc(e) {
            var t = Vi(e, 3, Dr, Wi())
              , n = Vi(e, 2, Ur, Wi())
              , r = Vi(e, 1, Jr, Wi())
              , i = Vi(e, 9, Jr, Wi());
            const o = {
                categories: [],
                keypoints: []
            };
            for (let a = 0; a < t.length; a++)
                o.categories.push({
                    score: t[a],
                    index: n[a] ?? -1,
                    categoryName: r[a] ?? "",
                    displayName: i[a] ?? ""
                });
            if ((t = ro(e, ol, 4)?.h()) && (o.boundingBox = {
                originX: po(t, 1) ?? 0,
                originY: po(t, 2) ?? 0,
                width: po(t, 3) ?? 0,
                height: po(t, 4) ?? 0,
                angle: 0
            }),
            ro(e, ol, 4)?.g().length)
                for (const a of ro(e, ol, 4).g())
                    o.keypoints.push({
                        x: Hi(a, 1) ?? 0,
                        y: Hi(a, 2) ?? 0,
                        score: Hi(a, 4) ?? 0,
                        label: Jr(Oi(a, 3)) ?? ""
                    });
            return o
        }
        function wc(e) {
            const t = [];
            for (const n of oo(e, cl, 1))
                t.push({
                    x: fo(n, 1) ?? 0,
                    y: fo(n, 2) ?? 0,
                    z: fo(n, 3) ?? 0,
                    visibility: fo(n, 4) ?? 0
                });
            return t
        }
        function Ec(e) {
            const t = [];
            for (const n of oo(e, sl, 1))
                t.push({
                    x: fo(n, 1) ?? 0,
                    y: fo(n, 2) ?? 0,
                    z: fo(n, 3) ?? 0,
                    visibility: fo(n, 4) ?? 0
                });
            return t
        }
        function Mc(e) {
            return Array.from(e, (e => e > 127 ? e - 256 : e))
        }
        function Cc(e, t) {
            if (e.length !== t.length)
                throw Error(`Cannot compute cosine similarity between embeddings of different sizes (${e.length} vs. ${t.length}).`);
            let n = 0
              , r = 0
              , i = 0;
            for (let o = 0; o < e.length; o++)
                n += e[o] * t[o],
                r += e[o] * e[o],
                i += t[o] * t[o];
            if (r <= 0 || i <= 0)
                throw Error("Cannot compute cosine similarity on embedding with 0 norm.");
            return n / Math.sqrt(r * i)
        }
        let Tc;
        Fs[516587230] = [0, Pl, oc, ac, ts],
        Fs[518928384] = ac;
        const Rc = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]);
        async function Pc() {
            if (void 0 === Tc)
                try {
                    await WebAssembly.instantiate(Rc),
                    Tc = !0
                } catch {
                    Tc = !1
                }
            return Tc
        }
        async function Bc(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Rs``;
            const n = await Pc() ? "wasm_internal" : "wasm_nosimd_internal";
            return {
                wasmLoaderPath: `${t}/${e}_${n}.js`,
                wasmBinaryPath: `${t}/${e}_${n}.wasm`
            }
        }
        var Ic = class {
        }
        ;
        function Lc() {
            var e = navigator;
            return "undefined" != typeof OffscreenCanvas && (!function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : navigator;
                return (e = e.userAgent).includes("Safari") && !e.includes("Chrome")
            }(e) || !!((e = e.userAgent.match(/Version\/([\d]+).*Safari/)) && e.length >= 1 && Number(e[1]) >= 17))
        }
        async function kc(e) {
            if ("function" != typeof importScripts) {
                const t = document.createElement("script");
                return t.src = e.toString(),
                t.crossOrigin = "anonymous",
                new Promise(( (e, n) => {
                    t.addEventListener("load", ( () => {
                        e()
                    }
                    ), !1),
                    t.addEventListener("error", (e => {
                        n(e)
                    }
                    ), !1),
                    document.body.appendChild(t)
                }
                ))
            }
            importScripts(e.toString())
        }
        function Dc(e) {
            return void 0 !== e.videoWidth ? [e.videoWidth, e.videoHeight] : void 0 !== e.naturalWidth ? [e.naturalWidth, e.naturalHeight] : void 0 !== e.displayWidth ? [e.displayWidth, e.displayHeight] : [e.width, e.height]
        }
        function Oc(e, t, n) {
            e.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target"),
            n(t = e.i.stringToNewUTF8(t)),
            e.i._free(t)
        }
        function Nc(e, t, n) {
            if (!e.i.canvas)
                throw Error("No OpenGL canvas configured.");
            if (n ? e.i._bindTextureToStream(n) : e.i._bindTextureToCanvas(),
            !(n = e.i.canvas.getContext("webgl2") || e.i.canvas.getContext("webgl")))
                throw Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");
            e.i.gpuOriginForWebTexturesIsBottomLeft && n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !0),
            n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, t),
            e.i.gpuOriginForWebTexturesIsBottomLeft && n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !1);
            const [r,i] = Dc(t);
            return !e.l || r === e.i.canvas.width && i === e.i.canvas.height || (e.i.canvas.width = r,
            e.i.canvas.height = i),
            [r, i]
        }
        function Fc(e, t, n) {
            e.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");
            const r = new Uint32Array(t.length);
            for (let i = 0; i < t.length; i++)
                r[i] = e.i.stringToNewUTF8(t[i]);
            t = e.i._malloc(4 * r.length),
            e.i.HEAPU32.set(r, t >> 2),
            n(t);
            for (const i of r)
                e.i._free(i);
            e.i._free(t)
        }
        function Uc(e, t, n) {
            e.i.simpleListeners = e.i.simpleListeners || {},
            e.i.simpleListeners[t] = n
        }
        function zc(e, t, n) {
            let r = [];
            e.i.simpleListeners = e.i.simpleListeners || {},
            e.i.simpleListeners[t] = (e, t, i) => {
                t ? (n(r, i),
                r = []) : r.push(e)
            }
        }
        function Gc(e, t) {
            const n = ro(e.baseOptions, Cl, 1) || new Cl;
            "string" == typeof t ? (Ui(n, 2, Xr(t)),
            Ui(n, 1)) : t instanceof Uint8Array && (Ui(n, 1, tr(t, !1, !1)),
            Ui(n, 2)),
            ao(e.baseOptions, 0, 1, n)
        }
        function Hc(e) {
            try {
                const t = e.H.length;
                if (1 === t)
                    throw Error(e.H[0].message);
                if (t > 1)
                    throw Error("Encountered multiple errors: " + e.H.map((e => e.message)).join(", "))
            } finally {
                e.H = []
            }
        }
        function jc(e, t) {
            e.B = Math.max(e.B, t)
        }
        function Wc(e, t) {
            e.A = new js,
            zs(e.A, "PassThroughCalculator"),
            Gs(e.A, "free_memory"),
            Hs(e.A, "free_memory_unused_out"),
            Ks(t, "free_memory"),
            Js(t, e.A)
        }
        function Vc(e, t) {
            Gs(e.A, t),
            Hs(e.A, t + "_unused_out")
        }
        function Xc(e) {
            e.g.addBoolToStream(!0, "free_memory", e.B)
        }
        Ic.forVisionTasks = function(e) {
            return Bc("vision", e)
        }
        ,
        Ic.forTextTasks = function(e) {
            return Bc("text", e)
        }
        ,
        Ic.forGenAiExperimentalTasks = function(e) {
            return Bc("genai_experimental", e)
        }
        ,
        Ic.forGenAiTasks = function(e) {
            return Bc("genai", e)
        }
        ,
        Ic.forAudioTasks = function(e) {
            return Bc("audio", e)
        }
        ,
        Ic.isSimdSupported = function() {
            return Pc()
        }
        ;
        var Jc = class {
            constructor(e) {
                this.g = e,
                this.H = [],
                this.B = 0,
                this.g.setAutoRenderToScreen(!1)
            }
            l(e) {
                if (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) {
                    const t = e.baseOptions || {};
                    if (e.baseOptions?.modelAssetBuffer && e.baseOptions?.modelAssetPath)
                        throw Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");
                    if (!(ro(this.baseOptions, Cl, 1)?.g() || ro(this.baseOptions, Cl, 1)?.h() || e.baseOptions?.modelAssetBuffer || e.baseOptions?.modelAssetPath))
                        throw Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");
                    if (function(e, t) {
                        let n = ro(e.baseOptions, El, 3);
                        if (!n) {
                            var r = n = new El
                              , i = new ks;
                            so(r, 4, Ml, i)
                        }
                        "delegate"in t && ("GPU" === t.delegate ? (t = n,
                        r = new Bs,
                        so(t, 2, Ml, r)) : (t = n,
                        r = new ks,
                        so(t, 4, Ml, r))),
                        ao(e.baseOptions, 0, 3, n)
                    }(this, t),
                    t.modelAssetPath)
                        return fetch(t.modelAssetPath.toString()).then((e => {
                            if (e.ok)
                                return e.arrayBuffer();
                            throw Error(`Failed to fetch model: ${t.modelAssetPath} (${e.status})`)
                        }
                        )).then((e => {
                            try {
                                this.g.i.FS_unlink("/model.dat")
                            } catch {}
                            this.g.i.FS_createDataFile("/", "model.dat", new Uint8Array(e), !0, !1, !1),
                            Gc(this, "/model.dat"),
                            this.m(),
                            this.J()
                        }
                        ));
                    if (t.modelAssetBuffer instanceof Uint8Array)
                        Gc(this, t.modelAssetBuffer);
                    else if (t.modelAssetBuffer)
                        return async function(e) {
                            const t = [];
                            for (var n = 0; ; ) {
                                const {done: r, value: i} = await e.read();
                                if (r)
                                    break;
                                t.push(i),
                                n += i.length
                            }
                            if (0 === t.length)
                                return new Uint8Array(0);
                            if (1 === t.length)
                                return t[0];
                            e = new Uint8Array(n),
                            n = 0;
                            for (const r of t)
                                e.set(r, n),
                                n += r.length;
                            return e
                        }(t.modelAssetBuffer).then((e => {
                            Gc(this, e),
                            this.m(),
                            this.J()
                        }
                        ))
                }
                return this.m(),
                this.J(),
                Promise.resolve()
            }
            J() {}
            ea() {
                let e;
                if (this.g.ea((t => {
                    e = Zs(t)
                }
                )),
                !e)
                    throw Error("Failed to retrieve CalculatorGraphConfig");
                return e
            }
            setGraph(e, t) {
                this.g.attachErrorListener(( (e, t) => {
                    this.H.push(Error(t))
                }
                )),
                this.g.Ma(),
                this.g.setGraph(e, t),
                this.A = void 0,
                Hc(this)
            }
            finishProcessing() {
                this.g.finishProcessing(),
                Hc(this)
            }
            close() {
                this.A = void 0,
                this.g.closeGraph()
            }
        }
        ;
        function Kc(e, t) {
            if (!e)
                throw Error(`Unable to obtain required WebGL resource: ${t}`);
            return e
        }
        Jc.prototype.close = Jc.prototype.close,
        function(e, t) {
            e = e.split(".");
            var n, r = Vt;
            e[0]in r || void 0 === r.execScript || r.execScript("var " + e[0]);
            for (; e.length && (n = e.shift()); )
                e.length || void 0 === t ? r = r[n] && r[n] !== Object.prototype[n] ? r[n] : r[n] = {} : r[n] = t
        }("TaskRunner", Jc);
        class qc {
            constructor(e, t, n, r) {
                this.g = e,
                this.h = t,
                this.m = n,
                this.l = r
            }
            bind() {
                this.g.bindVertexArray(this.h)
            }
            close() {
                this.g.deleteVertexArray(this.h),
                this.g.deleteBuffer(this.m),
                this.g.deleteBuffer(this.l)
            }
        }
        function Yc(e, t, n) {
            const r = e.g;
            if (n = Kc(r.createShader(n), "Failed to create WebGL shader"),
            r.shaderSource(n, t),
            r.compileShader(n),
            !r.getShaderParameter(n, r.COMPILE_STATUS))
                throw Error(`Could not compile WebGL shader: ${r.getShaderInfoLog(n)}`);
            return r.attachShader(e.h, n),
            n
        }
        function Qc(e, t) {
            const n = e.g
              , r = Kc(n.createVertexArray(), "Failed to create vertex array");
            n.bindVertexArray(r);
            const i = Kc(n.createBuffer(), "Failed to create buffer");
            n.bindBuffer(n.ARRAY_BUFFER, i),
            n.enableVertexAttribArray(e.P),
            n.vertexAttribPointer(e.P, 2, n.FLOAT, !1, 0, 0),
            n.bufferData(n.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), n.STATIC_DRAW);
            const o = Kc(n.createBuffer(), "Failed to create buffer");
            return n.bindBuffer(n.ARRAY_BUFFER, o),
            n.enableVertexAttribArray(e.J),
            n.vertexAttribPointer(e.J, 2, n.FLOAT, !1, 0, 0),
            n.bufferData(n.ARRAY_BUFFER, new Float32Array(t ? [0, 1, 0, 0, 1, 0, 1, 1] : [0, 0, 0, 1, 1, 1, 1, 0]), n.STATIC_DRAW),
            n.bindBuffer(n.ARRAY_BUFFER, null),
            n.bindVertexArray(null),
            new qc(n,r,i,o)
        }
        function Zc(e, t) {
            if (e.g) {
                if (t !== e.g)
                    throw Error("Cannot change GL context once initialized")
            } else
                e.g = t
        }
        function $c(e, t, n, r) {
            return Zc(e, t),
            e.h || (e.m(),
            e.C()),
            n ? (e.s || (e.s = Qc(e, !0)),
            n = e.s) : (e.v || (e.v = Qc(e, !1)),
            n = e.v),
            t.useProgram(e.h),
            n.bind(),
            e.l(),
            e = r(),
            n.g.bindVertexArray(null),
            e
        }
        function eu(e, t, n) {
            return Zc(e, t),
            e = Kc(t.createTexture(), "Failed to create texture"),
            t.bindTexture(t.TEXTURE_2D, e),
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, n ?? t.LINEAR),
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, n ?? t.LINEAR),
            t.bindTexture(t.TEXTURE_2D, null),
            e
        }
        function tu(e, t, n) {
            Zc(e, t),
            e.A || (e.A = Kc(t.createFramebuffer(), "Failed to create framebuffe.")),
            t.bindFramebuffer(t.FRAMEBUFFER, e.A),
            t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0)
        }
        function nu(e) {
            e.g?.bindFramebuffer(e.g.FRAMEBUFFER, null)
        }
        var ru = class {
            H() {
                return "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D inputTexture;\n  void main() {\n    gl_FragColor = texture2D(inputTexture, vTex);\n  }\n "
            }
            m() {
                const e = this.g;
                if (this.h = Kc(e.createProgram(), "Failed to create WebGL program"),
                this.ba = Yc(this, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", e.VERTEX_SHADER),
                this.aa = Yc(this, this.H(), e.FRAGMENT_SHADER),
                e.linkProgram(this.h),
                !e.getProgramParameter(this.h, e.LINK_STATUS))
                    throw Error(`Error during program linking: ${e.getProgramInfoLog(this.h)}`);
                this.P = e.getAttribLocation(this.h, "aVertex"),
                this.J = e.getAttribLocation(this.h, "aTex")
            }
            C() {}
            l() {}
            close() {
                if (this.h) {
                    const e = this.g;
                    e.deleteProgram(this.h),
                    e.deleteShader(this.ba),
                    e.deleteShader(this.aa)
                }
                this.A && this.g.deleteFramebuffer(this.A),
                this.v && this.v.close(),
                this.s && this.s.close()
            }
        }
          , iu = class extends ru {
            H() {
                return "\n  precision mediump float;\n  uniform sampler2D backgroundTexture;\n  uniform sampler2D maskTexture;\n  uniform sampler2D colorMappingTexture;\n  varying vec2 vTex;\n  void main() {\n    vec4 backgroundColor = texture2D(backgroundTexture, vTex);\n    float category = texture2D(maskTexture, vTex).r;\n    vec4 categoryColor = texture2D(colorMappingTexture, vec2(category, 0.0));\n    gl_FragColor = mix(backgroundColor, categoryColor, categoryColor.a);\n  }\n "
            }
            C() {
                const e = this.g;
                e.activeTexture(e.TEXTURE1),
                this.B = eu(this, e, e.LINEAR),
                e.activeTexture(e.TEXTURE2),
                this.j = eu(this, e, e.NEAREST)
            }
            m() {
                super.m();
                const e = this.g;
                this.L = Kc(e.getUniformLocation(this.h, "backgroundTexture"), "Uniform location"),
                this.U = Kc(e.getUniformLocation(this.h, "colorMappingTexture"), "Uniform location"),
                this.K = Kc(e.getUniformLocation(this.h, "maskTexture"), "Uniform location")
            }
            l() {
                super.l();
                const e = this.g;
                e.uniform1i(this.K, 0),
                e.uniform1i(this.L, 1),
                e.uniform1i(this.U, 2)
            }
            close() {
                this.B && this.g.deleteTexture(this.B),
                this.j && this.g.deleteTexture(this.j),
                super.close()
            }
        }
          , ou = class extends ru {
            H() {
                return "\n  precision mediump float;\n  uniform sampler2D maskTexture;\n  uniform sampler2D defaultTexture;\n  uniform sampler2D overlayTexture;\n  varying vec2 vTex;\n  void main() {\n    float confidence = texture2D(maskTexture, vTex).r;\n    vec4 defaultColor = texture2D(defaultTexture, vTex);\n    vec4 overlayColor = texture2D(overlayTexture, vTex);\n    // Apply the alpha from the overlay and merge in the default color\n    overlayColor = mix(defaultColor, overlayColor, overlayColor.a);\n    gl_FragColor = mix(defaultColor, overlayColor, confidence);\n  }\n "
            }
            C() {
                const e = this.g;
                e.activeTexture(e.TEXTURE1),
                this.j = eu(this, e),
                e.activeTexture(e.TEXTURE2),
                this.B = eu(this, e)
            }
            m() {
                super.m();
                const e = this.g;
                this.K = Kc(e.getUniformLocation(this.h, "defaultTexture"), "Uniform location"),
                this.L = Kc(e.getUniformLocation(this.h, "overlayTexture"), "Uniform location"),
                this.I = Kc(e.getUniformLocation(this.h, "maskTexture"), "Uniform location")
            }
            l() {
                super.l();
                const e = this.g;
                e.uniform1i(this.I, 0),
                e.uniform1i(this.K, 1),
                e.uniform1i(this.L, 2)
            }
            close() {
                this.j && this.g.deleteTexture(this.j),
                this.B && this.g.deleteTexture(this.B),
                super.close()
            }
        }
        ;
        function au(e, t) {
            switch (t) {
            case 0:
                return e.g.find((e => e instanceof Uint8Array));
            case 1:
                return e.g.find((e => e instanceof Float32Array));
            case 2:
                return e.g.find((e => "undefined" != typeof WebGLTexture && e instanceof WebGLTexture));
            default:
                throw Error(`Type is not supported: ${t}`)
            }
        }
        function su(e) {
            var t = au(e, 1);
            if (!t) {
                if (t = au(e, 0))
                    t = new Float32Array(t).map((e => e / 255));
                else {
                    t = new Float32Array(e.width * e.height);
                    const r = cu(e);
                    var n = du(e);
                    if (tu(n, r, lu(e)),
                    "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "document"in self && "ontouchend"in self.document) {
                        n = new Float32Array(e.width * e.height * 4),
                        r.readPixels(0, 0, e.width, e.height, r.RGBA, r.FLOAT, n);
                        for (let e = 0, r = 0; e < t.length; ++e,
                        r += 4)
                            t[e] = n[r]
                    } else
                        r.readPixels(0, 0, e.width, e.height, r.RED, r.FLOAT, t)
                }
                e.g.push(t)
            }
            return t
        }
        function lu(e) {
            let t = au(e, 2);
            if (!t) {
                const n = cu(e);
                t = hu(e);
                const r = su(e)
                  , i = uu(e);
                n.texImage2D(n.TEXTURE_2D, 0, i, e.width, e.height, 0, n.RED, n.FLOAT, r),
                pu(e)
            }
            return t
        }
        function cu(e) {
            if (!e.canvas)
                throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
            return e.h || (e.h = Kc(e.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")),
            e.h
        }
        function uu(e) {
            if (e = cu(e),
            !fu)
                if (e.getExtension("EXT_color_buffer_float") && e.getExtension("OES_texture_float_linear") && e.getExtension("EXT_float_blend"))
                    fu = e.R32F;
                else {
                    if (!e.getExtension("EXT_color_buffer_half_float"))
                        throw Error("GPU does not fully support 4-channel float32 or float16 formats");
                    fu = e.R16F
                }
            return fu
        }
        function du(e) {
            return e.l || (e.l = new ru),
            e.l
        }
        function hu(e) {
            const t = cu(e);
            t.viewport(0, 0, e.width, e.height),
            t.activeTexture(t.TEXTURE0);
            let n = au(e, 2);
            return n || (n = eu(du(e), t, e.m ? t.LINEAR : t.NEAREST),
            e.g.push(n),
            e.j = !0),
            t.bindTexture(t.TEXTURE_2D, n),
            n
        }
        function pu(e) {
            e.h.bindTexture(e.h.TEXTURE_2D, null)
        }
        var fu, mu = class {
            constructor(e, t, n, r, i, o, a) {
                this.g = e,
                this.m = t,
                this.j = n,
                this.canvas = r,
                this.l = i,
                this.width = o,
                this.height = a,
                this.j && 0 === --gu && console.error("You seem to be creating MPMask instances without invoking .close(). This leaks resources.")
            }
            Ha() {
                return !!au(this, 0)
            }
            la() {
                return !!au(this, 1)
            }
            R() {
                return !!au(this, 2)
            }
            ka() {
                return (e = au(this, 0)) || (e = su(this),
                e = new Uint8Array(e.map((e => 255 * e))),
                this.g.push(e)),
                e;
                var e
            }
            ja() {
                return su(this)
            }
            N() {
                return lu(this)
            }
            clone() {
                const e = [];
                for (const t of this.g) {
                    let n;
                    if (t instanceof Uint8Array)
                        n = new Uint8Array(t);
                    else if (t instanceof Float32Array)
                        n = new Float32Array(t);
                    else {
                        if (!(t instanceof WebGLTexture))
                            throw Error(`Type is not supported: ${t}`);
                        {
                            const e = cu(this)
                              , t = du(this);
                            e.activeTexture(e.TEXTURE1),
                            n = eu(t, e, this.m ? e.LINEAR : e.NEAREST),
                            e.bindTexture(e.TEXTURE_2D, n);
                            const r = uu(this);
                            e.texImage2D(e.TEXTURE_2D, 0, r, this.width, this.height, 0, e.RED, e.FLOAT, null),
                            e.bindTexture(e.TEXTURE_2D, null),
                            tu(t, e, n),
                            $c(t, e, !1, ( () => {
                                hu(this),
                                e.clearColor(0, 0, 0, 0),
                                e.clear(e.COLOR_BUFFER_BIT),
                                e.drawArrays(e.TRIANGLE_FAN, 0, 4),
                                pu(this)
                            }
                            )),
                            nu(t),
                            pu(this)
                        }
                    }
                    e.push(n)
                }
                return new mu(e,this.m,this.R(),this.canvas,this.l,this.width,this.height)
            }
            close() {
                this.j && cu(this).deleteTexture(au(this, 2)),
                gu = -1
            }
        }
        ;
        mu.prototype.close = mu.prototype.close,
        mu.prototype.clone = mu.prototype.clone,
        mu.prototype.getAsWebGLTexture = mu.prototype.N,
        mu.prototype.getAsFloat32Array = mu.prototype.ja,
        mu.prototype.getAsUint8Array = mu.prototype.ka,
        mu.prototype.hasWebGLTexture = mu.prototype.R,
        mu.prototype.hasFloat32Array = mu.prototype.la,
        mu.prototype.hasUint8Array = mu.prototype.Ha;
        var gu = 250;
        const vu = {
            color: "white",
            lineWidth: 4,
            radius: 6
        };
        function yu(e) {
            return {
                ...vu,
                fillColor: (e = e || {}).color,
                ...e
            }
        }
        function bu(e, t) {
            return e instanceof Function ? e(t) : e
        }
        function _u(e, t, n) {
            return Math.max(Math.min(t, n), Math.min(Math.max(t, n), e))
        }
        function Au(e) {
            if (!e.l)
                throw Error("CPU rendering requested but CanvasRenderingContext2D not provided.");
            return e.l
        }
        function xu(e) {
            if (!e.j)
                throw Error("GPU rendering requested but WebGL2RenderingContext not provided.");
            return e.j
        }
        function Su(e, t, n) {
            if (t.R())
                n(t.N());
            else {
                const r = t.la() ? t.ja() : t.ka();
                e.m = e.m ?? new ru;
                const i = xu(e);
                n((e = new mu([r],t.m,!1,i.canvas,e.m,t.width,t.height)).N()),
                e.close()
            }
        }
        function wu(e, t, n, r) {
            const i = function(e) {
                return e.g || (e.g = new iu),
                e.g
            }(e)
              , o = xu(e)
              , a = Array.isArray(n) ? new ImageData(new Uint8ClampedArray(n),1,1) : n;
            $c(i, o, !0, ( () => {
                !function(e, t, n, r) {
                    const i = e.g;
                    if (i.activeTexture(i.TEXTURE0),
                    i.bindTexture(i.TEXTURE_2D, t),
                    i.activeTexture(i.TEXTURE1),
                    i.bindTexture(i.TEXTURE_2D, e.B),
                    i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, n),
                    e.I && function(e, t) {
                        if (e !== t)
                            return !1;
                        e = e.entries(),
                        t = t.entries();
                        for (const [r,i] of e) {
                            e = r;
                            const o = i;
                            var n = t.next();
                            if (n.done)
                                return !1;
                            const [a,s] = n.value;
                            if (n = s,
                            e !== a || o[0] !== n[0] || o[1] !== n[1] || o[2] !== n[2] || o[3] !== n[3])
                                return !1
                        }
                        return !!t.next().done
                    }(e.I, r))
                        i.activeTexture(i.TEXTURE2),
                        i.bindTexture(i.TEXTURE_2D, e.j);
                    else {
                        e.I = r;
                        const t = Array(1024).fill(0);
                        r.forEach(( (e, n) => {
                            if (4 !== e.length)
                                throw Error(`Color at index ${n} is not a four-channel value.`);
                            t[4 * n] = e[0],
                            t[4 * n + 1] = e[1],
                            t[4 * n + 2] = e[2],
                            t[4 * n + 3] = e[3]
                        }
                        )),
                        i.activeTexture(i.TEXTURE2),
                        i.bindTexture(i.TEXTURE_2D, e.j),
                        i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, 256, 1, 0, i.RGBA, i.UNSIGNED_BYTE, new Uint8Array(t))
                    }
                }(i, t, a, r),
                o.clearColor(0, 0, 0, 0),
                o.clear(o.COLOR_BUFFER_BIT),
                o.drawArrays(o.TRIANGLE_FAN, 0, 4);
                const e = i.g;
                e.activeTexture(e.TEXTURE0),
                e.bindTexture(e.TEXTURE_2D, null),
                e.activeTexture(e.TEXTURE1),
                e.bindTexture(e.TEXTURE_2D, null),
                e.activeTexture(e.TEXTURE2),
                e.bindTexture(e.TEXTURE_2D, null)
            }
            ))
        }
        function Eu(e, t, n, r) {
            const i = xu(e)
              , o = function(e) {
                return e.h || (e.h = new ou),
                e.h
            }(e)
              , a = Array.isArray(n) ? new ImageData(new Uint8ClampedArray(n),1,1) : n
              , s = Array.isArray(r) ? new ImageData(new Uint8ClampedArray(r),1,1) : r;
            $c(o, i, !0, ( () => {
                var e = o.g;
                e.activeTexture(e.TEXTURE0),
                e.bindTexture(e.TEXTURE_2D, t),
                e.activeTexture(e.TEXTURE1),
                e.bindTexture(e.TEXTURE_2D, o.j),
                e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, a),
                e.activeTexture(e.TEXTURE2),
                e.bindTexture(e.TEXTURE_2D, o.B),
                e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, s),
                i.clearColor(0, 0, 0, 0),
                i.clear(i.COLOR_BUFFER_BIT),
                i.drawArrays(i.TRIANGLE_FAN, 0, 4),
                i.bindTexture(i.TEXTURE_2D, null),
                (e = o.g).activeTexture(e.TEXTURE0),
                e.bindTexture(e.TEXTURE_2D, null),
                e.activeTexture(e.TEXTURE1),
                e.bindTexture(e.TEXTURE_2D, null),
                e.activeTexture(e.TEXTURE2),
                e.bindTexture(e.TEXTURE_2D, null)
            }
            ))
        }
        var Mu = class {
            constructor(e, t) {
                e instanceof CanvasRenderingContext2D || e instanceof OffscreenCanvasRenderingContext2D ? (this.l = e,
                this.j = t) : this.j = e
            }
            Aa(e, t) {
                if (e) {
                    var n = Au(this);
                    t = yu(t),
                    n.save();
                    var r = n.canvas
                      , i = 0;
                    for (const o of e)
                        n.fillStyle = bu(t.fillColor, {
                            index: i,
                            from: o
                        }),
                        n.strokeStyle = bu(t.color, {
                            index: i,
                            from: o
                        }),
                        n.lineWidth = bu(t.lineWidth, {
                            index: i,
                            from: o
                        }),
                        (e = new Path2D).arc(o.x * r.width, o.y * r.height, bu(t.radius, {
                            index: i,
                            from: o
                        }), 0, 2 * Math.PI),
                        n.fill(e),
                        n.stroke(e),
                        ++i;
                    n.restore()
                }
            }
            za(e, t, n) {
                if (e && t) {
                    var r = Au(this);
                    n = yu(n),
                    r.save();
                    var i = r.canvas
                      , o = 0;
                    for (const a of t) {
                        r.beginPath(),
                        t = e[a.start];
                        const s = e[a.end];
                        t && s && (r.strokeStyle = bu(n.color, {
                            index: o,
                            from: t,
                            to: s
                        }),
                        r.lineWidth = bu(n.lineWidth, {
                            index: o,
                            from: t,
                            to: s
                        }),
                        r.moveTo(t.x * i.width, t.y * i.height),
                        r.lineTo(s.x * i.width, s.y * i.height)),
                        ++o,
                        r.stroke()
                    }
                    r.restore()
                }
            }
            wa(e, t) {
                const n = Au(this);
                t = yu(t),
                n.save(),
                n.beginPath(),
                n.lineWidth = bu(t.lineWidth, {}),
                n.strokeStyle = bu(t.color, {}),
                n.fillStyle = bu(t.fillColor, {}),
                n.moveTo(e.originX, e.originY),
                n.lineTo(e.originX + e.width, e.originY),
                n.lineTo(e.originX + e.width, e.originY + e.height),
                n.lineTo(e.originX, e.originY + e.height),
                n.lineTo(e.originX, e.originY),
                n.stroke(),
                n.fill(),
                n.restore()
            }
            xa(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [0, 0, 0, 255];
                this.l ? function(e, t, n, r) {
                    const i = xu(e);
                    Su(e, t, (t => {
                        wu(e, t, n, r),
                        (t = Au(e)).drawImage(i.canvas, 0, 0, t.canvas.width, t.canvas.height)
                    }
                    ))
                }(this, e, n, t) : wu(this, e.N(), n, t)
            }
            ya(e, t, n) {
                this.l ? function(e, t, n, r) {
                    const i = xu(e);
                    Su(e, t, (t => {
                        Eu(e, t, n, r),
                        (t = Au(e)).drawImage(i.canvas, 0, 0, t.canvas.width, t.canvas.height)
                    }
                    ))
                }(this, e, t, n) : Eu(this, e.N(), t, n)
            }
            close() {
                this.g?.close(),
                this.g = void 0,
                this.h?.close(),
                this.h = void 0,
                this.m?.close(),
                this.m = void 0
            }
        }
        ;
        function Cu(e, t) {
            switch (t) {
            case 0:
                return e.g.find((e => e instanceof ImageData));
            case 1:
                return e.g.find((e => "undefined" != typeof ImageBitmap && e instanceof ImageBitmap));
            case 2:
                return e.g.find((e => "undefined" != typeof WebGLTexture && e instanceof WebGLTexture));
            default:
                throw Error(`Type is not supported: ${t}`)
            }
        }
        function Tu(e) {
            var t = Cu(e, 0);
            if (!t) {
                t = Pu(e);
                const n = Bu(e)
                  , r = new Uint8Array(e.width * e.height * 4);
                tu(n, t, Ru(e)),
                t.readPixels(0, 0, e.width, e.height, t.RGBA, t.UNSIGNED_BYTE, r),
                nu(n),
                t = new ImageData(new Uint8ClampedArray(r.buffer),e.width,e.height),
                e.g.push(t)
            }
            return t
        }
        function Ru(e) {
            let t = Cu(e, 2);
            if (!t) {
                const n = Pu(e);
                t = Iu(e);
                const r = Cu(e, 1) || Tu(e);
                n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, r),
                Lu(e)
            }
            return t
        }
        function Pu(e) {
            if (!e.canvas)
                throw Error("Conversion to different image formats require that a canvas is passed when iniitializing the image.");
            return e.h || (e.h = Kc(e.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")),
            e.h
        }
        function Bu(e) {
            return e.l || (e.l = new ru),
            e.l
        }
        function Iu(e) {
            const t = Pu(e);
            t.viewport(0, 0, e.width, e.height),
            t.activeTexture(t.TEXTURE0);
            let n = Cu(e, 2);
            return n || (n = eu(Bu(e), t),
            e.g.push(n),
            e.m = !0),
            t.bindTexture(t.TEXTURE_2D, n),
            n
        }
        function Lu(e) {
            e.h.bindTexture(e.h.TEXTURE_2D, null)
        }
        function ku(e) {
            const t = Pu(e);
            return $c(Bu(e), t, !0, ( () => function(e, t) {
                const n = e.canvas;
                if (n.width === e.width && n.height === e.height)
                    return t();
                const r = n.width
                  , i = n.height;
                return n.width = e.width,
                n.height = e.height,
                e = t(),
                n.width = r,
                n.height = i,
                e
            }(e, ( () => {
                if (t.bindFramebuffer(t.FRAMEBUFFER, null),
                t.clearColor(0, 0, 0, 0),
                t.clear(t.COLOR_BUFFER_BIT),
                t.drawArrays(t.TRIANGLE_FAN, 0, 4),
                !(e.canvas instanceof OffscreenCanvas))
                    throw Error("Conversion to ImageBitmap requires that the MediaPipe Tasks is initialized with an OffscreenCanvas");
                return e.canvas.transferToImageBitmap()
            }
            ))))
        }
        Mu.prototype.close = Mu.prototype.close,
        Mu.prototype.drawConfidenceMask = Mu.prototype.ya,
        Mu.prototype.drawCategoryMask = Mu.prototype.xa,
        Mu.prototype.drawBoundingBox = Mu.prototype.wa,
        Mu.prototype.drawConnectors = Mu.prototype.za,
        Mu.prototype.drawLandmarks = Mu.prototype.Aa,
        Mu.lerp = function(e, t, n, r, i) {
            return _u(r * (1 - (e - t) / (n - t)) + i * (1 - (n - e) / (n - t)), r, i)
        }
        ,
        Mu.clamp = _u;
        var Du = class {
            constructor(e, t, n, r, i, o, a) {
                this.g = e,
                this.j = t,
                this.m = n,
                this.canvas = r,
                this.l = i,
                this.width = o,
                this.height = a,
                (this.j || this.m) && 0 === --Ou && console.error("You seem to be creating MPImage instances without invoking .close(). This leaks resources.")
            }
            Ga() {
                return !!Cu(this, 0)
            }
            ma() {
                return !!Cu(this, 1)
            }
            R() {
                return !!Cu(this, 2)
            }
            Ea() {
                return Tu(this)
            }
            Da() {
                var e = Cu(this, 1);
                return e || (Ru(this),
                Iu(this),
                e = ku(this),
                Lu(this),
                this.g.push(e),
                this.j = !0),
                e
            }
            N() {
                return Ru(this)
            }
            clone() {
                const e = [];
                for (const t of this.g) {
                    let n;
                    if (t instanceof ImageData)
                        n = new ImageData(t.data,this.width,this.height);
                    else if (t instanceof WebGLTexture) {
                        const e = Pu(this)
                          , t = Bu(this);
                        e.activeTexture(e.TEXTURE1),
                        n = eu(t, e),
                        e.bindTexture(e.TEXTURE_2D, n),
                        e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, this.width, this.height, 0, e.RGBA, e.UNSIGNED_BYTE, null),
                        e.bindTexture(e.TEXTURE_2D, null),
                        tu(t, e, n),
                        $c(t, e, !1, ( () => {
                            Iu(this),
                            e.clearColor(0, 0, 0, 0),
                            e.clear(e.COLOR_BUFFER_BIT),
                            e.drawArrays(e.TRIANGLE_FAN, 0, 4),
                            Lu(this)
                        }
                        )),
                        nu(t),
                        Lu(this)
                    } else {
                        if (!(t instanceof ImageBitmap))
                            throw Error(`Type is not supported: ${t}`);
                        Ru(this),
                        Iu(this),
                        n = ku(this),
                        Lu(this)
                    }
                    e.push(n)
                }
                return new Du(e,this.ma(),this.R(),this.canvas,this.l,this.width,this.height)
            }
            close() {
                this.j && Cu(this, 1).close(),
                this.m && Pu(this).deleteTexture(Cu(this, 2)),
                Ou = -1
            }
        }
        ;
        Du.prototype.close = Du.prototype.close,
        Du.prototype.clone = Du.prototype.clone,
        Du.prototype.getAsWebGLTexture = Du.prototype.N,
        Du.prototype.getAsImageBitmap = Du.prototype.Da,
        Du.prototype.getAsImageData = Du.prototype.Ea,
        Du.prototype.hasWebGLTexture = Du.prototype.R,
        Du.prototype.hasImageBitmap = Du.prototype.ma,
        Du.prototype.hasImageData = Du.prototype.Ga;
        var Ou = 250;
        function Nu() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                t[n] = arguments[n];
            return t.map((e => {
                let[t,n] = e;
                return {
                    start: t,
                    end: n
                }
            }
            ))
        }
        const Fu = function(e) {
            return class extends e {
                Ma() {
                    this.i._registerModelResourcesGraphService()
                }
            }
        }((Uu = class {
            constructor(e, t) {
                this.l = !0,
                this.i = e,
                this.g = null,
                this.h = 0,
                this.m = "function" == typeof this.i._addIntToInputStream,
                void 0 !== t ? this.i.canvas = t : Lc() ? this.i.canvas = new OffscreenCanvas(1,1) : (console.warn("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."),
                this.i.canvas = document.createElement("canvas"))
            }
            async initializeGraph(e) {
                const t = await (await fetch(e)).arrayBuffer();
                e = !(e.endsWith(".pbtxt") || e.endsWith(".textproto")),
                this.setGraph(new Uint8Array(t), e)
            }
            setGraphFromString(e) {
                this.setGraph((new TextEncoder).encode(e), !1)
            }
            setGraph(e, t) {
                const n = e.length
                  , r = this.i._malloc(n);
                this.i.HEAPU8.set(e, r),
                t ? this.i._changeBinaryGraph(n, r) : this.i._changeTextGraph(n, r),
                this.i._free(r)
            }
            configureAudio(e, t, n, r, i) {
                this.i._configureAudio || console.warn('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'),
                Oc(this, r || "input_audio", (r => {
                    Oc(this, i = i || "audio_header", (i => {
                        this.i._configureAudio(r, i, e, t ?? 0, n)
                    }
                    ))
                }
                ))
            }
            setAutoResizeCanvas(e) {
                this.l = e
            }
            setAutoRenderToScreen(e) {
                this.i._setAutoRenderToScreen(e)
            }
            setGpuBufferVerticalFlip(e) {
                this.i.gpuOriginForWebTexturesIsBottomLeft = e
            }
            ea(e) {
                Uc(this, "__graph_config__", (t => {
                    e(t)
                }
                )),
                Oc(this, "__graph_config__", (e => {
                    this.i._getGraphConfig(e, void 0)
                }
                )),
                delete this.i.simpleListeners.__graph_config__
            }
            attachErrorListener(e) {
                this.i.errorListener = e
            }
            attachEmptyPacketListener(e, t) {
                this.i.emptyPacketListeners = this.i.emptyPacketListeners || {},
                this.i.emptyPacketListeners[e] = t
            }
            addAudioToStream(e, t, n) {
                this.addAudioToStreamWithShape(e, 0, 0, t, n)
            }
            addAudioToStreamWithShape(e, t, n, r, i) {
                const o = 4 * e.length;
                this.h !== o && (this.g && this.i._free(this.g),
                this.g = this.i._malloc(o),
                this.h = o),
                this.i.HEAPF32.set(e, this.g / 4),
                Oc(this, r, (e => {
                    this.i._addAudioToInputStream(this.g, t, n, e, i)
                }
                ))
            }
            addGpuBufferToStream(e, t, n) {
                Oc(this, t, (t => {
                    const [r,i] = Nc(this, e, t);
                    this.i._addBoundTextureToStream(t, r, i, n)
                }
                ))
            }
            addBoolToStream(e, t, n) {
                Oc(this, t, (t => {
                    this.i._addBoolToInputStream(e, t, n)
                }
                ))
            }
            addDoubleToStream(e, t, n) {
                Oc(this, t, (t => {
                    this.i._addDoubleToInputStream(e, t, n)
                }
                ))
            }
            addFloatToStream(e, t, n) {
                Oc(this, t, (t => {
                    this.i._addFloatToInputStream(e, t, n)
                }
                ))
            }
            addIntToStream(e, t, n) {
                Oc(this, t, (t => {
                    this.i._addIntToInputStream(e, t, n)
                }
                ))
            }
            addUintToStream(e, t, n) {
                Oc(this, t, (t => {
                    this.i._addUintToInputStream(e, t, n)
                }
                ))
            }
            addStringToStream(e, t, n) {
                Oc(this, t, (t => {
                    Oc(this, e, (e => {
                        this.i._addStringToInputStream(e, t, n)
                    }
                    ))
                }
                ))
            }
            addStringRecordToStream(e, t, n) {
                Oc(this, t, (t => {
                    Fc(this, Object.keys(e), (r => {
                        Fc(this, Object.values(e), (i => {
                            this.i._addFlatHashMapToInputStream(r, i, Object.keys(e).length, t, n)
                        }
                        ))
                    }
                    ))
                }
                ))
            }
            addProtoToStream(e, t, n, r) {
                Oc(this, n, (n => {
                    Oc(this, t, (t => {
                        const i = this.i._malloc(e.length);
                        this.i.HEAPU8.set(e, i),
                        this.i._addProtoToInputStream(i, e.length, t, n, r),
                        this.i._free(i)
                    }
                    ))
                }
                ))
            }
            addEmptyPacketToStream(e, t) {
                Oc(this, e, (e => {
                    this.i._addEmptyPacketToInputStream(e, t)
                }
                ))
            }
            addBoolVectorToStream(e, t, n) {
                Oc(this, t, (t => {
                    const r = this.i._allocateBoolVector(e.length);
                    if (!r)
                        throw Error("Unable to allocate new bool vector on heap.");
                    for (const n of e)
                        this.i._addBoolVectorEntry(r, n);
                    this.i._addBoolVectorToInputStream(r, t, n)
                }
                ))
            }
            addDoubleVectorToStream(e, t, n) {
                Oc(this, t, (t => {
                    const r = this.i._allocateDoubleVector(e.length);
                    if (!r)
                        throw Error("Unable to allocate new double vector on heap.");
                    for (const n of e)
                        this.i._addDoubleVectorEntry(r, n);
                    this.i._addDoubleVectorToInputStream(r, t, n)
                }
                ))
            }
            addFloatVectorToStream(e, t, n) {
                Oc(this, t, (t => {
                    const r = this.i._allocateFloatVector(e.length);
                    if (!r)
                        throw Error("Unable to allocate new float vector on heap.");
                    for (const n of e)
                        this.i._addFloatVectorEntry(r, n);
                    this.i._addFloatVectorToInputStream(r, t, n)
                }
                ))
            }
            addIntVectorToStream(e, t, n) {
                Oc(this, t, (t => {
                    const r = this.i._allocateIntVector(e.length);
                    if (!r)
                        throw Error("Unable to allocate new int vector on heap.");
                    for (const n of e)
                        this.i._addIntVectorEntry(r, n);
                    this.i._addIntVectorToInputStream(r, t, n)
                }
                ))
            }
            addUintVectorToStream(e, t, n) {
                Oc(this, t, (t => {
                    const r = this.i._allocateUintVector(e.length);
                    if (!r)
                        throw Error("Unable to allocate new unsigned int vector on heap.");
                    for (const n of e)
                        this.i._addUintVectorEntry(r, n);
                    this.i._addUintVectorToInputStream(r, t, n)
                }
                ))
            }
            addStringVectorToStream(e, t, n) {
                Oc(this, t, (t => {
                    const r = this.i._allocateStringVector(e.length);
                    if (!r)
                        throw Error("Unable to allocate new string vector on heap.");
                    for (const n of e)
                        Oc(this, n, (e => {
                            this.i._addStringVectorEntry(r, e)
                        }
                        ));
                    this.i._addStringVectorToInputStream(r, t, n)
                }
                ))
            }
            addBoolToInputSidePacket(e, t) {
                Oc(this, t, (t => {
                    this.i._addBoolToInputSidePacket(e, t)
                }
                ))
            }
            addDoubleToInputSidePacket(e, t) {
                Oc(this, t, (t => {
                    this.i._addDoubleToInputSidePacket(e, t)
                }
                ))
            }
            addFloatToInputSidePacket(e, t) {
                Oc(this, t, (t => {
                    this.i._addFloatToInputSidePacket(e, t)
                }
                ))
            }
            addIntToInputSidePacket(e, t) {
                Oc(this, t, (t => {
                    this.i._addIntToInputSidePacket(e, t)
                }
                ))
            }
            addUintToInputSidePacket(e, t) {
                Oc(this, t, (t => {
                    this.i._addUintToInputSidePacket(e, t)
                }
                ))
            }
            addStringToInputSidePacket(e, t) {
                Oc(this, t, (t => {
                    Oc(this, e, (e => {
                        this.i._addStringToInputSidePacket(e, t)
                    }
                    ))
                }
                ))
            }
            addProtoToInputSidePacket(e, t, n) {
                Oc(this, n, (n => {
                    Oc(this, t, (t => {
                        const r = this.i._malloc(e.length);
                        this.i.HEAPU8.set(e, r),
                        this.i._addProtoToInputSidePacket(r, e.length, t, n),
                        this.i._free(r)
                    }
                    ))
                }
                ))
            }
            addBoolVectorToInputSidePacket(e, t) {
                Oc(this, t, (t => {
                    const n = this.i._allocateBoolVector(e.length);
                    if (!n)
                        throw Error("Unable to allocate new bool vector on heap.");
                    for (const r of e)
                        this.i._addBoolVectorEntry(n, r);
                    this.i._addBoolVectorToInputSidePacket(n, t)
                }
                ))
            }
            addDoubleVectorToInputSidePacket(e, t) {
                Oc(this, t, (t => {
                    const n = this.i._allocateDoubleVector(e.length);
                    if (!n)
                        throw Error("Unable to allocate new double vector on heap.");
                    for (const r of e)
                        this.i._addDoubleVectorEntry(n, r);
                    this.i._addDoubleVectorToInputSidePacket(n, t)
                }
                ))
            }
            addFloatVectorToInputSidePacket(e, t) {
                Oc(this, t, (t => {
                    const n = this.i._allocateFloatVector(e.length);
                    if (!n)
                        throw Error("Unable to allocate new float vector on heap.");
                    for (const r of e)
                        this.i._addFloatVectorEntry(n, r);
                    this.i._addFloatVectorToInputSidePacket(n, t)
                }
                ))
            }
            addIntVectorToInputSidePacket(e, t) {
                Oc(this, t, (t => {
                    const n = this.i._allocateIntVector(e.length);
                    if (!n)
                        throw Error("Unable to allocate new int vector on heap.");
                    for (const r of e)
                        this.i._addIntVectorEntry(n, r);
                    this.i._addIntVectorToInputSidePacket(n, t)
                }
                ))
            }
            addUintVectorToInputSidePacket(e, t) {
                Oc(this, t, (t => {
                    const n = this.i._allocateUintVector(e.length);
                    if (!n)
                        throw Error("Unable to allocate new unsigned int vector on heap.");
                    for (const r of e)
                        this.i._addUintVectorEntry(n, r);
                    this.i._addUintVectorToInputSidePacket(n, t)
                }
                ))
            }
            addStringVectorToInputSidePacket(e, t) {
                Oc(this, t, (t => {
                    const n = this.i._allocateStringVector(e.length);
                    if (!n)
                        throw Error("Unable to allocate new string vector on heap.");
                    for (const r of e)
                        Oc(this, r, (e => {
                            this.i._addStringVectorEntry(n, e)
                        }
                        ));
                    this.i._addStringVectorToInputSidePacket(n, t)
                }
                ))
            }
            attachBoolListener(e, t) {
                Uc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachBoolListener(e)
                }
                ))
            }
            attachBoolVectorListener(e, t) {
                zc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachBoolVectorListener(e)
                }
                ))
            }
            attachIntListener(e, t) {
                Uc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachIntListener(e)
                }
                ))
            }
            attachIntVectorListener(e, t) {
                zc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachIntVectorListener(e)
                }
                ))
            }
            attachUintListener(e, t) {
                Uc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachUintListener(e)
                }
                ))
            }
            attachUintVectorListener(e, t) {
                zc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachUintVectorListener(e)
                }
                ))
            }
            attachDoubleListener(e, t) {
                Uc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachDoubleListener(e)
                }
                ))
            }
            attachDoubleVectorListener(e, t) {
                zc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachDoubleVectorListener(e)
                }
                ))
            }
            attachFloatListener(e, t) {
                Uc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachFloatListener(e)
                }
                ))
            }
            attachFloatVectorListener(e, t) {
                zc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachFloatVectorListener(e)
                }
                ))
            }
            attachStringListener(e, t) {
                Uc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachStringListener(e)
                }
                ))
            }
            attachStringVectorListener(e, t) {
                zc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachStringVectorListener(e)
                }
                ))
            }
            attachProtoListener(e, t, n) {
                Uc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachProtoListener(e, n || !1)
                }
                ))
            }
            attachProtoVectorListener(e, t, n) {
                zc(this, e, t),
                Oc(this, e, (e => {
                    this.i._attachProtoVectorListener(e, n || !1)
                }
                ))
            }
            attachAudioListener(e, t, n) {
                this.i._attachAudioListener || console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'),
                Uc(this, e, ( (e, n) => {
                    e = new Float32Array(e.buffer,e.byteOffset,e.length / 4),
                    t(e, n)
                }
                )),
                Oc(this, e, (e => {
                    this.i._attachAudioListener(e, n || !1)
                }
                ))
            }
            finishProcessing() {
                this.i._waitUntilIdle()
            }
            closeGraph() {
                this.i._closeGraph(),
                this.i.simpleListeners = void 0,
                this.i.emptyPacketListeners = void 0
            }
        }
        ,
        class extends Uu {
            get ga() {
                return this.i
            }
            sa(e, t, n) {
                Oc(this, t, (t => {
                    const [r,i] = Nc(this, e, t);
                    this.ga._addBoundTextureAsImageToStream(t, r, i, n)
                }
                ))
            }
            V(e, t) {
                Uc(this, e, t),
                Oc(this, e, (e => {
                    this.ga._attachImageListener(e)
                }
                ))
            }
            da(e, t) {
                zc(this, e, t),
                Oc(this, e, (e => {
                    this.ga._attachImageVectorListener(e)
                }
                ))
            }
        }
        ));
        var Uu, zu = class extends Fu {
        }
        ;
        async function Gu(e, t, n) {
            return async function(e, t, n, r) {
                return async function(e, t, n, r) {
                    return e = await (async (e, t, n, r, i) => {
                        if (t && await kc(t),
                        !self.ModuleFactory)
                            throw Error("ModuleFactory not set.");
                        if (n && (await kc(n),
                        !self.ModuleFactory))
                            throw Error("ModuleFactory not set.");
                        return self.Module && i && ((t = self.Module).locateFile = i.locateFile,
                        i.mainScriptUrlOrBlob && (t.mainScriptUrlOrBlob = i.mainScriptUrlOrBlob)),
                        i = await self.ModuleFactory(self.Module || i),
                        self.ModuleFactory = self.Module = void 0,
                        new e(i,r)
                    }
                    )(e, n.wasmLoaderPath, n.assetLoaderPath, t, {
                        locateFile: e => e.endsWith(".wasm") ? n.wasmBinaryPath.toString() : n.assetBinaryPath && e.endsWith(".data") ? n.assetBinaryPath.toString() : e
                    }),
                    await e.o(r),
                    e
                }(e, t, n, r)
            }(e, n.canvas ?? (Lc() ? void 0 : document.createElement("canvas")), t, n)
        }
        function Hu(e, t, n, r) {
            if (e.U) {
                const o = new pl;
                if (n?.regionOfInterest) {
                    if (!e.ra)
                        throw Error("This task doesn't support region-of-interest.");
                    var i = n.regionOfInterest;
                    if (i.left >= i.right || i.top >= i.bottom)
                        throw Error("Expected RectF with left < right and top < bottom.");
                    if (i.left < 0 || i.top < 0 || i.right > 1 || i.bottom > 1)
                        throw Error("Expected RectF values to be in [0,1].");
                    yo(o, 1, (i.left + i.right) / 2),
                    yo(o, 2, (i.top + i.bottom) / 2),
                    yo(o, 4, i.right - i.left),
                    yo(o, 3, i.bottom - i.top)
                } else
                    yo(o, 1, .5),
                    yo(o, 2, .5),
                    yo(o, 4, 1),
                    yo(o, 3, 1);
                if (n?.rotationDegrees) {
                    if (n?.rotationDegrees % 90 != 0)
                        throw Error("Expected rotation to be a multiple of 90\xb0.");
                    if (yo(o, 5, -Math.PI * n.rotationDegrees / 180),
                    n?.rotationDegrees % 180 != 0) {
                        const [e,r] = Dc(t);
                        n = fo(o, 3) * r / e,
                        i = fo(o, 4) * e / r,
                        yo(o, 4, n),
                        yo(o, 3, i)
                    }
                }
                e.g.addProtoToStream(o.g(), "mediapipe.NormalizedRect", e.U, r)
            }
            e.g.sa(t, e.ba, r ?? performance.now()),
            e.finishProcessing()
        }
        function ju(e, t, n) {
            if (e.baseOptions?.g())
                throw Error("Task is not initialized with image mode. 'runningMode' must be set to 'IMAGE'.");
            Hu(e, t, n, e.B + 1)
        }
        function Wu(e, t, n, r) {
            if (!e.baseOptions?.g())
                throw Error("Task is not initialized with video mode. 'runningMode' must be set to 'VIDEO'.");
            Hu(e, t, n, r)
        }
        function Vu(e, t, n, r) {
            var i = t.data;
            const o = t.width
              , a = o * (t = t.height);
            if ((i instanceof Uint8Array || i instanceof Float32Array) && i.length !== a)
                throw Error("Unsupported channel count: " + i.length / a);
            return e = new mu([i],n,!1,e.g.i.canvas,e.P,o,t),
            r ? e.clone() : e
        }
        var Xu = class extends Jc {
            constructor(e, t, n, r) {
                super(e),
                this.g = e,
                this.ba = t,
                this.U = n,
                this.ra = r,
                this.P = new ru
            }
            l(e) {
                let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                if ("runningMode"in e && go(this.baseOptions, 2, !!e.runningMode && "IMAGE" !== e.runningMode),
                void 0 !== e.canvas && this.g.i.canvas !== e.canvas)
                    throw Error("You must create a new task to reset the canvas.");
                return super.l(e, t)
            }
            close() {
                this.P.close(),
                super.close()
            }
        }
        ;
        Xu.prototype.close = Xu.prototype.close;
        var Ju = class extends Xu {
            constructor(e, t) {
                super(new zu(e,t), "image_in", "norm_rect_in", !1),
                this.j = {
                    detections: []
                },
                ao(e = this.h = new Bl, 0, 1, t = new Tl),
                yo(this.h, 2, .5),
                yo(this.h, 3, .3)
            }
            get baseOptions() {
                return ro(this.h, Tl, 1)
            }
            set baseOptions(e) {
                ao(this.h, 0, 1, e)
            }
            o(e) {
                return "minDetectionConfidence"in e && yo(this.h, 2, e.minDetectionConfidence ?? .5),
                "minSuppressionThreshold"in e && yo(this.h, 3, e.minSuppressionThreshold ?? .3),
                this.l(e)
            }
            D(e, t) {
                return this.j = {
                    detections: []
                },
                ju(this, e, t),
                this.j
            }
            F(e, t, n) {
                return this.j = {
                    detections: []
                },
                Wu(this, e, n, t),
                this.j
            }
            m() {
                var e = new Ys;
                Ks(e, "image_in"),
                Ks(e, "norm_rect_in"),
                qs(e, "detections");
                const t = new Ns;
                Vo(t, Ll, this.h);
                const n = new js;
                zs(n, "mediapipe.tasks.vision.face_detector.FaceDetectorGraph"),
                Gs(n, "IMAGE:image_in"),
                Gs(n, "NORM_RECT:norm_rect_in"),
                Hs(n, "DETECTIONS:detections"),
                n.o(t),
                Js(e, n),
                this.g.attachProtoVectorListener("detections", ( (e, t) => {
                    for (const n of e)
                        e = al(n),
                        this.j.detections.push(Sc(e));
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("detections", (e => {
                    jc(this, e)
                }
                )),
                e = e.g(),
                this.setGraph(new Uint8Array(e), !0)
            }
        }
        ;
        Ju.prototype.detectForVideo = Ju.prototype.F,
        Ju.prototype.detect = Ju.prototype.D,
        Ju.prototype.setOptions = Ju.prototype.o,
        Ju.createFromModelPath = async function(e, t) {
            return Gu(Ju, e, {
                baseOptions: {
                    modelAssetPath: t
                }
            })
        }
        ,
        Ju.createFromModelBuffer = function(e, t) {
            return Gu(Ju, e, {
                baseOptions: {
                    modelAssetBuffer: t
                }
            })
        }
        ,
        Ju.createFromOptions = function(e, t) {
            return Gu(Ju, e, t)
        }
        ;
        var Ku = Nu([61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308])
          , qu = Nu([263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362])
          , Yu = Nu([276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336])
          , Qu = Nu([474, 475], [475, 476], [476, 477], [477, 474])
          , Zu = Nu([33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133])
          , $u = Nu([46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107])
          , ed = Nu([469, 470], [470, 471], [471, 472], [472, 469])
          , td = Nu([10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10])
          , nd = [...Ku, ...qu, ...Yu, ...Zu, ...$u, ...td]
          , rd = Nu([127, 34], [34, 139], [139, 127], [11, 0], [0, 37], [37, 11], [232, 231], [231, 120], [120, 232], [72, 37], [37, 39], [39, 72], [128, 121], [121, 47], [47, 128], [232, 121], [121, 128], [128, 232], [104, 69], [69, 67], [67, 104], [175, 171], [171, 148], [148, 175], [118, 50], [50, 101], [101, 118], [73, 39], [39, 40], [40, 73], [9, 151], [151, 108], [108, 9], [48, 115], [115, 131], [131, 48], [194, 204], [204, 211], [211, 194], [74, 40], [40, 185], [185, 74], [80, 42], [42, 183], [183, 80], [40, 92], [92, 186], [186, 40], [230, 229], [229, 118], [118, 230], [202, 212], [212, 214], [214, 202], [83, 18], [18, 17], [17, 83], [76, 61], [61, 146], [146, 76], [160, 29], [29, 30], [30, 160], [56, 157], [157, 173], [173, 56], [106, 204], [204, 194], [194, 106], [135, 214], [214, 192], [192, 135], [203, 165], [165, 98], [98, 203], [21, 71], [71, 68], [68, 21], [51, 45], [45, 4], [4, 51], [144, 24], [24, 23], [23, 144], [77, 146], [146, 91], [91, 77], [205, 50], [50, 187], [187, 205], [201, 200], [200, 18], [18, 201], [91, 106], [106, 182], [182, 91], [90, 91], [91, 181], [181, 90], [85, 84], [84, 17], [17, 85], [206, 203], [203, 36], [36, 206], [148, 171], [171, 140], [140, 148], [92, 40], [40, 39], [39, 92], [193, 189], [189, 244], [244, 193], [159, 158], [158, 28], [28, 159], [247, 246], [246, 161], [161, 247], [236, 3], [3, 196], [196, 236], [54, 68], [68, 104], [104, 54], [193, 168], [168, 8], [8, 193], [117, 228], [228, 31], [31, 117], [189, 193], [193, 55], [55, 189], [98, 97], [97, 99], [99, 98], [126, 47], [47, 100], [100, 126], [166, 79], [79, 218], [218, 166], [155, 154], [154, 26], [26, 155], [209, 49], [49, 131], [131, 209], [135, 136], [136, 150], [150, 135], [47, 126], [126, 217], [217, 47], [223, 52], [52, 53], [53, 223], [45, 51], [51, 134], [134, 45], [211, 170], [170, 140], [140, 211], [67, 69], [69, 108], [108, 67], [43, 106], [106, 91], [91, 43], [230, 119], [119, 120], [120, 230], [226, 130], [130, 247], [247, 226], [63, 53], [53, 52], [52, 63], [238, 20], [20, 242], [242, 238], [46, 70], [70, 156], [156, 46], [78, 62], [62, 96], [96, 78], [46, 53], [53, 63], [63, 46], [143, 34], [34, 227], [227, 143], [123, 117], [117, 111], [111, 123], [44, 125], [125, 19], [19, 44], [236, 134], [134, 51], [51, 236], [216, 206], [206, 205], [205, 216], [154, 153], [153, 22], [22, 154], [39, 37], [37, 167], [167, 39], [200, 201], [201, 208], [208, 200], [36, 142], [142, 100], [100, 36], [57, 212], [212, 202], [202, 57], [20, 60], [60, 99], [99, 20], [28, 158], [158, 157], [157, 28], [35, 226], [226, 113], [113, 35], [160, 159], [159, 27], [27, 160], [204, 202], [202, 210], [210, 204], [113, 225], [225, 46], [46, 113], [43, 202], [202, 204], [204, 43], [62, 76], [76, 77], [77, 62], [137, 123], [123, 116], [116, 137], [41, 38], [38, 72], [72, 41], [203, 129], [129, 142], [142, 203], [64, 98], [98, 240], [240, 64], [49, 102], [102, 64], [64, 49], [41, 73], [73, 74], [74, 41], [212, 216], [216, 207], [207, 212], [42, 74], [74, 184], [184, 42], [169, 170], [170, 211], [211, 169], [170, 149], [149, 176], [176, 170], [105, 66], [66, 69], [69, 105], [122, 6], [6, 168], [168, 122], [123, 147], [147, 187], [187, 123], [96, 77], [77, 90], [90, 96], [65, 55], [55, 107], [107, 65], [89, 90], [90, 180], [180, 89], [101, 100], [100, 120], [120, 101], [63, 105], [105, 104], [104, 63], [93, 137], [137, 227], [227, 93], [15, 86], [86, 85], [85, 15], [129, 102], [102, 49], [49, 129], [14, 87], [87, 86], [86, 14], [55, 8], [8, 9], [9, 55], [100, 47], [47, 121], [121, 100], [145, 23], [23, 22], [22, 145], [88, 89], [89, 179], [179, 88], [6, 122], [122, 196], [196, 6], [88, 95], [95, 96], [96, 88], [138, 172], [172, 136], [136, 138], [215, 58], [58, 172], [172, 215], [115, 48], [48, 219], [219, 115], [42, 80], [80, 81], [81, 42], [195, 3], [3, 51], [51, 195], [43, 146], [146, 61], [61, 43], [171, 175], [175, 199], [199, 171], [81, 82], [82, 38], [38, 81], [53, 46], [46, 225], [225, 53], [144, 163], [163, 110], [110, 144], [52, 65], [65, 66], [66, 52], [229, 228], [228, 117], [117, 229], [34, 127], [127, 234], [234, 34], [107, 108], [108, 69], [69, 107], [109, 108], [108, 151], [151, 109], [48, 64], [64, 235], [235, 48], [62, 78], [78, 191], [191, 62], [129, 209], [209, 126], [126, 129], [111, 35], [35, 143], [143, 111], [117, 123], [123, 50], [50, 117], [222, 65], [65, 52], [52, 222], [19, 125], [125, 141], [141, 19], [221, 55], [55, 65], [65, 221], [3, 195], [195, 197], [197, 3], [25, 7], [7, 33], [33, 25], [220, 237], [237, 44], [44, 220], [70, 71], [71, 139], [139, 70], [122, 193], [193, 245], [245, 122], [247, 130], [130, 33], [33, 247], [71, 21], [21, 162], [162, 71], [170, 169], [169, 150], [150, 170], [188, 174], [174, 196], [196, 188], [216, 186], [186, 92], [92, 216], [2, 97], [97, 167], [167, 2], [141, 125], [125, 241], [241, 141], [164, 167], [167, 37], [37, 164], [72, 38], [38, 12], [12, 72], [38, 82], [82, 13], [13, 38], [63, 68], [68, 71], [71, 63], [226, 35], [35, 111], [111, 226], [101, 50], [50, 205], [205, 101], [206, 92], [92, 165], [165, 206], [209, 198], [198, 217], [217, 209], [165, 167], [167, 97], [97, 165], [220, 115], [115, 218], [218, 220], [133, 112], [112, 243], [243, 133], [239, 238], [238, 241], [241, 239], [214, 135], [135, 169], [169, 214], [190, 173], [173, 133], [133, 190], [171, 208], [208, 32], [32, 171], [125, 44], [44, 237], [237, 125], [86, 87], [87, 178], [178, 86], [85, 86], [86, 179], [179, 85], [84, 85], [85, 180], [180, 84], [83, 84], [84, 181], [181, 83], [201, 83], [83, 182], [182, 201], [137, 93], [93, 132], [132, 137], [76, 62], [62, 183], [183, 76], [61, 76], [76, 184], [184, 61], [57, 61], [61, 185], [185, 57], [212, 57], [57, 186], [186, 212], [214, 207], [207, 187], [187, 214], [34, 143], [143, 156], [156, 34], [79, 239], [239, 237], [237, 79], [123, 137], [137, 177], [177, 123], [44, 1], [1, 4], [4, 44], [201, 194], [194, 32], [32, 201], [64, 102], [102, 129], [129, 64], [213, 215], [215, 138], [138, 213], [59, 166], [166, 219], [219, 59], [242, 99], [99, 97], [97, 242], [2, 94], [94, 141], [141, 2], [75, 59], [59, 235], [235, 75], [24, 110], [110, 228], [228, 24], [25, 130], [130, 226], [226, 25], [23, 24], [24, 229], [229, 23], [22, 23], [23, 230], [230, 22], [26, 22], [22, 231], [231, 26], [112, 26], [26, 232], [232, 112], [189, 190], [190, 243], [243, 189], [221, 56], [56, 190], [190, 221], [28, 56], [56, 221], [221, 28], [27, 28], [28, 222], [222, 27], [29, 27], [27, 223], [223, 29], [30, 29], [29, 224], [224, 30], [247, 30], [30, 225], [225, 247], [238, 79], [79, 20], [20, 238], [166, 59], [59, 75], [75, 166], [60, 75], [75, 240], [240, 60], [147, 177], [177, 215], [215, 147], [20, 79], [79, 166], [166, 20], [187, 147], [147, 213], [213, 187], [112, 233], [233, 244], [244, 112], [233, 128], [128, 245], [245, 233], [128, 114], [114, 188], [188, 128], [114, 217], [217, 174], [174, 114], [131, 115], [115, 220], [220, 131], [217, 198], [198, 236], [236, 217], [198, 131], [131, 134], [134, 198], [177, 132], [132, 58], [58, 177], [143, 35], [35, 124], [124, 143], [110, 163], [163, 7], [7, 110], [228, 110], [110, 25], [25, 228], [356, 389], [389, 368], [368, 356], [11, 302], [302, 267], [267, 11], [452, 350], [350, 349], [349, 452], [302, 303], [303, 269], [269, 302], [357, 343], [343, 277], [277, 357], [452, 453], [453, 357], [357, 452], [333, 332], [332, 297], [297, 333], [175, 152], [152, 377], [377, 175], [347, 348], [348, 330], [330, 347], [303, 304], [304, 270], [270, 303], [9, 336], [336, 337], [337, 9], [278, 279], [279, 360], [360, 278], [418, 262], [262, 431], [431, 418], [304, 408], [408, 409], [409, 304], [310, 415], [415, 407], [407, 310], [270, 409], [409, 410], [410, 270], [450, 348], [348, 347], [347, 450], [422, 430], [430, 434], [434, 422], [313, 314], [314, 17], [17, 313], [306, 307], [307, 375], [375, 306], [387, 388], [388, 260], [260, 387], [286, 414], [414, 398], [398, 286], [335, 406], [406, 418], [418, 335], [364, 367], [367, 416], [416, 364], [423, 358], [358, 327], [327, 423], [251, 284], [284, 298], [298, 251], [281, 5], [5, 4], [4, 281], [373, 374], [374, 253], [253, 373], [307, 320], [320, 321], [321, 307], [425, 427], [427, 411], [411, 425], [421, 313], [313, 18], [18, 421], [321, 405], [405, 406], [406, 321], [320, 404], [404, 405], [405, 320], [315, 16], [16, 17], [17, 315], [426, 425], [425, 266], [266, 426], [377, 400], [400, 369], [369, 377], [322, 391], [391, 269], [269, 322], [417, 465], [465, 464], [464, 417], [386, 257], [257, 258], [258, 386], [466, 260], [260, 388], [388, 466], [456, 399], [399, 419], [419, 456], [284, 332], [332, 333], [333, 284], [417, 285], [285, 8], [8, 417], [346, 340], [340, 261], [261, 346], [413, 441], [441, 285], [285, 413], [327, 460], [460, 328], [328, 327], [355, 371], [371, 329], [329, 355], [392, 439], [439, 438], [438, 392], [382, 341], [341, 256], [256, 382], [429, 420], [420, 360], [360, 429], [364, 394], [394, 379], [379, 364], [277, 343], [343, 437], [437, 277], [443, 444], [444, 283], [283, 443], [275, 440], [440, 363], [363, 275], [431, 262], [262, 369], [369, 431], [297, 338], [338, 337], [337, 297], [273, 375], [375, 321], [321, 273], [450, 451], [451, 349], [349, 450], [446, 342], [342, 467], [467, 446], [293, 334], [334, 282], [282, 293], [458, 461], [461, 462], [462, 458], [276, 353], [353, 383], [383, 276], [308, 324], [324, 325], [325, 308], [276, 300], [300, 293], [293, 276], [372, 345], [345, 447], [447, 372], [352, 345], [345, 340], [340, 352], [274, 1], [1, 19], [19, 274], [456, 248], [248, 281], [281, 456], [436, 427], [427, 425], [425, 436], [381, 256], [256, 252], [252, 381], [269, 391], [391, 393], [393, 269], [200, 199], [199, 428], [428, 200], [266, 330], [330, 329], [329, 266], [287, 273], [273, 422], [422, 287], [250, 462], [462, 328], [328, 250], [258, 286], [286, 384], [384, 258], [265, 353], [353, 342], [342, 265], [387, 259], [259, 257], [257, 387], [424, 431], [431, 430], [430, 424], [342, 353], [353, 276], [276, 342], [273, 335], [335, 424], [424, 273], [292, 325], [325, 307], [307, 292], [366, 447], [447, 345], [345, 366], [271, 303], [303, 302], [302, 271], [423, 266], [266, 371], [371, 423], [294, 455], [455, 460], [460, 294], [279, 278], [278, 294], [294, 279], [271, 272], [272, 304], [304, 271], [432, 434], [434, 427], [427, 432], [272, 407], [407, 408], [408, 272], [394, 430], [430, 431], [431, 394], [395, 369], [369, 400], [400, 395], [334, 333], [333, 299], [299, 334], [351, 417], [417, 168], [168, 351], [352, 280], [280, 411], [411, 352], [325, 319], [319, 320], [320, 325], [295, 296], [296, 336], [336, 295], [319, 403], [403, 404], [404, 319], [330, 348], [348, 349], [349, 330], [293, 298], [298, 333], [333, 293], [323, 454], [454, 447], [447, 323], [15, 16], [16, 315], [315, 15], [358, 429], [429, 279], [279, 358], [14, 15], [15, 316], [316, 14], [285, 336], [336, 9], [9, 285], [329, 349], [349, 350], [350, 329], [374, 380], [380, 252], [252, 374], [318, 402], [402, 403], [403, 318], [6, 197], [197, 419], [419, 6], [318, 319], [319, 325], [325, 318], [367, 364], [364, 365], [365, 367], [435, 367], [367, 397], [397, 435], [344, 438], [438, 439], [439, 344], [272, 271], [271, 311], [311, 272], [195, 5], [5, 281], [281, 195], [273, 287], [287, 291], [291, 273], [396, 428], [428, 199], [199, 396], [311, 271], [271, 268], [268, 311], [283, 444], [444, 445], [445, 283], [373, 254], [254, 339], [339, 373], [282, 334], [334, 296], [296, 282], [449, 347], [347, 346], [346, 449], [264, 447], [447, 454], [454, 264], [336, 296], [296, 299], [299, 336], [338, 10], [10, 151], [151, 338], [278, 439], [439, 455], [455, 278], [292, 407], [407, 415], [415, 292], [358, 371], [371, 355], [355, 358], [340, 345], [345, 372], [372, 340], [346, 347], [347, 280], [280, 346], [442, 443], [443, 282], [282, 442], [19, 94], [94, 370], [370, 19], [441, 442], [442, 295], [295, 441], [248, 419], [419, 197], [197, 248], [263, 255], [255, 359], [359, 263], [440, 275], [275, 274], [274, 440], [300, 383], [383, 368], [368, 300], [351, 412], [412, 465], [465, 351], [263, 467], [467, 466], [466, 263], [301, 368], [368, 389], [389, 301], [395, 378], [378, 379], [379, 395], [412, 351], [351, 419], [419, 412], [436, 426], [426, 322], [322, 436], [2, 164], [164, 393], [393, 2], [370, 462], [462, 461], [461, 370], [164, 0], [0, 267], [267, 164], [302, 11], [11, 12], [12, 302], [268, 12], [12, 13], [13, 268], [293, 300], [300, 301], [301, 293], [446, 261], [261, 340], [340, 446], [330, 266], [266, 425], [425, 330], [426, 423], [423, 391], [391, 426], [429, 355], [355, 437], [437, 429], [391, 327], [327, 326], [326, 391], [440, 457], [457, 438], [438, 440], [341, 382], [382, 362], [362, 341], [459, 457], [457, 461], [461, 459], [434, 430], [430, 394], [394, 434], [414, 463], [463, 362], [362, 414], [396, 369], [369, 262], [262, 396], [354, 461], [461, 457], [457, 354], [316, 403], [403, 402], [402, 316], [315, 404], [404, 403], [403, 315], [314, 405], [405, 404], [404, 314], [313, 406], [406, 405], [405, 313], [421, 418], [418, 406], [406, 421], [366, 401], [401, 361], [361, 366], [306, 408], [408, 407], [407, 306], [291, 409], [409, 408], [408, 291], [287, 410], [410, 409], [409, 287], [432, 436], [436, 410], [410, 432], [434, 416], [416, 411], [411, 434], [264, 368], [368, 383], [383, 264], [309, 438], [438, 457], [457, 309], [352, 376], [376, 401], [401, 352], [274, 275], [275, 4], [4, 274], [421, 428], [428, 262], [262, 421], [294, 327], [327, 358], [358, 294], [433, 416], [416, 367], [367, 433], [289, 455], [455, 439], [439, 289], [462, 370], [370, 326], [326, 462], [2, 326], [326, 370], [370, 2], [305, 460], [460, 455], [455, 305], [254, 449], [449, 448], [448, 254], [255, 261], [261, 446], [446, 255], [253, 450], [450, 449], [449, 253], [252, 451], [451, 450], [450, 252], [256, 452], [452, 451], [451, 256], [341, 453], [453, 452], [452, 341], [413, 464], [464, 463], [463, 413], [441, 413], [413, 414], [414, 441], [258, 442], [442, 441], [441, 258], [257, 443], [443, 442], [442, 257], [259, 444], [444, 443], [443, 259], [260, 445], [445, 444], [444, 260], [467, 342], [342, 445], [445, 467], [459, 458], [458, 250], [250, 459], [289, 392], [392, 290], [290, 289], [290, 328], [328, 460], [460, 290], [376, 433], [433, 435], [435, 376], [250, 290], [290, 392], [392, 250], [411, 416], [416, 433], [433, 411], [341, 463], [463, 464], [464, 341], [453, 464], [464, 465], [465, 453], [357, 465], [465, 412], [412, 357], [343, 412], [412, 399], [399, 343], [360, 363], [363, 440], [440, 360], [437, 399], [399, 456], [456, 437], [420, 456], [456, 363], [363, 420], [401, 435], [435, 288], [288, 401], [372, 383], [383, 353], [353, 372], [339, 255], [255, 249], [249, 339], [448, 261], [261, 255], [255, 448], [133, 243], [243, 190], [190, 133], [133, 155], [155, 112], [112, 133], [33, 246], [246, 247], [247, 33], [33, 130], [130, 25], [25, 33], [398, 384], [384, 286], [286, 398], [362, 398], [398, 414], [414, 362], [362, 463], [463, 341], [341, 362], [263, 359], [359, 467], [467, 263], [263, 249], [249, 255], [255, 263], [466, 467], [467, 260], [260, 466], [75, 60], [60, 166], [166, 75], [238, 239], [239, 79], [79, 238], [162, 127], [127, 139], [139, 162], [72, 11], [11, 37], [37, 72], [121, 232], [232, 120], [120, 121], [73, 72], [72, 39], [39, 73], [114, 128], [128, 47], [47, 114], [233, 232], [232, 128], [128, 233], [103, 104], [104, 67], [67, 103], [152, 175], [175, 148], [148, 152], [119, 118], [118, 101], [101, 119], [74, 73], [73, 40], [40, 74], [107, 9], [9, 108], [108, 107], [49, 48], [48, 131], [131, 49], [32, 194], [194, 211], [211, 32], [184, 74], [74, 185], [185, 184], [191, 80], [80, 183], [183, 191], [185, 40], [40, 186], [186, 185], [119, 230], [230, 118], [118, 119], [210, 202], [202, 214], [214, 210], [84, 83], [83, 17], [17, 84], [77, 76], [76, 146], [146, 77], [161, 160], [160, 30], [30, 161], [190, 56], [56, 173], [173, 190], [182, 106], [106, 194], [194, 182], [138, 135], [135, 192], [192, 138], [129, 203], [203, 98], [98, 129], [54, 21], [21, 68], [68, 54], [5, 51], [51, 4], [4, 5], [145, 144], [144, 23], [23, 145], [90, 77], [77, 91], [91, 90], [207, 205], [205, 187], [187, 207], [83, 201], [201, 18], [18, 83], [181, 91], [91, 182], [182, 181], [180, 90], [90, 181], [181, 180], [16, 85], [85, 17], [17, 16], [205, 206], [206, 36], [36, 205], [176, 148], [148, 140], [140, 176], [165, 92], [92, 39], [39, 165], [245, 193], [193, 244], [244, 245], [27, 159], [159, 28], [28, 27], [30, 247], [247, 161], [161, 30], [174, 236], [236, 196], [196, 174], [103, 54], [54, 104], [104, 103], [55, 193], [193, 8], [8, 55], [111, 117], [117, 31], [31, 111], [221, 189], [189, 55], [55, 221], [240, 98], [98, 99], [99, 240], [142, 126], [126, 100], [100, 142], [219, 166], [166, 218], [218, 219], [112, 155], [155, 26], [26, 112], [198, 209], [209, 131], [131, 198], [169, 135], [135, 150], [150, 169], [114, 47], [47, 217], [217, 114], [224, 223], [223, 53], [53, 224], [220, 45], [45, 134], [134, 220], [32, 211], [211, 140], [140, 32], [109, 67], [67, 108], [108, 109], [146, 43], [43, 91], [91, 146], [231, 230], [230, 120], [120, 231], [113, 226], [226, 247], [247, 113], [105, 63], [63, 52], [52, 105], [241, 238], [238, 242], [242, 241], [124, 46], [46, 156], [156, 124], [95, 78], [78, 96], [96, 95], [70, 46], [46, 63], [63, 70], [116, 143], [143, 227], [227, 116], [116, 123], [123, 111], [111, 116], [1, 44], [44, 19], [19, 1], [3, 236], [236, 51], [51, 3], [207, 216], [216, 205], [205, 207], [26, 154], [154, 22], [22, 26], [165, 39], [39, 167], [167, 165], [199, 200], [200, 208], [208, 199], [101, 36], [36, 100], [100, 101], [43, 57], [57, 202], [202, 43], [242, 20], [20, 99], [99, 242], [56, 28], [28, 157], [157, 56], [124, 35], [35, 113], [113, 124], [29, 160], [160, 27], [27, 29], [211, 204], [204, 210], [210, 211], [124, 113], [113, 46], [46, 124], [106, 43], [43, 204], [204, 106], [96, 62], [62, 77], [77, 96], [227, 137], [137, 116], [116, 227], [73, 41], [41, 72], [72, 73], [36, 203], [203, 142], [142, 36], [235, 64], [64, 240], [240, 235], [48, 49], [49, 64], [64, 48], [42, 41], [41, 74], [74, 42], [214, 212], [212, 207], [207, 214], [183, 42], [42, 184], [184, 183], [210, 169], [169, 211], [211, 210], [140, 170], [170, 176], [176, 140], [104, 105], [105, 69], [69, 104], [193, 122], [122, 168], [168, 193], [50, 123], [123, 187], [187, 50], [89, 96], [96, 90], [90, 89], [66, 65], [65, 107], [107, 66], [179, 89], [89, 180], [180, 179], [119, 101], [101, 120], [120, 119], [68, 63], [63, 104], [104, 68], [234, 93], [93, 227], [227, 234], [16, 15], [15, 85], [85, 16], [209, 129], [129, 49], [49, 209], [15, 14], [14, 86], [86, 15], [107, 55], [55, 9], [9, 107], [120, 100], [100, 121], [121, 120], [153, 145], [145, 22], [22, 153], [178, 88], [88, 179], [179, 178], [197, 6], [6, 196], [196, 197], [89, 88], [88, 96], [96, 89], [135, 138], [138, 136], [136, 135], [138, 215], [215, 172], [172, 138], [218, 115], [115, 219], [219, 218], [41, 42], [42, 81], [81, 41], [5, 195], [195, 51], [51, 5], [57, 43], [43, 61], [61, 57], [208, 171], [171, 199], [199, 208], [41, 81], [81, 38], [38, 41], [224, 53], [53, 225], [225, 224], [24, 144], [144, 110], [110, 24], [105, 52], [52, 66], [66, 105], [118, 229], [229, 117], [117, 118], [227, 34], [34, 234], [234, 227], [66, 107], [107, 69], [69, 66], [10, 109], [109, 151], [151, 10], [219, 48], [48, 235], [235, 219], [183, 62], [62, 191], [191, 183], [142, 129], [129, 126], [126, 142], [116, 111], [111, 143], [143, 116], [118, 117], [117, 50], [50, 118], [223, 222], [222, 52], [52, 223], [94, 19], [19, 141], [141, 94], [222, 221], [221, 65], [65, 222], [196, 3], [3, 197], [197, 196], [45, 220], [220, 44], [44, 45], [156, 70], [70, 139], [139, 156], [188, 122], [122, 245], [245, 188], [139, 71], [71, 162], [162, 139], [149, 170], [170, 150], [150, 149], [122, 188], [188, 196], [196, 122], [206, 216], [216, 92], [92, 206], [164, 2], [2, 167], [167, 164], [242, 141], [141, 241], [241, 242], [0, 164], [164, 37], [37, 0], [11, 72], [72, 12], [12, 11], [12, 38], [38, 13], [13, 12], [70, 63], [63, 71], [71, 70], [31, 226], [226, 111], [111, 31], [36, 101], [101, 205], [205, 36], [203, 206], [206, 165], [165, 203], [126, 209], [209, 217], [217, 126], [98, 165], [165, 97], [97, 98], [237, 220], [220, 218], [218, 237], [237, 239], [239, 241], [241, 237], [210, 214], [214, 169], [169, 210], [140, 171], [171, 32], [32, 140], [241, 125], [125, 237], [237, 241], [179, 86], [86, 178], [178, 179], [180, 85], [85, 179], [179, 180], [181, 84], [84, 180], [180, 181], [182, 83], [83, 181], [181, 182], [194, 201], [201, 182], [182, 194], [177, 137], [137, 132], [132, 177], [184, 76], [76, 183], [183, 184], [185, 61], [61, 184], [184, 185], [186, 57], [57, 185], [185, 186], [216, 212], [212, 186], [186, 216], [192, 214], [214, 187], [187, 192], [139, 34], [34, 156], [156, 139], [218, 79], [79, 237], [237, 218], [147, 123], [123, 177], [177, 147], [45, 44], [44, 4], [4, 45], [208, 201], [201, 32], [32, 208], [98, 64], [64, 129], [129, 98], [192, 213], [213, 138], [138, 192], [235, 59], [59, 219], [219, 235], [141, 242], [242, 97], [97, 141], [97, 2], [2, 141], [141, 97], [240, 75], [75, 235], [235, 240], [229, 24], [24, 228], [228, 229], [31, 25], [25, 226], [226, 31], [230, 23], [23, 229], [229, 230], [231, 22], [22, 230], [230, 231], [232, 26], [26, 231], [231, 232], [233, 112], [112, 232], [232, 233], [244, 189], [189, 243], [243, 244], [189, 221], [221, 190], [190, 189], [222, 28], [28, 221], [221, 222], [223, 27], [27, 222], [222, 223], [224, 29], [29, 223], [223, 224], [225, 30], [30, 224], [224, 225], [113, 247], [247, 225], [225, 113], [99, 60], [60, 240], [240, 99], [213, 147], [147, 215], [215, 213], [60, 20], [20, 166], [166, 60], [192, 187], [187, 213], [213, 192], [243, 112], [112, 244], [244, 243], [244, 233], [233, 245], [245, 244], [245, 128], [128, 188], [188, 245], [188, 114], [114, 174], [174, 188], [134, 131], [131, 220], [220, 134], [174, 217], [217, 236], [236, 174], [236, 198], [198, 134], [134, 236], [215, 177], [177, 58], [58, 215], [156, 143], [143, 124], [124, 156], [25, 110], [110, 7], [7, 25], [31, 228], [228, 25], [25, 31], [264, 356], [356, 368], [368, 264], [0, 11], [11, 267], [267, 0], [451, 452], [452, 349], [349, 451], [267, 302], [302, 269], [269, 267], [350, 357], [357, 277], [277, 350], [350, 452], [452, 357], [357, 350], [299, 333], [333, 297], [297, 299], [396, 175], [175, 377], [377, 396], [280, 347], [347, 330], [330, 280], [269, 303], [303, 270], [270, 269], [151, 9], [9, 337], [337, 151], [344, 278], [278, 360], [360, 344], [424, 418], [418, 431], [431, 424], [270, 304], [304, 409], [409, 270], [272, 310], [310, 407], [407, 272], [322, 270], [270, 410], [410, 322], [449, 450], [450, 347], [347, 449], [432, 422], [422, 434], [434, 432], [18, 313], [313, 17], [17, 18], [291, 306], [306, 375], [375, 291], [259, 387], [387, 260], [260, 259], [424, 335], [335, 418], [418, 424], [434, 364], [364, 416], [416, 434], [391, 423], [423, 327], [327, 391], [301, 251], [251, 298], [298, 301], [275, 281], [281, 4], [4, 275], [254, 373], [373, 253], [253, 254], [375, 307], [307, 321], [321, 375], [280, 425], [425, 411], [411, 280], [200, 421], [421, 18], [18, 200], [335, 321], [321, 406], [406, 335], [321, 320], [320, 405], [405, 321], [314, 315], [315, 17], [17, 314], [423, 426], [426, 266], [266, 423], [396, 377], [377, 369], [369, 396], [270, 322], [322, 269], [269, 270], [413, 417], [417, 464], [464, 413], [385, 386], [386, 258], [258, 385], [248, 456], [456, 419], [419, 248], [298, 284], [284, 333], [333, 298], [168, 417], [417, 8], [8, 168], [448, 346], [346, 261], [261, 448], [417, 413], [413, 285], [285, 417], [326, 327], [327, 328], [328, 326], [277, 355], [355, 329], [329, 277], [309, 392], [392, 438], [438, 309], [381, 382], [382, 256], [256, 381], [279, 429], [429, 360], [360, 279], [365, 364], [364, 379], [379, 365], [355, 277], [277, 437], [437, 355], [282, 443], [443, 283], [283, 282], [281, 275], [275, 363], [363, 281], [395, 431], [431, 369], [369, 395], [299, 297], [297, 337], [337, 299], [335, 273], [273, 321], [321, 335], [348, 450], [450, 349], [349, 348], [359, 446], [446, 467], [467, 359], [283, 293], [293, 282], [282, 283], [250, 458], [458, 462], [462, 250], [300, 276], [276, 383], [383, 300], [292, 308], [308, 325], [325, 292], [283, 276], [276, 293], [293, 283], [264, 372], [372, 447], [447, 264], [346, 352], [352, 340], [340, 346], [354, 274], [274, 19], [19, 354], [363, 456], [456, 281], [281, 363], [426, 436], [436, 425], [425, 426], [380, 381], [381, 252], [252, 380], [267, 269], [269, 393], [393, 267], [421, 200], [200, 428], [428, 421], [371, 266], [266, 329], [329, 371], [432, 287], [287, 422], [422, 432], [290, 250], [250, 328], [328, 290], [385, 258], [258, 384], [384, 385], [446, 265], [265, 342], [342, 446], [386, 387], [387, 257], [257, 386], [422, 424], [424, 430], [430, 422], [445, 342], [342, 276], [276, 445], [422, 273], [273, 424], [424, 422], [306, 292], [292, 307], [307, 306], [352, 366], [366, 345], [345, 352], [268, 271], [271, 302], [302, 268], [358, 423], [423, 371], [371, 358], [327, 294], [294, 460], [460, 327], [331, 279], [279, 294], [294, 331], [303, 271], [271, 304], [304, 303], [436, 432], [432, 427], [427, 436], [304, 272], [272, 408], [408, 304], [395, 394], [394, 431], [431, 395], [378, 395], [395, 400], [400, 378], [296, 334], [334, 299], [299, 296], [6, 351], [351, 168], [168, 6], [376, 352], [352, 411], [411, 376], [307, 325], [325, 320], [320, 307], [285, 295], [295, 336], [336, 285], [320, 319], [319, 404], [404, 320], [329, 330], [330, 349], [349, 329], [334, 293], [293, 333], [333, 334], [366, 323], [323, 447], [447, 366], [316, 15], [15, 315], [315, 316], [331, 358], [358, 279], [279, 331], [317, 14], [14, 316], [316, 317], [8, 285], [285, 9], [9, 8], [277, 329], [329, 350], [350, 277], [253, 374], [374, 252], [252, 253], [319, 318], [318, 403], [403, 319], [351, 6], [6, 419], [419, 351], [324, 318], [318, 325], [325, 324], [397, 367], [367, 365], [365, 397], [288, 435], [435, 397], [397, 288], [278, 344], [344, 439], [439, 278], [310, 272], [272, 311], [311, 310], [248, 195], [195, 281], [281, 248], [375, 273], [273, 291], [291, 375], [175, 396], [396, 199], [199, 175], [312, 311], [311, 268], [268, 312], [276, 283], [283, 445], [445, 276], [390, 373], [373, 339], [339, 390], [295, 282], [282, 296], [296, 295], [448, 449], [449, 346], [346, 448], [356, 264], [264, 454], [454, 356], [337, 336], [336, 299], [299, 337], [337, 338], [338, 151], [151, 337], [294, 278], [278, 455], [455, 294], [308, 292], [292, 415], [415, 308], [429, 358], [358, 355], [355, 429], [265, 340], [340, 372], [372, 265], [352, 346], [346, 280], [280, 352], [295, 442], [442, 282], [282, 295], [354, 19], [19, 370], [370, 354], [285, 441], [441, 295], [295, 285], [195, 248], [248, 197], [197, 195], [457, 440], [440, 274], [274, 457], [301, 300], [300, 368], [368, 301], [417, 351], [351, 465], [465, 417], [251, 301], [301, 389], [389, 251], [394, 395], [395, 379], [379, 394], [399, 412], [412, 419], [419, 399], [410, 436], [436, 322], [322, 410], [326, 2], [2, 393], [393, 326], [354, 370], [370, 461], [461, 354], [393, 164], [164, 267], [267, 393], [268, 302], [302, 12], [12, 268], [312, 268], [268, 13], [13, 312], [298, 293], [293, 301], [301, 298], [265, 446], [446, 340], [340, 265], [280, 330], [330, 425], [425, 280], [322, 426], [426, 391], [391, 322], [420, 429], [429, 437], [437, 420], [393, 391], [391, 326], [326, 393], [344, 440], [440, 438], [438, 344], [458, 459], [459, 461], [461, 458], [364, 434], [434, 394], [394, 364], [428, 396], [396, 262], [262, 428], [274, 354], [354, 457], [457, 274], [317, 316], [316, 402], [402, 317], [316, 315], [315, 403], [403, 316], [315, 314], [314, 404], [404, 315], [314, 313], [313, 405], [405, 314], [313, 421], [421, 406], [406, 313], [323, 366], [366, 361], [361, 323], [292, 306], [306, 407], [407, 292], [306, 291], [291, 408], [408, 306], [291, 287], [287, 409], [409, 291], [287, 432], [432, 410], [410, 287], [427, 434], [434, 411], [411, 427], [372, 264], [264, 383], [383, 372], [459, 309], [309, 457], [457, 459], [366, 352], [352, 401], [401, 366], [1, 274], [274, 4], [4, 1], [418, 421], [421, 262], [262, 418], [331, 294], [294, 358], [358, 331], [435, 433], [433, 367], [367, 435], [392, 289], [289, 439], [439, 392], [328, 462], [462, 326], [326, 328], [94, 2], [2, 370], [370, 94], [289, 305], [305, 455], [455, 289], [339, 254], [254, 448], [448, 339], [359, 255], [255, 446], [446, 359], [254, 253], [253, 449], [449, 254], [253, 252], [252, 450], [450, 253], [252, 256], [256, 451], [451, 252], [256, 341], [341, 452], [452, 256], [414, 413], [413, 463], [463, 414], [286, 441], [441, 414], [414, 286], [286, 258], [258, 441], [441, 286], [258, 257], [257, 442], [442, 258], [257, 259], [259, 443], [443, 257], [259, 260], [260, 444], [444, 259], [260, 467], [467, 445], [445, 260], [309, 459], [459, 250], [250, 309], [305, 289], [289, 290], [290, 305], [305, 290], [290, 460], [460, 305], [401, 376], [376, 435], [435, 401], [309, 250], [250, 392], [392, 309], [376, 411], [411, 433], [433, 376], [453, 341], [341, 464], [464, 453], [357, 453], [453, 465], [465, 357], [343, 357], [357, 412], [412, 343], [437, 343], [343, 399], [399, 437], [344, 360], [360, 440], [440, 344], [420, 437], [437, 456], [456, 420], [360, 420], [420, 363], [363, 360], [361, 401], [401, 288], [288, 361], [265, 372], [372, 353], [353, 265], [390, 339], [339, 249], [249, 390], [339, 448], [448, 255], [255, 339]);
        function id(e) {
            e.j = {
                faceLandmarks: [],
                faceBlendshapes: [],
                facialTransformationMatrixes: []
            }
        }
        var od = class extends Xu {
            constructor(e, t) {
                super(new zu(e,t), "image_in", "norm_rect", !1),
                this.j = {
                    faceLandmarks: [],
                    faceBlendshapes: [],
                    facialTransformationMatrixes: []
                },
                this.outputFacialTransformationMatrixes = this.outputFaceBlendshapes = !1,
                ao(e = this.h = new Ol, 0, 1, t = new Tl),
                this.v = new Dl,
                ao(this.h, 0, 3, this.v),
                this.s = new Bl,
                ao(this.h, 0, 2, this.s),
                vo(this.s, 4, 1),
                yo(this.s, 2, .5),
                yo(this.v, 2, .5),
                yo(this.h, 4, .5)
            }
            get baseOptions() {
                return ro(this.h, Tl, 1)
            }
            set baseOptions(e) {
                ao(this.h, 0, 1, e)
            }
            o(e) {
                return "numFaces"in e && vo(this.s, 4, e.numFaces ?? 1),
                "minFaceDetectionConfidence"in e && yo(this.s, 2, e.minFaceDetectionConfidence ?? .5),
                "minTrackingConfidence"in e && yo(this.h, 4, e.minTrackingConfidence ?? .5),
                "minFacePresenceConfidence"in e && yo(this.v, 2, e.minFacePresenceConfidence ?? .5),
                "outputFaceBlendshapes"in e && (this.outputFaceBlendshapes = !!e.outputFaceBlendshapes),
                "outputFacialTransformationMatrixes"in e && (this.outputFacialTransformationMatrixes = !!e.outputFacialTransformationMatrixes),
                this.l(e)
            }
            D(e, t) {
                return id(this),
                ju(this, e, t),
                this.j
            }
            F(e, t, n) {
                return id(this),
                Wu(this, e, n, t),
                this.j
            }
            m() {
                var e = new Ys;
                Ks(e, "image_in"),
                Ks(e, "norm_rect"),
                qs(e, "face_landmarks");
                const t = new Ns;
                Vo(t, Ul, this.h);
                const n = new js;
                zs(n, "mediapipe.tasks.vision.face_landmarker.FaceLandmarkerGraph"),
                Gs(n, "IMAGE:image_in"),
                Gs(n, "NORM_RECT:norm_rect"),
                Hs(n, "NORM_LANDMARKS:face_landmarks"),
                n.o(t),
                Js(e, n),
                this.g.attachProtoVectorListener("face_landmarks", ( (e, t) => {
                    for (const n of e)
                        e = ul(n),
                        this.j.faceLandmarks.push(wc(e));
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("face_landmarks", (e => {
                    jc(this, e)
                }
                )),
                this.outputFaceBlendshapes && (qs(e, "blendshapes"),
                Hs(n, "BLENDSHAPES:blendshapes"),
                this.g.attachProtoVectorListener("blendshapes", ( (e, t) => {
                    if (this.outputFaceBlendshapes)
                        for (const n of e)
                            e = nl(n),
                            this.j.faceBlendshapes.push(xc(e.g() ?? []));
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("blendshapes", (e => {
                    jc(this, e)
                }
                ))),
                this.outputFacialTransformationMatrixes && (qs(e, "face_geometry"),
                Hs(n, "FACE_GEOMETRY:face_geometry"),
                this.g.attachProtoVectorListener("face_geometry", ( (e, t) => {
                    if (this.outputFacialTransformationMatrixes)
                        for (const n of e)
                            (e = ro(kl(n), dl, 2)) && this.j.facialTransformationMatrixes.push({
                                rows: ho(po(e, 1), 0) ?? 0,
                                columns: ho(po(e, 2), 0) ?? 0,
                                data: Vi(e, 3, Dr, Wi()).slice() ?? []
                            });
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("face_geometry", (e => {
                    jc(this, e)
                }
                ))),
                e = e.g(),
                this.setGraph(new Uint8Array(e), !0)
            }
        }
        ;
        od.prototype.detectForVideo = od.prototype.F,
        od.prototype.detect = od.prototype.D,
        od.prototype.setOptions = od.prototype.o,
        od.createFromModelPath = function(e, t) {
            return Gu(od, e, {
                baseOptions: {
                    modelAssetPath: t
                }
            })
        }
        ,
        od.createFromModelBuffer = function(e, t) {
            return Gu(od, e, {
                baseOptions: {
                    modelAssetBuffer: t
                }
            })
        }
        ,
        od.createFromOptions = function(e, t) {
            return Gu(od, e, t)
        }
        ,
        od.FACE_LANDMARKS_LIPS = Ku,
        od.FACE_LANDMARKS_LEFT_EYE = qu,
        od.FACE_LANDMARKS_LEFT_EYEBROW = Yu,
        od.FACE_LANDMARKS_LEFT_IRIS = Qu,
        od.FACE_LANDMARKS_RIGHT_EYE = Zu,
        od.FACE_LANDMARKS_RIGHT_EYEBROW = $u,
        od.FACE_LANDMARKS_RIGHT_IRIS = ed,
        od.FACE_LANDMARKS_FACE_OVAL = td,
        od.FACE_LANDMARKS_CONTOURS = nd,
        od.FACE_LANDMARKS_TESSELATION = rd;
        var ad = class extends Xu {
            constructor(e, t) {
                super(new zu(e,t), "image_in", "norm_rect", !0),
                ao(e = this.j = new zl, 0, 1, t = new Tl)
            }
            get baseOptions() {
                return ro(this.j, Tl, 1)
            }
            set baseOptions(e) {
                ao(this.j, 0, 1, e)
            }
            o(e) {
                return super.l(e)
            }
            Pa(e, t, n) {
                const r = "function" != typeof t ? t : {};
                if (this.h = "function" == typeof t ? t : n,
                ju(this, e, r ?? {}),
                !this.h)
                    return this.s
            }
            m() {
                var e = new Ys;
                Ks(e, "image_in"),
                Ks(e, "norm_rect"),
                qs(e, "stylized_image");
                const t = new Ns;
                Vo(t, Gl, this.j);
                const n = new js;
                zs(n, "mediapipe.tasks.vision.face_stylizer.FaceStylizerGraph"),
                Gs(n, "IMAGE:image_in"),
                Gs(n, "NORM_RECT:norm_rect"),
                Hs(n, "STYLIZED_IMAGE:stylized_image"),
                n.o(t),
                Js(e, n),
                this.g.V("stylized_image", ( (e, t) => {
                    var n = !this.h
                      , r = e.data
                      , i = e.width;
                    const o = i * (e = e.height);
                    if (r instanceof Uint8Array)
                        if (r.length === 3 * o) {
                            const t = new Uint8ClampedArray(4 * o);
                            for (let e = 0; e < o; ++e)
                                t[4 * e] = r[3 * e],
                                t[4 * e + 1] = r[3 * e + 1],
                                t[4 * e + 2] = r[3 * e + 2],
                                t[4 * e + 3] = 255;
                            r = new ImageData(t,i,e)
                        } else {
                            if (r.length !== 4 * o)
                                throw Error("Unsupported channel count: " + r.length / o);
                            r = new ImageData(new Uint8ClampedArray(r.buffer,r.byteOffset,r.length),i,e)
                        }
                    else if (!(r instanceof WebGLTexture))
                        throw Error(`Unsupported format: ${r.constructor.name}`);
                    i = new Du([r],!1,!1,this.g.i.canvas,this.P,i,e),
                    this.s = n = n ? i.clone() : i,
                    this.h && this.h(n),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("stylized_image", (e => {
                    this.s = null,
                    this.h && this.h(null),
                    jc(this, e)
                }
                )),
                e = e.g(),
                this.setGraph(new Uint8Array(e), !0)
            }
        }
        ;
        ad.prototype.stylize = ad.prototype.Pa,
        ad.prototype.setOptions = ad.prototype.o,
        ad.createFromModelPath = function(e, t) {
            return Gu(ad, e, {
                baseOptions: {
                    modelAssetPath: t
                }
            })
        }
        ,
        ad.createFromModelBuffer = function(e, t) {
            return Gu(ad, e, {
                baseOptions: {
                    modelAssetBuffer: t
                }
            })
        }
        ,
        ad.createFromOptions = function(e, t) {
            return Gu(ad, e, t)
        }
        ;
        var sd = Nu([0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [0, 17], [17, 18], [18, 19], [19, 20]);
        function ld(e) {
            e.gestures = [],
            e.landmarks = [],
            e.worldLandmarks = [],
            e.handedness = []
        }
        function cd(e) {
            return 0 === e.gestures.length ? {
                gestures: [],
                landmarks: [],
                worldLandmarks: [],
                handedness: [],
                handednesses: []
            } : {
                gestures: e.gestures,
                landmarks: e.landmarks,
                worldLandmarks: e.worldLandmarks,
                handedness: e.handedness,
                handednesses: e.handedness
            }
        }
        function ud(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            const n = [];
            for (const i of e) {
                var r = nl(i);
                e = [];
                for (const n of r.g())
                    r = t && null != po(n, 1) ? ho(po(n, 1), 0) : -1,
                    e.push({
                        score: fo(n, 2) ?? 0,
                        index: r,
                        categoryName: mo(n, 3) ?? "",
                        displayName: mo(n, 4) ?? ""
                    });
                n.push(e)
            }
            return n
        }
        var dd = class extends Xu {
            constructor(e, t) {
                super(new zu(e,t), "image_in", "norm_rect", !1),
                this.gestures = [],
                this.landmarks = [],
                this.worldLandmarks = [],
                this.handedness = [],
                ao(e = this.j = new Kl, 0, 1, t = new Tl),
                this.s = new Jl,
                ao(this.j, 0, 2, this.s),
                this.C = new Xl,
                ao(this.s, 0, 3, this.C),
                this.v = new Vl,
                ao(this.s, 0, 2, this.v),
                this.h = new Wl,
                ao(this.j, 0, 3, this.h),
                yo(this.v, 2, .5),
                yo(this.s, 4, .5),
                yo(this.C, 2, .5)
            }
            get baseOptions() {
                return ro(this.j, Tl, 1)
            }
            set baseOptions(e) {
                ao(this.j, 0, 1, e)
            }
            o(e) {
                if (vo(this.v, 3, e.numHands ?? 1),
                "minHandDetectionConfidence"in e && yo(this.v, 2, e.minHandDetectionConfidence ?? .5),
                "minTrackingConfidence"in e && yo(this.s, 4, e.minTrackingConfidence ?? .5),
                "minHandPresenceConfidence"in e && yo(this.C, 2, e.minHandPresenceConfidence ?? .5),
                e.cannedGesturesClassifierOptions) {
                    var t = new Hl
                      , n = t
                      , r = Ac(e.cannedGesturesClassifierOptions, ro(this.h, Hl, 3)?.h());
                    ao(n, 0, 2, r),
                    ao(this.h, 0, 3, t)
                } else
                    void 0 === e.cannedGesturesClassifierOptions && ro(this.h, Hl, 3)?.g();
                return e.customGesturesClassifierOptions ? (ao(n = t = new Hl, 0, 2, r = Ac(e.customGesturesClassifierOptions, ro(this.h, Hl, 4)?.h())),
                ao(this.h, 0, 4, t)) : void 0 === e.customGesturesClassifierOptions && ro(this.h, Hl, 4)?.g(),
                this.l(e)
            }
            Ka(e, t) {
                return ld(this),
                ju(this, e, t),
                cd(this)
            }
            La(e, t, n) {
                return ld(this),
                Wu(this, e, n, t),
                cd(this)
            }
            m() {
                var e = new Ys;
                Ks(e, "image_in"),
                Ks(e, "norm_rect"),
                qs(e, "hand_gestures"),
                qs(e, "hand_landmarks"),
                qs(e, "world_hand_landmarks"),
                qs(e, "handedness");
                const t = new Ns;
                Vo(t, $l, this.j);
                const n = new js;
                zs(n, "mediapipe.tasks.vision.gesture_recognizer.GestureRecognizerGraph"),
                Gs(n, "IMAGE:image_in"),
                Gs(n, "NORM_RECT:norm_rect"),
                Hs(n, "HAND_GESTURES:hand_gestures"),
                Hs(n, "LANDMARKS:hand_landmarks"),
                Hs(n, "WORLD_LANDMARKS:world_hand_landmarks"),
                Hs(n, "HANDEDNESS:handedness"),
                n.o(t),
                Js(e, n),
                this.g.attachProtoVectorListener("hand_landmarks", ( (e, t) => {
                    for (const n of e) {
                        e = ul(n);
                        const t = [];
                        for (const n of oo(e, cl, 1))
                            t.push({
                                x: fo(n, 1) ?? 0,
                                y: fo(n, 2) ?? 0,
                                z: fo(n, 3) ?? 0,
                                visibility: fo(n, 4) ?? 0
                            });
                        this.landmarks.push(t)
                    }
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("hand_landmarks", (e => {
                    jc(this, e)
                }
                )),
                this.g.attachProtoVectorListener("world_hand_landmarks", ( (e, t) => {
                    for (const n of e) {
                        e = ll(n);
                        const t = [];
                        for (const n of oo(e, sl, 1))
                            t.push({
                                x: fo(n, 1) ?? 0,
                                y: fo(n, 2) ?? 0,
                                z: fo(n, 3) ?? 0,
                                visibility: fo(n, 4) ?? 0
                            });
                        this.worldLandmarks.push(t)
                    }
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("world_hand_landmarks", (e => {
                    jc(this, e)
                }
                )),
                this.g.attachProtoVectorListener("hand_gestures", ( (e, t) => {
                    this.gestures.push(...ud(e, !1)),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("hand_gestures", (e => {
                    jc(this, e)
                }
                )),
                this.g.attachProtoVectorListener("handedness", ( (e, t) => {
                    this.handedness.push(...ud(e)),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("handedness", (e => {
                    jc(this, e)
                }
                )),
                e = e.g(),
                this.setGraph(new Uint8Array(e), !0)
            }
        }
        ;
        function hd(e) {
            return {
                landmarks: e.landmarks,
                worldLandmarks: e.worldLandmarks,
                handednesses: e.handedness,
                handedness: e.handedness
            }
        }
        dd.prototype.recognizeForVideo = dd.prototype.La,
        dd.prototype.recognize = dd.prototype.Ka,
        dd.prototype.setOptions = dd.prototype.o,
        dd.createFromModelPath = function(e, t) {
            return Gu(dd, e, {
                baseOptions: {
                    modelAssetPath: t
                }
            })
        }
        ,
        dd.createFromModelBuffer = function(e, t) {
            return Gu(dd, e, {
                baseOptions: {
                    modelAssetBuffer: t
                }
            })
        }
        ,
        dd.createFromOptions = function(e, t) {
            return Gu(dd, e, t)
        }
        ,
        dd.HAND_CONNECTIONS = sd;
        var pd = class extends Xu {
            constructor(e, t) {
                super(new zu(e,t), "image_in", "norm_rect", !1),
                this.landmarks = [],
                this.worldLandmarks = [],
                this.handedness = [],
                ao(e = this.h = new Jl, 0, 1, t = new Tl),
                this.s = new Xl,
                ao(this.h, 0, 3, this.s),
                this.j = new Vl,
                ao(this.h, 0, 2, this.j),
                vo(this.j, 3, 1),
                yo(this.j, 2, .5),
                yo(this.s, 2, .5),
                yo(this.h, 4, .5)
            }
            get baseOptions() {
                return ro(this.h, Tl, 1)
            }
            set baseOptions(e) {
                ao(this.h, 0, 1, e)
            }
            o(e) {
                return "numHands"in e && vo(this.j, 3, e.numHands ?? 1),
                "minHandDetectionConfidence"in e && yo(this.j, 2, e.minHandDetectionConfidence ?? .5),
                "minTrackingConfidence"in e && yo(this.h, 4, e.minTrackingConfidence ?? .5),
                "minHandPresenceConfidence"in e && yo(this.s, 2, e.minHandPresenceConfidence ?? .5),
                this.l(e)
            }
            D(e, t) {
                return this.landmarks = [],
                this.worldLandmarks = [],
                this.handedness = [],
                ju(this, e, t),
                hd(this)
            }
            F(e, t, n) {
                return this.landmarks = [],
                this.worldLandmarks = [],
                this.handedness = [],
                Wu(this, e, n, t),
                hd(this)
            }
            m() {
                var e = new Ys;
                Ks(e, "image_in"),
                Ks(e, "norm_rect"),
                qs(e, "hand_landmarks"),
                qs(e, "world_hand_landmarks"),
                qs(e, "handedness");
                const t = new Ns;
                Vo(t, ec, this.h);
                const n = new js;
                zs(n, "mediapipe.tasks.vision.hand_landmarker.HandLandmarkerGraph"),
                Gs(n, "IMAGE:image_in"),
                Gs(n, "NORM_RECT:norm_rect"),
                Hs(n, "LANDMARKS:hand_landmarks"),
                Hs(n, "WORLD_LANDMARKS:world_hand_landmarks"),
                Hs(n, "HANDEDNESS:handedness"),
                n.o(t),
                Js(e, n),
                this.g.attachProtoVectorListener("hand_landmarks", ( (e, t) => {
                    for (const n of e)
                        e = ul(n),
                        this.landmarks.push(wc(e));
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("hand_landmarks", (e => {
                    jc(this, e)
                }
                )),
                this.g.attachProtoVectorListener("world_hand_landmarks", ( (e, t) => {
                    for (const n of e)
                        e = ll(n),
                        this.worldLandmarks.push(Ec(e));
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("world_hand_landmarks", (e => {
                    jc(this, e)
                }
                )),
                this.g.attachProtoVectorListener("handedness", ( (e, t) => {
                    var n = this.handedness
                      , r = n.push;
                    const i = [];
                    for (const o of e) {
                        e = nl(o);
                        const t = [];
                        for (const n of e.g())
                            t.push({
                                score: fo(n, 2) ?? 0,
                                index: ho(po(n, 1), 0) ?? -1,
                                categoryName: mo(n, 3) ?? "",
                                displayName: mo(n, 4) ?? ""
                            });
                        i.push(t)
                    }
                    r.call(n, ...i),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("handedness", (e => {
                    jc(this, e)
                }
                )),
                e = e.g(),
                this.setGraph(new Uint8Array(e), !0)
            }
        }
        ;
        pd.prototype.detectForVideo = pd.prototype.F,
        pd.prototype.detect = pd.prototype.D,
        pd.prototype.setOptions = pd.prototype.o,
        pd.createFromModelPath = function(e, t) {
            return Gu(pd, e, {
                baseOptions: {
                    modelAssetPath: t
                }
            })
        }
        ,
        pd.createFromModelBuffer = function(e, t) {
            return Gu(pd, e, {
                baseOptions: {
                    modelAssetBuffer: t
                }
            })
        }
        ,
        pd.createFromOptions = function(e, t) {
            return Gu(pd, e, t)
        }
        ,
        pd.HAND_CONNECTIONS = sd;
        var fd = Nu([0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8], [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20], [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]);
        function md(e) {
            e.h = {
                faceLandmarks: [],
                faceBlendshapes: [],
                poseLandmarks: [],
                poseWorldLandmarks: [],
                poseSegmentationMasks: [],
                leftHandLandmarks: [],
                leftHandWorldLandmarks: [],
                rightHandLandmarks: [],
                rightHandWorldLandmarks: []
            }
        }
        function gd(e) {
            try {
                if (!e.C)
                    return e.h;
                e.C(e.h)
            } finally {
                Xc(e)
            }
        }
        function vd(e, t) {
            e = ul(e),
            t.push(wc(e))
        }
        var yd = class extends Xu {
            constructor(e, t) {
                super(new zu(e,t), "input_frames_image", null, !1),
                this.h = {
                    faceLandmarks: [],
                    faceBlendshapes: [],
                    poseLandmarks: [],
                    poseWorldLandmarks: [],
                    poseSegmentationMasks: [],
                    leftHandLandmarks: [],
                    leftHandWorldLandmarks: [],
                    rightHandLandmarks: [],
                    rightHandWorldLandmarks: []
                },
                this.outputPoseSegmentationMasks = this.outputFaceBlendshapes = !1,
                ao(e = this.j = new ic, 0, 1, t = new Tl),
                this.K = new Xl,
                ao(this.j, 0, 2, this.K),
                this.aa = new tc,
                ao(this.j, 0, 3, this.aa),
                this.s = new Bl,
                ao(this.j, 0, 4, this.s),
                this.I = new Dl,
                ao(this.j, 0, 5, this.I),
                this.v = new nc,
                ao(this.j, 0, 6, this.v),
                this.L = new rc,
                ao(this.j, 0, 7, this.L),
                yo(this.s, 2, .5),
                yo(this.s, 3, .3),
                yo(this.I, 2, .5),
                yo(this.v, 2, .5),
                yo(this.v, 3, .3),
                yo(this.L, 2, .5),
                yo(this.K, 2, .5)
            }
            get baseOptions() {
                return ro(this.j, Tl, 1)
            }
            set baseOptions(e) {
                ao(this.j, 0, 1, e)
            }
            o(e) {
                return "minFaceDetectionConfidence"in e && yo(this.s, 2, e.minFaceDetectionConfidence ?? .5),
                "minFaceSuppressionThreshold"in e && yo(this.s, 3, e.minFaceSuppressionThreshold ?? .3),
                "minFacePresenceConfidence"in e && yo(this.I, 2, e.minFacePresenceConfidence ?? .5),
                "outputFaceBlendshapes"in e && (this.outputFaceBlendshapes = !!e.outputFaceBlendshapes),
                "minPoseDetectionConfidence"in e && yo(this.v, 2, e.minPoseDetectionConfidence ?? .5),
                "minPoseSuppressionThreshold"in e && yo(this.v, 3, e.minPoseSuppressionThreshold ?? .3),
                "minPosePresenceConfidence"in e && yo(this.L, 2, e.minPosePresenceConfidence ?? .5),
                "outputPoseSegmentationMasks"in e && (this.outputPoseSegmentationMasks = !!e.outputPoseSegmentationMasks),
                "minHandLandmarksConfidence"in e && yo(this.K, 2, e.minHandLandmarksConfidence ?? .5),
                this.l(e)
            }
            D(e, t, n) {
                const r = "function" != typeof t ? t : {};
                return this.C = "function" == typeof t ? t : n,
                md(this),
                ju(this, e, r),
                gd(this)
            }
            F(e, t, n, r) {
                const i = "function" != typeof n ? n : {};
                return this.C = "function" == typeof n ? n : r,
                md(this),
                Wu(this, e, i, t),
                gd(this)
            }
            m() {
                var e = new Ys;
                Ks(e, "input_frames_image"),
                qs(e, "pose_landmarks"),
                qs(e, "pose_world_landmarks"),
                qs(e, "face_landmarks"),
                qs(e, "left_hand_landmarks"),
                qs(e, "left_hand_world_landmarks"),
                qs(e, "right_hand_landmarks"),
                qs(e, "right_hand_world_landmarks");
                const t = new Ns
                  , n = new ws;
                Yi(n, 1, Xr("type.googleapis.com/mediapipe.tasks.vision.holistic_landmarker.proto.HolisticLandmarkerGraphOptions"), ""),
                function(e, t) {
                    if (null != t)
                        if (Array.isArray(t))
                            Ui(e, 2, Ti(t, Pi, void 0, void 0, !1));
                        else {
                            if (!("string" == typeof t || t instanceof Tn || xn(t)))
                                throw Error("invalid value in Any.value field: " + t + " expected a ByteString, a base64 encoded string, a Uint8Array or a jspb array");
                            Yi(e, 2, tr(t, !1, !1), Mn())
                        }
                }(n, this.j.g());
                const r = new js;
                zs(r, "mediapipe.tasks.vision.holistic_landmarker.HolisticLandmarkerGraph"),
                uo(r, 8, ws, n),
                Gs(r, "IMAGE:input_frames_image"),
                Hs(r, "POSE_LANDMARKS:pose_landmarks"),
                Hs(r, "POSE_WORLD_LANDMARKS:pose_world_landmarks"),
                Hs(r, "FACE_LANDMARKS:face_landmarks"),
                Hs(r, "LEFT_HAND_LANDMARKS:left_hand_landmarks"),
                Hs(r, "LEFT_HAND_WORLD_LANDMARKS:left_hand_world_landmarks"),
                Hs(r, "RIGHT_HAND_LANDMARKS:right_hand_landmarks"),
                Hs(r, "RIGHT_HAND_WORLD_LANDMARKS:right_hand_world_landmarks"),
                r.o(t),
                Js(e, r),
                Wc(this, e),
                this.g.attachProtoListener("pose_landmarks", ( (e, t) => {
                    vd(e, this.h.poseLandmarks),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("pose_landmarks", (e => {
                    jc(this, e)
                }
                )),
                this.g.attachProtoListener("pose_world_landmarks", ( (e, t) => {
                    var n = this.h.poseWorldLandmarks;
                    e = ll(e),
                    n.push(Ec(e)),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("pose_world_landmarks", (e => {
                    jc(this, e)
                }
                )),
                this.outputPoseSegmentationMasks && (Hs(r, "POSE_SEGMENTATION_MASK:pose_segmentation_mask"),
                Vc(this, "pose_segmentation_mask"),
                this.g.V("pose_segmentation_mask", ( (e, t) => {
                    this.h.poseSegmentationMasks = [Vu(this, e, !0, !this.C)],
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("pose_segmentation_mask", (e => {
                    this.h.poseSegmentationMasks = [],
                    jc(this, e)
                }
                ))),
                this.g.attachProtoListener("face_landmarks", ( (e, t) => {
                    vd(e, this.h.faceLandmarks),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("face_landmarks", (e => {
                    jc(this, e)
                }
                )),
                this.outputFaceBlendshapes && (qs(e, "extra_blendshapes"),
                Hs(r, "FACE_BLENDSHAPES:extra_blendshapes"),
                this.g.attachProtoListener("extra_blendshapes", ( (e, t) => {
                    var n = this.h.faceBlendshapes;
                    this.outputFaceBlendshapes && (e = nl(e),
                    n.push(xc(e.g() ?? []))),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("extra_blendshapes", (e => {
                    jc(this, e)
                }
                ))),
                this.g.attachProtoListener("left_hand_landmarks", ( (e, t) => {
                    vd(e, this.h.leftHandLandmarks),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("left_hand_landmarks", (e => {
                    jc(this, e)
                }
                )),
                this.g.attachProtoListener("left_hand_world_landmarks", ( (e, t) => {
                    var n = this.h.leftHandWorldLandmarks;
                    e = ll(e),
                    n.push(Ec(e)),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("left_hand_world_landmarks", (e => {
                    jc(this, e)
                }
                )),
                this.g.attachProtoListener("right_hand_landmarks", ( (e, t) => {
                    vd(e, this.h.rightHandLandmarks),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("right_hand_landmarks", (e => {
                    jc(this, e)
                }
                )),
                this.g.attachProtoListener("right_hand_world_landmarks", ( (e, t) => {
                    var n = this.h.rightHandWorldLandmarks;
                    e = ll(e),
                    n.push(Ec(e)),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("right_hand_world_landmarks", (e => {
                    jc(this, e)
                }
                )),
                e = e.g(),
                this.setGraph(new Uint8Array(e), !0)
            }
        }
        ;
        yd.prototype.detectForVideo = yd.prototype.F,
        yd.prototype.detect = yd.prototype.D,
        yd.prototype.setOptions = yd.prototype.o,
        yd.createFromModelPath = function(e, t) {
            return Gu(yd, e, {
                baseOptions: {
                    modelAssetPath: t
                }
            })
        }
        ,
        yd.createFromModelBuffer = function(e, t) {
            return Gu(yd, e, {
                baseOptions: {
                    modelAssetBuffer: t
                }
            })
        }
        ,
        yd.createFromOptions = function(e, t) {
            return Gu(yd, e, t)
        }
        ,
        yd.HAND_CONNECTIONS = sd,
        yd.POSE_CONNECTIONS = fd,
        yd.FACE_LANDMARKS_LIPS = Ku,
        yd.FACE_LANDMARKS_LEFT_EYE = qu,
        yd.FACE_LANDMARKS_LEFT_EYEBROW = Yu,
        yd.FACE_LANDMARKS_LEFT_IRIS = Qu,
        yd.FACE_LANDMARKS_RIGHT_EYE = Zu,
        yd.FACE_LANDMARKS_RIGHT_EYEBROW = $u,
        yd.FACE_LANDMARKS_RIGHT_IRIS = ed,
        yd.FACE_LANDMARKS_FACE_OVAL = td,
        yd.FACE_LANDMARKS_CONTOURS = nd,
        yd.FACE_LANDMARKS_TESSELATION = rd;
        var bd = class extends Xu {
            constructor(e, t) {
                super(new zu(e,t), "input_image", "norm_rect", !0),
                this.j = {
                    classifications: []
                },
                ao(e = this.h = new sc, 0, 1, t = new Tl)
            }
            get baseOptions() {
                return ro(this.h, Tl, 1)
            }
            set baseOptions(e) {
                ao(this.h, 0, 1, e)
            }
            o(e) {
                return ao(this.h, 0, 2, Ac(e, ro(this.h, Al, 2))),
                this.l(e)
            }
            ua(e, t) {
                return this.j = {
                    classifications: []
                },
                ju(this, e, t),
                this.j
            }
            va(e, t, n) {
                return this.j = {
                    classifications: []
                },
                Wu(this, e, n, t),
                this.j
            }
            m() {
                var e = new Ys;
                Ks(e, "input_image"),
                Ks(e, "norm_rect"),
                qs(e, "classifications");
                const t = new Ns;
                Vo(t, lc, this.h);
                const n = new js;
                zs(n, "mediapipe.tasks.vision.image_classifier.ImageClassifierGraph"),
                Gs(n, "IMAGE:input_image"),
                Gs(n, "NORM_RECT:norm_rect"),
                Hs(n, "CLASSIFICATIONS:classifications"),
                n.o(t),
                Js(e, n),
                this.g.attachProtoListener("classifications", ( (e, t) => {
                    this.j = function(e) {
                        const t = {
                            classifications: oo(e, fl, 1).map((e => xc(ro(e, el, 4)?.g() ?? [], ho(po(e, 2), 0), mo(e, 3))))
                        };
                        return null != Wr(Oi(e, 2)) && (t.timestampMs = ho(Wr(Oi(e, 2)), 0)),
                        t
                    }(ml(e)),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("classifications", (e => {
                    jc(this, e)
                }
                )),
                e = e.g(),
                this.setGraph(new Uint8Array(e), !0)
            }
        }
        ;
        bd.prototype.classifyForVideo = bd.prototype.va,
        bd.prototype.classify = bd.prototype.ua,
        bd.prototype.setOptions = bd.prototype.o,
        bd.createFromModelPath = function(e, t) {
            return Gu(bd, e, {
                baseOptions: {
                    modelAssetPath: t
                }
            })
        }
        ,
        bd.createFromModelBuffer = function(e, t) {
            return Gu(bd, e, {
                baseOptions: {
                    modelAssetBuffer: t
                }
            })
        }
        ,
        bd.createFromOptions = function(e, t) {
            return Gu(bd, e, t)
        }
        ;
        var _d = class extends Xu {
            constructor(e, t) {
                super(new zu(e,t), "image_in", "norm_rect", !0),
                this.h = new cc,
                this.embeddings = {
                    embeddings: []
                },
                ao(e = this.h, 0, 1, t = new Tl)
            }
            get baseOptions() {
                return ro(this.h, Tl, 1)
            }
            set baseOptions(e) {
                ao(this.h, 0, 1, e)
            }
            o(e) {
                var t = this.h
                  , n = ro(this.h, Sl, 2);
                return n = n ? n.clone() : new Sl,
                void 0 !== e.l2Normalize ? go(n, 1, e.l2Normalize) : "l2Normalize"in e && Ui(n, 1),
                void 0 !== e.quantize ? go(n, 2, e.quantize) : "quantize"in e && Ui(n, 2),
                ao(t, 0, 2, n),
                this.l(e)
            }
            Ba(e, t) {
                return ju(this, e, t),
                this.embeddings
            }
            Ca(e, t, n) {
                return Wu(this, e, n, t),
                this.embeddings
            }
            m() {
                var e = new Ys;
                Ks(e, "image_in"),
                Ks(e, "norm_rect"),
                qs(e, "embeddings_out");
                const t = new Ns;
                Vo(t, uc, this.h);
                const n = new js;
                zs(n, "mediapipe.tasks.vision.image_embedder.ImageEmbedderGraph"),
                Gs(n, "IMAGE:image_in"),
                Gs(n, "NORM_RECT:norm_rect"),
                Hs(n, "EMBEDDINGS:embeddings_out"),
                n.o(t),
                Js(e, n),
                this.g.attachProtoListener("embeddings_out", ( (e, t) => {
                    e = _l(e),
                    this.embeddings = function(e) {
                        return {
                            embeddings: oo(e, yl, 1).map((e => {
                                const t = {
                                    headIndex: ho(po(e, 3), 0) ?? -1,
                                    headName: mo(e, 4) ?? ""
                                };
                                if (void 0 !== no(e, gl, Qi(e, 1)))
                                    e = Vi(e = ro(e, gl, Qi(e, 1)), 1, Dr, Wi()),
                                    t.floatEmbedding = e.slice();
                                else {
                                    const n = new Uint8Array(0);
                                    t.quantizedEmbedding = ro(e, vl, Qi(e, 2))?.qa()?.h() ?? n
                                }
                                return t
                            }
                            )),
                            timestampMs: ho(Wr(Oi(e, 2)), 0)
                        }
                    }(e),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("embeddings_out", (e => {
                    jc(this, e)
                }
                )),
                e = e.g(),
                this.setGraph(new Uint8Array(e), !0)
            }
        }
        ;
        _d.cosineSimilarity = function(e, t) {
            if (e.floatEmbedding && t.floatEmbedding)
                e = Cc(e.floatEmbedding, t.floatEmbedding);
            else {
                if (!e.quantizedEmbedding || !t.quantizedEmbedding)
                    throw Error("Cannot compute cosine similarity between quantized and float embeddings.");
                e = Cc(Mc(e.quantizedEmbedding), Mc(t.quantizedEmbedding))
            }
            return e
        }
        ,
        _d.prototype.embedForVideo = _d.prototype.Ca,
        _d.prototype.embed = _d.prototype.Ba,
        _d.prototype.setOptions = _d.prototype.o,
        _d.createFromModelPath = function(e, t) {
            return Gu(_d, e, {
                baseOptions: {
                    modelAssetPath: t
                }
            })
        }
        ,
        _d.createFromModelBuffer = function(e, t) {
            return Gu(_d, e, {
                baseOptions: {
                    modelAssetBuffer: t
                }
            })
        }
        ,
        _d.createFromOptions = function(e, t) {
            return Gu(_d, e, t)
        }
        ;
        var Ad = class {
            constructor(e, t, n) {
                this.confidenceMasks = e,
                this.categoryMask = t,
                this.qualityScores = n
            }
            close() {
                this.confidenceMasks?.forEach((e => {
                    e.close()
                }
                )),
                this.categoryMask?.close()
            }
        }
        ;
        function xd(e) {
            e.categoryMask = void 0,
            e.confidenceMasks = void 0,
            e.qualityScores = void 0
        }
        function Sd(e) {
            try {
                const t = new Ad(e.confidenceMasks,e.categoryMask,e.qualityScores);
                if (!e.j)
                    return t;
                e.j(t)
            } finally {
                Xc(e)
            }
        }
        Ad.prototype.close = Ad.prototype.close;
        var wd = class extends Xu {
            constructor(e, t) {
                super(new zu(e,t), "image_in", "norm_rect", !1),
                this.s = [],
                this.outputCategoryMask = !1,
                this.outputConfidenceMasks = !0,
                this.h = new mc,
                this.v = new dc,
                ao(this.h, 0, 3, this.v),
                ao(e = this.h, 0, 1, t = new Tl)
            }
            get baseOptions() {
                return ro(this.h, Tl, 1)
            }
            set baseOptions(e) {
                ao(this.h, 0, 1, e)
            }
            o(e) {
                return void 0 !== e.displayNamesLocale ? Ui(this.h, 2, Xr(e.displayNamesLocale)) : "displayNamesLocale"in e && Ui(this.h, 2),
                "outputCategoryMask"in e && (this.outputCategoryMask = e.outputCategoryMask ?? !1),
                "outputConfidenceMasks"in e && (this.outputConfidenceMasks = e.outputConfidenceMasks ?? !0),
                super.l(e)
            }
            J() {
                !function(e) {
                    const t = oo(e.ea(), js, 1).filter((e => mo(e, 1).includes("mediapipe.tasks.TensorsToSegmentationCalculator")));
                    if (e.s = [],
                    t.length > 1)
                        throw Error("The graph has more than one mediapipe.tasks.TensorsToSegmentationCalculator.");
                    1 === t.length && (ro(t[0], Ns, 7)?.l()?.g() ?? new Map).forEach(( (t, n) => {
                        e.s[Number(n)] = mo(t, 1)
                    }
                    ))
                }(this)
            }
            fa(e, t, n) {
                const r = "function" != typeof t ? t : {};
                return this.j = "function" == typeof t ? t : n,
                xd(this),
                ju(this, e, r),
                Sd(this)
            }
            Na(e, t, n, r) {
                const i = "function" != typeof n ? n : {};
                return this.j = "function" == typeof n ? n : r,
                xd(this),
                Wu(this, e, i, t),
                Sd(this)
            }
            Fa() {
                return this.s
            }
            m() {
                var e = new Ys;
                Ks(e, "image_in"),
                Ks(e, "norm_rect");
                const t = new Ns;
                Vo(t, gc, this.h);
                const n = new js;
                zs(n, "mediapipe.tasks.vision.image_segmenter.ImageSegmenterGraph"),
                Gs(n, "IMAGE:image_in"),
                Gs(n, "NORM_RECT:norm_rect"),
                n.o(t),
                Js(e, n),
                Wc(this, e),
                this.outputConfidenceMasks && (qs(e, "confidence_masks"),
                Hs(n, "CONFIDENCE_MASKS:confidence_masks"),
                Vc(this, "confidence_masks"),
                this.g.da("confidence_masks", ( (e, t) => {
                    this.confidenceMasks = e.map((e => Vu(this, e, !0, !this.j))),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("confidence_masks", (e => {
                    this.confidenceMasks = [],
                    jc(this, e)
                }
                ))),
                this.outputCategoryMask && (qs(e, "category_mask"),
                Hs(n, "CATEGORY_MASK:category_mask"),
                Vc(this, "category_mask"),
                this.g.V("category_mask", ( (e, t) => {
                    this.categoryMask = Vu(this, e, !1, !this.j),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("category_mask", (e => {
                    this.categoryMask = void 0,
                    jc(this, e)
                }
                ))),
                qs(e, "quality_scores"),
                Hs(n, "QUALITY_SCORES:quality_scores"),
                this.g.attachFloatVectorListener("quality_scores", ( (e, t) => {
                    this.qualityScores = e,
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("quality_scores", (e => {
                    this.categoryMask = void 0,
                    jc(this, e)
                }
                )),
                e = e.g(),
                this.setGraph(new Uint8Array(e), !0)
            }
        }
        ;
        wd.prototype.getLabels = wd.prototype.Fa,
        wd.prototype.segmentForVideo = wd.prototype.Na,
        wd.prototype.segment = wd.prototype.fa,
        wd.prototype.setOptions = wd.prototype.o,
        wd.createFromModelPath = function(e, t) {
            return Gu(wd, e, {
                baseOptions: {
                    modelAssetPath: t
                }
            })
        }
        ,
        wd.createFromModelBuffer = function(e, t) {
            return Gu(wd, e, {
                baseOptions: {
                    modelAssetBuffer: t
                }
            })
        }
        ,
        wd.createFromOptions = function(e, t) {
            return Gu(wd, e, t)
        }
        ;
        var Ed = class {
            constructor(e, t, n) {
                this.confidenceMasks = e,
                this.categoryMask = t,
                this.qualityScores = n
            }
            close() {
                this.confidenceMasks?.forEach((e => {
                    e.close()
                }
                )),
                this.categoryMask?.close()
            }
        }
        ;
        Ed.prototype.close = Ed.prototype.close;
        var Md = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , Cd = [0, ss, -2]
          , Td = [0, es, -3, us, es, -1]
          , Rd = [0, Td]
          , Pd = [0, Td, ss, -1]
          , Bd = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , Id = [0, es, -1, us]
          , Ld = class extends Xo {
            constructor() {
                super()
            }
        }
          , kd = class extends Xo {
            constructor(e) {
                super(e)
            }
        }
          , Dd = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 15]
          , Od = class extends Xo {
            constructor() {
                super()
            }
        }
        ;
        Od.prototype.g = Ss([0, ms, [0, Dd, gs, Td, gs, [0, Td, Cd], gs, Rd, gs, [0, Rd, Cd], gs, Id, gs, [0, es, -3, us, bs], gs, [0, es, -3, us], gs, [0, fs, es, -2, us, ss, us, -1, 2, es, Cd], gs, Pd, gs, [0, Pd, Cd], es, Cd, fs, gs, [0, es, -3, us, Cd, -1], gs, [0, ms, Id]], fs, [0, fs, ss, -1, us]]);
        var Nd = class extends Xu {
            constructor(e, t) {
                super(new zu(e,t), "image_in", "norm_rect_in", !1),
                this.outputCategoryMask = !1,
                this.outputConfidenceMasks = !0,
                this.h = new mc,
                this.s = new dc,
                ao(this.h, 0, 3, this.s),
                ao(e = this.h, 0, 1, t = new Tl)
            }
            get baseOptions() {
                return ro(this.h, Tl, 1)
            }
            set baseOptions(e) {
                ao(this.h, 0, 1, e)
            }
            o(e) {
                return "outputCategoryMask"in e && (this.outputCategoryMask = e.outputCategoryMask ?? !1),
                "outputConfidenceMasks"in e && (this.outputConfidenceMasks = e.outputConfidenceMasks ?? !0),
                super.l(e)
            }
            fa(e, t, n, r) {
                const i = "function" != typeof n ? n : {};
                this.j = "function" == typeof n ? n : r,
                this.qualityScores = this.categoryMask = this.confidenceMasks = void 0,
                n = this.B + 1,
                r = new Od;
                const o = new kd;
                var a = new Md;
                if (vo(a, 1, 255),
                ao(o, 0, 12, a),
                t.keypoint && t.scribble)
                    throw Error("Cannot provide both keypoint and scribble.");
                if (t.keypoint) {
                    var s = new Bd;
                    go(s, 3, !0),
                    yo(s, 1, t.keypoint.x),
                    yo(s, 2, t.keypoint.y),
                    so(o, 5, Dd, s)
                } else {
                    if (!t.scribble)
                        throw Error("Must provide either a keypoint or a scribble.");
                    for (s of (a = new Ld,
                    t.scribble))
                        go(t = new Bd, 3, !0),
                        yo(t, 1, s.x),
                        yo(t, 2, s.y),
                        uo(a, 1, Bd, t);
                    so(o, 15, Dd, a)
                }
                uo(r, 1, kd, o),
                this.g.addProtoToStream(r.g(), "drishti.RenderData", "roi_in", n),
                ju(this, e, i);
                e: {
                    try {
                        const e = new Ed(this.confidenceMasks,this.categoryMask,this.qualityScores);
                        if (!this.j) {
                            var l = e;
                            break e
                        }
                        this.j(e)
                    } finally {
                        Xc(this)
                    }
                    l = void 0
                }
                return l
            }
            m() {
                var e = new Ys;
                Ks(e, "image_in"),
                Ks(e, "roi_in"),
                Ks(e, "norm_rect_in");
                const t = new Ns;
                Vo(t, gc, this.h);
                const n = new js;
                zs(n, "mediapipe.tasks.vision.interactive_segmenter.InteractiveSegmenterGraph"),
                Gs(n, "IMAGE:image_in"),
                Gs(n, "ROI:roi_in"),
                Gs(n, "NORM_RECT:norm_rect_in"),
                n.o(t),
                Js(e, n),
                Wc(this, e),
                this.outputConfidenceMasks && (qs(e, "confidence_masks"),
                Hs(n, "CONFIDENCE_MASKS:confidence_masks"),
                Vc(this, "confidence_masks"),
                this.g.da("confidence_masks", ( (e, t) => {
                    this.confidenceMasks = e.map((e => Vu(this, e, !0, !this.j))),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("confidence_masks", (e => {
                    this.confidenceMasks = [],
                    jc(this, e)
                }
                ))),
                this.outputCategoryMask && (qs(e, "category_mask"),
                Hs(n, "CATEGORY_MASK:category_mask"),
                Vc(this, "category_mask"),
                this.g.V("category_mask", ( (e, t) => {
                    this.categoryMask = Vu(this, e, !1, !this.j),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("category_mask", (e => {
                    this.categoryMask = void 0,
                    jc(this, e)
                }
                ))),
                qs(e, "quality_scores"),
                Hs(n, "QUALITY_SCORES:quality_scores"),
                this.g.attachFloatVectorListener("quality_scores", ( (e, t) => {
                    this.qualityScores = e,
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("quality_scores", (e => {
                    this.categoryMask = void 0,
                    jc(this, e)
                }
                )),
                e = e.g(),
                this.setGraph(new Uint8Array(e), !0)
            }
        }
        ;
        Nd.prototype.segment = Nd.prototype.fa,
        Nd.prototype.setOptions = Nd.prototype.o,
        Nd.createFromModelPath = function(e, t) {
            return Gu(Nd, e, {
                baseOptions: {
                    modelAssetPath: t
                }
            })
        }
        ,
        Nd.createFromModelBuffer = function(e, t) {
            return Gu(Nd, e, {
                baseOptions: {
                    modelAssetBuffer: t
                }
            })
        }
        ,
        Nd.createFromOptions = function(e, t) {
            return Gu(Nd, e, t)
        }
        ;
        var Fd = class extends Xu {
            constructor(e, t) {
                super(new zu(e,t), "input_frame_gpu", "norm_rect", !1),
                this.j = {
                    detections: []
                },
                ao(e = this.h = new vc, 0, 1, t = new Tl)
            }
            get baseOptions() {
                return ro(this.h, Tl, 1)
            }
            set baseOptions(e) {
                ao(this.h, 0, 1, e)
            }
            o(e) {
                return void 0 !== e.displayNamesLocale ? Ui(this.h, 2, Xr(e.displayNamesLocale)) : "displayNamesLocale"in e && Ui(this.h, 2),
                void 0 !== e.maxResults ? vo(this.h, 3, e.maxResults) : "maxResults"in e && Ui(this.h, 3),
                void 0 !== e.scoreThreshold ? yo(this.h, 4, e.scoreThreshold) : "scoreThreshold"in e && Ui(this.h, 4),
                void 0 !== e.categoryAllowlist ? bo(this.h, 5, e.categoryAllowlist) : "categoryAllowlist"in e && Ui(this.h, 5),
                void 0 !== e.categoryDenylist ? bo(this.h, 6, e.categoryDenylist) : "categoryDenylist"in e && Ui(this.h, 6),
                this.l(e)
            }
            D(e, t) {
                return this.j = {
                    detections: []
                },
                ju(this, e, t),
                this.j
            }
            F(e, t, n) {
                return this.j = {
                    detections: []
                },
                Wu(this, e, n, t),
                this.j
            }
            m() {
                var e = new Ys;
                Ks(e, "input_frame_gpu"),
                Ks(e, "norm_rect"),
                qs(e, "detections");
                const t = new Ns;
                Vo(t, yc, this.h);
                const n = new js;
                zs(n, "mediapipe.tasks.vision.ObjectDetectorGraph"),
                Gs(n, "IMAGE:input_frame_gpu"),
                Gs(n, "NORM_RECT:norm_rect"),
                Hs(n, "DETECTIONS:detections"),
                n.o(t),
                Js(e, n),
                this.g.attachProtoVectorListener("detections", ( (e, t) => {
                    for (const n of e)
                        e = al(n),
                        this.j.detections.push(Sc(e));
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("detections", (e => {
                    jc(this, e)
                }
                )),
                e = e.g(),
                this.setGraph(new Uint8Array(e), !0)
            }
        }
        ;
        Fd.prototype.detectForVideo = Fd.prototype.F,
        Fd.prototype.detect = Fd.prototype.D,
        Fd.prototype.setOptions = Fd.prototype.o,
        Fd.createFromModelPath = async function(e, t) {
            return Gu(Fd, e, {
                baseOptions: {
                    modelAssetPath: t
                }
            })
        }
        ,
        Fd.createFromModelBuffer = function(e, t) {
            return Gu(Fd, e, {
                baseOptions: {
                    modelAssetBuffer: t
                }
            })
        }
        ,
        Fd.createFromOptions = function(e, t) {
            return Gu(Fd, e, t)
        }
        ;
        var Ud = class {
            constructor(e, t, n) {
                this.landmarks = e,
                this.worldLandmarks = t,
                this.segmentationMasks = n
            }
            close() {
                this.segmentationMasks?.forEach((e => {
                    e.close()
                }
                ))
            }
        }
        ;
        function zd(e) {
            e.landmarks = [],
            e.worldLandmarks = [],
            e.segmentationMasks = void 0
        }
        function Gd(e) {
            try {
                const t = new Ud(e.landmarks,e.worldLandmarks,e.segmentationMasks);
                if (!e.s)
                    return t;
                e.s(t)
            } finally {
                Xc(e)
            }
        }
        Ud.prototype.close = Ud.prototype.close;
        var Hd = class extends Xu {
            constructor(e, t) {
                super(new zu(e,t), "image_in", "norm_rect", !1),
                this.landmarks = [],
                this.worldLandmarks = [],
                this.outputSegmentationMasks = !1,
                ao(e = this.h = new bc, 0, 1, t = new Tl),
                this.v = new rc,
                ao(this.h, 0, 3, this.v),
                this.j = new nc,
                ao(this.h, 0, 2, this.j),
                vo(this.j, 4, 1),
                yo(this.j, 2, .5),
                yo(this.v, 2, .5),
                yo(this.h, 4, .5)
            }
            get baseOptions() {
                return ro(this.h, Tl, 1)
            }
            set baseOptions(e) {
                ao(this.h, 0, 1, e)
            }
            o(e) {
                return "numPoses"in e && vo(this.j, 4, e.numPoses ?? 1),
                "minPoseDetectionConfidence"in e && yo(this.j, 2, e.minPoseDetectionConfidence ?? .5),
                "minTrackingConfidence"in e && yo(this.h, 4, e.minTrackingConfidence ?? .5),
                "minPosePresenceConfidence"in e && yo(this.v, 2, e.minPosePresenceConfidence ?? .5),
                "outputSegmentationMasks"in e && (this.outputSegmentationMasks = e.outputSegmentationMasks ?? !1),
                this.l(e)
            }
            D(e, t, n) {
                const r = "function" != typeof t ? t : {};
                return this.s = "function" == typeof t ? t : n,
                zd(this),
                ju(this, e, r),
                Gd(this)
            }
            F(e, t, n, r) {
                const i = "function" != typeof n ? n : {};
                return this.s = "function" == typeof n ? n : r,
                zd(this),
                Wu(this, e, i, t),
                Gd(this)
            }
            m() {
                var e = new Ys;
                Ks(e, "image_in"),
                Ks(e, "norm_rect"),
                qs(e, "normalized_landmarks"),
                qs(e, "world_landmarks"),
                qs(e, "segmentation_masks");
                const t = new Ns;
                Vo(t, _c, this.h);
                const n = new js;
                zs(n, "mediapipe.tasks.vision.pose_landmarker.PoseLandmarkerGraph"),
                Gs(n, "IMAGE:image_in"),
                Gs(n, "NORM_RECT:norm_rect"),
                Hs(n, "NORM_LANDMARKS:normalized_landmarks"),
                Hs(n, "WORLD_LANDMARKS:world_landmarks"),
                n.o(t),
                Js(e, n),
                Wc(this, e),
                this.g.attachProtoVectorListener("normalized_landmarks", ( (e, t) => {
                    this.landmarks = [];
                    for (const n of e)
                        e = ul(n),
                        this.landmarks.push(wc(e));
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("normalized_landmarks", (e => {
                    this.landmarks = [],
                    jc(this, e)
                }
                )),
                this.g.attachProtoVectorListener("world_landmarks", ( (e, t) => {
                    this.worldLandmarks = [];
                    for (const n of e)
                        e = ll(n),
                        this.worldLandmarks.push(Ec(e));
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("world_landmarks", (e => {
                    this.worldLandmarks = [],
                    jc(this, e)
                }
                )),
                this.outputSegmentationMasks && (Hs(n, "SEGMENTATION_MASK:segmentation_masks"),
                Vc(this, "segmentation_masks"),
                this.g.da("segmentation_masks", ( (e, t) => {
                    this.segmentationMasks = e.map((e => Vu(this, e, !0, !this.s))),
                    jc(this, t)
                }
                )),
                this.g.attachEmptyPacketListener("segmentation_masks", (e => {
                    this.segmentationMasks = [],
                    jc(this, e)
                }
                ))),
                e = e.g(),
                this.setGraph(new Uint8Array(e), !0)
            }
        }
        ;
        Hd.prototype.detectForVideo = Hd.prototype.F,
        Hd.prototype.detect = Hd.prototype.D,
        Hd.prototype.setOptions = Hd.prototype.o,
        Hd.createFromModelPath = function(e, t) {
            return Gu(Hd, e, {
                baseOptions: {
                    modelAssetPath: t
                }
            })
        }
        ,
        Hd.createFromModelBuffer = function(e, t) {
            return Gu(Hd, e, {
                baseOptions: {
                    modelAssetBuffer: t
                }
            })
        }
        ,
        Hd.createFromOptions = function(e, t) {
            return Gu(Hd, e, t)
        }
        ,
        Hd.POSE_CONNECTIONS = fd;
        const jd = "159"
          , Wd = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2
        }
          , Vd = {
            ROTATE: 0,
            PAN: 1,
            DOLLY_PAN: 2,
            DOLLY_ROTATE: 3
        }
          , Xd = 0
          , Jd = 1
          , Kd = 2
          , qd = 3
          , Yd = 0
          , Qd = 1
          , Zd = 2
          , $d = 3
          , eh = 0
          , th = 1
          , nh = 2
          , rh = 2
          , ih = 0
          , oh = 1
          , ah = 2
          , sh = 3
          , lh = 4
          , ch = 5
          , uh = 100
          , dh = 101
          , hh = 102
          , ph = 103
          , fh = 104
          , mh = 200
          , gh = 201
          , vh = 202
          , yh = 203
          , bh = 204
          , _h = 205
          , Ah = 206
          , xh = 207
          , Sh = 208
          , wh = 209
          , Eh = 210
          , Mh = 211
          , Ch = 212
          , Th = 213
          , Rh = 214
          , Ph = 0
          , Bh = 1
          , Ih = 2
          , Lh = 3
          , kh = 4
          , Dh = 5
          , Oh = 6
          , Nh = 7
          , Fh = 0
          , Uh = 1
          , zh = 2
          , Gh = 0
          , Hh = 1
          , jh = 2
          , Wh = 3
          , Vh = 4
          , Xh = 5
          , Jh = "attached"
          , Kh = "detached"
          , qh = 300
          , Yh = 301
          , Qh = 302
          , Zh = 303
          , $h = 304
          , ep = 306
          , tp = 1e3
          , np = 1001
          , rp = 1002
          , ip = 1003
          , op = 1004
          , ap = 1004
          , sp = 1005
          , lp = 1005
          , cp = 1006
          , up = 1007
          , dp = 1007
          , hp = 1008
          , pp = 1008
          , fp = 1009
          , mp = 1010
          , gp = 1011
          , vp = 1012
          , yp = 1013
          , bp = 1014
          , _p = 1015
          , Ap = 1016
          , xp = 1017
          , Sp = 1018
          , wp = 1020
          , Ep = 1021
          , Mp = 1023
          , Cp = 1024
          , Tp = 1025
          , Rp = 1026
          , Pp = 1027
          , Bp = 1028
          , Ip = 1029
          , Lp = 1030
          , kp = 1031
          , Dp = 1033
          , Op = 33776
          , Np = 33777
          , Fp = 33778
          , Up = 33779
          , zp = 35840
          , Gp = 35841
          , Hp = 35842
          , jp = 35843
          , Wp = 36196
          , Vp = 37492
          , Xp = 37496
          , Jp = 37808
          , Kp = 37809
          , qp = 37810
          , Yp = 37811
          , Qp = 37812
          , Zp = 37813
          , $p = 37814
          , ef = 37815
          , tf = 37816
          , nf = 37817
          , rf = 37818
          , of = 37819
          , af = 37820
          , sf = 37821
          , lf = 36492
          , cf = 36494
          , uf = 36495
          , df = 36283
          , hf = 36284
          , pf = 36285
          , ff = 36286
          , mf = 2200
          , gf = 2201
          , vf = 2202
          , yf = 2300
          , bf = 2301
          , _f = 2302
          , Af = 2400
          , xf = 2401
          , Sf = 2402
          , wf = 2500
          , Ef = 2501
          , Mf = 0
          , Cf = 1
          , Tf = 2
          , Rf = 3e3
          , Pf = 3001
          , Bf = 3200
          , If = 3201
          , Lf = 0
          , kf = 1
          , Df = ""
          , Of = "srgb"
          , Nf = "srgb-linear"
          , Ff = "display-p3"
          , Uf = "display-p3-linear"
          , zf = "linear"
          , Gf = "srgb"
          , Hf = "rec709"
          , jf = "p3"
          , Wf = 0
          , Vf = 7680
          , Xf = 7681
          , Jf = 7682
          , Kf = 7683
          , qf = 34055
          , Yf = 34056
          , Qf = 5386
          , Zf = 512
          , $f = 513
          , em = 514
          , tm = 515
          , nm = 516
          , rm = 517
          , im = 518
          , om = 519
          , am = 512
          , sm = 513
          , lm = 514
          , cm = 515
          , um = 516
          , dm = 517
          , hm = 518
          , pm = 519
          , fm = 35044
          , mm = 35048
          , gm = 35040
          , vm = 35045
          , ym = 35049
          , bm = 35041
          , _m = 35046
          , Am = 35050
          , xm = 35042
          , Sm = "100"
          , wm = "300 es"
          , Em = 1035
          , Mm = 2e3
          , Cm = 2001;
        class Tm {
            addEventListener(e, t) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[e] && (n[e] = []),
                -1 === n[e].indexOf(t) && n[e].push(t)
            }
            hasEventListener(e, t) {
                if (void 0 === this._listeners)
                    return !1;
                const n = this._listeners;
                return void 0 !== n[e] && -1 !== n[e].indexOf(t)
            }
            removeEventListener(e, t) {
                if (void 0 === this._listeners)
                    return;
                const n = this._listeners[e];
                if (void 0 !== n) {
                    const e = n.indexOf(t);
                    -1 !== e && n.splice(e, 1)
                }
            }
            dispatchEvent(e) {
                if (void 0 === this._listeners)
                    return;
                const t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    const n = t.slice(0);
                    for (let t = 0, r = n.length; t < r; t++)
                        n[t].call(this, e);
                    e.target = null
                }
            }
        }
        const Rm = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let Pm = 1234567;
        const Bm = Math.PI / 180
          , Im = 180 / Math.PI;
        function Lm() {
            const e = 4294967295 * Math.random() | 0
              , t = 4294967295 * Math.random() | 0
              , n = 4294967295 * Math.random() | 0
              , r = 4294967295 * Math.random() | 0;
            return (Rm[255 & e] + Rm[e >> 8 & 255] + Rm[e >> 16 & 255] + Rm[e >> 24 & 255] + "-" + Rm[255 & t] + Rm[t >> 8 & 255] + "-" + Rm[t >> 16 & 15 | 64] + Rm[t >> 24 & 255] + "-" + Rm[63 & n | 128] + Rm[n >> 8 & 255] + "-" + Rm[n >> 16 & 255] + Rm[n >> 24 & 255] + Rm[255 & r] + Rm[r >> 8 & 255] + Rm[r >> 16 & 255] + Rm[r >> 24 & 255]).toLowerCase()
        }
        function km(e, t, n) {
            return Math.max(t, Math.min(n, e))
        }
        function Dm(e, t) {
            return (e % t + t) % t
        }
        function Om(e, t, n) {
            return (1 - n) * e + n * t
        }
        function Nm(e) {
            return 0 === (e & e - 1) && 0 !== e
        }
        function Fm(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        }
        function Um(e, t) {
            switch (t.constructor) {
            case Float32Array:
                return e;
            case Uint32Array:
                return e / 4294967295;
            case Uint16Array:
                return e / 65535;
            case Uint8Array:
                return e / 255;
            case Int32Array:
                return Math.max(e / 2147483647, -1);
            case Int16Array:
                return Math.max(e / 32767, -1);
            case Int8Array:
                return Math.max(e / 127, -1);
            default:
                throw new Error("Invalid component type.")
            }
        }
        function zm(e, t) {
            switch (t.constructor) {
            case Float32Array:
                return e;
            case Uint32Array:
                return Math.round(4294967295 * e);
            case Uint16Array:
                return Math.round(65535 * e);
            case Uint8Array:
                return Math.round(255 * e);
            case Int32Array:
                return Math.round(2147483647 * e);
            case Int16Array:
                return Math.round(32767 * e);
            case Int8Array:
                return Math.round(127 * e);
            default:
                throw new Error("Invalid component type.")
            }
        }
        const Gm = {
            DEG2RAD: Bm,
            RAD2DEG: Im,
            generateUUID: Lm,
            clamp: km,
            euclideanModulo: Dm,
            mapLinear: function(e, t, n, r, i) {
                return r + (e - t) * (i - r) / (n - t)
            },
            inverseLerp: function(e, t, n) {
                return e !== t ? (n - e) / (t - e) : 0
            },
            lerp: Om,
            damp: function(e, t, n, r) {
                return Om(e, t, 1 - Math.exp(-n * r))
            },
            pingpong: function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                return t - Math.abs(Dm(e, 2 * t) - t)
            },
            smoothstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
            },
            smootherstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
            },
            randInt: function(e, t) {
                return e + Math.floor(Math.random() * (t - e + 1))
            },
            randFloat: function(e, t) {
                return e + Math.random() * (t - e)
            },
            randFloatSpread: function(e) {
                return e * (.5 - Math.random())
            },
            seededRandom: function(e) {
                void 0 !== e && (Pm = e);
                let t = Pm += 1831565813;
                return t = Math.imul(t ^ t >>> 15, 1 | t),
                t ^= t + Math.imul(t ^ t >>> 7, 61 | t),
                ((t ^ t >>> 14) >>> 0) / 4294967296
            },
            degToRad: function(e) {
                return e * Bm
            },
            radToDeg: function(e) {
                return e * Im
            },
            isPowerOfTwo: Nm,
            ceilPowerOfTwo: function(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            },
            floorPowerOfTwo: Fm,
            setQuaternionFromProperEuler: function(e, t, n, r, i) {
                const o = Math.cos
                  , a = Math.sin
                  , s = o(n / 2)
                  , l = a(n / 2)
                  , c = o((t + r) / 2)
                  , u = a((t + r) / 2)
                  , d = o((t - r) / 2)
                  , h = a((t - r) / 2)
                  , p = o((r - t) / 2)
                  , f = a((r - t) / 2);
                switch (i) {
                case "XYX":
                    e.set(s * u, l * d, l * h, s * c);
                    break;
                case "YZY":
                    e.set(l * h, s * u, l * d, s * c);
                    break;
                case "ZXZ":
                    e.set(l * d, l * h, s * u, s * c);
                    break;
                case "XZX":
                    e.set(s * u, l * f, l * p, s * c);
                    break;
                case "YXY":
                    e.set(l * p, s * u, l * f, s * c);
                    break;
                case "ZYZ":
                    e.set(l * f, l * p, s * u, s * c);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                }
            },
            normalize: zm,
            denormalize: Um
        };
        class Hm {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                Hm.prototype.isVector2 = !0,
                this.x = e,
                this.y = t
            }
            get width() {
                return this.x
            }
            set width(e) {
                this.x = e
            }
            get height() {
                return this.y
            }
            set height(e) {
                this.y = e
            }
            set(e, t) {
                return this.x = e,
                this.y = t,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setComponent(e, t) {
                switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x,
                this.y = e.y + t.y,
                this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t,
                this.y += e.y * t,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x,
                this.y = e.y - t.y,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this
            }
            divide(e) {
                return this.x /= e.x,
                this.y /= e.y,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            applyMatrix3(e) {
                const t = this.x
                  , n = this.y
                  , r = e.elements;
                return this.x = r[0] * t + r[3] * n + r[6],
                this.y = r[1] * t + r[4] * n + r[7],
                this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                this.y = Math.max(e.y, Math.min(t.y, this.y)),
                this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)),
                this.y = Math.max(e, Math.min(t, this.y)),
                this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y
            }
            cross(e) {
                return this.x * e.y - this.y * e.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t)
                    return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(km(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x
                  , n = this.y - e.y;
                return t * t + n * n
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t,
                this.y += (e.y - this.y) * t,
                this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n,
                this.y = e.y + (t.y - e.y) * n,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.x = e[t],
                this.y = e[t + 1],
                this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this.x,
                e[t + 1] = this.y,
                e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t),
                this.y = e.getY(t),
                this
            }
            rotateAround(e, t) {
                const n = Math.cos(t)
                  , r = Math.sin(t)
                  , i = this.x - e.x
                  , o = this.y - e.y;
                return this.x = i * n - o * r + e.x,
                this.y = i * r + o * n + e.y,
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y
            }
        }
        class jm {
            constructor(e, t, n, r, i, o, a, s, l) {
                jm.prototype.isMatrix3 = !0,
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                void 0 !== e && this.set(e, t, n, r, i, o, a, s, l)
            }
            set(e, t, n, r, i, o, a, s, l) {
                const c = this.elements;
                return c[0] = e,
                c[1] = r,
                c[2] = a,
                c[3] = t,
                c[4] = i,
                c[5] = s,
                c[6] = n,
                c[7] = o,
                c[8] = l,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            }
            copy(e) {
                const t = this.elements
                  , n = e.elements;
                return t[0] = n[0],
                t[1] = n[1],
                t[2] = n[2],
                t[3] = n[3],
                t[4] = n[4],
                t[5] = n[5],
                t[6] = n[6],
                t[7] = n[7],
                t[8] = n[8],
                this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrix3Column(this, 0),
                t.setFromMatrix3Column(this, 1),
                n.setFromMatrix3Column(this, 2),
                this
            }
            setFromMatrix4(e) {
                const t = e.elements;
                return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
                this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements
                  , r = t.elements
                  , i = this.elements
                  , o = n[0]
                  , a = n[3]
                  , s = n[6]
                  , l = n[1]
                  , c = n[4]
                  , u = n[7]
                  , d = n[2]
                  , h = n[5]
                  , p = n[8]
                  , f = r[0]
                  , m = r[3]
                  , g = r[6]
                  , v = r[1]
                  , y = r[4]
                  , b = r[7]
                  , _ = r[2]
                  , A = r[5]
                  , x = r[8];
                return i[0] = o * f + a * v + s * _,
                i[3] = o * m + a * y + s * A,
                i[6] = o * g + a * b + s * x,
                i[1] = l * f + c * v + u * _,
                i[4] = l * m + c * y + u * A,
                i[7] = l * g + c * b + u * x,
                i[2] = d * f + h * v + p * _,
                i[5] = d * m + h * y + p * A,
                i[8] = d * g + h * b + p * x,
                this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e,
                t[3] *= e,
                t[6] *= e,
                t[1] *= e,
                t[4] *= e,
                t[7] *= e,
                t[2] *= e,
                t[5] *= e,
                t[8] *= e,
                this
            }
            determinant() {
                const e = this.elements
                  , t = e[0]
                  , n = e[1]
                  , r = e[2]
                  , i = e[3]
                  , o = e[4]
                  , a = e[5]
                  , s = e[6]
                  , l = e[7]
                  , c = e[8];
                return t * o * c - t * a * l - n * i * c + n * a * s + r * i * l - r * o * s
            }
            invert() {
                const e = this.elements
                  , t = e[0]
                  , n = e[1]
                  , r = e[2]
                  , i = e[3]
                  , o = e[4]
                  , a = e[5]
                  , s = e[6]
                  , l = e[7]
                  , c = e[8]
                  , u = c * o - a * l
                  , d = a * s - c * i
                  , h = l * i - o * s
                  , p = t * u + n * d + r * h;
                if (0 === p)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return e[0] = u * f,
                e[1] = (r * l - c * n) * f,
                e[2] = (a * n - r * o) * f,
                e[3] = d * f,
                e[4] = (c * t - r * s) * f,
                e[5] = (r * i - a * t) * f,
                e[6] = h * f,
                e[7] = (n * s - l * t) * f,
                e[8] = (o * t - n * i) * f,
                this
            }
            transpose() {
                let e;
                const t = this.elements;
                return e = t[1],
                t[1] = t[3],
                t[3] = e,
                e = t[2],
                t[2] = t[6],
                t[6] = e,
                e = t[5],
                t[5] = t[7],
                t[7] = e,
                this
            }
            getNormalMatrix(e) {
                return this.setFromMatrix4(e).invert().transpose()
            }
            transposeIntoArray(e) {
                const t = this.elements;
                return e[0] = t[0],
                e[1] = t[3],
                e[2] = t[6],
                e[3] = t[1],
                e[4] = t[4],
                e[5] = t[7],
                e[6] = t[2],
                e[7] = t[5],
                e[8] = t[8],
                this
            }
            setUvTransform(e, t, n, r, i, o, a) {
                const s = Math.cos(i)
                  , l = Math.sin(i);
                return this.set(n * s, n * l, -n * (s * o + l * a) + o + e, -r * l, r * s, -r * (-l * o + s * a) + a + t, 0, 0, 1),
                this
            }
            scale(e, t) {
                return this.premultiply(Wm.makeScale(e, t)),
                this
            }
            rotate(e) {
                return this.premultiply(Wm.makeRotation(-e)),
                this
            }
            translate(e, t) {
                return this.premultiply(Wm.makeTranslation(e, t)),
                this
            }
            makeTranslation(e, t) {
                return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
                this
            }
            makeRotation(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
                this
            }
            makeScale(e, t) {
                return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
                this
            }
            equals(e) {
                const t = this.elements
                  , n = e.elements;
                for (let r = 0; r < 9; r++)
                    if (t[r] !== n[r])
                        return !1;
                return !0
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                for (let n = 0; n < 9; n++)
                    this.elements[n] = e[n + t];
                return this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.elements;
                return e[t] = n[0],
                e[t + 1] = n[1],
                e[t + 2] = n[2],
                e[t + 3] = n[3],
                e[t + 4] = n[4],
                e[t + 5] = n[5],
                e[t + 6] = n[6],
                e[t + 7] = n[7],
                e[t + 8] = n[8],
                e
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        const Wm = new jm;
        function Vm(e) {
            for (let t = e.length - 1; t >= 0; --t)
                if (e[t] >= 65535)
                    return !0;
            return !1
        }
        const Xm = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: Uint8ClampedArray,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };
        function Jm(e, t) {
            return new Xm[e](t)
        }
        function Km(e) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", e)
        }
        function qm() {
            const e = Km("canvas");
            return e.style.display = "block",
            e
        }
        const Ym = {};
        function Qm(e) {
            e in Ym || (Ym[e] = !0,
            console.warn(e))
        }
        const Zm = (new jm).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
          , $m = (new jm).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
          , eg = {
            [Nf]: {
                transfer: zf,
                primaries: Hf,
                toReference: e => e,
                fromReference: e => e
            },
            [Of]: {
                transfer: Gf,
                primaries: Hf,
                toReference: e => e.convertSRGBToLinear(),
                fromReference: e => e.convertLinearToSRGB()
            },
            [Uf]: {
                transfer: zf,
                primaries: jf,
                toReference: e => e.applyMatrix3($m),
                fromReference: e => e.applyMatrix3(Zm)
            },
            [Ff]: {
                transfer: Gf,
                primaries: jf,
                toReference: e => e.convertSRGBToLinear().applyMatrix3($m),
                fromReference: e => e.applyMatrix3(Zm).convertLinearToSRGB()
            }
        }
          , tg = new Set([Nf, Uf])
          , ng = {
            enabled: !0,
            _workingColorSpace: Nf,
            get legacyMode() {
                return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
                !this.enabled
            },
            set legacyMode(e) {
                console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
                this.enabled = !e
            },
            get workingColorSpace() {
                return this._workingColorSpace
            },
            set workingColorSpace(e) {
                if (!tg.has(e))
                    throw new Error(`Unsupported working color space, "${e}".`);
                this._workingColorSpace = e
            },
            convert: function(e, t, n) {
                if (!1 === this.enabled || t === n || !t || !n)
                    return e;
                const r = eg[t].toReference;
                return (0,
                eg[n].fromReference)(r(e))
            },
            fromWorkingColorSpace: function(e, t) {
                return this.convert(e, this._workingColorSpace, t)
            },
            toWorkingColorSpace: function(e, t) {
                return this.convert(e, t, this._workingColorSpace)
            },
            getPrimaries: function(e) {
                return eg[e].primaries
            },
            getTransfer: function(e) {
                return e === Df ? zf : eg[e].transfer
            }
        };
        function rg(e) {
            return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
        }
        function ig(e) {
            return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
        }
        let og;
        class ag {
            static getDataURL(e) {
                if (/^data:/i.test(e.src))
                    return e.src;
                if ("undefined" === typeof HTMLCanvasElement)
                    return e.src;
                let t;
                if (e instanceof HTMLCanvasElement)
                    t = e;
                else {
                    void 0 === og && (og = Km("canvas")),
                    og.width = e.width,
                    og.height = e.height;
                    const n = og.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
                    t = og
                }
                return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
                t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
            }
            static sRGBToLinear(e) {
                if ("undefined" !== typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && e instanceof ImageBitmap) {
                    const t = Km("canvas");
                    t.width = e.width,
                    t.height = e.height;
                    const n = t.getContext("2d");
                    n.drawImage(e, 0, 0, e.width, e.height);
                    const r = n.getImageData(0, 0, e.width, e.height)
                      , i = r.data;
                    for (let e = 0; e < i.length; e++)
                        i[e] = 255 * rg(i[e] / 255);
                    return n.putImageData(r, 0, 0),
                    t
                }
                if (e.data) {
                    const t = e.data.slice(0);
                    for (let e = 0; e < t.length; e++)
                        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * rg(t[e] / 255)) : t[e] = rg(t[e]);
                    return {
                        data: t,
                        width: e.width,
                        height: e.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                e
            }
        }
        let sg = 0;
        class lg {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                this.isSource = !0,
                Object.defineProperty(this, "id", {
                    value: sg++
                }),
                this.uuid = Lm(),
                this.data = e,
                this.version = 0
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            toJSON(e) {
                const t = void 0 === e || "string" === typeof e;
                if (!t && void 0 !== e.images[this.uuid])
                    return e.images[this.uuid];
                const n = {
                    uuid: this.uuid,
                    url: ""
                }
                  , r = this.data;
                if (null !== r) {
                    let e;
                    if (Array.isArray(r)) {
                        e = [];
                        for (let t = 0, n = r.length; t < n; t++)
                            r[t].isDataTexture ? e.push(cg(r[t].image)) : e.push(cg(r[t]))
                    } else
                        e = cg(r);
                    n.url = e
                }
                return t || (e.images[this.uuid] = n),
                n
            }
        }
        function cg(e) {
            return "undefined" !== typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && e instanceof ImageBitmap ? ag.getDataURL(e) : e.data ? {
                data: Array.from(e.data),
                width: e.width,
                height: e.height,
                type: e.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        let ug = 0;
        class dg extends Tm {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dg.DEFAULT_IMAGE
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : dg.DEFAULT_MAPPING
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : np
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : np
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : cp
                  , o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : hp
                  , a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : Mp
                  , s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : fp
                  , l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : dg.DEFAULT_ANISOTROPY
                  , c = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : Df;
                super(),
                this.isTexture = !0,
                Object.defineProperty(this, "id", {
                    value: ug++
                }),
                this.uuid = Lm(),
                this.name = "",
                this.source = new lg(e),
                this.mipmaps = [],
                this.mapping = t,
                this.channel = 0,
                this.wrapS = n,
                this.wrapT = r,
                this.magFilter = i,
                this.minFilter = o,
                this.anisotropy = l,
                this.format = a,
                this.internalFormat = null,
                this.type = s,
                this.offset = new Hm(0,0),
                this.repeat = new Hm(1,1),
                this.center = new Hm(0,0),
                this.rotation = 0,
                this.matrixAutoUpdate = !0,
                this.matrix = new jm,
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                "string" === typeof c ? this.colorSpace = c : (Qm("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace = c === Pf ? Of : Df),
                this.userData = {},
                this.version = 0,
                this.onUpdate = null,
                this.isRenderTargetTexture = !1,
                this.needsPMREMUpdate = !1
            }
            get image() {
                return this.source.data
            }
            set image(e) {
                void 0 === e && (e = null),
                this.source.data = e
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.name = e.name,
                this.source = e.source,
                this.mipmaps = e.mipmaps.slice(0),
                this.mapping = e.mapping,
                this.channel = e.channel,
                this.wrapS = e.wrapS,
                this.wrapT = e.wrapT,
                this.magFilter = e.magFilter,
                this.minFilter = e.minFilter,
                this.anisotropy = e.anisotropy,
                this.format = e.format,
                this.internalFormat = e.internalFormat,
                this.type = e.type,
                this.offset.copy(e.offset),
                this.repeat.copy(e.repeat),
                this.center.copy(e.center),
                this.rotation = e.rotation,
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this.matrix.copy(e.matrix),
                this.generateMipmaps = e.generateMipmaps,
                this.premultiplyAlpha = e.premultiplyAlpha,
                this.flipY = e.flipY,
                this.unpackAlignment = e.unpackAlignment,
                this.colorSpace = e.colorSpace,
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                this.needsUpdate = !0,
                this
            }
            toJSON(e) {
                const t = void 0 === e || "string" === typeof e;
                if (!t && void 0 !== e.textures[this.uuid])
                    return e.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(e).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                t || (e.textures[this.uuid] = n),
                n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(e) {
                if (this.mapping !== qh)
                    return e;
                if (e.applyMatrix3(this.matrix),
                e.x < 0 || e.x > 1)
                    switch (this.wrapS) {
                    case tp:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case np:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case rp:
                        1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                if (e.y < 0 || e.y > 1)
                    switch (this.wrapT) {
                    case tp:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case np:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case rp:
                        1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                return this.flipY && (e.y = 1 - e.y),
                e
            }
            set needsUpdate(e) {
                !0 === e && (this.version++,
                this.source.needsUpdate = !0)
            }
            get encoding() {
                return Qm("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace === Of ? Pf : Rf
            }
            set encoding(e) {
                Qm("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace = e === Pf ? Of : Df
            }
        }
        dg.DEFAULT_IMAGE = null,
        dg.DEFAULT_MAPPING = qh,
        dg.DEFAULT_ANISOTROPY = 1;
        class hg {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                hg.prototype.isVector4 = !0,
                this.x = e,
                this.y = t,
                this.z = n,
                this.w = r
            }
            get width() {
                return this.z
            }
            set width(e) {
                this.z = e
            }
            get height() {
                return this.w
            }
            set height(e) {
                this.w = e
            }
            set(e, t, n, r) {
                return this.x = e,
                this.y = t,
                this.z = n,
                this.w = r,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this.z = e,
                this.w = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setZ(e) {
                return this.z = e,
                this
            }
            setW(e) {
                return this.w = e,
                this
            }
            setComponent(e, t) {
                switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this.z = e.z,
                this.w = void 0 !== e.w ? e.w : 1,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this.z += e.z,
                this.w += e.w,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this.z += e,
                this.w += e,
                this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x,
                this.y = e.y + t.y,
                this.z = e.z + t.z,
                this.w = e.w + t.w,
                this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t,
                this.y += e.y * t,
                this.z += e.z * t,
                this.w += e.w * t,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this.z -= e.z,
                this.w -= e.w,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this.z -= e,
                this.w -= e,
                this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x,
                this.y = e.y - t.y,
                this.z = e.z - t.z,
                this.w = e.w - t.w,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this.z *= e.z,
                this.w *= e.w,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this.z *= e,
                this.w *= e,
                this
            }
            applyMatrix4(e) {
                const t = this.x
                  , n = this.y
                  , r = this.z
                  , i = this.w
                  , o = e.elements;
                return this.x = o[0] * t + o[4] * n + o[8] * r + o[12] * i,
                this.y = o[1] * t + o[5] * n + o[9] * r + o[13] * i,
                this.z = o[2] * t + o[6] * n + o[10] * r + o[14] * i,
                this.w = o[3] * t + o[7] * n + o[11] * r + o[15] * i,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            setAxisAngleFromQuaternion(e) {
                this.w = 2 * Math.acos(e.w);
                const t = Math.sqrt(1 - e.w * e.w);
                return t < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = e.x / t,
                this.y = e.y / t,
                this.z = e.z / t),
                this
            }
            setAxisAngleFromRotationMatrix(e) {
                let t, n, r, i;
                const o = .01
                  , a = .1
                  , s = e.elements
                  , l = s[0]
                  , c = s[4]
                  , u = s[8]
                  , d = s[1]
                  , h = s[5]
                  , p = s[9]
                  , f = s[2]
                  , m = s[6]
                  , g = s[10];
                if (Math.abs(c - d) < o && Math.abs(u - f) < o && Math.abs(p - m) < o) {
                    if (Math.abs(c + d) < a && Math.abs(u + f) < a && Math.abs(p + m) < a && Math.abs(l + h + g - 3) < a)
                        return this.set(1, 0, 0, 0),
                        this;
                    t = Math.PI;
                    const e = (l + 1) / 2
                      , s = (h + 1) / 2
                      , v = (g + 1) / 2
                      , y = (c + d) / 4
                      , b = (u + f) / 4
                      , _ = (p + m) / 4;
                    return e > s && e > v ? e < o ? (n = 0,
                    r = .707106781,
                    i = .707106781) : (n = Math.sqrt(e),
                    r = y / n,
                    i = b / n) : s > v ? s < o ? (n = .707106781,
                    r = 0,
                    i = .707106781) : (r = Math.sqrt(s),
                    n = y / r,
                    i = _ / r) : v < o ? (n = .707106781,
                    r = .707106781,
                    i = 0) : (i = Math.sqrt(v),
                    n = b / i,
                    r = _ / i),
                    this.set(n, r, i, t),
                    this
                }
                let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (d - c) * (d - c));
                return Math.abs(v) < .001 && (v = 1),
                this.x = (m - p) / v,
                this.y = (u - f) / v,
                this.z = (d - c) / v,
                this.w = Math.acos((l + h + g - 1) / 2),
                this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this.z = Math.min(this.z, e.z),
                this.w = Math.min(this.w, e.w),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this.z = Math.max(this.z, e.z),
                this.w = Math.max(this.w, e.w),
                this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                this.y = Math.max(e.y, Math.min(t.y, this.y)),
                this.z = Math.max(e.z, Math.min(t.z, this.z)),
                this.w = Math.max(e.w, Math.min(t.w, this.w)),
                this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)),
                this.y = Math.max(e, Math.min(t, this.y)),
                this.z = Math.max(e, Math.min(t, this.z)),
                this.w = Math.max(e, Math.min(t, this.w)),
                this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this.w = Math.trunc(this.w),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t,
                this.y += (e.y - this.y) * t,
                this.z += (e.z - this.z) * t,
                this.w += (e.w - this.w) * t,
                this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n,
                this.y = e.y + (t.y - e.y) * n,
                this.z = e.z + (t.z - e.z) * n,
                this.w = e.w + (t.w - e.w) * n,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.x = e[t],
                this.y = e[t + 1],
                this.z = e[t + 2],
                this.w = e[t + 3],
                this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this.x,
                e[t + 1] = this.y,
                e[t + 2] = this.z,
                e[t + 3] = this.w,
                e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t),
                this.y = e.getY(t),
                this.z = e.getZ(t),
                this.w = e.getW(t),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this.w = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z,
                yield this.w
            }
        }
        class pg extends Tm {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                super(),
                this.isRenderTarget = !0,
                this.width = e,
                this.height = t,
                this.depth = 1,
                this.scissor = new hg(0,0,e,t),
                this.scissorTest = !1,
                this.viewport = new hg(0,0,e,t);
                const r = {
                    width: e,
                    height: t,
                    depth: 1
                };
                void 0 !== n.encoding && (Qm("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),
                n.colorSpace = n.encoding === Pf ? Of : Df),
                n = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: cp,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    depthTexture: null,
                    samples: 0
                }, n),
                this.texture = new dg(r,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace),
                this.texture.isRenderTargetTexture = !0,
                this.texture.flipY = !1,
                this.texture.generateMipmaps = n.generateMipmaps,
                this.texture.internalFormat = n.internalFormat,
                this.depthBuffer = n.depthBuffer,
                this.stencilBuffer = n.stencilBuffer,
                this.depthTexture = n.depthTexture,
                this.samples = n.samples
            }
            setSize(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                this.width === e && this.height === t && this.depth === n || (this.width = e,
                this.height = t,
                this.depth = n,
                this.texture.image.width = e,
                this.texture.image.height = t,
                this.texture.image.depth = n,
                this.dispose()),
                this.viewport.set(0, 0, e, t),
                this.scissor.set(0, 0, e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.width = e.width,
                this.height = e.height,
                this.depth = e.depth,
                this.scissor.copy(e.scissor),
                this.scissorTest = e.scissorTest,
                this.viewport.copy(e.viewport),
                this.texture = e.texture.clone(),
                this.texture.isRenderTargetTexture = !0;
                const t = Object.assign({}, e.texture.image);
                return this.texture.source = new lg(t),
                this.depthBuffer = e.depthBuffer,
                this.stencilBuffer = e.stencilBuffer,
                null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
                this.samples = e.samples,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class fg extends pg {
            constructor() {
                super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}),
                this.isWebGLRenderTarget = !0
            }
        }
        class mg extends dg {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                super(null),
                this.isDataArrayTexture = !0,
                this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: r
                },
                this.magFilter = ip,
                this.minFilter = ip,
                this.wrapR = np,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class gg extends fg {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                super(e, t, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}),
                this.isWebGLArrayRenderTarget = !0,
                this.depth = n,
                this.texture = new mg(null,e,t,n),
                this.texture.isRenderTargetTexture = !0
            }
        }
        class vg extends dg {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                super(null),
                this.isData3DTexture = !0,
                this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: r
                },
                this.magFilter = ip,
                this.minFilter = ip,
                this.wrapR = np,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class yg extends fg {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                super(e, t, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}),
                this.isWebGL3DRenderTarget = !0,
                this.depth = n,
                this.texture = new vg(null,e,t,n),
                this.texture.isRenderTargetTexture = !0
            }
        }
        class bg extends fg {
            constructor() {
                let e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}),
                this.isWebGLMultipleRenderTargets = !0;
                const t = this.texture;
                this.texture = [];
                for (let n = 0; n < e; n++)
                    this.texture[n] = t.clone(),
                    this.texture[n].isRenderTargetTexture = !0
            }
            setSize(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                if (this.width !== e || this.height !== t || this.depth !== n) {
                    this.width = e,
                    this.height = t,
                    this.depth = n;
                    for (let r = 0, i = this.texture.length; r < i; r++)
                        this.texture[r].image.width = e,
                        this.texture[r].image.height = t,
                        this.texture[r].image.depth = n;
                    this.dispose()
                }
                this.viewport.set(0, 0, e, t),
                this.scissor.set(0, 0, e, t)
            }
            copy(e) {
                this.dispose(),
                this.width = e.width,
                this.height = e.height,
                this.depth = e.depth,
                this.scissor.copy(e.scissor),
                this.scissorTest = e.scissorTest,
                this.viewport.copy(e.viewport),
                this.depthBuffer = e.depthBuffer,
                this.stencilBuffer = e.stencilBuffer,
                null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
                this.texture.length = 0;
                for (let t = 0, n = e.texture.length; t < n; t++)
                    this.texture[t] = e.texture[t].clone(),
                    this.texture[t].isRenderTargetTexture = !0;
                return this
            }
        }
        class _g {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                this.isQuaternion = !0,
                this._x = e,
                this._y = t,
                this._z = n,
                this._w = r
            }
            static slerpFlat(e, t, n, r, i, o, a) {
                let s = n[r + 0]
                  , l = n[r + 1]
                  , c = n[r + 2]
                  , u = n[r + 3];
                const d = i[o + 0]
                  , h = i[o + 1]
                  , p = i[o + 2]
                  , f = i[o + 3];
                if (0 === a)
                    return e[t + 0] = s,
                    e[t + 1] = l,
                    e[t + 2] = c,
                    void (e[t + 3] = u);
                if (1 === a)
                    return e[t + 0] = d,
                    e[t + 1] = h,
                    e[t + 2] = p,
                    void (e[t + 3] = f);
                if (u !== f || s !== d || l !== h || c !== p) {
                    let e = 1 - a;
                    const t = s * d + l * h + c * p + u * f
                      , n = t >= 0 ? 1 : -1
                      , r = 1 - t * t;
                    if (r > Number.EPSILON) {
                        const i = Math.sqrt(r)
                          , o = Math.atan2(i, t * n);
                        e = Math.sin(e * o) / i,
                        a = Math.sin(a * o) / i
                    }
                    const i = a * n;
                    if (s = s * e + d * i,
                    l = l * e + h * i,
                    c = c * e + p * i,
                    u = u * e + f * i,
                    e === 1 - a) {
                        const e = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
                        s *= e,
                        l *= e,
                        c *= e,
                        u *= e
                    }
                }
                e[t] = s,
                e[t + 1] = l,
                e[t + 2] = c,
                e[t + 3] = u
            }
            static multiplyQuaternionsFlat(e, t, n, r, i, o) {
                const a = n[r]
                  , s = n[r + 1]
                  , l = n[r + 2]
                  , c = n[r + 3]
                  , u = i[o]
                  , d = i[o + 1]
                  , h = i[o + 2]
                  , p = i[o + 3];
                return e[t] = a * p + c * u + s * h - l * d,
                e[t + 1] = s * p + c * d + l * u - a * h,
                e[t + 2] = l * p + c * h + a * d - s * u,
                e[t + 3] = c * p - a * u - s * d - l * h,
                e
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e,
                this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(e) {
                this._w = e,
                this._onChangeCallback()
            }
            set(e, t, n, r) {
                return this._x = e,
                this._y = t,
                this._z = n,
                this._w = r,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(e) {
                return this._x = e.x,
                this._y = e.y,
                this._z = e.z,
                this._w = e.w,
                this._onChangeCallback(),
                this
            }
            setFromEuler(e, t) {
                const n = e._x
                  , r = e._y
                  , i = e._z
                  , o = e._order
                  , a = Math.cos
                  , s = Math.sin
                  , l = a(n / 2)
                  , c = a(r / 2)
                  , u = a(i / 2)
                  , d = s(n / 2)
                  , h = s(r / 2)
                  , p = s(i / 2);
                switch (o) {
                case "XYZ":
                    this._x = d * c * u + l * h * p,
                    this._y = l * h * u - d * c * p,
                    this._z = l * c * p + d * h * u,
                    this._w = l * c * u - d * h * p;
                    break;
                case "YXZ":
                    this._x = d * c * u + l * h * p,
                    this._y = l * h * u - d * c * p,
                    this._z = l * c * p - d * h * u,
                    this._w = l * c * u + d * h * p;
                    break;
                case "ZXY":
                    this._x = d * c * u - l * h * p,
                    this._y = l * h * u + d * c * p,
                    this._z = l * c * p + d * h * u,
                    this._w = l * c * u - d * h * p;
                    break;
                case "ZYX":
                    this._x = d * c * u - l * h * p,
                    this._y = l * h * u + d * c * p,
                    this._z = l * c * p - d * h * u,
                    this._w = l * c * u + d * h * p;
                    break;
                case "YZX":
                    this._x = d * c * u + l * h * p,
                    this._y = l * h * u + d * c * p,
                    this._z = l * c * p - d * h * u,
                    this._w = l * c * u - d * h * p;
                    break;
                case "XZY":
                    this._x = d * c * u - l * h * p,
                    this._y = l * h * u - d * c * p,
                    this._z = l * c * p + d * h * u,
                    this._w = l * c * u + d * h * p;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
                }
                return !1 !== t && this._onChangeCallback(),
                this
            }
            setFromAxisAngle(e, t) {
                const n = t / 2
                  , r = Math.sin(n);
                return this._x = e.x * r,
                this._y = e.y * r,
                this._z = e.z * r,
                this._w = Math.cos(n),
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(e) {
                const t = e.elements
                  , n = t[0]
                  , r = t[4]
                  , i = t[8]
                  , o = t[1]
                  , a = t[5]
                  , s = t[9]
                  , l = t[2]
                  , c = t[6]
                  , u = t[10]
                  , d = n + a + u;
                if (d > 0) {
                    const e = .5 / Math.sqrt(d + 1);
                    this._w = .25 / e,
                    this._x = (c - s) * e,
                    this._y = (i - l) * e,
                    this._z = (o - r) * e
                } else if (n > a && n > u) {
                    const e = 2 * Math.sqrt(1 + n - a - u);
                    this._w = (c - s) / e,
                    this._x = .25 * e,
                    this._y = (r + o) / e,
                    this._z = (i + l) / e
                } else if (a > u) {
                    const e = 2 * Math.sqrt(1 + a - n - u);
                    this._w = (i - l) / e,
                    this._x = (r + o) / e,
                    this._y = .25 * e,
                    this._z = (s + c) / e
                } else {
                    const e = 2 * Math.sqrt(1 + u - n - a);
                    this._w = (o - r) / e,
                    this._x = (i + l) / e,
                    this._y = (s + c) / e,
                    this._z = .25 * e
                }
                return this._onChangeCallback(),
                this
            }
            setFromUnitVectors(e, t) {
                let n = e.dot(t) + 1;
                return n < Number.EPSILON ? (n = 0,
                Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
                this._y = e.x,
                this._z = 0,
                this._w = n) : (this._x = 0,
                this._y = -e.z,
                this._z = e.y,
                this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
                this._y = e.z * t.x - e.x * t.z,
                this._z = e.x * t.y - e.y * t.x,
                this._w = n),
                this.normalize()
            }
            angleTo(e) {
                return 2 * Math.acos(Math.abs(km(this.dot(e), -1, 1)))
            }
            rotateTowards(e, t) {
                const n = this.angleTo(e);
                if (0 === n)
                    return this;
                const r = Math.min(1, t / n);
                return this.slerp(e, r),
                this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._onChangeCallback(),
                this
            }
            dot(e) {
                return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let e = this.length();
                return 0 === e ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (e = 1 / e,
                this._x = this._x * e,
                this._y = this._y * e,
                this._z = this._z * e,
                this._w = this._w * e),
                this._onChangeCallback(),
                this
            }
            multiply(e) {
                return this.multiplyQuaternions(this, e)
            }
            premultiply(e) {
                return this.multiplyQuaternions(e, this)
            }
            multiplyQuaternions(e, t) {
                const n = e._x
                  , r = e._y
                  , i = e._z
                  , o = e._w
                  , a = t._x
                  , s = t._y
                  , l = t._z
                  , c = t._w;
                return this._x = n * c + o * a + r * l - i * s,
                this._y = r * c + o * s + i * a - n * l,
                this._z = i * c + o * l + n * s - r * a,
                this._w = o * c - n * a - r * s - i * l,
                this._onChangeCallback(),
                this
            }
            slerp(e, t) {
                if (0 === t)
                    return this;
                if (1 === t)
                    return this.copy(e);
                const n = this._x
                  , r = this._y
                  , i = this._z
                  , o = this._w;
                let a = o * e._w + n * e._x + r * e._y + i * e._z;
                if (a < 0 ? (this._w = -e._w,
                this._x = -e._x,
                this._y = -e._y,
                this._z = -e._z,
                a = -a) : this.copy(e),
                a >= 1)
                    return this._w = o,
                    this._x = n,
                    this._y = r,
                    this._z = i,
                    this;
                const s = 1 - a * a;
                if (s <= Number.EPSILON) {
                    const e = 1 - t;
                    return this._w = e * o + t * this._w,
                    this._x = e * n + t * this._x,
                    this._y = e * r + t * this._y,
                    this._z = e * i + t * this._z,
                    this.normalize(),
                    this._onChangeCallback(),
                    this
                }
                const l = Math.sqrt(s)
                  , c = Math.atan2(l, a)
                  , u = Math.sin((1 - t) * c) / l
                  , d = Math.sin(t * c) / l;
                return this._w = o * u + this._w * d,
                this._x = n * u + this._x * d,
                this._y = r * u + this._y * d,
                this._z = i * u + this._z * d,
                this._onChangeCallback(),
                this
            }
            slerpQuaternions(e, t, n) {
                return this.copy(e).slerp(t, n)
            }
            random() {
                const e = Math.random()
                  , t = Math.sqrt(1 - e)
                  , n = Math.sqrt(e)
                  , r = 2 * Math.PI * Math.random()
                  , i = 2 * Math.PI * Math.random();
                return this.set(t * Math.cos(r), n * Math.sin(i), n * Math.cos(i), t * Math.sin(r))
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this._x = e[t],
                this._y = e[t + 1],
                this._z = e[t + 2],
                this._w = e[t + 3],
                this._onChangeCallback(),
                this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this._x,
                e[t + 1] = this._y,
                e[t + 2] = this._z,
                e[t + 3] = this._w,
                e
            }
            fromBufferAttribute(e, t) {
                return this._x = e.getX(t),
                this._y = e.getY(t),
                this._z = e.getZ(t),
                this._w = e.getW(t),
                this
            }
            toJSON() {
                return this.toArray()
            }
            _onChange(e) {
                return this._onChangeCallback = e,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._w
            }
        }
        class Ag {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                Ag.prototype.isVector3 = !0,
                this.x = e,
                this.y = t,
                this.z = n
            }
            set(e, t, n) {
                return void 0 === n && (n = this.z),
                this.x = e,
                this.y = t,
                this.z = n,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this.z = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setZ(e) {
                return this.z = e,
                this
            }
            setComponent(e, t) {
                switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this.z = e.z,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this.z += e.z,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this.z += e,
                this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x,
                this.y = e.y + t.y,
                this.z = e.z + t.z,
                this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t,
                this.y += e.y * t,
                this.z += e.z * t,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this.z -= e.z,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this.z -= e,
                this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x,
                this.y = e.y - t.y,
                this.z = e.z - t.z,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this.z *= e.z,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this.z *= e,
                this
            }
            multiplyVectors(e, t) {
                return this.x = e.x * t.x,
                this.y = e.y * t.y,
                this.z = e.z * t.z,
                this
            }
            applyEuler(e) {
                return this.applyQuaternion(Sg.setFromEuler(e))
            }
            applyAxisAngle(e, t) {
                return this.applyQuaternion(Sg.setFromAxisAngle(e, t))
            }
            applyMatrix3(e) {
                const t = this.x
                  , n = this.y
                  , r = this.z
                  , i = e.elements;
                return this.x = i[0] * t + i[3] * n + i[6] * r,
                this.y = i[1] * t + i[4] * n + i[7] * r,
                this.z = i[2] * t + i[5] * n + i[8] * r,
                this
            }
            applyNormalMatrix(e) {
                return this.applyMatrix3(e).normalize()
            }
            applyMatrix4(e) {
                const t = this.x
                  , n = this.y
                  , r = this.z
                  , i = e.elements
                  , o = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * o,
                this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * o,
                this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * o,
                this
            }
            applyQuaternion(e) {
                const t = this.x
                  , n = this.y
                  , r = this.z
                  , i = e.x
                  , o = e.y
                  , a = e.z
                  , s = e.w
                  , l = 2 * (o * r - a * n)
                  , c = 2 * (a * t - i * r)
                  , u = 2 * (i * n - o * t);
                return this.x = t + s * l + o * u - a * c,
                this.y = n + s * c + a * l - i * u,
                this.z = r + s * u + i * c - o * l,
                this
            }
            project(e) {
                return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
            }
            unproject(e) {
                return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
            }
            transformDirection(e) {
                const t = this.x
                  , n = this.y
                  , r = this.z
                  , i = e.elements;
                return this.x = i[0] * t + i[4] * n + i[8] * r,
                this.y = i[1] * t + i[5] * n + i[9] * r,
                this.z = i[2] * t + i[6] * n + i[10] * r,
                this.normalize()
            }
            divide(e) {
                return this.x /= e.x,
                this.y /= e.y,
                this.z /= e.z,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this.z = Math.min(this.z, e.z),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this.z = Math.max(this.z, e.z),
                this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                this.y = Math.max(e.y, Math.min(t.y, this.y)),
                this.z = Math.max(e.z, Math.min(t.z, this.z)),
                this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)),
                this.y = Math.max(e, Math.min(t, this.y)),
                this.z = Math.max(e, Math.min(t, this.z)),
                this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t,
                this.y += (e.y - this.y) * t,
                this.z += (e.z - this.z) * t,
                this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n,
                this.y = e.y + (t.y - e.y) * n,
                this.z = e.z + (t.z - e.z) * n,
                this
            }
            cross(e) {
                return this.crossVectors(this, e)
            }
            crossVectors(e, t) {
                const n = e.x
                  , r = e.y
                  , i = e.z
                  , o = t.x
                  , a = t.y
                  , s = t.z;
                return this.x = r * s - i * a,
                this.y = i * o - n * s,
                this.z = n * a - r * o,
                this
            }
            projectOnVector(e) {
                const t = e.lengthSq();
                if (0 === t)
                    return this.set(0, 0, 0);
                const n = e.dot(this) / t;
                return this.copy(e).multiplyScalar(n)
            }
            projectOnPlane(e) {
                return xg.copy(this).projectOnVector(e),
                this.sub(xg)
            }
            reflect(e) {
                return this.sub(xg.copy(e).multiplyScalar(2 * this.dot(e)))
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t)
                    return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(km(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x
                  , n = this.y - e.y
                  , r = this.z - e.z;
                return t * t + n * n + r * r
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
            }
            setFromSpherical(e) {
                return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
            }
            setFromSphericalCoords(e, t, n) {
                const r = Math.sin(t) * e;
                return this.x = r * Math.sin(n),
                this.y = Math.cos(t) * e,
                this.z = r * Math.cos(n),
                this
            }
            setFromCylindrical(e) {
                return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
            }
            setFromCylindricalCoords(e, t, n) {
                return this.x = e * Math.sin(t),
                this.y = n,
                this.z = e * Math.cos(t),
                this
            }
            setFromMatrixPosition(e) {
                const t = e.elements;
                return this.x = t[12],
                this.y = t[13],
                this.z = t[14],
                this
            }
            setFromMatrixScale(e) {
                const t = this.setFromMatrixColumn(e, 0).length()
                  , n = this.setFromMatrixColumn(e, 1).length()
                  , r = this.setFromMatrixColumn(e, 2).length();
                return this.x = t,
                this.y = n,
                this.z = r,
                this
            }
            setFromMatrixColumn(e, t) {
                return this.fromArray(e.elements, 4 * t)
            }
            setFromMatrix3Column(e, t) {
                return this.fromArray(e.elements, 3 * t)
            }
            setFromEuler(e) {
                return this.x = e._x,
                this.y = e._y,
                this.z = e._z,
                this
            }
            setFromColor(e) {
                return this.x = e.r,
                this.y = e.g,
                this.z = e.b,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.x = e[t],
                this.y = e[t + 1],
                this.z = e[t + 2],
                this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this.x,
                e[t + 1] = this.y,
                e[t + 2] = this.z,
                e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t),
                this.y = e.getY(t),
                this.z = e.getZ(t),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this
            }
            randomDirection() {
                const e = 2 * (Math.random() - .5)
                  , t = Math.random() * Math.PI * 2
                  , n = Math.sqrt(1 - e ** 2);
                return this.x = n * Math.cos(t),
                this.y = n * Math.sin(t),
                this.z = e,
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z
            }
        }
        const xg = new Ag
          , Sg = new _g;
        class wg {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Ag(1 / 0,1 / 0,1 / 0)
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ag(-1 / 0,-1 / 0,-1 / 0);
                this.isBox3 = !0,
                this.min = e,
                this.max = t
            }
            set(e, t) {
                return this.min.copy(e),
                this.max.copy(t),
                this
            }
            setFromArray(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t += 3)
                    this.expandByPoint(Mg.fromArray(e, t));
                return this
            }
            setFromBufferAttribute(e) {
                this.makeEmpty();
                for (let t = 0, n = e.count; t < n; t++)
                    this.expandByPoint(Mg.fromBufferAttribute(e, t));
                return this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t++)
                    this.expandByPoint(e[t]);
                return this
            }
            setFromCenterAndSize(e, t) {
                const n = Mg.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n),
                this.max.copy(e).add(n),
                this
            }
            setFromObject(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                return this.makeEmpty(),
                this.expandByObject(e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.min.copy(e.min),
                this.max.copy(e.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e),
                this.max.max(e),
                this
            }
            expandByVector(e) {
                return this.min.sub(e),
                this.max.add(e),
                this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e),
                this.max.addScalar(e),
                this
            }
            expandByObject(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                e.updateWorldMatrix(!1, !1);
                const n = e.geometry;
                if (void 0 !== n) {
                    const r = n.getAttribute("position");
                    if (!0 === t && void 0 !== r && !0 !== e.isInstancedMesh)
                        for (let t = 0, n = r.count; t < n; t++)
                            !0 === e.isMesh ? e.getVertexPosition(t, Mg) : Mg.fromBufferAttribute(r, t),
                            Mg.applyMatrix4(e.matrixWorld),
                            this.expandByPoint(Mg);
                    else
                        void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(),
                        Cg.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(),
                        Cg.copy(n.boundingBox)),
                        Cg.applyMatrix4(e.matrixWorld),
                        this.union(Cg)
                }
                const r = e.children;
                for (let i = 0, o = r.length; i < o; i++)
                    this.expandByObject(r[i], t);
                return this
            }
            containsPoint(e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
            }
            getParameter(e, t) {
                return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
            }
            intersectsSphere(e) {
                return this.clampPoint(e.center, Mg),
                Mg.distanceToSquared(e.center) <= e.radius * e.radius
            }
            intersectsPlane(e) {
                let t, n;
                return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
                n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
                n = e.normal.x * this.min.x),
                e.normal.y > 0 ? (t += e.normal.y * this.min.y,
                n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
                n += e.normal.y * this.min.y),
                e.normal.z > 0 ? (t += e.normal.z * this.min.z,
                n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
                n += e.normal.z * this.min.z),
                t <= -e.constant && n >= -e.constant
            }
            intersectsTriangle(e) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(kg),
                Dg.subVectors(this.max, kg),
                Tg.subVectors(e.a, kg),
                Rg.subVectors(e.b, kg),
                Pg.subVectors(e.c, kg),
                Bg.subVectors(Rg, Tg),
                Ig.subVectors(Pg, Rg),
                Lg.subVectors(Tg, Pg);
                let t = [0, -Bg.z, Bg.y, 0, -Ig.z, Ig.y, 0, -Lg.z, Lg.y, Bg.z, 0, -Bg.x, Ig.z, 0, -Ig.x, Lg.z, 0, -Lg.x, -Bg.y, Bg.x, 0, -Ig.y, Ig.x, 0, -Lg.y, Lg.x, 0];
                return !!Fg(t, Tg, Rg, Pg, Dg) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !!Fg(t, Tg, Rg, Pg, Dg) && (Og.crossVectors(Bg, Ig),
                t = [Og.x, Og.y, Og.z],
                Fg(t, Tg, Rg, Pg, Dg)))
            }
            clampPoint(e, t) {
                return t.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return this.clampPoint(e, Mg).distanceTo(e)
            }
            getBoundingSphere(e) {
                return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
                e.radius = .5 * this.getSize(Mg).length()),
                e
            }
            intersect(e) {
                return this.min.max(e.min),
                this.max.min(e.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(e) {
                return this.min.min(e.min),
                this.max.max(e.max),
                this
            }
            applyMatrix4(e) {
                return this.isEmpty() || (Eg[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                Eg[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                Eg[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                Eg[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                Eg[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                Eg[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                Eg[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                Eg[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                this.setFromPoints(Eg)),
                this
            }
            translate(e) {
                return this.min.add(e),
                this.max.add(e),
                this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        const Eg = [new Ag, new Ag, new Ag, new Ag, new Ag, new Ag, new Ag, new Ag]
          , Mg = new Ag
          , Cg = new wg
          , Tg = new Ag
          , Rg = new Ag
          , Pg = new Ag
          , Bg = new Ag
          , Ig = new Ag
          , Lg = new Ag
          , kg = new Ag
          , Dg = new Ag
          , Og = new Ag
          , Ng = new Ag;
        function Fg(e, t, n, r, i) {
            for (let o = 0, a = e.length - 3; o <= a; o += 3) {
                Ng.fromArray(e, o);
                const a = i.x * Math.abs(Ng.x) + i.y * Math.abs(Ng.y) + i.z * Math.abs(Ng.z)
                  , s = t.dot(Ng)
                  , l = n.dot(Ng)
                  , c = r.dot(Ng);
                if (Math.max(-Math.max(s, l, c), Math.min(s, l, c)) > a)
                    return !1
            }
            return !0
        }
        const Ug = new wg
          , zg = new Ag
          , Gg = new Ag;
        class Hg {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Ag
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
                this.center = e,
                this.radius = t
            }
            set(e, t) {
                return this.center.copy(e),
                this.radius = t,
                this
            }
            setFromPoints(e, t) {
                const n = this.center;
                void 0 !== t ? n.copy(t) : Ug.setFromPoints(e).getCenter(n);
                let r = 0;
                for (let i = 0, o = e.length; i < o; i++)
                    r = Math.max(r, n.distanceToSquared(e[i]));
                return this.radius = Math.sqrt(r),
                this
            }
            copy(e) {
                return this.center.copy(e.center),
                this.radius = e.radius,
                this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                this.radius = -1,
                this
            }
            containsPoint(e) {
                return e.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(e) {
                return e.distanceTo(this.center) - this.radius
            }
            intersectsSphere(e) {
                const t = this.radius + e.radius;
                return e.center.distanceToSquared(this.center) <= t * t
            }
            intersectsBox(e) {
                return e.intersectsSphere(this)
            }
            intersectsPlane(e) {
                return Math.abs(e.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(e, t) {
                const n = this.center.distanceToSquared(e);
                return t.copy(e),
                n > this.radius * this.radius && (t.sub(this.center).normalize(),
                t.multiplyScalar(this.radius).add(this.center)),
                t
            }
            getBoundingBox(e) {
                return this.isEmpty() ? (e.makeEmpty(),
                e) : (e.set(this.center, this.center),
                e.expandByScalar(this.radius),
                e)
            }
            applyMatrix4(e) {
                return this.center.applyMatrix4(e),
                this.radius = this.radius * e.getMaxScaleOnAxis(),
                this
            }
            translate(e) {
                return this.center.add(e),
                this
            }
            expandByPoint(e) {
                if (this.isEmpty())
                    return this.center.copy(e),
                    this.radius = 0,
                    this;
                zg.subVectors(e, this.center);
                const t = zg.lengthSq();
                if (t > this.radius * this.radius) {
                    const e = Math.sqrt(t)
                      , n = .5 * (e - this.radius);
                    this.center.addScaledVector(zg, n / e),
                    this.radius += n
                }
                return this
            }
            union(e) {
                return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
                this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (Gg.subVectors(e.center, this.center).setLength(e.radius),
                this.expandByPoint(zg.copy(e.center).add(Gg)),
                this.expandByPoint(zg.copy(e.center).sub(Gg))),
                this)
            }
            equals(e) {
                return e.center.equals(this.center) && e.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const jg = new Ag
          , Wg = new Ag
          , Vg = new Ag
          , Xg = new Ag
          , Jg = new Ag
          , Kg = new Ag
          , qg = new Ag;
        class Yg {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Ag
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ag(0,0,-1);
                this.origin = e,
                this.direction = t
            }
            set(e, t) {
                return this.origin.copy(e),
                this.direction.copy(t),
                this
            }
            copy(e) {
                return this.origin.copy(e.origin),
                this.direction.copy(e.direction),
                this
            }
            at(e, t) {
                return t.copy(this.origin).addScaledVector(this.direction, e)
            }
            lookAt(e) {
                return this.direction.copy(e).sub(this.origin).normalize(),
                this
            }
            recast(e) {
                return this.origin.copy(this.at(e, jg)),
                this
            }
            closestPointToPoint(e, t) {
                t.subVectors(e, this.origin);
                const n = t.dot(this.direction);
                return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
            }
            distanceToPoint(e) {
                return Math.sqrt(this.distanceSqToPoint(e))
            }
            distanceSqToPoint(e) {
                const t = jg.subVectors(e, this.origin).dot(this.direction);
                return t < 0 ? this.origin.distanceToSquared(e) : (jg.copy(this.origin).addScaledVector(this.direction, t),
                jg.distanceToSquared(e))
            }
            distanceSqToSegment(e, t, n, r) {
                Wg.copy(e).add(t).multiplyScalar(.5),
                Vg.copy(t).sub(e).normalize(),
                Xg.copy(this.origin).sub(Wg);
                const i = .5 * e.distanceTo(t)
                  , o = -this.direction.dot(Vg)
                  , a = Xg.dot(this.direction)
                  , s = -Xg.dot(Vg)
                  , l = Xg.lengthSq()
                  , c = Math.abs(1 - o * o);
                let u, d, h, p;
                if (c > 0)
                    if (u = o * s - a,
                    d = o * a - s,
                    p = i * c,
                    u >= 0)
                        if (d >= -p)
                            if (d <= p) {
                                const e = 1 / c;
                                u *= e,
                                d *= e,
                                h = u * (u + o * d + 2 * a) + d * (o * u + d + 2 * s) + l
                            } else
                                d = i,
                                u = Math.max(0, -(o * d + a)),
                                h = -u * u + d * (d + 2 * s) + l;
                        else
                            d = -i,
                            u = Math.max(0, -(o * d + a)),
                            h = -u * u + d * (d + 2 * s) + l;
                    else
                        d <= -p ? (u = Math.max(0, -(-o * i + a)),
                        d = u > 0 ? -i : Math.min(Math.max(-i, -s), i),
                        h = -u * u + d * (d + 2 * s) + l) : d <= p ? (u = 0,
                        d = Math.min(Math.max(-i, -s), i),
                        h = d * (d + 2 * s) + l) : (u = Math.max(0, -(o * i + a)),
                        d = u > 0 ? i : Math.min(Math.max(-i, -s), i),
                        h = -u * u + d * (d + 2 * s) + l);
                else
                    d = o > 0 ? -i : i,
                    u = Math.max(0, -(o * d + a)),
                    h = -u * u + d * (d + 2 * s) + l;
                return n && n.copy(this.origin).addScaledVector(this.direction, u),
                r && r.copy(Wg).addScaledVector(Vg, d),
                h
            }
            intersectSphere(e, t) {
                jg.subVectors(e.center, this.origin);
                const n = jg.dot(this.direction)
                  , r = jg.dot(jg) - n * n
                  , i = e.radius * e.radius;
                if (r > i)
                    return null;
                const o = Math.sqrt(i - r)
                  , a = n - o
                  , s = n + o;
                return s < 0 ? null : a < 0 ? this.at(s, t) : this.at(a, t)
            }
            intersectsSphere(e) {
                return this.distanceSqToPoint(e.center) <= e.radius * e.radius
            }
            distanceToPlane(e) {
                const t = e.normal.dot(this.direction);
                if (0 === t)
                    return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(e.normal) + e.constant) / t;
                return n >= 0 ? n : null
            }
            intersectPlane(e, t) {
                const n = this.distanceToPlane(e);
                return null === n ? null : this.at(n, t)
            }
            intersectsPlane(e) {
                const t = e.distanceToPoint(this.origin);
                if (0 === t)
                    return !0;
                return e.normal.dot(this.direction) * t < 0
            }
            intersectBox(e, t) {
                let n, r, i, o, a, s;
                const l = 1 / this.direction.x
                  , c = 1 / this.direction.y
                  , u = 1 / this.direction.z
                  , d = this.origin;
                return l >= 0 ? (n = (e.min.x - d.x) * l,
                r = (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l,
                r = (e.min.x - d.x) * l),
                c >= 0 ? (i = (e.min.y - d.y) * c,
                o = (e.max.y - d.y) * c) : (i = (e.max.y - d.y) * c,
                o = (e.min.y - d.y) * c),
                n > o || i > r ? null : ((i > n || isNaN(n)) && (n = i),
                (o < r || isNaN(r)) && (r = o),
                u >= 0 ? (a = (e.min.z - d.z) * u,
                s = (e.max.z - d.z) * u) : (a = (e.max.z - d.z) * u,
                s = (e.min.z - d.z) * u),
                n > s || a > r ? null : ((a > n || n !== n) && (n = a),
                (s < r || r !== r) && (r = s),
                r < 0 ? null : this.at(n >= 0 ? n : r, t)))
            }
            intersectsBox(e) {
                return null !== this.intersectBox(e, jg)
            }
            intersectTriangle(e, t, n, r, i) {
                Jg.subVectors(t, e),
                Kg.subVectors(n, e),
                qg.crossVectors(Jg, Kg);
                let o, a = this.direction.dot(qg);
                if (a > 0) {
                    if (r)
                        return null;
                    o = 1
                } else {
                    if (!(a < 0))
                        return null;
                    o = -1,
                    a = -a
                }
                Xg.subVectors(this.origin, e);
                const s = o * this.direction.dot(Kg.crossVectors(Xg, Kg));
                if (s < 0)
                    return null;
                const l = o * this.direction.dot(Jg.cross(Xg));
                if (l < 0)
                    return null;
                if (s + l > a)
                    return null;
                const c = -o * Xg.dot(qg);
                return c < 0 ? null : this.at(c / a, i)
            }
            applyMatrix4(e) {
                return this.origin.applyMatrix4(e),
                this.direction.transformDirection(e),
                this
            }
            equals(e) {
                return e.origin.equals(this.origin) && e.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Qg {
            constructor(e, t, n, r, i, o, a, s, l, c, u, d, h, p, f, m) {
                Qg.prototype.isMatrix4 = !0,
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                void 0 !== e && this.set(e, t, n, r, i, o, a, s, l, c, u, d, h, p, f, m)
            }
            set(e, t, n, r, i, o, a, s, l, c, u, d, h, p, f, m) {
                const g = this.elements;
                return g[0] = e,
                g[4] = t,
                g[8] = n,
                g[12] = r,
                g[1] = i,
                g[5] = o,
                g[9] = a,
                g[13] = s,
                g[2] = l,
                g[6] = c,
                g[10] = u,
                g[14] = d,
                g[3] = h,
                g[7] = p,
                g[11] = f,
                g[15] = m,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            clone() {
                return (new Qg).fromArray(this.elements)
            }
            copy(e) {
                const t = this.elements
                  , n = e.elements;
                return t[0] = n[0],
                t[1] = n[1],
                t[2] = n[2],
                t[3] = n[3],
                t[4] = n[4],
                t[5] = n[5],
                t[6] = n[6],
                t[7] = n[7],
                t[8] = n[8],
                t[9] = n[9],
                t[10] = n[10],
                t[11] = n[11],
                t[12] = n[12],
                t[13] = n[13],
                t[14] = n[14],
                t[15] = n[15],
                this
            }
            copyPosition(e) {
                const t = this.elements
                  , n = e.elements;
                return t[12] = n[12],
                t[13] = n[13],
                t[14] = n[14],
                this
            }
            setFromMatrix3(e) {
                const t = e.elements;
                return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
                this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrixColumn(this, 0),
                t.setFromMatrixColumn(this, 1),
                n.setFromMatrixColumn(this, 2),
                this
            }
            makeBasis(e, t, n) {
                return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
                this
            }
            extractRotation(e) {
                const t = this.elements
                  , n = e.elements
                  , r = 1 / Zg.setFromMatrixColumn(e, 0).length()
                  , i = 1 / Zg.setFromMatrixColumn(e, 1).length()
                  , o = 1 / Zg.setFromMatrixColumn(e, 2).length();
                return t[0] = n[0] * r,
                t[1] = n[1] * r,
                t[2] = n[2] * r,
                t[3] = 0,
                t[4] = n[4] * i,
                t[5] = n[5] * i,
                t[6] = n[6] * i,
                t[7] = 0,
                t[8] = n[8] * o,
                t[9] = n[9] * o,
                t[10] = n[10] * o,
                t[11] = 0,
                t[12] = 0,
                t[13] = 0,
                t[14] = 0,
                t[15] = 1,
                this
            }
            makeRotationFromEuler(e) {
                const t = this.elements
                  , n = e.x
                  , r = e.y
                  , i = e.z
                  , o = Math.cos(n)
                  , a = Math.sin(n)
                  , s = Math.cos(r)
                  , l = Math.sin(r)
                  , c = Math.cos(i)
                  , u = Math.sin(i);
                if ("XYZ" === e.order) {
                    const e = o * c
                      , n = o * u
                      , r = a * c
                      , i = a * u;
                    t[0] = s * c,
                    t[4] = -s * u,
                    t[8] = l,
                    t[1] = n + r * l,
                    t[5] = e - i * l,
                    t[9] = -a * s,
                    t[2] = i - e * l,
                    t[6] = r + n * l,
                    t[10] = o * s
                } else if ("YXZ" === e.order) {
                    const e = s * c
                      , n = s * u
                      , r = l * c
                      , i = l * u;
                    t[0] = e + i * a,
                    t[4] = r * a - n,
                    t[8] = o * l,
                    t[1] = o * u,
                    t[5] = o * c,
                    t[9] = -a,
                    t[2] = n * a - r,
                    t[6] = i + e * a,
                    t[10] = o * s
                } else if ("ZXY" === e.order) {
                    const e = s * c
                      , n = s * u
                      , r = l * c
                      , i = l * u;
                    t[0] = e - i * a,
                    t[4] = -o * u,
                    t[8] = r + n * a,
                    t[1] = n + r * a,
                    t[5] = o * c,
                    t[9] = i - e * a,
                    t[2] = -o * l,
                    t[6] = a,
                    t[10] = o * s
                } else if ("ZYX" === e.order) {
                    const e = o * c
                      , n = o * u
                      , r = a * c
                      , i = a * u;
                    t[0] = s * c,
                    t[4] = r * l - n,
                    t[8] = e * l + i,
                    t[1] = s * u,
                    t[5] = i * l + e,
                    t[9] = n * l - r,
                    t[2] = -l,
                    t[6] = a * s,
                    t[10] = o * s
                } else if ("YZX" === e.order) {
                    const e = o * s
                      , n = o * l
                      , r = a * s
                      , i = a * l;
                    t[0] = s * c,
                    t[4] = i - e * u,
                    t[8] = r * u + n,
                    t[1] = u,
                    t[5] = o * c,
                    t[9] = -a * c,
                    t[2] = -l * c,
                    t[6] = n * u + r,
                    t[10] = e - i * u
                } else if ("XZY" === e.order) {
                    const e = o * s
                      , n = o * l
                      , r = a * s
                      , i = a * l;
                    t[0] = s * c,
                    t[4] = -u,
                    t[8] = l * c,
                    t[1] = e * u + i,
                    t[5] = o * c,
                    t[9] = n * u - r,
                    t[2] = r * u - n,
                    t[6] = a * c,
                    t[10] = i * u + e
                }
                return t[3] = 0,
                t[7] = 0,
                t[11] = 0,
                t[12] = 0,
                t[13] = 0,
                t[14] = 0,
                t[15] = 1,
                this
            }
            makeRotationFromQuaternion(e) {
                return this.compose(ev, e, tv)
            }
            lookAt(e, t, n) {
                const r = this.elements;
                return iv.subVectors(e, t),
                0 === iv.lengthSq() && (iv.z = 1),
                iv.normalize(),
                nv.crossVectors(n, iv),
                0 === nv.lengthSq() && (1 === Math.abs(n.z) ? iv.x += 1e-4 : iv.z += 1e-4,
                iv.normalize(),
                nv.crossVectors(n, iv)),
                nv.normalize(),
                rv.crossVectors(iv, nv),
                r[0] = nv.x,
                r[4] = rv.x,
                r[8] = iv.x,
                r[1] = nv.y,
                r[5] = rv.y,
                r[9] = iv.y,
                r[2] = nv.z,
                r[6] = rv.z,
                r[10] = iv.z,
                this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements
                  , r = t.elements
                  , i = this.elements
                  , o = n[0]
                  , a = n[4]
                  , s = n[8]
                  , l = n[12]
                  , c = n[1]
                  , u = n[5]
                  , d = n[9]
                  , h = n[13]
                  , p = n[2]
                  , f = n[6]
                  , m = n[10]
                  , g = n[14]
                  , v = n[3]
                  , y = n[7]
                  , b = n[11]
                  , _ = n[15]
                  , A = r[0]
                  , x = r[4]
                  , S = r[8]
                  , w = r[12]
                  , E = r[1]
                  , M = r[5]
                  , C = r[9]
                  , T = r[13]
                  , R = r[2]
                  , P = r[6]
                  , B = r[10]
                  , I = r[14]
                  , L = r[3]
                  , k = r[7]
                  , D = r[11]
                  , O = r[15];
                return i[0] = o * A + a * E + s * R + l * L,
                i[4] = o * x + a * M + s * P + l * k,
                i[8] = o * S + a * C + s * B + l * D,
                i[12] = o * w + a * T + s * I + l * O,
                i[1] = c * A + u * E + d * R + h * L,
                i[5] = c * x + u * M + d * P + h * k,
                i[9] = c * S + u * C + d * B + h * D,
                i[13] = c * w + u * T + d * I + h * O,
                i[2] = p * A + f * E + m * R + g * L,
                i[6] = p * x + f * M + m * P + g * k,
                i[10] = p * S + f * C + m * B + g * D,
                i[14] = p * w + f * T + m * I + g * O,
                i[3] = v * A + y * E + b * R + _ * L,
                i[7] = v * x + y * M + b * P + _ * k,
                i[11] = v * S + y * C + b * B + _ * D,
                i[15] = v * w + y * T + b * I + _ * O,
                this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e,
                t[4] *= e,
                t[8] *= e,
                t[12] *= e,
                t[1] *= e,
                t[5] *= e,
                t[9] *= e,
                t[13] *= e,
                t[2] *= e,
                t[6] *= e,
                t[10] *= e,
                t[14] *= e,
                t[3] *= e,
                t[7] *= e,
                t[11] *= e,
                t[15] *= e,
                this
            }
            determinant() {
                const e = this.elements
                  , t = e[0]
                  , n = e[4]
                  , r = e[8]
                  , i = e[12]
                  , o = e[1]
                  , a = e[5]
                  , s = e[9]
                  , l = e[13]
                  , c = e[2]
                  , u = e[6]
                  , d = e[10]
                  , h = e[14];
                return e[3] * (+i * s * u - r * l * u - i * a * d + n * l * d + r * a * h - n * s * h) + e[7] * (+t * s * h - t * l * d + i * o * d - r * o * h + r * l * c - i * s * c) + e[11] * (+t * l * u - t * a * h - i * o * u + n * o * h + i * a * c - n * l * c) + e[15] * (-r * a * c - t * s * u + t * a * d + r * o * u - n * o * d + n * s * c)
            }
            transpose() {
                const e = this.elements;
                let t;
                return t = e[1],
                e[1] = e[4],
                e[4] = t,
                t = e[2],
                e[2] = e[8],
                e[8] = t,
                t = e[6],
                e[6] = e[9],
                e[9] = t,
                t = e[3],
                e[3] = e[12],
                e[12] = t,
                t = e[7],
                e[7] = e[13],
                e[13] = t,
                t = e[11],
                e[11] = e[14],
                e[14] = t,
                this
            }
            setPosition(e, t, n) {
                const r = this.elements;
                return e.isVector3 ? (r[12] = e.x,
                r[13] = e.y,
                r[14] = e.z) : (r[12] = e,
                r[13] = t,
                r[14] = n),
                this
            }
            invert() {
                const e = this.elements
                  , t = e[0]
                  , n = e[1]
                  , r = e[2]
                  , i = e[3]
                  , o = e[4]
                  , a = e[5]
                  , s = e[6]
                  , l = e[7]
                  , c = e[8]
                  , u = e[9]
                  , d = e[10]
                  , h = e[11]
                  , p = e[12]
                  , f = e[13]
                  , m = e[14]
                  , g = e[15]
                  , v = u * m * l - f * d * l + f * s * h - a * m * h - u * s * g + a * d * g
                  , y = p * d * l - c * m * l - p * s * h + o * m * h + c * s * g - o * d * g
                  , b = c * f * l - p * u * l + p * a * h - o * f * h - c * a * g + o * u * g
                  , _ = p * u * s - c * f * s - p * a * d + o * f * d + c * a * m - o * u * m
                  , A = t * v + n * y + r * b + i * _;
                if (0 === A)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const x = 1 / A;
                return e[0] = v * x,
                e[1] = (f * d * i - u * m * i - f * r * h + n * m * h + u * r * g - n * d * g) * x,
                e[2] = (a * m * i - f * s * i + f * r * l - n * m * l - a * r * g + n * s * g) * x,
                e[3] = (u * s * i - a * d * i - u * r * l + n * d * l + a * r * h - n * s * h) * x,
                e[4] = y * x,
                e[5] = (c * m * i - p * d * i + p * r * h - t * m * h - c * r * g + t * d * g) * x,
                e[6] = (p * s * i - o * m * i - p * r * l + t * m * l + o * r * g - t * s * g) * x,
                e[7] = (o * d * i - c * s * i + c * r * l - t * d * l - o * r * h + t * s * h) * x,
                e[8] = b * x,
                e[9] = (p * u * i - c * f * i - p * n * h + t * f * h + c * n * g - t * u * g) * x,
                e[10] = (o * f * i - p * a * i + p * n * l - t * f * l - o * n * g + t * a * g) * x,
                e[11] = (c * a * i - o * u * i - c * n * l + t * u * l + o * n * h - t * a * h) * x,
                e[12] = _ * x,
                e[13] = (c * f * r - p * u * r + p * n * d - t * f * d - c * n * m + t * u * m) * x,
                e[14] = (p * a * r - o * f * r - p * n * s + t * f * s + o * n * m - t * a * m) * x,
                e[15] = (o * u * r - c * a * r + c * n * s - t * u * s - o * n * d + t * a * d) * x,
                this
            }
            scale(e) {
                const t = this.elements
                  , n = e.x
                  , r = e.y
                  , i = e.z;
                return t[0] *= n,
                t[4] *= r,
                t[8] *= i,
                t[1] *= n,
                t[5] *= r,
                t[9] *= i,
                t[2] *= n,
                t[6] *= r,
                t[10] *= i,
                t[3] *= n,
                t[7] *= r,
                t[11] *= i,
                this
            }
            getMaxScaleOnAxis() {
                const e = this.elements
                  , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
                  , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
                  , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                return Math.sqrt(Math.max(t, n, r))
            }
            makeTranslation(e, t, n) {
                return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
                this
            }
            makeRotationX(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
                this
            }
            makeRotationY(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
                this
            }
            makeRotationZ(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            makeRotationAxis(e, t) {
                const n = Math.cos(t)
                  , r = Math.sin(t)
                  , i = 1 - n
                  , o = e.x
                  , a = e.y
                  , s = e.z
                  , l = i * o
                  , c = i * a;
                return this.set(l * o + n, l * a - r * s, l * s + r * a, 0, l * a + r * s, c * a + n, c * s - r * o, 0, l * s - r * a, c * s + r * o, i * s * s + n, 0, 0, 0, 0, 1),
                this
            }
            makeScale(e, t, n) {
                return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                this
            }
            makeShear(e, t, n, r, i, o) {
                return this.set(1, n, i, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1),
                this
            }
            compose(e, t, n) {
                const r = this.elements
                  , i = t._x
                  , o = t._y
                  , a = t._z
                  , s = t._w
                  , l = i + i
                  , c = o + o
                  , u = a + a
                  , d = i * l
                  , h = i * c
                  , p = i * u
                  , f = o * c
                  , m = o * u
                  , g = a * u
                  , v = s * l
                  , y = s * c
                  , b = s * u
                  , _ = n.x
                  , A = n.y
                  , x = n.z;
                return r[0] = (1 - (f + g)) * _,
                r[1] = (h + b) * _,
                r[2] = (p - y) * _,
                r[3] = 0,
                r[4] = (h - b) * A,
                r[5] = (1 - (d + g)) * A,
                r[6] = (m + v) * A,
                r[7] = 0,
                r[8] = (p + y) * x,
                r[9] = (m - v) * x,
                r[10] = (1 - (d + f)) * x,
                r[11] = 0,
                r[12] = e.x,
                r[13] = e.y,
                r[14] = e.z,
                r[15] = 1,
                this
            }
            decompose(e, t, n) {
                const r = this.elements;
                let i = Zg.set(r[0], r[1], r[2]).length();
                const o = Zg.set(r[4], r[5], r[6]).length()
                  , a = Zg.set(r[8], r[9], r[10]).length();
                this.determinant() < 0 && (i = -i),
                e.x = r[12],
                e.y = r[13],
                e.z = r[14],
                $g.copy(this);
                const s = 1 / i
                  , l = 1 / o
                  , c = 1 / a;
                return $g.elements[0] *= s,
                $g.elements[1] *= s,
                $g.elements[2] *= s,
                $g.elements[4] *= l,
                $g.elements[5] *= l,
                $g.elements[6] *= l,
                $g.elements[8] *= c,
                $g.elements[9] *= c,
                $g.elements[10] *= c,
                t.setFromRotationMatrix($g),
                n.x = i,
                n.y = o,
                n.z = a,
                this
            }
            makePerspective(e, t, n, r, i, o) {
                let a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : Mm;
                const s = this.elements
                  , l = 2 * i / (t - e)
                  , c = 2 * i / (n - r)
                  , u = (t + e) / (t - e)
                  , d = (n + r) / (n - r);
                let h, p;
                if (a === Mm)
                    h = -(o + i) / (o - i),
                    p = -2 * o * i / (o - i);
                else {
                    if (a !== Cm)
                        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
                    h = -o / (o - i),
                    p = -o * i / (o - i)
                }
                return s[0] = l,
                s[4] = 0,
                s[8] = u,
                s[12] = 0,
                s[1] = 0,
                s[5] = c,
                s[9] = d,
                s[13] = 0,
                s[2] = 0,
                s[6] = 0,
                s[10] = h,
                s[14] = p,
                s[3] = 0,
                s[7] = 0,
                s[11] = -1,
                s[15] = 0,
                this
            }
            makeOrthographic(e, t, n, r, i, o) {
                let a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : Mm;
                const s = this.elements
                  , l = 1 / (t - e)
                  , c = 1 / (n - r)
                  , u = 1 / (o - i)
                  , d = (t + e) * l
                  , h = (n + r) * c;
                let p, f;
                if (a === Mm)
                    p = (o + i) * u,
                    f = -2 * u;
                else {
                    if (a !== Cm)
                        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
                    p = i * u,
                    f = -1 * u
                }
                return s[0] = 2 * l,
                s[4] = 0,
                s[8] = 0,
                s[12] = -d,
                s[1] = 0,
                s[5] = 2 * c,
                s[9] = 0,
                s[13] = -h,
                s[2] = 0,
                s[6] = 0,
                s[10] = f,
                s[14] = -p,
                s[3] = 0,
                s[7] = 0,
                s[11] = 0,
                s[15] = 1,
                this
            }
            equals(e) {
                const t = this.elements
                  , n = e.elements;
                for (let r = 0; r < 16; r++)
                    if (t[r] !== n[r])
                        return !1;
                return !0
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                for (let n = 0; n < 16; n++)
                    this.elements[n] = e[n + t];
                return this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.elements;
                return e[t] = n[0],
                e[t + 1] = n[1],
                e[t + 2] = n[2],
                e[t + 3] = n[3],
                e[t + 4] = n[4],
                e[t + 5] = n[5],
                e[t + 6] = n[6],
                e[t + 7] = n[7],
                e[t + 8] = n[8],
                e[t + 9] = n[9],
                e[t + 10] = n[10],
                e[t + 11] = n[11],
                e[t + 12] = n[12],
                e[t + 13] = n[13],
                e[t + 14] = n[14],
                e[t + 15] = n[15],
                e
            }
        }
        const Zg = new Ag
          , $g = new Qg
          , ev = new Ag(0,0,0)
          , tv = new Ag(1,1,1)
          , nv = new Ag
          , rv = new Ag
          , iv = new Ag
          , ov = new Qg
          , av = new _g;
        class sv {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : sv.DEFAULT_ORDER;
                this.isEuler = !0,
                this._x = e,
                this._y = t,
                this._z = n,
                this._order = r
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e,
                this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(e) {
                this._order = e,
                this._onChangeCallback()
            }
            set(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this._order;
                return this._x = e,
                this._y = t,
                this._z = n,
                this._order = r,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(e) {
                return this._x = e._x,
                this._y = e._y,
                this._z = e._z,
                this._order = e._order,
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._order
                  , n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                const r = e.elements
                  , i = r[0]
                  , o = r[4]
                  , a = r[8]
                  , s = r[1]
                  , l = r[5]
                  , c = r[9]
                  , u = r[2]
                  , d = r[6]
                  , h = r[10];
                switch (t) {
                case "XYZ":
                    this._y = Math.asin(km(a, -1, 1)),
                    Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, h),
                    this._z = Math.atan2(-o, i)) : (this._x = Math.atan2(d, l),
                    this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-km(c, -1, 1)),
                    Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, h),
                    this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-u, i),
                    this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(km(d, -1, 1)),
                    Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, h),
                    this._z = Math.atan2(-o, l)) : (this._y = 0,
                    this._z = Math.atan2(s, i));
                    break;
                case "ZYX":
                    this._y = Math.asin(-km(u, -1, 1)),
                    Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, h),
                    this._z = Math.atan2(s, i)) : (this._x = 0,
                    this._z = Math.atan2(-o, l));
                    break;
                case "YZX":
                    this._z = Math.asin(km(s, -1, 1)),
                    Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, l),
                    this._y = Math.atan2(-u, i)) : (this._x = 0,
                    this._y = Math.atan2(a, h));
                    break;
                case "XZY":
                    this._z = Math.asin(-km(o, -1, 1)),
                    Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, l),
                    this._y = Math.atan2(a, i)) : (this._x = Math.atan2(-c, h),
                    this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                }
                return this._order = t,
                !0 === n && this._onChangeCallback(),
                this
            }
            setFromQuaternion(e, t, n) {
                return ov.makeRotationFromQuaternion(e),
                this.setFromRotationMatrix(ov, t, n)
            }
            setFromVector3(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._order;
                return this.set(e.x, e.y, e.z, t)
            }
            reorder(e) {
                return av.setFromEuler(this),
                this.setFromQuaternion(av, e)
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
            }
            fromArray(e) {
                return this._x = e[0],
                this._y = e[1],
                this._z = e[2],
                void 0 !== e[3] && (this._order = e[3]),
                this._onChangeCallback(),
                this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this._x,
                e[t + 1] = this._y,
                e[t + 2] = this._z,
                e[t + 3] = this._order,
                e
            }
            _onChange(e) {
                return this._onChangeCallback = e,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._order
            }
        }
        sv.DEFAULT_ORDER = "XYZ";
        class lv {
            constructor() {
                this.mask = 1
            }
            set(e) {
                this.mask = 1 << e >>> 0
            }
            enable(e) {
                this.mask |= 1 << e
            }
            enableAll() {
                this.mask = -1
            }
            toggle(e) {
                this.mask ^= 1 << e
            }
            disable(e) {
                this.mask &= ~(1 << e)
            }
            disableAll() {
                this.mask = 0
            }
            test(e) {
                return 0 !== (this.mask & e.mask)
            }
            isEnabled(e) {
                return 0 !== (this.mask & 1 << e)
            }
        }
        let cv = 0;
        const uv = new Ag
          , dv = new _g
          , hv = new Qg
          , pv = new Ag
          , fv = new Ag
          , mv = new Ag
          , gv = new _g
          , vv = new Ag(1,0,0)
          , yv = new Ag(0,1,0)
          , bv = new Ag(0,0,1)
          , _v = {
            type: "added"
        }
          , Av = {
            type: "removed"
        };
        class xv extends Tm {
            constructor() {
                super(),
                this.isObject3D = !0,
                Object.defineProperty(this, "id", {
                    value: cv++
                }),
                this.uuid = Lm(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = xv.DEFAULT_UP.clone();
                const e = new Ag
                  , t = new sv
                  , n = new _g
                  , r = new Ag(1,1,1);
                t._onChange((function() {
                    n.setFromEuler(t, !1)
                }
                )),
                n._onChange((function() {
                    t.setFromQuaternion(n, void 0, !1)
                }
                )),
                Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: r
                    },
                    modelViewMatrix: {
                        value: new Qg
                    },
                    normalMatrix: {
                        value: new jm
                    }
                }),
                this.matrix = new Qg,
                this.matrixWorld = new Qg,
                this.matrixAutoUpdate = xv.DEFAULT_MATRIX_AUTO_UPDATE,
                this.matrixWorldAutoUpdate = xv.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                this.matrixWorldNeedsUpdate = !1,
                this.layers = new lv,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.animations = [],
                this.userData = {}
            }
            onBeforeShadow() {}
            onAfterShadow() {}
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(e) {
                this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(e),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(e) {
                return this.quaternion.premultiply(e),
                this
            }
            setRotationFromAxisAngle(e, t) {
                this.quaternion.setFromAxisAngle(e, t)
            }
            setRotationFromEuler(e) {
                this.quaternion.setFromEuler(e, !0)
            }
            setRotationFromMatrix(e) {
                this.quaternion.setFromRotationMatrix(e)
            }
            setRotationFromQuaternion(e) {
                this.quaternion.copy(e)
            }
            rotateOnAxis(e, t) {
                return dv.setFromAxisAngle(e, t),
                this.quaternion.multiply(dv),
                this
            }
            rotateOnWorldAxis(e, t) {
                return dv.setFromAxisAngle(e, t),
                this.quaternion.premultiply(dv),
                this
            }
            rotateX(e) {
                return this.rotateOnAxis(vv, e)
            }
            rotateY(e) {
                return this.rotateOnAxis(yv, e)
            }
            rotateZ(e) {
                return this.rotateOnAxis(bv, e)
            }
            translateOnAxis(e, t) {
                return uv.copy(e).applyQuaternion(this.quaternion),
                this.position.add(uv.multiplyScalar(t)),
                this
            }
            translateX(e) {
                return this.translateOnAxis(vv, e)
            }
            translateY(e) {
                return this.translateOnAxis(yv, e)
            }
            translateZ(e) {
                return this.translateOnAxis(bv, e)
            }
            localToWorld(e) {
                return this.updateWorldMatrix(!0, !1),
                e.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(e) {
                return this.updateWorldMatrix(!0, !1),
                e.applyMatrix4(hv.copy(this.matrixWorld).invert())
            }
            lookAt(e, t, n) {
                e.isVector3 ? pv.copy(e) : pv.set(e, t, n);
                const r = this.parent;
                this.updateWorldMatrix(!0, !1),
                fv.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? hv.lookAt(fv, pv, this.up) : hv.lookAt(pv, fv, this.up),
                this.quaternion.setFromRotationMatrix(hv),
                r && (hv.extractRotation(r.matrixWorld),
                dv.setFromRotationMatrix(hv),
                this.quaternion.premultiply(dv.invert()))
            }
            add(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++)
                        this.add(arguments[e]);
                    return this
                }
                return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
                this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e),
                e.parent = this,
                this.children.push(e),
                e.dispatchEvent(_v)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
                this)
            }
            remove(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++)
                        this.remove(arguments[e]);
                    return this
                }
                const t = this.children.indexOf(e);
                return -1 !== t && (e.parent = null,
                this.children.splice(t, 1),
                e.dispatchEvent(Av)),
                this
            }
            removeFromParent() {
                const e = this.parent;
                return null !== e && e.remove(this),
                this
            }
            clear() {
                return this.remove(...this.children)
            }
            attach(e) {
                return this.updateWorldMatrix(!0, !1),
                hv.copy(this.matrixWorld).invert(),
                null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
                hv.multiply(e.parent.matrixWorld)),
                e.applyMatrix4(hv),
                this.add(e),
                e.updateWorldMatrix(!1, !0),
                this
            }
            getObjectById(e) {
                return this.getObjectByProperty("id", e)
            }
            getObjectByName(e) {
                return this.getObjectByProperty("name", e)
            }
            getObjectByProperty(e, t) {
                if (this[e] === t)
                    return this;
                for (let n = 0, r = this.children.length; n < r; n++) {
                    const r = this.children[n].getObjectByProperty(e, t);
                    if (void 0 !== r)
                        return r
                }
            }
            getObjectsByProperty(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                this[e] === t && n.push(this);
                const r = this.children;
                for (let i = 0, o = r.length; i < o; i++)
                    r[i].getObjectsByProperty(e, t, n);
                return n
            }
            getWorldPosition(e) {
                return this.updateWorldMatrix(!0, !1),
                e.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(e) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(fv, e, mv),
                e
            }
            getWorldScale(e) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(fv, gv, e),
                e
            }
            getWorldDirection(e) {
                this.updateWorldMatrix(!0, !1);
                const t = this.matrixWorld.elements;
                return e.set(t[8], t[9], t[10]).normalize()
            }
            raycast() {}
            traverse(e) {
                e(this);
                const t = this.children;
                for (let n = 0, r = t.length; n < r; n++)
                    t[n].traverse(e)
            }
            traverseVisible(e) {
                if (!1 === this.visible)
                    return;
                e(this);
                const t = this.children;
                for (let n = 0, r = t.length; n < r; n++)
                    t[n].traverseVisible(e)
            }
            traverseAncestors(e) {
                const t = this.parent;
                null !== t && (e(t),
                t.traverseAncestors(e))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(e) {
                this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                this.matrixWorldNeedsUpdate = !1,
                e = !0);
                const t = this.children;
                for (let n = 0, r = t.length; n < r; n++) {
                    const r = t[n];
                    !0 !== r.matrixWorldAutoUpdate && !0 !== e || r.updateMatrixWorld(e)
                }
            }
            updateWorldMatrix(e, t) {
                const n = this.parent;
                if (!0 === e && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                !0 === t) {
                    const e = this.children;
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(e) {
                const t = void 0 === e || "string" === typeof e
                  , n = {};
                t && (e = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                },
                n.metadata = {
                    version: 4.6,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const r = {};
                function i(t, n) {
                    return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)),
                    n.uuid
                }
                if (r.uuid = this.uuid,
                r.type = this.type,
                "" !== this.name && (r.name = this.name),
                !0 === this.castShadow && (r.castShadow = !0),
                !0 === this.receiveShadow && (r.receiveShadow = !0),
                !1 === this.visible && (r.visible = !1),
                !1 === this.frustumCulled && (r.frustumCulled = !1),
                0 !== this.renderOrder && (r.renderOrder = this.renderOrder),
                Object.keys(this.userData).length > 0 && (r.userData = this.userData),
                r.layers = this.layers.mask,
                r.matrix = this.matrix.toArray(),
                r.up = this.up.toArray(),
                !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
                this.isInstancedMesh && (r.type = "InstancedMesh",
                r.count = this.count,
                r.instanceMatrix = this.instanceMatrix.toJSON(),
                null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())),
                this.isBatchedMesh && (r.type = "BatchedMesh",
                r.perObjectFrustumCulled = this.perObjectFrustumCulled,
                r.sortObjects = this.sortObjects,
                r.drawRanges = this._drawRanges,
                r.reservedRanges = this._reservedRanges,
                r.visibility = this._visibility,
                r.active = this._active,
                r.bounds = this._bounds.map((e => ({
                    boxInitialized: e.boxInitialized,
                    boxMin: e.box.min.toArray(),
                    boxMax: e.box.max.toArray(),
                    sphereInitialized: e.sphereInitialized,
                    sphereRadius: e.sphere.radius,
                    sphereCenter: e.sphere.center.toArray()
                }))),
                r.maxGeometryCount = this._maxGeometryCount,
                r.maxVertexCount = this._maxVertexCount,
                r.maxIndexCount = this._maxIndexCount,
                r.geometryInitialized = this._geometryInitialized,
                r.geometryCount = this._geometryCount,
                r.matricesTexture = this._matricesTexture.toJSON(e),
                null !== this.boundingSphere && (r.boundingSphere = {
                    center: r.boundingSphere.center.toArray(),
                    radius: r.boundingSphere.radius
                }),
                null !== this.boundingBox && (r.boundingBox = {
                    min: r.boundingBox.min.toArray(),
                    max: r.boundingBox.max.toArray()
                })),
                this.isScene)
                    this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
                    this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (r.environment = this.environment.toJSON(e).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    r.geometry = i(e.geometries, this.geometry);
                    const t = this.geometry.parameters;
                    if (void 0 !== t && void 0 !== t.shapes) {
                        const n = t.shapes;
                        if (Array.isArray(n))
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = n[t];
                                i(e.shapes, r)
                            }
                        else
                            i(e.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
                r.bindMatrix = this.bindMatrix.toArray(),
                void 0 !== this.skeleton && (i(e.skeletons, this.skeleton),
                r.skeleton = this.skeleton.uuid)),
                void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const t = [];
                        for (let n = 0, r = this.material.length; n < r; n++)
                            t.push(i(e.materials, this.material[n]));
                        r.material = t
                    } else
                        r.material = i(e.materials, this.material);
                if (this.children.length > 0) {
                    r.children = [];
                    for (let t = 0; t < this.children.length; t++)
                        r.children.push(this.children[t].toJSON(e).object)
                }
                if (this.animations.length > 0) {
                    r.animations = [];
                    for (let t = 0; t < this.animations.length; t++) {
                        const n = this.animations[t];
                        r.animations.push(i(e.animations, n))
                    }
                }
                if (t) {
                    const t = o(e.geometries)
                      , r = o(e.materials)
                      , i = o(e.textures)
                      , a = o(e.images)
                      , s = o(e.shapes)
                      , l = o(e.skeletons)
                      , c = o(e.animations)
                      , u = o(e.nodes);
                    t.length > 0 && (n.geometries = t),
                    r.length > 0 && (n.materials = r),
                    i.length > 0 && (n.textures = i),
                    a.length > 0 && (n.images = a),
                    s.length > 0 && (n.shapes = s),
                    l.length > 0 && (n.skeletons = l),
                    c.length > 0 && (n.animations = c),
                    u.length > 0 && (n.nodes = u)
                }
                return n.object = r,
                n;
                function o(e) {
                    const t = [];
                    for (const n in e) {
                        const r = e[n];
                        delete r.metadata,
                        t.push(r)
                    }
                    return t
                }
            }
            clone(e) {
                return (new this.constructor).copy(this, e)
            }
            copy(e) {
                let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                if (this.name = e.name,
                this.up.copy(e.up),
                this.position.copy(e.position),
                this.rotation.order = e.rotation.order,
                this.quaternion.copy(e.quaternion),
                this.scale.copy(e.scale),
                this.matrix.copy(e.matrix),
                this.matrixWorld.copy(e.matrixWorld),
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
                this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
                this.layers.mask = e.layers.mask,
                this.visible = e.visible,
                this.castShadow = e.castShadow,
                this.receiveShadow = e.receiveShadow,
                this.frustumCulled = e.frustumCulled,
                this.renderOrder = e.renderOrder,
                this.animations = e.animations.slice(),
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                !0 === t)
                    for (let n = 0; n < e.children.length; n++) {
                        const t = e.children[n];
                        this.add(t.clone())
                    }
                return this
            }
        }
        xv.DEFAULT_UP = new Ag(0,1,0),
        xv.DEFAULT_MATRIX_AUTO_UPDATE = !0,
        xv.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const Sv = new Ag
          , wv = new Ag
          , Ev = new Ag
          , Mv = new Ag
          , Cv = new Ag
          , Tv = new Ag
          , Rv = new Ag
          , Pv = new Ag
          , Bv = new Ag
          , Iv = new Ag;
        let Lv = !1;
        class kv {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Ag
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ag
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Ag;
                this.a = e,
                this.b = t,
                this.c = n
            }
            static getNormal(e, t, n, r) {
                r.subVectors(n, t),
                Sv.subVectors(e, t),
                r.cross(Sv);
                const i = r.lengthSq();
                return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
            }
            static getBarycoord(e, t, n, r, i) {
                Sv.subVectors(r, t),
                wv.subVectors(n, t),
                Ev.subVectors(e, t);
                const o = Sv.dot(Sv)
                  , a = Sv.dot(wv)
                  , s = Sv.dot(Ev)
                  , l = wv.dot(wv)
                  , c = wv.dot(Ev)
                  , u = o * l - a * a;
                if (0 === u)
                    return i.set(-2, -1, -1);
                const d = 1 / u
                  , h = (l * s - a * c) * d
                  , p = (o * c - a * s) * d;
                return i.set(1 - h - p, p, h)
            }
            static containsPoint(e, t, n, r) {
                return this.getBarycoord(e, t, n, r, Mv),
                Mv.x >= 0 && Mv.y >= 0 && Mv.x + Mv.y <= 1
            }
            static getUV(e, t, n, r, i, o, a, s) {
                return !1 === Lv && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
                Lv = !0),
                this.getInterpolation(e, t, n, r, i, o, a, s)
            }
            static getInterpolation(e, t, n, r, i, o, a, s) {
                return this.getBarycoord(e, t, n, r, Mv),
                s.setScalar(0),
                s.addScaledVector(i, Mv.x),
                s.addScaledVector(o, Mv.y),
                s.addScaledVector(a, Mv.z),
                s
            }
            static isFrontFacing(e, t, n, r) {
                return Sv.subVectors(n, t),
                wv.subVectors(e, t),
                Sv.cross(wv).dot(r) < 0
            }
            set(e, t, n) {
                return this.a.copy(e),
                this.b.copy(t),
                this.c.copy(n),
                this
            }
            setFromPointsAndIndices(e, t, n, r) {
                return this.a.copy(e[t]),
                this.b.copy(e[n]),
                this.c.copy(e[r]),
                this
            }
            setFromAttributeAndIndices(e, t, n, r) {
                return this.a.fromBufferAttribute(e, t),
                this.b.fromBufferAttribute(e, n),
                this.c.fromBufferAttribute(e, r),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.a.copy(e.a),
                this.b.copy(e.b),
                this.c.copy(e.c),
                this
            }
            getArea() {
                return Sv.subVectors(this.c, this.b),
                wv.subVectors(this.a, this.b),
                .5 * Sv.cross(wv).length()
            }
            getMidpoint(e) {
                return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(e) {
                return kv.getNormal(this.a, this.b, this.c, e)
            }
            getPlane(e) {
                return e.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(e, t) {
                return kv.getBarycoord(e, this.a, this.b, this.c, t)
            }
            getUV(e, t, n, r, i) {
                return !1 === Lv && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
                Lv = !0),
                kv.getInterpolation(e, this.a, this.b, this.c, t, n, r, i)
            }
            getInterpolation(e, t, n, r, i) {
                return kv.getInterpolation(e, this.a, this.b, this.c, t, n, r, i)
            }
            containsPoint(e) {
                return kv.containsPoint(e, this.a, this.b, this.c)
            }
            isFrontFacing(e) {
                return kv.isFrontFacing(this.a, this.b, this.c, e)
            }
            intersectsBox(e) {
                return e.intersectsTriangle(this)
            }
            closestPointToPoint(e, t) {
                const n = this.a
                  , r = this.b
                  , i = this.c;
                let o, a;
                Cv.subVectors(r, n),
                Tv.subVectors(i, n),
                Pv.subVectors(e, n);
                const s = Cv.dot(Pv)
                  , l = Tv.dot(Pv);
                if (s <= 0 && l <= 0)
                    return t.copy(n);
                Bv.subVectors(e, r);
                const c = Cv.dot(Bv)
                  , u = Tv.dot(Bv);
                if (c >= 0 && u <= c)
                    return t.copy(r);
                const d = s * u - c * l;
                if (d <= 0 && s >= 0 && c <= 0)
                    return o = s / (s - c),
                    t.copy(n).addScaledVector(Cv, o);
                Iv.subVectors(e, i);
                const h = Cv.dot(Iv)
                  , p = Tv.dot(Iv);
                if (p >= 0 && h <= p)
                    return t.copy(i);
                const f = h * l - s * p;
                if (f <= 0 && l >= 0 && p <= 0)
                    return a = l / (l - p),
                    t.copy(n).addScaledVector(Tv, a);
                const m = c * p - h * u;
                if (m <= 0 && u - c >= 0 && h - p >= 0)
                    return Rv.subVectors(i, r),
                    a = (u - c) / (u - c + (h - p)),
                    t.copy(r).addScaledVector(Rv, a);
                const g = 1 / (m + f + d);
                return o = f * g,
                a = d * g,
                t.copy(n).addScaledVector(Cv, o).addScaledVector(Tv, a)
            }
            equals(e) {
                return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            }
        }
        const Dv = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
          , Ov = {
            h: 0,
            s: 0,
            l: 0
        }
          , Nv = {
            h: 0,
            s: 0,
            l: 0
        };
        function Fv(e, t, n) {
            return n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
        }
        class Uv {
            constructor(e, t, n) {
                return this.isColor = !0,
                this.r = 1,
                this.g = 1,
                this.b = 1,
                this.set(e, t, n)
            }
            set(e, t, n) {
                if (void 0 === t && void 0 === n) {
                    const t = e;
                    t && t.isColor ? this.copy(t) : "number" === typeof t ? this.setHex(t) : "string" === typeof t && this.setStyle(t)
                } else
                    this.setRGB(e, t, n);
                return this
            }
            setScalar(e) {
                return this.r = e,
                this.g = e,
                this.b = e,
                this
            }
            setHex(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Of;
                return e = Math.floor(e),
                this.r = (e >> 16 & 255) / 255,
                this.g = (e >> 8 & 255) / 255,
                this.b = (255 & e) / 255,
                ng.toWorkingColorSpace(this, t),
                this
            }
            setRGB(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : ng.workingColorSpace;
                return this.r = e,
                this.g = t,
                this.b = n,
                ng.toWorkingColorSpace(this, r),
                this
            }
            setHSL(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : ng.workingColorSpace;
                if (e = Dm(e, 1),
                t = km(t, 0, 1),
                n = km(n, 0, 1),
                0 === t)
                    this.r = this.g = this.b = n;
                else {
                    const r = n <= .5 ? n * (1 + t) : n + t - n * t
                      , i = 2 * n - r;
                    this.r = Fv(i, r, e + 1 / 3),
                    this.g = Fv(i, r, e),
                    this.b = Fv(i, r, e - 1 / 3)
                }
                return ng.toWorkingColorSpace(this, r),
                this
            }
            setStyle(e) {
                let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Of;
                function r(t) {
                    void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                }
                if (t = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                    let i;
                    const o = t[1]
                      , a = t[2];
                    switch (o) {
                    case "rgb":
                    case "rgba":
                        if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                            return r(i[4]),
                            this.setRGB(Math.min(255, parseInt(i[1], 10)) / 255, Math.min(255, parseInt(i[2], 10)) / 255, Math.min(255, parseInt(i[3], 10)) / 255, n);
                        if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                            return r(i[4]),
                            this.setRGB(Math.min(100, parseInt(i[1], 10)) / 100, Math.min(100, parseInt(i[2], 10)) / 100, Math.min(100, parseInt(i[3], 10)) / 100, n);
                        break;
                    case "hsl":
                    case "hsla":
                        if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                            return r(i[4]),
                            this.setHSL(parseFloat(i[1]) / 360, parseFloat(i[2]) / 100, parseFloat(i[3]) / 100, n);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + e)
                    }
                } else if (t = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                    const r = t[1]
                      , i = r.length;
                    if (3 === i)
                        return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, n);
                    if (6 === i)
                        return this.setHex(parseInt(r, 16), n);
                    console.warn("THREE.Color: Invalid hex color " + e)
                } else if (e && e.length > 0)
                    return this.setColorName(e, n);
                return this
            }
            setColorName(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Of;
                const n = Dv[e.toLowerCase()];
                return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
                this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(e) {
                return this.r = e.r,
                this.g = e.g,
                this.b = e.b,
                this
            }
            copySRGBToLinear(e) {
                return this.r = rg(e.r),
                this.g = rg(e.g),
                this.b = rg(e.b),
                this
            }
            copyLinearToSRGB(e) {
                return this.r = ig(e.r),
                this.g = ig(e.g),
                this.b = ig(e.b),
                this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                this
            }
            getHex() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Of;
                return ng.fromWorkingColorSpace(zv.copy(this), e),
                65536 * Math.round(km(255 * zv.r, 0, 255)) + 256 * Math.round(km(255 * zv.g, 0, 255)) + Math.round(km(255 * zv.b, 0, 255))
            }
            getHexString() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Of;
                return ("000000" + this.getHex(e).toString(16)).slice(-6)
            }
            getHSL(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ng.workingColorSpace;
                ng.fromWorkingColorSpace(zv.copy(this), t);
                const n = zv.r
                  , r = zv.g
                  , i = zv.b
                  , o = Math.max(n, r, i)
                  , a = Math.min(n, r, i);
                let s, l;
                const c = (a + o) / 2;
                if (a === o)
                    s = 0,
                    l = 0;
                else {
                    const e = o - a;
                    switch (l = c <= .5 ? e / (o + a) : e / (2 - o - a),
                    o) {
                    case n:
                        s = (r - i) / e + (r < i ? 6 : 0);
                        break;
                    case r:
                        s = (i - n) / e + 2;
                        break;
                    case i:
                        s = (n - r) / e + 4
                    }
                    s /= 6
                }
                return e.h = s,
                e.s = l,
                e.l = c,
                e
            }
            getRGB(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ng.workingColorSpace;
                return ng.fromWorkingColorSpace(zv.copy(this), t),
                e.r = zv.r,
                e.g = zv.g,
                e.b = zv.b,
                e
            }
            getStyle() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Of;
                ng.fromWorkingColorSpace(zv.copy(this), e);
                const t = zv.r
                  , n = zv.g
                  , r = zv.b;
                return e !== Of ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(255 * t)},${Math.round(255 * n)},${Math.round(255 * r)})`
            }
            offsetHSL(e, t, n) {
                return this.getHSL(Ov),
                this.setHSL(Ov.h + e, Ov.s + t, Ov.l + n)
            }
            add(e) {
                return this.r += e.r,
                this.g += e.g,
                this.b += e.b,
                this
            }
            addColors(e, t) {
                return this.r = e.r + t.r,
                this.g = e.g + t.g,
                this.b = e.b + t.b,
                this
            }
            addScalar(e) {
                return this.r += e,
                this.g += e,
                this.b += e,
                this
            }
            sub(e) {
                return this.r = Math.max(0, this.r - e.r),
                this.g = Math.max(0, this.g - e.g),
                this.b = Math.max(0, this.b - e.b),
                this
            }
            multiply(e) {
                return this.r *= e.r,
                this.g *= e.g,
                this.b *= e.b,
                this
            }
            multiplyScalar(e) {
                return this.r *= e,
                this.g *= e,
                this.b *= e,
                this
            }
            lerp(e, t) {
                return this.r += (e.r - this.r) * t,
                this.g += (e.g - this.g) * t,
                this.b += (e.b - this.b) * t,
                this
            }
            lerpColors(e, t, n) {
                return this.r = e.r + (t.r - e.r) * n,
                this.g = e.g + (t.g - e.g) * n,
                this.b = e.b + (t.b - e.b) * n,
                this
            }
            lerpHSL(e, t) {
                this.getHSL(Ov),
                e.getHSL(Nv);
                const n = Om(Ov.h, Nv.h, t)
                  , r = Om(Ov.s, Nv.s, t)
                  , i = Om(Ov.l, Nv.l, t);
                return this.setHSL(n, r, i),
                this
            }
            setFromVector3(e) {
                return this.r = e.x,
                this.g = e.y,
                this.b = e.z,
                this
            }
            applyMatrix3(e) {
                const t = this.r
                  , n = this.g
                  , r = this.b
                  , i = e.elements;
                return this.r = i[0] * t + i[3] * n + i[6] * r,
                this.g = i[1] * t + i[4] * n + i[7] * r,
                this.b = i[2] * t + i[5] * n + i[8] * r,
                this
            }
            equals(e) {
                return e.r === this.r && e.g === this.g && e.b === this.b
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.r = e[t],
                this.g = e[t + 1],
                this.b = e[t + 2],
                this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this.r,
                e[t + 1] = this.g,
                e[t + 2] = this.b,
                e
            }
            fromBufferAttribute(e, t) {
                return this.r = e.getX(t),
                this.g = e.getY(t),
                this.b = e.getZ(t),
                this
            }
            toJSON() {
                return this.getHex()
            }
            *[Symbol.iterator]() {
                yield this.r,
                yield this.g,
                yield this.b
            }
        }
        const zv = new Uv;
        Uv.NAMES = Dv;
        let Gv = 0;
        class Hv extends Tm {
            constructor() {
                super(),
                this.isMaterial = !0,
                Object.defineProperty(this, "id", {
                    value: Gv++
                }),
                this.uuid = Lm(),
                this.name = "",
                this.type = "Material",
                this.blending = oh,
                this.side = eh,
                this.vertexColors = !1,
                this.opacity = 1,
                this.transparent = !1,
                this.alphaHash = !1,
                this.blendSrc = bh,
                this.blendDst = _h,
                this.blendEquation = uh,
                this.blendSrcAlpha = null,
                this.blendDstAlpha = null,
                this.blendEquationAlpha = null,
                this.blendColor = new Uv(0,0,0),
                this.blendAlpha = 0,
                this.depthFunc = Lh,
                this.depthTest = !0,
                this.depthWrite = !0,
                this.stencilWriteMask = 255,
                this.stencilFunc = om,
                this.stencilRef = 0,
                this.stencilFuncMask = 255,
                this.stencilFail = Vf,
                this.stencilZFail = Vf,
                this.stencilZPass = Vf,
                this.stencilWrite = !1,
                this.clippingPlanes = null,
                this.clipIntersection = !1,
                this.clipShadows = !1,
                this.shadowSide = null,
                this.colorWrite = !0,
                this.precision = null,
                this.polygonOffset = !1,
                this.polygonOffsetFactor = 0,
                this.polygonOffsetUnits = 0,
                this.dithering = !1,
                this.alphaToCoverage = !1,
                this.premultipliedAlpha = !1,
                this.forceSinglePass = !1,
                this.visible = !0,
                this.toneMapped = !0,
                this.userData = {},
                this.version = 0,
                this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(e) {
                this._alphaTest > 0 !== e > 0 && this.version++,
                this._alphaTest = e
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(e) {
                if (void 0 !== e)
                    for (const t in e) {
                        const n = e[t];
                        if (void 0 === n) {
                            console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                            continue
                        }
                        const r = this[t];
                        void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`)
                    }
            }
            toJSON(e) {
                const t = void 0 === e || "string" === typeof e;
                t && (e = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                function r(e) {
                    const t = [];
                    for (const n in e) {
                        const r = e[n];
                        delete r.metadata,
                        t.push(r)
                    }
                    return t
                }
                if (n.uuid = this.uuid,
                n.type = this.type,
                "" !== this.name && (n.name = this.name),
                this.color && this.color.isColor && (n.color = this.color.getHex()),
                void 0 !== this.roughness && (n.roughness = this.roughness),
                void 0 !== this.metalness && (n.metalness = this.metalness),
                void 0 !== this.sheen && (n.sheen = this.sheen),
                this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
                this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
                this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                void 0 !== this.shininess && (n.shininess = this.shininess),
                void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
                n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                void 0 !== this.iridescence && (n.iridescence = this.iridescence),
                void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR),
                void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
                this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
                this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
                void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
                void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation),
                this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
                this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
                this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
                this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
                n.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
                n.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
                n.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
                n.normalMapType = this.normalMapType,
                n.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
                n.displacementScale = this.displacementScale,
                n.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
                this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
                this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
                this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
                void 0 !== this.combine && (n.combine = this.combine)),
                void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
                void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
                void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
                this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                void 0 !== this.transmission && (n.transmission = this.transmission),
                this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
                void 0 !== this.thickness && (n.thickness = this.thickness),
                this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
                void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
                void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()),
                void 0 !== this.size && (n.size = this.size),
                null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                this.blending !== oh && (n.blending = this.blending),
                this.side !== eh && (n.side = this.side),
                !0 === this.vertexColors && (n.vertexColors = !0),
                this.opacity < 1 && (n.opacity = this.opacity),
                !0 === this.transparent && (n.transparent = !0),
                this.blendSrc !== bh && (n.blendSrc = this.blendSrc),
                this.blendDst !== _h && (n.blendDst = this.blendDst),
                this.blendEquation !== uh && (n.blendEquation = this.blendEquation),
                null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha),
                null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha),
                null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha),
                this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
                0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
                this.depthFunc !== Lh && (n.depthFunc = this.depthFunc),
                !1 === this.depthTest && (n.depthTest = this.depthTest),
                !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
                !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
                255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask),
                this.stencilFunc !== om && (n.stencilFunc = this.stencilFunc),
                0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
                255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask),
                this.stencilFail !== Vf && (n.stencilFail = this.stencilFail),
                this.stencilZFail !== Vf && (n.stencilZFail = this.stencilZFail),
                this.stencilZPass !== Vf && (n.stencilZPass = this.stencilZPass),
                !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
                void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                !0 === this.polygonOffset && (n.polygonOffset = !0),
                0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                void 0 !== this.scale && (n.scale = this.scale),
                !0 === this.dithering && (n.dithering = !0),
                this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                !0 === this.alphaHash && (n.alphaHash = !0),
                !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
                !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
                !0 === this.forceSinglePass && (n.forceSinglePass = !0),
                !0 === this.wireframe && (n.wireframe = !0),
                this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                !0 === this.flatShading && (n.flatShading = !0),
                !1 === this.visible && (n.visible = !1),
                !1 === this.toneMapped && (n.toneMapped = !1),
                !1 === this.fog && (n.fog = !1),
                Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                t) {
                    const t = r(e.textures)
                      , i = r(e.images);
                    t.length > 0 && (n.textures = t),
                    i.length > 0 && (n.images = i)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.name = e.name,
                this.blending = e.blending,
                this.side = e.side,
                this.vertexColors = e.vertexColors,
                this.opacity = e.opacity,
                this.transparent = e.transparent,
                this.blendSrc = e.blendSrc,
                this.blendDst = e.blendDst,
                this.blendEquation = e.blendEquation,
                this.blendSrcAlpha = e.blendSrcAlpha,
                this.blendDstAlpha = e.blendDstAlpha,
                this.blendEquationAlpha = e.blendEquationAlpha,
                this.blendColor.copy(e.blendColor),
                this.blendAlpha = e.blendAlpha,
                this.depthFunc = e.depthFunc,
                this.depthTest = e.depthTest,
                this.depthWrite = e.depthWrite,
                this.stencilWriteMask = e.stencilWriteMask,
                this.stencilFunc = e.stencilFunc,
                this.stencilRef = e.stencilRef,
                this.stencilFuncMask = e.stencilFuncMask,
                this.stencilFail = e.stencilFail,
                this.stencilZFail = e.stencilZFail,
                this.stencilZPass = e.stencilZPass,
                this.stencilWrite = e.stencilWrite;
                const t = e.clippingPlanes;
                let n = null;
                if (null !== t) {
                    const e = t.length;
                    n = new Array(e);
                    for (let r = 0; r !== e; ++r)
                        n[r] = t[r].clone()
                }
                return this.clippingPlanes = n,
                this.clipIntersection = e.clipIntersection,
                this.clipShadows = e.clipShadows,
                this.shadowSide = e.shadowSide,
                this.colorWrite = e.colorWrite,
                this.precision = e.precision,
                this.polygonOffset = e.polygonOffset,
                this.polygonOffsetFactor = e.polygonOffsetFactor,
                this.polygonOffsetUnits = e.polygonOffsetUnits,
                this.dithering = e.dithering,
                this.alphaTest = e.alphaTest,
                this.alphaHash = e.alphaHash,
                this.alphaToCoverage = e.alphaToCoverage,
                this.premultipliedAlpha = e.premultipliedAlpha,
                this.forceSinglePass = e.forceSinglePass,
                this.visible = e.visible,
                this.toneMapped = e.toneMapped,
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
        }
        class jv extends Hv {
            constructor(e) {
                super(),
                this.isMeshBasicMaterial = !0,
                this.type = "MeshBasicMaterial",
                this.color = new Uv(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = Fh,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.specularMap = e.specularMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.combine = e.combine,
                this.reflectivity = e.reflectivity,
                this.refractionRatio = e.refractionRatio,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.fog = e.fog,
                this
            }
        }
        const Wv = Vv();
        function Vv() {
            const e = new ArrayBuffer(4)
              , t = new Float32Array(e)
              , n = new Uint32Array(e)
              , r = new Uint32Array(512)
              , i = new Uint32Array(512);
            for (let l = 0; l < 256; ++l) {
                const e = l - 127;
                e < -27 ? (r[l] = 0,
                r[256 | l] = 32768,
                i[l] = 24,
                i[256 | l] = 24) : e < -14 ? (r[l] = 1024 >> -e - 14,
                r[256 | l] = 1024 >> -e - 14 | 32768,
                i[l] = -e - 1,
                i[256 | l] = -e - 1) : e <= 15 ? (r[l] = e + 15 << 10,
                r[256 | l] = e + 15 << 10 | 32768,
                i[l] = 13,
                i[256 | l] = 13) : e < 128 ? (r[l] = 31744,
                r[256 | l] = 64512,
                i[l] = 24,
                i[256 | l] = 24) : (r[l] = 31744,
                r[256 | l] = 64512,
                i[l] = 13,
                i[256 | l] = 13)
            }
            const o = new Uint32Array(2048)
              , a = new Uint32Array(64)
              , s = new Uint32Array(64);
            for (let l = 1; l < 1024; ++l) {
                let e = l << 13
                  , t = 0;
                for (; 0 === (8388608 & e); )
                    e <<= 1,
                    t -= 8388608;
                e &= -8388609,
                t += 947912704,
                o[l] = e | t
            }
            for (let l = 1024; l < 2048; ++l)
                o[l] = 939524096 + (l - 1024 << 13);
            for (let l = 1; l < 31; ++l)
                a[l] = l << 23;
            a[31] = 1199570944,
            a[32] = 2147483648;
            for (let l = 33; l < 63; ++l)
                a[l] = 2147483648 + (l - 32 << 23);
            a[63] = 3347054592;
            for (let l = 1; l < 64; ++l)
                32 !== l && (s[l] = 1024);
            return {
                floatView: t,
                uint32View: n,
                baseTable: r,
                shiftTable: i,
                mantissaTable: o,
                exponentTable: a,
                offsetTable: s
            }
        }
        function Xv(e) {
            Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
            e = km(e, -65504, 65504),
            Wv.floatView[0] = e;
            const t = Wv.uint32View[0]
              , n = t >> 23 & 511;
            return Wv.baseTable[n] + ((8388607 & t) >> Wv.shiftTable[n])
        }
        function Jv(e) {
            const t = e >> 10;
            return Wv.uint32View[0] = Wv.mantissaTable[Wv.offsetTable[t] + (1023 & e)] + Wv.exponentTable[t],
            Wv.floatView[0]
        }
        const Kv = {
            toHalfFloat: Xv,
            fromHalfFloat: Jv
        }
          , qv = new Ag
          , Yv = new Hm;
        class Qv {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                if (Array.isArray(e))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0,
                this.name = "",
                this.array = e,
                this.itemSize = t,
                this.count = void 0 !== e ? e.length / t : 0,
                this.normalized = n,
                this.usage = fm,
                this._updateRange = {
                    offset: 0,
                    count: -1
                },
                this.updateRanges = [],
                this.gpuType = _p,
                this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            get updateRange() {
                return console.warn('THREE.BufferAttribute: "updateRange" is deprecated and removed in r169. Use "addUpdateRange()" instead.'),
                this._updateRange
            }
            setUsage(e) {
                return this.usage = e,
                this
            }
            addUpdateRange(e, t) {
                this.updateRanges.push({
                    start: e,
                    count: t
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(e) {
                return this.name = e.name,
                this.array = new e.array.constructor(e.array),
                this.itemSize = e.itemSize,
                this.count = e.count,
                this.normalized = e.normalized,
                this.usage = e.usage,
                this.gpuType = e.gpuType,
                this
            }
            copyAt(e, t, n) {
                e *= this.itemSize,
                n *= t.itemSize;
                for (let r = 0, i = this.itemSize; r < i; r++)
                    this.array[e + r] = t.array[n + r];
                return this
            }
            copyArray(e) {
                return this.array.set(e),
                this
            }
            applyMatrix3(e) {
                if (2 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++)
                        Yv.fromBufferAttribute(this, t),
                        Yv.applyMatrix3(e),
                        this.setXY(t, Yv.x, Yv.y);
                else if (3 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++)
                        qv.fromBufferAttribute(this, t),
                        qv.applyMatrix3(e),
                        this.setXYZ(t, qv.x, qv.y, qv.z);
                return this
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    qv.fromBufferAttribute(this, t),
                    qv.applyMatrix4(e),
                    this.setXYZ(t, qv.x, qv.y, qv.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    qv.fromBufferAttribute(this, t),
                    qv.applyNormalMatrix(e),
                    this.setXYZ(t, qv.x, qv.y, qv.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    qv.fromBufferAttribute(this, t),
                    qv.transformDirection(e),
                    this.setXYZ(t, qv.x, qv.y, qv.z);
                return this
            }
            set(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.array.set(e, t),
                this
            }
            getComponent(e, t) {
                let n = this.array[e * this.itemSize + t];
                return this.normalized && (n = Um(n, this.array)),
                n
            }
            setComponent(e, t, n) {
                return this.normalized && (n = zm(n, this.array)),
                this.array[e * this.itemSize + t] = n,
                this
            }
            getX(e) {
                let t = this.array[e * this.itemSize];
                return this.normalized && (t = Um(t, this.array)),
                t
            }
            setX(e, t) {
                return this.normalized && (t = zm(t, this.array)),
                this.array[e * this.itemSize] = t,
                this
            }
            getY(e) {
                let t = this.array[e * this.itemSize + 1];
                return this.normalized && (t = Um(t, this.array)),
                t
            }
            setY(e, t) {
                return this.normalized && (t = zm(t, this.array)),
                this.array[e * this.itemSize + 1] = t,
                this
            }
            getZ(e) {
                let t = this.array[e * this.itemSize + 2];
                return this.normalized && (t = Um(t, this.array)),
                t
            }
            setZ(e, t) {
                return this.normalized && (t = zm(t, this.array)),
                this.array[e * this.itemSize + 2] = t,
                this
            }
            getW(e) {
                let t = this.array[e * this.itemSize + 3];
                return this.normalized && (t = Um(t, this.array)),
                t
            }
            setW(e, t) {
                return this.normalized && (t = zm(t, this.array)),
                this.array[e * this.itemSize + 3] = t,
                this
            }
            setXY(e, t, n) {
                return e *= this.itemSize,
                this.normalized && (t = zm(t, this.array),
                n = zm(n, this.array)),
                this.array[e + 0] = t,
                this.array[e + 1] = n,
                this
            }
            setXYZ(e, t, n, r) {
                return e *= this.itemSize,
                this.normalized && (t = zm(t, this.array),
                n = zm(n, this.array),
                r = zm(r, this.array)),
                this.array[e + 0] = t,
                this.array[e + 1] = n,
                this.array[e + 2] = r,
                this
            }
            setXYZW(e, t, n, r, i) {
                return e *= this.itemSize,
                this.normalized && (t = zm(t, this.array),
                n = zm(n, this.array),
                r = zm(r, this.array),
                i = zm(i, this.array)),
                this.array[e + 0] = t,
                this.array[e + 1] = n,
                this.array[e + 2] = r,
                this.array[e + 3] = i,
                this
            }
            onUpload(e) {
                return this.onUploadCallback = e,
                this
            }
            clone() {
                return new this.constructor(this.array,this.itemSize).copy(this)
            }
            toJSON() {
                const e = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (e.name = this.name),
                this.usage !== fm && (e.usage = this.usage),
                e
            }
        }
        class Zv extends Qv {
            constructor(e, t, n) {
                super(new Int8Array(e), t, n)
            }
        }
        class $v extends Qv {
            constructor(e, t, n) {
                super(new Uint8Array(e), t, n)
            }
        }
        class ey extends Qv {
            constructor(e, t, n) {
                super(new Uint8ClampedArray(e), t, n)
            }
        }
        class ty extends Qv {
            constructor(e, t, n) {
                super(new Int16Array(e), t, n)
            }
        }
        class ny extends Qv {
            constructor(e, t, n) {
                super(new Uint16Array(e), t, n)
            }
        }
        class ry extends Qv {
            constructor(e, t, n) {
                super(new Int32Array(e), t, n)
            }
        }
        class iy extends Qv {
            constructor(e, t, n) {
                super(new Uint32Array(e), t, n)
            }
        }
        class oy extends Qv {
            constructor(e, t, n) {
                super(new Uint16Array(e), t, n),
                this.isFloat16BufferAttribute = !0
            }
            getX(e) {
                let t = Jv(this.array[e * this.itemSize]);
                return this.normalized && (t = Um(t, this.array)),
                t
            }
            setX(e, t) {
                return this.normalized && (t = zm(t, this.array)),
                this.array[e * this.itemSize] = Xv(t),
                this
            }
            getY(e) {
                let t = Jv(this.array[e * this.itemSize + 1]);
                return this.normalized && (t = Um(t, this.array)),
                t
            }
            setY(e, t) {
                return this.normalized && (t = zm(t, this.array)),
                this.array[e * this.itemSize + 1] = Xv(t),
                this
            }
            getZ(e) {
                let t = Jv(this.array[e * this.itemSize + 2]);
                return this.normalized && (t = Um(t, this.array)),
                t
            }
            setZ(e, t) {
                return this.normalized && (t = zm(t, this.array)),
                this.array[e * this.itemSize + 2] = Xv(t),
                this
            }
            getW(e) {
                let t = Jv(this.array[e * this.itemSize + 3]);
                return this.normalized && (t = Um(t, this.array)),
                t
            }
            setW(e, t) {
                return this.normalized && (t = zm(t, this.array)),
                this.array[e * this.itemSize + 3] = Xv(t),
                this
            }
            setXY(e, t, n) {
                return e *= this.itemSize,
                this.normalized && (t = zm(t, this.array),
                n = zm(n, this.array)),
                this.array[e + 0] = Xv(t),
                this.array[e + 1] = Xv(n),
                this
            }
            setXYZ(e, t, n, r) {
                return e *= this.itemSize,
                this.normalized && (t = zm(t, this.array),
                n = zm(n, this.array),
                r = zm(r, this.array)),
                this.array[e + 0] = Xv(t),
                this.array[e + 1] = Xv(n),
                this.array[e + 2] = Xv(r),
                this
            }
            setXYZW(e, t, n, r, i) {
                return e *= this.itemSize,
                this.normalized && (t = zm(t, this.array),
                n = zm(n, this.array),
                r = zm(r, this.array),
                i = zm(i, this.array)),
                this.array[e + 0] = Xv(t),
                this.array[e + 1] = Xv(n),
                this.array[e + 2] = Xv(r),
                this.array[e + 3] = Xv(i),
                this
            }
        }
        class ay extends Qv {
            constructor(e, t, n) {
                super(new Float32Array(e), t, n)
            }
        }
        class sy extends Qv {
            constructor(e, t, n) {
                super(new Float64Array(e), t, n)
            }
        }
        let ly = 0;
        const cy = new Qg
          , uy = new xv
          , dy = new Ag
          , hy = new wg
          , py = new wg
          , fy = new Ag;
        class my extends Tm {
            constructor() {
                super(),
                this.isBufferGeometry = !0,
                Object.defineProperty(this, "id", {
                    value: ly++
                }),
                this.uuid = Lm(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.morphTargetsRelative = !1,
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                },
                this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(e) {
                return Array.isArray(e) ? this.index = new (Vm(e) ? iy : ny)(e,1) : this.index = e,
                this
            }
            getAttribute(e) {
                return this.attributes[e]
            }
            setAttribute(e, t) {
                return this.attributes[e] = t,
                this
            }
            deleteAttribute(e) {
                return delete this.attributes[e],
                this
            }
            hasAttribute(e) {
                return void 0 !== this.attributes[e]
            }
            addGroup(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                this.groups.push({
                    start: e,
                    count: t,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(e, t) {
                this.drawRange.start = e,
                this.drawRange.count = t
            }
            applyMatrix4(e) {
                const t = this.attributes.position;
                void 0 !== t && (t.applyMatrix4(e),
                t.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const t = (new jm).getNormalMatrix(e);
                    n.applyNormalMatrix(t),
                    n.needsUpdate = !0
                }
                const r = this.attributes.tangent;
                return void 0 !== r && (r.transformDirection(e),
                r.needsUpdate = !0),
                null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                this
            }
            applyQuaternion(e) {
                return cy.makeRotationFromQuaternion(e),
                this.applyMatrix4(cy),
                this
            }
            rotateX(e) {
                return cy.makeRotationX(e),
                this.applyMatrix4(cy),
                this
            }
            rotateY(e) {
                return cy.makeRotationY(e),
                this.applyMatrix4(cy),
                this
            }
            rotateZ(e) {
                return cy.makeRotationZ(e),
                this.applyMatrix4(cy),
                this
            }
            translate(e, t, n) {
                return cy.makeTranslation(e, t, n),
                this.applyMatrix4(cy),
                this
            }
            scale(e, t, n) {
                return cy.makeScale(e, t, n),
                this.applyMatrix4(cy),
                this
            }
            lookAt(e) {
                return uy.lookAt(e),
                uy.updateMatrix(),
                this.applyMatrix4(uy.matrix),
                this
            }
            center() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(dy).negate(),
                this.translate(dy.x, dy.y, dy.z),
                this
            }
            setFromPoints(e) {
                const t = [];
                for (let n = 0, r = e.length; n < r; n++) {
                    const r = e[n];
                    t.push(r.x, r.y, r.z || 0)
                }
                return this.setAttribute("position", new ay(t,3)),
                this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new wg);
                const e = this.attributes.position
                  , t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingBox.set(new Ag(-1 / 0,-1 / 0,-1 / 0), new Ag(1 / 0,1 / 0,1 / 0));
                if (void 0 !== e) {
                    if (this.boundingBox.setFromBufferAttribute(e),
                    t)
                        for (let n = 0, r = t.length; n < r; n++) {
                            const e = t[n];
                            hy.setFromBufferAttribute(e),
                            this.morphTargetsRelative ? (fy.addVectors(this.boundingBox.min, hy.min),
                            this.boundingBox.expandByPoint(fy),
                            fy.addVectors(this.boundingBox.max, hy.max),
                            this.boundingBox.expandByPoint(fy)) : (this.boundingBox.expandByPoint(hy.min),
                            this.boundingBox.expandByPoint(hy.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Hg);
                const e = this.attributes.position
                  , t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingSphere.set(new Ag, 1 / 0);
                if (e) {
                    const n = this.boundingSphere.center;
                    if (hy.setFromBufferAttribute(e),
                    t)
                        for (let e = 0, i = t.length; e < i; e++) {
                            const n = t[e];
                            py.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (fy.addVectors(hy.min, py.min),
                            hy.expandByPoint(fy),
                            fy.addVectors(hy.max, py.max),
                            hy.expandByPoint(fy)) : (hy.expandByPoint(py.min),
                            hy.expandByPoint(py.max))
                        }
                    hy.getCenter(n);
                    let r = 0;
                    for (let t = 0, i = e.count; t < i; t++)
                        fy.fromBufferAttribute(e, t),
                        r = Math.max(r, n.distanceToSquared(fy));
                    if (t)
                        for (let i = 0, o = t.length; i < o; i++) {
                            const o = t[i]
                              , a = this.morphTargetsRelative;
                            for (let t = 0, i = o.count; t < i; t++)
                                fy.fromBufferAttribute(o, t),
                                a && (dy.fromBufferAttribute(e, t),
                                fy.add(dy)),
                                r = Math.max(r, n.distanceToSquared(fy))
                        }
                    this.boundingSphere.radius = Math.sqrt(r),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const e = this.index
                  , t = this.attributes;
                if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
                    return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = e.array
                  , r = t.position.array
                  , i = t.normal.array
                  , o = t.uv.array
                  , a = r.length / 3;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Qv(new Float32Array(4 * a),4));
                const s = this.getAttribute("tangent").array
                  , l = []
                  , c = [];
                for (let E = 0; E < a; E++)
                    l[E] = new Ag,
                    c[E] = new Ag;
                const u = new Ag
                  , d = new Ag
                  , h = new Ag
                  , p = new Hm
                  , f = new Hm
                  , m = new Hm
                  , g = new Ag
                  , v = new Ag;
                function y(e, t, n) {
                    u.fromArray(r, 3 * e),
                    d.fromArray(r, 3 * t),
                    h.fromArray(r, 3 * n),
                    p.fromArray(o, 2 * e),
                    f.fromArray(o, 2 * t),
                    m.fromArray(o, 2 * n),
                    d.sub(u),
                    h.sub(u),
                    f.sub(p),
                    m.sub(p);
                    const i = 1 / (f.x * m.y - m.x * f.y);
                    isFinite(i) && (g.copy(d).multiplyScalar(m.y).addScaledVector(h, -f.y).multiplyScalar(i),
                    v.copy(h).multiplyScalar(f.x).addScaledVector(d, -m.x).multiplyScalar(i),
                    l[e].add(g),
                    l[t].add(g),
                    l[n].add(g),
                    c[e].add(v),
                    c[t].add(v),
                    c[n].add(v))
                }
                let b = this.groups;
                0 === b.length && (b = [{
                    start: 0,
                    count: n.length
                }]);
                for (let E = 0, M = b.length; E < M; ++E) {
                    const e = b[E]
                      , t = e.start;
                    for (let r = t, i = t + e.count; r < i; r += 3)
                        y(n[r + 0], n[r + 1], n[r + 2])
                }
                const _ = new Ag
                  , A = new Ag
                  , x = new Ag
                  , S = new Ag;
                function w(e) {
                    x.fromArray(i, 3 * e),
                    S.copy(x);
                    const t = l[e];
                    _.copy(t),
                    _.sub(x.multiplyScalar(x.dot(t))).normalize(),
                    A.crossVectors(S, t);
                    const n = A.dot(c[e]) < 0 ? -1 : 1;
                    s[4 * e] = _.x,
                    s[4 * e + 1] = _.y,
                    s[4 * e + 2] = _.z,
                    s[4 * e + 3] = n
                }
                for (let E = 0, M = b.length; E < M; ++E) {
                    const e = b[E]
                      , t = e.start;
                    for (let r = t, i = t + e.count; r < i; r += 3)
                        w(n[r + 0]),
                        w(n[r + 1]),
                        w(n[r + 2])
                }
            }
            computeVertexNormals() {
                const e = this.index
                  , t = this.getAttribute("position");
                if (void 0 !== t) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n)
                        n = new Qv(new Float32Array(3 * t.count),3),
                        this.setAttribute("normal", n);
                    else
                        for (let e = 0, t = n.count; e < t; e++)
                            n.setXYZ(e, 0, 0, 0);
                    const r = new Ag
                      , i = new Ag
                      , o = new Ag
                      , a = new Ag
                      , s = new Ag
                      , l = new Ag
                      , c = new Ag
                      , u = new Ag;
                    if (e)
                        for (let d = 0, h = e.count; d < h; d += 3) {
                            const h = e.getX(d + 0)
                              , p = e.getX(d + 1)
                              , f = e.getX(d + 2);
                            r.fromBufferAttribute(t, h),
                            i.fromBufferAttribute(t, p),
                            o.fromBufferAttribute(t, f),
                            c.subVectors(o, i),
                            u.subVectors(r, i),
                            c.cross(u),
                            a.fromBufferAttribute(n, h),
                            s.fromBufferAttribute(n, p),
                            l.fromBufferAttribute(n, f),
                            a.add(c),
                            s.add(c),
                            l.add(c),
                            n.setXYZ(h, a.x, a.y, a.z),
                            n.setXYZ(p, s.x, s.y, s.z),
                            n.setXYZ(f, l.x, l.y, l.z)
                        }
                    else
                        for (let e = 0, d = t.count; e < d; e += 3)
                            r.fromBufferAttribute(t, e + 0),
                            i.fromBufferAttribute(t, e + 1),
                            o.fromBufferAttribute(t, e + 2),
                            c.subVectors(o, i),
                            u.subVectors(r, i),
                            c.cross(u),
                            n.setXYZ(e + 0, c.x, c.y, c.z),
                            n.setXYZ(e + 1, c.x, c.y, c.z),
                            n.setXYZ(e + 2, c.x, c.y, c.z);
                    this.normalizeNormals(),
                    n.needsUpdate = !0
                }
            }
            normalizeNormals() {
                const e = this.attributes.normal;
                for (let t = 0, n = e.count; t < n; t++)
                    fy.fromBufferAttribute(e, t),
                    fy.normalize(),
                    e.setXYZ(t, fy.x, fy.y, fy.z)
            }
            toNonIndexed() {
                function e(e, t) {
                    const n = e.array
                      , r = e.itemSize
                      , i = e.normalized
                      , o = new n.constructor(t.length * r);
                    let a = 0
                      , s = 0;
                    for (let l = 0, c = t.length; l < c; l++) {
                        a = e.isInterleavedBufferAttribute ? t[l] * e.data.stride + e.offset : t[l] * r;
                        for (let e = 0; e < r; e++)
                            o[s++] = n[a++]
                    }
                    return new Qv(o,r,i)
                }
                if (null === this.index)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                    this;
                const t = new my
                  , n = this.index.array
                  , r = this.attributes;
                for (const a in r) {
                    const i = e(r[a], n);
                    t.setAttribute(a, i)
                }
                const i = this.morphAttributes;
                for (const a in i) {
                    const r = []
                      , o = i[a];
                    for (let t = 0, i = o.length; t < i; t++) {
                        const i = e(o[t], n);
                        r.push(i)
                    }
                    t.morphAttributes[a] = r
                }
                t.morphTargetsRelative = this.morphTargetsRelative;
                const o = this.groups;
                for (let a = 0, s = o.length; a < s; a++) {
                    const e = o[a];
                    t.addGroup(e.start, e.count, e.materialIndex)
                }
                return t
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid,
                e.type = this.type,
                "" !== this.name && (e.name = this.name),
                Object.keys(this.userData).length > 0 && (e.userData = this.userData),
                void 0 !== this.parameters) {
                    const t = this.parameters;
                    for (const n in t)
                        void 0 !== t[n] && (e[n] = t[n]);
                    return e
                }
                e.data = {
                    attributes: {}
                };
                const t = this.index;
                null !== t && (e.data.index = {
                    type: t.array.constructor.name,
                    array: Array.prototype.slice.call(t.array)
                });
                const n = this.attributes;
                for (const s in n) {
                    const t = n[s];
                    e.data.attributes[s] = t.toJSON(e.data)
                }
                const r = {};
                let i = !1;
                for (const s in this.morphAttributes) {
                    const t = this.morphAttributes[s]
                      , n = [];
                    for (let r = 0, i = t.length; r < i; r++) {
                        const i = t[r];
                        n.push(i.toJSON(e.data))
                    }
                    n.length > 0 && (r[s] = n,
                    i = !0)
                }
                i && (e.data.morphAttributes = r,
                e.data.morphTargetsRelative = this.morphTargetsRelative);
                const o = this.groups;
                o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
                const a = this.boundingSphere;
                return null !== a && (e.data.boundingSphere = {
                    center: a.center.toArray(),
                    radius: a.radius
                }),
                e
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null;
                const t = {};
                this.name = e.name;
                const n = e.index;
                null !== n && this.setIndex(n.clone(t));
                const r = e.attributes;
                for (const l in r) {
                    const e = r[l];
                    this.setAttribute(l, e.clone(t))
                }
                const i = e.morphAttributes;
                for (const l in i) {
                    const e = []
                      , n = i[l];
                    for (let r = 0, i = n.length; r < i; r++)
                        e.push(n[r].clone(t));
                    this.morphAttributes[l] = e
                }
                this.morphTargetsRelative = e.morphTargetsRelative;
                const o = e.groups;
                for (let l = 0, c = o.length; l < c; l++) {
                    const e = o[l];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const a = e.boundingBox;
                null !== a && (this.boundingBox = a.clone());
                const s = e.boundingSphere;
                return null !== s && (this.boundingSphere = s.clone()),
                this.drawRange.start = e.drawRange.start,
                this.drawRange.count = e.drawRange.count,
                this.userData = e.userData,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const gy = new Qg
          , vy = new Yg
          , yy = new Hg
          , by = new Ag
          , _y = new Ag
          , Ay = new Ag
          , xy = new Ag
          , Sy = new Ag
          , wy = new Ag
          , Ey = new Hm
          , My = new Hm
          , Cy = new Hm
          , Ty = new Ag
          , Ry = new Ag
          , Py = new Ag
          , By = new Ag
          , Iy = new Ag;
        class Ly extends xv {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new my
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new jv;
                super(),
                this.isMesh = !0,
                this.type = "Mesh",
                this.geometry = e,
                this.material = t,
                this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t),
                void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
                void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                this.geometry = e.geometry,
                this
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes
                  , t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
            getVertexPosition(e, t) {
                const n = this.geometry
                  , r = n.attributes.position
                  , i = n.morphAttributes.position
                  , o = n.morphTargetsRelative;
                t.fromBufferAttribute(r, e);
                const a = this.morphTargetInfluences;
                if (i && a) {
                    wy.set(0, 0, 0);
                    for (let n = 0, r = i.length; n < r; n++) {
                        const r = a[n]
                          , s = i[n];
                        0 !== r && (Sy.fromBufferAttribute(s, e),
                        o ? wy.addScaledVector(Sy, r) : wy.addScaledVector(Sy.sub(t), r))
                    }
                    t.add(wy)
                }
                return t
            }
            raycast(e, t) {
                const n = this.geometry
                  , r = this.material
                  , i = this.matrixWorld;
                if (void 0 !== r) {
                    if (null === n.boundingSphere && n.computeBoundingSphere(),
                    yy.copy(n.boundingSphere),
                    yy.applyMatrix4(i),
                    vy.copy(e.ray).recast(e.near),
                    !1 === yy.containsPoint(vy.origin)) {
                        if (null === vy.intersectSphere(yy, by))
                            return;
                        if (vy.origin.distanceToSquared(by) > (e.far - e.near) ** 2)
                            return
                    }
                    gy.copy(i).invert(),
                    vy.copy(e.ray).applyMatrix4(gy),
                    null !== n.boundingBox && !1 === vy.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, vy)
                }
            }
            _computeIntersections(e, t, n) {
                let r;
                const i = this.geometry
                  , o = this.material
                  , a = i.index
                  , s = i.attributes.position
                  , l = i.attributes.uv
                  , c = i.attributes.uv1
                  , u = i.attributes.normal
                  , d = i.groups
                  , h = i.drawRange;
                if (null !== a)
                    if (Array.isArray(o))
                        for (let p = 0, f = d.length; p < f; p++) {
                            const i = d[p]
                              , s = o[i.materialIndex];
                            for (let o = Math.max(i.start, h.start), d = Math.min(a.count, Math.min(i.start + i.count, h.start + h.count)); o < d; o += 3) {
                                r = ky(this, s, e, n, l, c, u, a.getX(o), a.getX(o + 1), a.getX(o + 2)),
                                r && (r.faceIndex = Math.floor(o / 3),
                                r.face.materialIndex = i.materialIndex,
                                t.push(r))
                            }
                        }
                    else {
                        for (let i = Math.max(0, h.start), s = Math.min(a.count, h.start + h.count); i < s; i += 3) {
                            r = ky(this, o, e, n, l, c, u, a.getX(i), a.getX(i + 1), a.getX(i + 2)),
                            r && (r.faceIndex = Math.floor(i / 3),
                            t.push(r))
                        }
                    }
                else if (void 0 !== s)
                    if (Array.isArray(o))
                        for (let p = 0, f = d.length; p < f; p++) {
                            const i = d[p]
                              , a = o[i.materialIndex];
                            for (let o = Math.max(i.start, h.start), d = Math.min(s.count, Math.min(i.start + i.count, h.start + h.count)); o < d; o += 3) {
                                r = ky(this, a, e, n, l, c, u, o, o + 1, o + 2),
                                r && (r.faceIndex = Math.floor(o / 3),
                                r.face.materialIndex = i.materialIndex,
                                t.push(r))
                            }
                        }
                    else {
                        for (let i = Math.max(0, h.start), a = Math.min(s.count, h.start + h.count); i < a; i += 3) {
                            r = ky(this, o, e, n, l, c, u, i, i + 1, i + 2),
                            r && (r.faceIndex = Math.floor(i / 3),
                            t.push(r))
                        }
                    }
            }
        }
        function ky(e, t, n, r, i, o, a, s, l, c) {
            e.getVertexPosition(s, _y),
            e.getVertexPosition(l, Ay),
            e.getVertexPosition(c, xy);
            const u = function(e, t, n, r, i, o, a, s) {
                let l;
                if (l = t.side === th ? r.intersectTriangle(a, o, i, !0, s) : r.intersectTriangle(i, o, a, t.side === eh, s),
                null === l)
                    return null;
                Iy.copy(s),
                Iy.applyMatrix4(e.matrixWorld);
                const c = n.ray.origin.distanceTo(Iy);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: Iy.clone(),
                    object: e
                }
            }(e, t, n, r, _y, Ay, xy, By);
            if (u) {
                i && (Ey.fromBufferAttribute(i, s),
                My.fromBufferAttribute(i, l),
                Cy.fromBufferAttribute(i, c),
                u.uv = kv.getInterpolation(By, _y, Ay, xy, Ey, My, Cy, new Hm)),
                o && (Ey.fromBufferAttribute(o, s),
                My.fromBufferAttribute(o, l),
                Cy.fromBufferAttribute(o, c),
                u.uv1 = kv.getInterpolation(By, _y, Ay, xy, Ey, My, Cy, new Hm),
                u.uv2 = u.uv1),
                a && (Ty.fromBufferAttribute(a, s),
                Ry.fromBufferAttribute(a, l),
                Py.fromBufferAttribute(a, c),
                u.normal = kv.getInterpolation(By, _y, Ay, xy, Ty, Ry, Py, new Ag),
                u.normal.dot(r.direction) > 0 && u.normal.multiplyScalar(-1));
                const e = {
                    a: s,
                    b: l,
                    c: c,
                    normal: new Ag,
                    materialIndex: 0
                };
                kv.getNormal(_y, Ay, xy, e.normal),
                u.face = e
            }
            return u
        }
        class Dy extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1
                  , o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: r,
                    heightSegments: i,
                    depthSegments: o
                };
                const a = this;
                r = Math.floor(r),
                i = Math.floor(i),
                o = Math.floor(o);
                const s = []
                  , l = []
                  , c = []
                  , u = [];
                let d = 0
                  , h = 0;
                function p(e, t, n, r, i, o, p, f, m, g, v) {
                    const y = o / m
                      , b = p / g
                      , _ = o / 2
                      , A = p / 2
                      , x = f / 2
                      , S = m + 1
                      , w = g + 1;
                    let E = 0
                      , M = 0;
                    const C = new Ag;
                    for (let a = 0; a < w; a++) {
                        const o = a * b - A;
                        for (let s = 0; s < S; s++) {
                            const d = s * y - _;
                            C[e] = d * r,
                            C[t] = o * i,
                            C[n] = x,
                            l.push(C.x, C.y, C.z),
                            C[e] = 0,
                            C[t] = 0,
                            C[n] = f > 0 ? 1 : -1,
                            c.push(C.x, C.y, C.z),
                            u.push(s / m),
                            u.push(1 - a / g),
                            E += 1
                        }
                    }
                    for (let a = 0; a < g; a++)
                        for (let e = 0; e < m; e++) {
                            const t = d + e + S * a
                              , n = d + e + S * (a + 1)
                              , r = d + (e + 1) + S * (a + 1)
                              , i = d + (e + 1) + S * a;
                            s.push(t, n, i),
                            s.push(n, r, i),
                            M += 6
                        }
                    a.addGroup(h, M, v),
                    h += M,
                    d += E
                }
                p("z", "y", "x", -1, -1, n, t, e, o, i, 0),
                p("z", "y", "x", 1, -1, n, t, -e, o, i, 1),
                p("x", "z", "y", 1, 1, e, n, t, r, o, 2),
                p("x", "z", "y", 1, -1, e, n, -t, r, o, 3),
                p("x", "y", "z", 1, -1, e, t, n, r, i, 4),
                p("x", "y", "z", -1, -1, e, t, -n, r, i, 5),
                this.setIndex(s),
                this.setAttribute("position", new ay(l,3)),
                this.setAttribute("normal", new ay(c,3)),
                this.setAttribute("uv", new ay(u,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new Dy(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
            }
        }
        function Oy(e) {
            const t = {};
            for (const n in e) {
                t[n] = {};
                for (const r in e[n]) {
                    const i = e[n][r];
                    i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                    t[n][r] = null) : t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
                }
            }
            return t
        }
        function Ny(e) {
            const t = {};
            for (let n = 0; n < e.length; n++) {
                const r = Oy(e[n]);
                for (const e in r)
                    t[e] = r[e]
            }
            return t
        }
        function Fy(e) {
            return null === e.getRenderTarget() ? e.outputColorSpace : ng.workingColorSpace
        }
        const Uy = {
            clone: Oy,
            merge: Ny
        };
        class zy extends Hv {
            constructor(e) {
                super(),
                this.isShaderMaterial = !0,
                this.type = "ShaderMaterial",
                this.defines = {},
                this.uniforms = {},
                this.uniformsGroups = [],
                this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.forceSinglePass = !0,
                this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                },
                this.index0AttributeName = void 0,
                this.uniformsNeedUpdate = !1,
                this.glslVersion = null,
                void 0 !== e && this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.fragmentShader = e.fragmentShader,
                this.vertexShader = e.vertexShader,
                this.uniforms = Oy(e.uniforms),
                this.uniformsGroups = function(e) {
                    const t = [];
                    for (let n = 0; n < e.length; n++)
                        t.push(e[n].clone());
                    return t
                }(e.uniformsGroups),
                this.defines = Object.assign({}, e.defines),
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.fog = e.fog,
                this.lights = e.lights,
                this.clipping = e.clipping,
                this.extensions = Object.assign({}, e.extensions),
                this.glslVersion = e.glslVersion,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                t.glslVersion = this.glslVersion,
                t.uniforms = {};
                for (const r in this.uniforms) {
                    const n = this.uniforms[r].value;
                    n && n.isTexture ? t.uniforms[r] = {
                        type: "t",
                        value: n.toJSON(e).uuid
                    } : n && n.isColor ? t.uniforms[r] = {
                        type: "c",
                        value: n.getHex()
                    } : n && n.isVector2 ? t.uniforms[r] = {
                        type: "v2",
                        value: n.toArray()
                    } : n && n.isVector3 ? t.uniforms[r] = {
                        type: "v3",
                        value: n.toArray()
                    } : n && n.isVector4 ? t.uniforms[r] = {
                        type: "v4",
                        value: n.toArray()
                    } : n && n.isMatrix3 ? t.uniforms[r] = {
                        type: "m3",
                        value: n.toArray()
                    } : n && n.isMatrix4 ? t.uniforms[r] = {
                        type: "m4",
                        value: n.toArray()
                    } : t.uniforms[r] = {
                        value: n
                    }
                }
                Object.keys(this.defines).length > 0 && (t.defines = this.defines),
                t.vertexShader = this.vertexShader,
                t.fragmentShader = this.fragmentShader,
                t.lights = this.lights,
                t.clipping = this.clipping;
                const n = {};
                for (const r in this.extensions)
                    !0 === this.extensions[r] && (n[r] = !0);
                return Object.keys(n).length > 0 && (t.extensions = n),
                t
            }
        }
        class Gy extends xv {
            constructor() {
                super(),
                this.isCamera = !0,
                this.type = "Camera",
                this.matrixWorldInverse = new Qg,
                this.projectionMatrix = new Qg,
                this.projectionMatrixInverse = new Qg,
                this.coordinateSystem = Mm
            }
            copy(e, t) {
                return super.copy(e, t),
                this.matrixWorldInverse.copy(e.matrixWorldInverse),
                this.projectionMatrix.copy(e.projectionMatrix),
                this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                this.coordinateSystem = e.coordinateSystem,
                this
            }
            getWorldDirection(e) {
                return super.getWorldDirection(e).negate()
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(e, t) {
                super.updateWorldMatrix(e, t),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Hy extends Gy {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 50
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2e3;
                super(),
                this.isPerspectiveCamera = !0,
                this.type = "PerspectiveCamera",
                this.fov = e,
                this.zoom = 1,
                this.near = n,
                this.far = r,
                this.focus = 10,
                this.aspect = t,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.fov = e.fov,
                this.zoom = e.zoom,
                this.near = e.near,
                this.far = e.far,
                this.focus = e.focus,
                this.aspect = e.aspect,
                this.view = null === e.view ? null : Object.assign({}, e.view),
                this.filmGauge = e.filmGauge,
                this.filmOffset = e.filmOffset,
                this
            }
            setFocalLength(e) {
                const t = .5 * this.getFilmHeight() / e;
                this.fov = 2 * Im * Math.atan(t),
                this.updateProjectionMatrix()
            }
            getFocalLength() {
                const e = Math.tan(.5 * Bm * this.fov);
                return .5 * this.getFilmHeight() / e
            }
            getEffectiveFOV() {
                return 2 * Im * Math.atan(Math.tan(.5 * Bm * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(e, t, n, r, i, o) {
                this.aspect = e / t,
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = e,
                this.view.fullHeight = t,
                this.view.offsetX = n,
                this.view.offsetY = r,
                this.view.width = i,
                this.view.height = o,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = this.near;
                let t = e * Math.tan(.5 * Bm * this.fov) / this.zoom
                  , n = 2 * t
                  , r = this.aspect * n
                  , i = -.5 * r;
                const o = this.view;
                if (null !== this.view && this.view.enabled) {
                    const e = o.fullWidth
                      , a = o.fullHeight;
                    i += o.offsetX * r / e,
                    t -= o.offsetY * n / a,
                    r *= o.width / e,
                    n *= o.height / a
                }
                const a = this.filmOffset;
                0 !== a && (i += e * a / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.fov = this.fov,
                t.object.zoom = this.zoom,
                t.object.near = this.near,
                t.object.far = this.far,
                t.object.focus = this.focus,
                t.object.aspect = this.aspect,
                null !== this.view && (t.object.view = Object.assign({}, this.view)),
                t.object.filmGauge = this.filmGauge,
                t.object.filmOffset = this.filmOffset,
                t
            }
        }
        const jy = -90;
        class Wy extends xv {
            constructor(e, t, n) {
                super(),
                this.type = "CubeCamera",
                this.renderTarget = n,
                this.coordinateSystem = null,
                this.activeMipmapLevel = 0;
                const r = new Hy(jy,1,e,t);
                r.layers = this.layers,
                this.add(r);
                const i = new Hy(jy,1,e,t);
                i.layers = this.layers,
                this.add(i);
                const o = new Hy(jy,1,e,t);
                o.layers = this.layers,
                this.add(o);
                const a = new Hy(jy,1,e,t);
                a.layers = this.layers,
                this.add(a);
                const s = new Hy(jy,1,e,t);
                s.layers = this.layers,
                this.add(s);
                const l = new Hy(jy,1,e,t);
                l.layers = this.layers,
                this.add(l)
            }
            updateCoordinateSystem() {
                const e = this.coordinateSystem
                  , t = this.children.concat()
                  , [n,r,i,o,a,s] = t;
                for (const l of t)
                    this.remove(l);
                if (e === Mm)
                    n.up.set(0, 1, 0),
                    n.lookAt(1, 0, 0),
                    r.up.set(0, 1, 0),
                    r.lookAt(-1, 0, 0),
                    i.up.set(0, 0, -1),
                    i.lookAt(0, 1, 0),
                    o.up.set(0, 0, 1),
                    o.lookAt(0, -1, 0),
                    a.up.set(0, 1, 0),
                    a.lookAt(0, 0, 1),
                    s.up.set(0, 1, 0),
                    s.lookAt(0, 0, -1);
                else {
                    if (e !== Cm)
                        throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                    n.up.set(0, -1, 0),
                    n.lookAt(-1, 0, 0),
                    r.up.set(0, -1, 0),
                    r.lookAt(1, 0, 0),
                    i.up.set(0, 0, 1),
                    i.lookAt(0, 1, 0),
                    o.up.set(0, 0, -1),
                    o.lookAt(0, -1, 0),
                    a.up.set(0, -1, 0),
                    a.lookAt(0, 0, 1),
                    s.up.set(0, -1, 0),
                    s.lookAt(0, 0, -1)
                }
                for (const l of t)
                    this.add(l),
                    l.updateMatrixWorld()
            }
            update(e, t) {
                null === this.parent && this.updateMatrixWorld();
                const {renderTarget: n, activeMipmapLevel: r} = this;
                this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
                this.updateCoordinateSystem());
                const [i,o,a,s,l,c] = this.children
                  , u = e.getRenderTarget()
                  , d = e.getActiveCubeFace()
                  , h = e.getActiveMipmapLevel()
                  , p = e.xr.enabled;
                e.xr.enabled = !1;
                const f = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1,
                e.setRenderTarget(n, 0, r),
                e.render(t, i),
                e.setRenderTarget(n, 1, r),
                e.render(t, o),
                e.setRenderTarget(n, 2, r),
                e.render(t, a),
                e.setRenderTarget(n, 3, r),
                e.render(t, s),
                e.setRenderTarget(n, 4, r),
                e.render(t, l),
                n.texture.generateMipmaps = f,
                e.setRenderTarget(n, 5, r),
                e.render(t, c),
                e.setRenderTarget(u, d, h),
                e.xr.enabled = p,
                n.texture.needsPMREMUpdate = !0
            }
        }
        class Vy extends dg {
            constructor(e, t, n, r, i, o, a, s, l, c) {
                super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : Yh, n, r, i, o, a, s, l, c),
                this.isCubeTexture = !0,
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(e) {
                this.image = e
            }
        }
        class Xy extends fg {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                super(e, e, t),
                this.isWebGLCubeRenderTarget = !0;
                const n = {
                    width: e,
                    height: e,
                    depth: 1
                }
                  , r = [n, n, n, n, n, n];
                void 0 !== t.encoding && (Qm("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),
                t.colorSpace = t.encoding === Pf ? Of : Df),
                this.texture = new Vy(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
                this.texture.isRenderTargetTexture = !0,
                this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps,
                this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : cp
            }
            fromEquirectangularTexture(e, t) {
                this.texture.type = t.type,
                this.texture.colorSpace = t.colorSpace,
                this.texture.generateMipmaps = t.generateMipmaps,
                this.texture.minFilter = t.minFilter,
                this.texture.magFilter = t.magFilter;
                const n = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                }
                  , r = new Dy(5,5,5)
                  , i = new zy({
                    name: "CubemapFromEquirect",
                    uniforms: Oy(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: th,
                    blending: ih
                });
                i.uniforms.tEquirect.value = t;
                const o = new Ly(r,i)
                  , a = t.minFilter;
                t.minFilter === hp && (t.minFilter = cp);
                return new Wy(1,10,this).update(e, o),
                t.minFilter = a,
                o.geometry.dispose(),
                o.material.dispose(),
                this
            }
            clear(e, t, n, r) {
                const i = e.getRenderTarget();
                for (let o = 0; o < 6; o++)
                    e.setRenderTarget(this, o),
                    e.clear(t, n, r);
                e.setRenderTarget(i)
            }
        }
        const Jy = new Ag
          , Ky = new Ag
          , qy = new jm;
        class Yy {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Ag(1,0,0)
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.isPlane = !0,
                this.normal = e,
                this.constant = t
            }
            set(e, t) {
                return this.normal.copy(e),
                this.constant = t,
                this
            }
            setComponents(e, t, n, r) {
                return this.normal.set(e, t, n),
                this.constant = r,
                this
            }
            setFromNormalAndCoplanarPoint(e, t) {
                return this.normal.copy(e),
                this.constant = -t.dot(this.normal),
                this
            }
            setFromCoplanarPoints(e, t, n) {
                const r = Jy.subVectors(n, t).cross(Ky.subVectors(e, t)).normalize();
                return this.setFromNormalAndCoplanarPoint(r, e),
                this
            }
            copy(e) {
                return this.normal.copy(e.normal),
                this.constant = e.constant,
                this
            }
            normalize() {
                const e = 1 / this.normal.length();
                return this.normal.multiplyScalar(e),
                this.constant *= e,
                this
            }
            negate() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            }
            distanceToPoint(e) {
                return this.normal.dot(e) + this.constant
            }
            distanceToSphere(e) {
                return this.distanceToPoint(e.center) - e.radius
            }
            projectPoint(e, t) {
                return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
            }
            intersectLine(e, t) {
                const n = e.delta(Jy)
                  , r = this.normal.dot(n);
                if (0 === r)
                    return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                const i = -(e.start.dot(this.normal) + this.constant) / r;
                return i < 0 || i > 1 ? null : t.copy(e.start).addScaledVector(n, i)
            }
            intersectsLine(e) {
                const t = this.distanceToPoint(e.start)
                  , n = this.distanceToPoint(e.end);
                return t < 0 && n > 0 || n < 0 && t > 0
            }
            intersectsBox(e) {
                return e.intersectsPlane(this)
            }
            intersectsSphere(e) {
                return e.intersectsPlane(this)
            }
            coplanarPoint(e) {
                return e.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(e, t) {
                const n = t || qy.getNormalMatrix(e)
                  , r = this.coplanarPoint(Jy).applyMatrix4(e)
                  , i = this.normal.applyMatrix3(n).normalize();
                return this.constant = -r.dot(i),
                this
            }
            translate(e) {
                return this.constant -= e.dot(this.normal),
                this
            }
            equals(e) {
                return e.normal.equals(this.normal) && e.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Qy = new Hg
          , Zy = new Ag;
        class $y {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Yy
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Yy
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Yy
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new Yy
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : new Yy
                  , o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : new Yy;
                this.planes = [e, t, n, r, i, o]
            }
            set(e, t, n, r, i, o) {
                const a = this.planes;
                return a[0].copy(e),
                a[1].copy(t),
                a[2].copy(n),
                a[3].copy(r),
                a[4].copy(i),
                a[5].copy(o),
                this
            }
            copy(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    t[n].copy(e.planes[n]);
                return this
            }
            setFromProjectionMatrix(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Mm;
                const n = this.planes
                  , r = e.elements
                  , i = r[0]
                  , o = r[1]
                  , a = r[2]
                  , s = r[3]
                  , l = r[4]
                  , c = r[5]
                  , u = r[6]
                  , d = r[7]
                  , h = r[8]
                  , p = r[9]
                  , f = r[10]
                  , m = r[11]
                  , g = r[12]
                  , v = r[13]
                  , y = r[14]
                  , b = r[15];
                if (n[0].setComponents(s - i, d - l, m - h, b - g).normalize(),
                n[1].setComponents(s + i, d + l, m + h, b + g).normalize(),
                n[2].setComponents(s + o, d + c, m + p, b + v).normalize(),
                n[3].setComponents(s - o, d - c, m - p, b - v).normalize(),
                n[4].setComponents(s - a, d - u, m - f, b - y).normalize(),
                t === Mm)
                    n[5].setComponents(s + a, d + u, m + f, b + y).normalize();
                else {
                    if (t !== Cm)
                        throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                    n[5].setComponents(a, u, f, y).normalize()
                }
                return this
            }
            intersectsObject(e) {
                if (void 0 !== e.boundingSphere)
                    null === e.boundingSphere && e.computeBoundingSphere(),
                    Qy.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                else {
                    const t = e.geometry;
                    null === t.boundingSphere && t.computeBoundingSphere(),
                    Qy.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                }
                return this.intersectsSphere(Qy)
            }
            intersectsSprite(e) {
                return Qy.center.set(0, 0, 0),
                Qy.radius = .7071067811865476,
                Qy.applyMatrix4(e.matrixWorld),
                this.intersectsSphere(Qy)
            }
            intersectsSphere(e) {
                const t = this.planes
                  , n = e.center
                  , r = -e.radius;
                for (let i = 0; i < 6; i++) {
                    if (t[i].distanceToPoint(n) < r)
                        return !1
                }
                return !0
            }
            intersectsBox(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++) {
                    const r = t[n];
                    if (Zy.x = r.normal.x > 0 ? e.max.x : e.min.x,
                    Zy.y = r.normal.y > 0 ? e.max.y : e.min.y,
                    Zy.z = r.normal.z > 0 ? e.max.z : e.min.z,
                    r.distanceToPoint(Zy) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    if (t[n].distanceToPoint(e) < 0)
                        return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        function eb() {
            let e = null
              , t = !1
              , n = null
              , r = null;
            function i(t, o) {
                n(t, o),
                r = e.requestAnimationFrame(i)
            }
            return {
                start: function() {
                    !0 !== t && null !== n && (r = e.requestAnimationFrame(i),
                    t = !0)
                },
                stop: function() {
                    e.cancelAnimationFrame(r),
                    t = !1
                },
                setAnimationLoop: function(e) {
                    n = e
                },
                setContext: function(t) {
                    e = t
                }
            }
        }
        function tb(e, t) {
            const n = t.isWebGL2
              , r = new WeakMap;
            return {
                get: function(e) {
                    return e.isInterleavedBufferAttribute && (e = e.data),
                    r.get(e)
                },
                remove: function(t) {
                    t.isInterleavedBufferAttribute && (t = t.data);
                    const n = r.get(t);
                    n && (e.deleteBuffer(n.buffer),
                    r.delete(t))
                },
                update: function(t, i) {
                    if (t.isGLBufferAttribute) {
                        const e = r.get(t);
                        return void ((!e || e.version < t.version) && r.set(t, {
                            buffer: t.buffer,
                            type: t.type,
                            bytesPerElement: t.elementSize,
                            version: t.version
                        }))
                    }
                    t.isInterleavedBufferAttribute && (t = t.data);
                    const o = r.get(t);
                    if (void 0 === o)
                        r.set(t, function(t, r) {
                            const i = t.array
                              , o = t.usage
                              , a = i.byteLength
                              , s = e.createBuffer();
                            let l;
                            if (e.bindBuffer(r, s),
                            e.bufferData(r, i, o),
                            t.onUploadCallback(),
                            i instanceof Float32Array)
                                l = e.FLOAT;
                            else if (i instanceof Uint16Array)
                                if (t.isFloat16BufferAttribute) {
                                    if (!n)
                                        throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                    l = e.HALF_FLOAT
                                } else
                                    l = e.UNSIGNED_SHORT;
                            else if (i instanceof Int16Array)
                                l = e.SHORT;
                            else if (i instanceof Uint32Array)
                                l = e.UNSIGNED_INT;
                            else if (i instanceof Int32Array)
                                l = e.INT;
                            else if (i instanceof Int8Array)
                                l = e.BYTE;
                            else if (i instanceof Uint8Array)
                                l = e.UNSIGNED_BYTE;
                            else {
                                if (!(i instanceof Uint8ClampedArray))
                                    throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                                l = e.UNSIGNED_BYTE
                            }
                            return {
                                buffer: s,
                                type: l,
                                bytesPerElement: i.BYTES_PER_ELEMENT,
                                version: t.version,
                                size: a
                            }
                        }(t, i));
                    else if (o.version < t.version) {
                        if (o.size !== t.array.byteLength)
                            throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                        !function(t, r, i) {
                            const o = r.array
                              , a = r._updateRange
                              , s = r.updateRanges;
                            if (e.bindBuffer(i, t),
                            -1 === a.count && 0 === s.length && e.bufferSubData(i, 0, o),
                            0 !== s.length) {
                                for (let t = 0, r = s.length; t < r; t++) {
                                    const r = s[t];
                                    n ? e.bufferSubData(i, r.start * o.BYTES_PER_ELEMENT, o, r.start, r.count) : e.bufferSubData(i, r.start * o.BYTES_PER_ELEMENT, o.subarray(r.start, r.start + r.count))
                                }
                                r.clearUpdateRanges()
                            }
                            -1 !== a.count && (n ? e.bufferSubData(i, a.offset * o.BYTES_PER_ELEMENT, o, a.offset, a.count) : e.bufferSubData(i, a.offset * o.BYTES_PER_ELEMENT, o.subarray(a.offset, a.offset + a.count)),
                            a.count = -1),
                            r.onUploadCallback()
                        }(o.buffer, t, i),
                        o.version = t.version
                    }
                }
            }
        }
        class nb extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                super(),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: r
                };
                const i = e / 2
                  , o = t / 2
                  , a = Math.floor(n)
                  , s = Math.floor(r)
                  , l = a + 1
                  , c = s + 1
                  , u = e / a
                  , d = t / s
                  , h = []
                  , p = []
                  , f = []
                  , m = [];
                for (let g = 0; g < c; g++) {
                    const e = g * d - o;
                    for (let t = 0; t < l; t++) {
                        const n = t * u - i;
                        p.push(n, -e, 0),
                        f.push(0, 0, 1),
                        m.push(t / a),
                        m.push(1 - g / s)
                    }
                }
                for (let g = 0; g < s; g++)
                    for (let e = 0; e < a; e++) {
                        const t = e + l * g
                          , n = e + l * (g + 1)
                          , r = e + 1 + l * (g + 1)
                          , i = e + 1 + l * g;
                        h.push(t, n, i),
                        h.push(n, r, i)
                    }
                this.setIndex(h),
                this.setAttribute("position", new ay(p,3)),
                this.setAttribute("normal", new ay(f,3)),
                this.setAttribute("uv", new ay(m,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new nb(e.width,e.height,e.widthSegments,e.heightSegments)
            }
        }
        const rb = {
            alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
            alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
            alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            batching_pars_vertex: "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
            batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
            iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
            lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
            normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
            iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
            opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
            transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
            uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
        }
          , ib = {
            common: {
                diffuse: {
                    value: new Uv(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new jm
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new jm
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                },
                specularMapTransform: {
                    value: new jm
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                },
                aoMapTransform: {
                    value: new jm
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                },
                lightMapTransform: {
                    value: new jm
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpMapTransform: {
                    value: new jm
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalMapTransform: {
                    value: new jm
                },
                normalScale: {
                    value: new Hm(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementMapTransform: {
                    value: new jm
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                },
                emissiveMapTransform: {
                    value: new jm
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                },
                metalnessMapTransform: {
                    value: new jm
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                },
                roughnessMapTransform: {
                    value: new jm
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new Uv(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotLightMap: {
                    value: []
                },
                spotShadowMap: {
                    value: []
                },
                spotLightMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new Uv(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new jm
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new jm
                }
            },
            sprite: {
                diffuse: {
                    value: new Uv(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new Hm(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new jm
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new jm
                },
                alphaTest: {
                    value: 0
                }
            }
        }
          , ob = {
            basic: {
                uniforms: Ny([ib.common, ib.specularmap, ib.envmap, ib.aomap, ib.lightmap, ib.fog]),
                vertexShader: rb.meshbasic_vert,
                fragmentShader: rb.meshbasic_frag
            },
            lambert: {
                uniforms: Ny([ib.common, ib.specularmap, ib.envmap, ib.aomap, ib.lightmap, ib.emissivemap, ib.bumpmap, ib.normalmap, ib.displacementmap, ib.fog, ib.lights, {
                    emissive: {
                        value: new Uv(0)
                    }
                }]),
                vertexShader: rb.meshlambert_vert,
                fragmentShader: rb.meshlambert_frag
            },
            phong: {
                uniforms: Ny([ib.common, ib.specularmap, ib.envmap, ib.aomap, ib.lightmap, ib.emissivemap, ib.bumpmap, ib.normalmap, ib.displacementmap, ib.fog, ib.lights, {
                    emissive: {
                        value: new Uv(0)
                    },
                    specular: {
                        value: new Uv(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: rb.meshphong_vert,
                fragmentShader: rb.meshphong_frag
            },
            standard: {
                uniforms: Ny([ib.common, ib.envmap, ib.aomap, ib.lightmap, ib.emissivemap, ib.bumpmap, ib.normalmap, ib.displacementmap, ib.roughnessmap, ib.metalnessmap, ib.fog, ib.lights, {
                    emissive: {
                        value: new Uv(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: rb.meshphysical_vert,
                fragmentShader: rb.meshphysical_frag
            },
            toon: {
                uniforms: Ny([ib.common, ib.aomap, ib.lightmap, ib.emissivemap, ib.bumpmap, ib.normalmap, ib.displacementmap, ib.gradientmap, ib.fog, ib.lights, {
                    emissive: {
                        value: new Uv(0)
                    }
                }]),
                vertexShader: rb.meshtoon_vert,
                fragmentShader: rb.meshtoon_frag
            },
            matcap: {
                uniforms: Ny([ib.common, ib.bumpmap, ib.normalmap, ib.displacementmap, ib.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: rb.meshmatcap_vert,
                fragmentShader: rb.meshmatcap_frag
            },
            points: {
                uniforms: Ny([ib.points, ib.fog]),
                vertexShader: rb.points_vert,
                fragmentShader: rb.points_frag
            },
            dashed: {
                uniforms: Ny([ib.common, ib.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: rb.linedashed_vert,
                fragmentShader: rb.linedashed_frag
            },
            depth: {
                uniforms: Ny([ib.common, ib.displacementmap]),
                vertexShader: rb.depth_vert,
                fragmentShader: rb.depth_frag
            },
            normal: {
                uniforms: Ny([ib.common, ib.bumpmap, ib.normalmap, ib.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: rb.meshnormal_vert,
                fragmentShader: rb.meshnormal_frag
            },
            sprite: {
                uniforms: Ny([ib.sprite, ib.fog]),
                vertexShader: rb.sprite_vert,
                fragmentShader: rb.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new jm
                    },
                    t2D: {
                        value: null
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: rb.background_vert,
                fragmentShader: rb.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    backgroundBlurriness: {
                        value: 0
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: rb.backgroundCube_vert,
                fragmentShader: rb.backgroundCube_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: rb.cube_vert,
                fragmentShader: rb.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: rb.equirect_vert,
                fragmentShader: rb.equirect_frag
            },
            distanceRGBA: {
                uniforms: Ny([ib.common, ib.displacementmap, {
                    referencePosition: {
                        value: new Ag
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: rb.distanceRGBA_vert,
                fragmentShader: rb.distanceRGBA_frag
            },
            shadow: {
                uniforms: Ny([ib.lights, ib.fog, {
                    color: {
                        value: new Uv(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: rb.shadow_vert,
                fragmentShader: rb.shadow_frag
            }
        };
        ob.physical = {
            uniforms: Ny([ob.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new jm
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new jm
                },
                clearcoatNormalScale: {
                    value: new Hm(1,1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new jm
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new jm
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new jm
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new Uv(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new jm
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new jm
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new jm
                },
                transmissionSamplerSize: {
                    value: new Hm
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new jm
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new Uv(0)
                },
                specularColor: {
                    value: new Uv(1,1,1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new jm
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new jm
                },
                anisotropyVector: {
                    value: new Hm
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new jm
                }
            }]),
            vertexShader: rb.meshphysical_vert,
            fragmentShader: rb.meshphysical_frag
        };
        const ab = {
            r: 0,
            b: 0,
            g: 0
        };
        function sb(e, t, n, r, i, o, a) {
            const s = new Uv(0);
            let l, c, u = !0 === o ? 0 : 1, d = null, h = 0, p = null;
            function f(t, n) {
                t.getRGB(ab, Fy(e)),
                r.buffers.color.setClear(ab.r, ab.g, ab.b, n, a)
            }
            return {
                getClearColor: function() {
                    return s
                },
                setClearColor: function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                    s.set(e),
                    u = t,
                    f(s, u)
                },
                getClearAlpha: function() {
                    return u
                },
                setClearAlpha: function(e) {
                    u = e,
                    f(s, u)
                },
                render: function(o, m) {
                    let g = !1
                      , v = !0 === m.isScene ? m.background : null;
                    if (v && v.isTexture) {
                        v = (m.backgroundBlurriness > 0 ? n : t).get(v)
                    }
                    null === v ? f(s, u) : v && v.isColor && (f(v, 1),
                    g = !0);
                    const y = e.xr.getEnvironmentBlendMode();
                    "additive" === y ? r.buffers.color.setClear(0, 0, 0, 1, a) : "alpha-blend" === y && r.buffers.color.setClear(0, 0, 0, 0, a),
                    (e.autoClear || g) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
                    v && (v.isCubeTexture || v.mapping === ep) ? (void 0 === c && (c = new Ly(new Dy(1,1,1),new zy({
                        name: "BackgroundCubeMaterial",
                        uniforms: Oy(ob.backgroundCube.uniforms),
                        vertexShader: ob.backgroundCube.vertexShader,
                        fragmentShader: ob.backgroundCube.fragmentShader,
                        side: th,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    c.geometry.deleteAttribute("normal"),
                    c.geometry.deleteAttribute("uv"),
                    c.onBeforeRender = function(e, t, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }
                    ,
                    Object.defineProperty(c.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }),
                    i.update(c)),
                    c.material.uniforms.envMap.value = v,
                    c.material.uniforms.flipEnvMap.value = v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1,
                    c.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness,
                    c.material.uniforms.backgroundIntensity.value = m.backgroundIntensity,
                    c.material.toneMapped = ng.getTransfer(v.colorSpace) !== Gf,
                    d === v && h === v.version && p === e.toneMapping || (c.material.needsUpdate = !0,
                    d = v,
                    h = v.version,
                    p = e.toneMapping),
                    c.layers.enableAll(),
                    o.unshift(c, c.geometry, c.material, 0, 0, null)) : v && v.isTexture && (void 0 === l && (l = new Ly(new nb(2,2),new zy({
                        name: "BackgroundMaterial",
                        uniforms: Oy(ob.background.uniforms),
                        vertexShader: ob.background.vertexShader,
                        fragmentShader: ob.background.fragmentShader,
                        side: eh,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    l.geometry.deleteAttribute("normal"),
                    Object.defineProperty(l.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }),
                    i.update(l)),
                    l.material.uniforms.t2D.value = v,
                    l.material.uniforms.backgroundIntensity.value = m.backgroundIntensity,
                    l.material.toneMapped = ng.getTransfer(v.colorSpace) !== Gf,
                    !0 === v.matrixAutoUpdate && v.updateMatrix(),
                    l.material.uniforms.uvTransform.value.copy(v.matrix),
                    d === v && h === v.version && p === e.toneMapping || (l.material.needsUpdate = !0,
                    d = v,
                    h = v.version,
                    p = e.toneMapping),
                    l.layers.enableAll(),
                    o.unshift(l, l.geometry, l.material, 0, 0, null))
                }
            }
        }
        function lb(e, t, n, r) {
            const i = e.getParameter(e.MAX_VERTEX_ATTRIBS)
              , o = r.isWebGL2 ? null : t.get("OES_vertex_array_object")
              , a = r.isWebGL2 || null !== o
              , s = {}
              , l = p(null);
            let c = l
              , u = !1;
            function d(t) {
                return r.isWebGL2 ? e.bindVertexArray(t) : o.bindVertexArrayOES(t)
            }
            function h(t) {
                return r.isWebGL2 ? e.deleteVertexArray(t) : o.deleteVertexArrayOES(t)
            }
            function p(e) {
                const t = []
                  , n = []
                  , r = [];
                for (let o = 0; o < i; o++)
                    t[o] = 0,
                    n[o] = 0,
                    r[o] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: t,
                    enabledAttributes: n,
                    attributeDivisors: r,
                    object: e,
                    attributes: {},
                    index: null
                }
            }
            function f() {
                const e = c.newAttributes;
                for (let t = 0, n = e.length; t < n; t++)
                    e[t] = 0
            }
            function m(e) {
                g(e, 0)
            }
            function g(n, i) {
                const o = c.newAttributes
                  , a = c.enabledAttributes
                  , s = c.attributeDivisors;
                if (o[n] = 1,
                0 === a[n] && (e.enableVertexAttribArray(n),
                a[n] = 1),
                s[n] !== i) {
                    (r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i),
                    s[n] = i
                }
            }
            function v() {
                const t = c.newAttributes
                  , n = c.enabledAttributes;
                for (let r = 0, i = n.length; r < i; r++)
                    n[r] !== t[r] && (e.disableVertexAttribArray(r),
                    n[r] = 0)
            }
            function y(t, n, r, i, o, a, s) {
                !0 === s ? e.vertexAttribIPointer(t, n, r, o, a) : e.vertexAttribPointer(t, n, r, i, o, a)
            }
            function b() {
                _(),
                u = !0,
                c !== l && (c = l,
                d(c.object))
            }
            function _() {
                l.geometry = null,
                l.program = null,
                l.wireframe = !1
            }
            return {
                setup: function(i, l, h, b, _) {
                    let A = !1;
                    if (a) {
                        const t = function(t, n, i) {
                            const a = !0 === i.wireframe;
                            let l = s[t.id];
                            void 0 === l && (l = {},
                            s[t.id] = l);
                            let c = l[n.id];
                            void 0 === c && (c = {},
                            l[n.id] = c);
                            let u = c[a];
                            void 0 === u && (u = p(r.isWebGL2 ? e.createVertexArray() : o.createVertexArrayOES()),
                            c[a] = u);
                            return u
                        }(b, h, l);
                        c !== t && (c = t,
                        d(c.object)),
                        A = function(e, t, n, r) {
                            const i = c.attributes
                              , o = t.attributes;
                            let a = 0;
                            const s = n.getAttributes();
                            for (const l in s) {
                                if (s[l].location >= 0) {
                                    const t = i[l];
                                    let n = o[l];
                                    if (void 0 === n && ("instanceMatrix" === l && e.instanceMatrix && (n = e.instanceMatrix),
                                    "instanceColor" === l && e.instanceColor && (n = e.instanceColor)),
                                    void 0 === t)
                                        return !0;
                                    if (t.attribute !== n)
                                        return !0;
                                    if (n && t.data !== n.data)
                                        return !0;
                                    a++
                                }
                            }
                            return c.attributesNum !== a || c.index !== r
                        }(i, b, h, _),
                        A && function(e, t, n, r) {
                            const i = {}
                              , o = t.attributes;
                            let a = 0;
                            const s = n.getAttributes();
                            for (const l in s) {
                                if (s[l].location >= 0) {
                                    let t = o[l];
                                    void 0 === t && ("instanceMatrix" === l && e.instanceMatrix && (t = e.instanceMatrix),
                                    "instanceColor" === l && e.instanceColor && (t = e.instanceColor));
                                    const n = {};
                                    n.attribute = t,
                                    t && t.data && (n.data = t.data),
                                    i[l] = n,
                                    a++
                                }
                            }
                            c.attributes = i,
                            c.attributesNum = a,
                            c.index = r
                        }(i, b, h, _)
                    } else {
                        const e = !0 === l.wireframe;
                        c.geometry === b.id && c.program === h.id && c.wireframe === e || (c.geometry = b.id,
                        c.program = h.id,
                        c.wireframe = e,
                        A = !0)
                    }
                    null !== _ && n.update(_, e.ELEMENT_ARRAY_BUFFER),
                    (A || u) && (u = !1,
                    function(i, o, a, s) {
                        if (!1 === r.isWebGL2 && (i.isInstancedMesh || s.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays"))
                            return;
                        f();
                        const l = s.attributes
                          , c = a.getAttributes()
                          , u = o.defaultAttributeValues;
                        for (const t in c) {
                            const o = c[t];
                            if (o.location >= 0) {
                                let a = l[t];
                                if (void 0 === a && ("instanceMatrix" === t && i.instanceMatrix && (a = i.instanceMatrix),
                                "instanceColor" === t && i.instanceColor && (a = i.instanceColor)),
                                void 0 !== a) {
                                    const t = a.normalized
                                      , l = a.itemSize
                                      , c = n.get(a);
                                    if (void 0 === c)
                                        continue;
                                    const u = c.buffer
                                      , d = c.type
                                      , h = c.bytesPerElement
                                      , p = !0 === r.isWebGL2 && (d === e.INT || d === e.UNSIGNED_INT || a.gpuType === yp);
                                    if (a.isInterleavedBufferAttribute) {
                                        const n = a.data
                                          , r = n.stride
                                          , c = a.offset;
                                        if (n.isInstancedInterleavedBuffer) {
                                            for (let e = 0; e < o.locationSize; e++)
                                                g(o.location + e, n.meshPerAttribute);
                                            !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else
                                            for (let e = 0; e < o.locationSize; e++)
                                                m(o.location + e);
                                        e.bindBuffer(e.ARRAY_BUFFER, u);
                                        for (let e = 0; e < o.locationSize; e++)
                                            y(o.location + e, l / o.locationSize, d, t, r * h, (c + l / o.locationSize * e) * h, p)
                                    } else {
                                        if (a.isInstancedBufferAttribute) {
                                            for (let e = 0; e < o.locationSize; e++)
                                                g(o.location + e, a.meshPerAttribute);
                                            !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = a.meshPerAttribute * a.count)
                                        } else
                                            for (let e = 0; e < o.locationSize; e++)
                                                m(o.location + e);
                                        e.bindBuffer(e.ARRAY_BUFFER, u);
                                        for (let e = 0; e < o.locationSize; e++)
                                            y(o.location + e, l / o.locationSize, d, t, l * h, l / o.locationSize * e * h, p)
                                    }
                                } else if (void 0 !== u) {
                                    const n = u[t];
                                    if (void 0 !== n)
                                        switch (n.length) {
                                        case 2:
                                            e.vertexAttrib2fv(o.location, n);
                                            break;
                                        case 3:
                                            e.vertexAttrib3fv(o.location, n);
                                            break;
                                        case 4:
                                            e.vertexAttrib4fv(o.location, n);
                                            break;
                                        default:
                                            e.vertexAttrib1fv(o.location, n)
                                        }
                                }
                            }
                        }
                        v()
                    }(i, l, h, b),
                    null !== _ && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n.get(_).buffer))
                },
                reset: b,
                resetDefaultState: _,
                dispose: function() {
                    b();
                    for (const e in s) {
                        const t = s[e];
                        for (const e in t) {
                            const n = t[e];
                            for (const e in n)
                                h(n[e].object),
                                delete n[e];
                            delete t[e]
                        }
                        delete s[e]
                    }
                },
                releaseStatesOfGeometry: function(e) {
                    if (void 0 === s[e.id])
                        return;
                    const t = s[e.id];
                    for (const n in t) {
                        const e = t[n];
                        for (const t in e)
                            h(e[t].object),
                            delete e[t];
                        delete t[n]
                    }
                    delete s[e.id]
                },
                releaseStatesOfProgram: function(e) {
                    for (const t in s) {
                        const n = s[t];
                        if (void 0 === n[e.id])
                            continue;
                        const r = n[e.id];
                        for (const e in r)
                            h(r[e].object),
                            delete r[e];
                        delete n[e.id]
                    }
                },
                initAttributes: f,
                enableAttribute: m,
                disableUnusedAttributes: v
            }
        }
        function cb(e, t, n, r) {
            const i = r.isWebGL2;
            let o;
            this.setMode = function(e) {
                o = e
            }
            ,
            this.render = function(t, r) {
                e.drawArrays(o, t, r),
                n.update(r, o, 1)
            }
            ,
            this.renderInstances = function(r, a, s) {
                if (0 === s)
                    return;
                let l, c;
                if (i)
                    l = e,
                    c = "drawArraysInstanced";
                else if (l = t.get("ANGLE_instanced_arrays"),
                c = "drawArraysInstancedANGLE",
                null === l)
                    return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                l[c](o, r, a, s),
                n.update(a, o, s)
            }
            ,
            this.renderMultiDraw = function(e, r, i) {
                if (0 === i)
                    return;
                const a = t.get("WEBGL_multi_draw");
                if (null === a)
                    for (let t = 0; t < i; t++)
                        this.render(e[t], r[t]);
                else {
                    a.multiDrawArraysWEBGL(o, e, 0, r, 0, i);
                    let t = 0;
                    for (let e = 0; e < i; e++)
                        t += r[e];
                    n.update(t, o, 1)
                }
            }
        }
        function ub(e, t, n) {
            let r;
            function i(t) {
                if ("highp" === t) {
                    if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
                        return "highp";
                    t = "mediump"
                }
                return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            const o = "undefined" !== typeof WebGL2RenderingContext && "WebGL2RenderingContext" === e.constructor.name;
            let a = void 0 !== n.precision ? n.precision : "highp";
            const s = i(a);
            s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."),
            a = s);
            const l = o || t.has("WEBGL_draw_buffers")
              , c = !0 === n.logarithmicDepthBuffer
              , u = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
              , d = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
              , h = e.getParameter(e.MAX_TEXTURE_SIZE)
              , p = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE)
              , f = e.getParameter(e.MAX_VERTEX_ATTRIBS)
              , m = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS)
              , g = e.getParameter(e.MAX_VARYING_VECTORS)
              , v = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)
              , y = d > 0
              , b = o || t.has("OES_texture_float");
            return {
                isWebGL2: o,
                drawBuffers: l,
                getMaxAnisotropy: function() {
                    if (void 0 !== r)
                        return r;
                    if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                        const n = t.get("EXT_texture_filter_anisotropic");
                        r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else
                        r = 0;
                    return r
                },
                getMaxPrecision: i,
                precision: a,
                logarithmicDepthBuffer: c,
                maxTextures: u,
                maxVertexTextures: d,
                maxTextureSize: h,
                maxCubemapSize: p,
                maxAttributes: f,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: v,
                vertexTextures: y,
                floatFragmentTextures: b,
                floatVertexTextures: y && b,
                maxSamples: o ? e.getParameter(e.MAX_SAMPLES) : 0
            }
        }
        function db(e) {
            const t = this;
            let n = null
              , r = 0
              , i = !1
              , o = !1;
            const a = new Yy
              , s = new jm
              , l = {
                value: null,
                needsUpdate: !1
            };
            function c(e, n, r, i) {
                const o = null !== e ? e.length : 0;
                let c = null;
                if (0 !== o) {
                    if (c = l.value,
                    !0 !== i || null === c) {
                        const t = r + 4 * o
                          , i = n.matrixWorldInverse;
                        s.getNormalMatrix(i),
                        (null === c || c.length < t) && (c = new Float32Array(t));
                        for (let n = 0, l = r; n !== o; ++n,
                        l += 4)
                            a.copy(e[n]).applyMatrix4(i, s),
                            a.normal.toArray(c, l),
                            c[l + 3] = a.constant
                    }
                    l.value = c,
                    l.needsUpdate = !0
                }
                return t.numPlanes = o,
                t.numIntersection = 0,
                c
            }
            this.uniform = l,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(e, t) {
                const n = 0 !== e.length || t || 0 !== r || i;
                return i = t,
                r = e.length,
                n
            }
            ,
            this.beginShadows = function() {
                o = !0,
                c(null)
            }
            ,
            this.endShadows = function() {
                o = !1
            }
            ,
            this.setGlobalState = function(e, t) {
                n = c(e, t, 0)
            }
            ,
            this.setState = function(a, s, u) {
                const d = a.clippingPlanes
                  , h = a.clipIntersection
                  , p = a.clipShadows
                  , f = e.get(a);
                if (!i || null === d || 0 === d.length || o && !p)
                    o ? c(null) : function() {
                        l.value !== n && (l.value = n,
                        l.needsUpdate = r > 0);
                        t.numPlanes = r,
                        t.numIntersection = 0
                    }();
                else {
                    const e = o ? 0 : r
                      , t = 4 * e;
                    let i = f.clippingState || null;
                    l.value = i,
                    i = c(d, s, t, u);
                    for (let r = 0; r !== t; ++r)
                        i[r] = n[r];
                    f.clippingState = i,
                    this.numIntersection = h ? this.numPlanes : 0,
                    this.numPlanes += e
                }
            }
        }
        function hb(e) {
            let t = new WeakMap;
            function n(e, t) {
                return t === Zh ? e.mapping = Yh : t === $h && (e.mapping = Qh),
                e
            }
            function r(e) {
                const n = e.target;
                n.removeEventListener("dispose", r);
                const i = t.get(n);
                void 0 !== i && (t.delete(n),
                i.dispose())
            }
            return {
                get: function(i) {
                    if (i && i.isTexture) {
                        const o = i.mapping;
                        if (o === Zh || o === $h) {
                            if (t.has(i)) {
                                return n(t.get(i).texture, i.mapping)
                            }
                            {
                                const o = i.image;
                                if (o && o.height > 0) {
                                    const a = new Xy(o.height / 2);
                                    return a.fromEquirectangularTexture(e, i),
                                    t.set(i, a),
                                    i.addEventListener("dispose", r),
                                    n(a.texture, i.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return i
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        class pb extends Gy {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .1
                  , o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2e3;
                super(),
                this.isOrthographicCamera = !0,
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = e,
                this.right = t,
                this.top = n,
                this.bottom = r,
                this.near = i,
                this.far = o,
                this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.left = e.left,
                this.right = e.right,
                this.top = e.top,
                this.bottom = e.bottom,
                this.near = e.near,
                this.far = e.far,
                this.zoom = e.zoom,
                this.view = null === e.view ? null : Object.assign({}, e.view),
                this
            }
            setViewOffset(e, t, n, r, i, o) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = e,
                this.view.fullHeight = t,
                this.view.offsetX = n,
                this.view.offsetY = r,
                this.view.width = i,
                this.view.height = o,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = (this.right - this.left) / (2 * this.zoom)
                  , t = (this.top - this.bottom) / (2 * this.zoom)
                  , n = (this.right + this.left) / 2
                  , r = (this.top + this.bottom) / 2;
                let i = n - e
                  , o = n + e
                  , a = r + t
                  , s = r - t;
                if (null !== this.view && this.view.enabled) {
                    const e = (this.right - this.left) / this.view.fullWidth / this.zoom
                      , t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    i += e * this.view.offsetX,
                    o = i + e * this.view.width,
                    a -= t * this.view.offsetY,
                    s = a - t * this.view.height
                }
                this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.zoom = this.zoom,
                t.object.left = this.left,
                t.object.right = this.right,
                t.object.top = this.top,
                t.object.bottom = this.bottom,
                t.object.near = this.near,
                t.object.far = this.far,
                null !== this.view && (t.object.view = Object.assign({}, this.view)),
                t
            }
        }
        const fb = [.125, .215, .35, .446, .526, .582]
          , mb = 20
          , gb = new pb
          , vb = new Uv;
        let yb = null
          , bb = 0
          , _b = 0;
        const Ab = (1 + Math.sqrt(5)) / 2
          , xb = 1 / Ab
          , Sb = [new Ag(1,1,1), new Ag(-1,1,1), new Ag(1,1,-1), new Ag(-1,1,-1), new Ag(0,Ab,xb), new Ag(0,Ab,-xb), new Ag(xb,0,Ab), new Ag(-xb,0,Ab), new Ag(Ab,xb,0), new Ag(-Ab,xb,0)];
        class wb {
            constructor(e) {
                this._renderer = e,
                this._pingPongRenderTarget = null,
                this._lodMax = 0,
                this._cubeSize = 0,
                this._lodPlanes = [],
                this._sizeLods = [],
                this._sigmas = [],
                this._blurMaterial = null,
                this._cubemapMaterial = null,
                this._equirectMaterial = null,
                this._compileMaterial(this._blurMaterial)
            }
            fromScene(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 100;
                yb = this._renderer.getRenderTarget(),
                bb = this._renderer.getActiveCubeFace(),
                _b = this._renderer.getActiveMipmapLevel(),
                this._setSize(256);
                const i = this._allocateTargets();
                return i.depthBuffer = !0,
                this._sceneToCubeUV(e, n, r, i),
                t > 0 && this._blur(i, 0, 0, t),
                this._applyPMREM(i),
                this._cleanup(i),
                i
            }
            fromEquirectangular(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                return this._fromTexture(e, t)
            }
            fromCubemap(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                return this._fromTexture(e, t)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = Tb(),
                this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = Cb(),
                this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(),
                null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
                null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(e) {
                this._lodMax = Math.floor(Math.log2(e)),
                this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(),
                null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let e = 0; e < this._lodPlanes.length; e++)
                    this._lodPlanes[e].dispose()
            }
            _cleanup(e) {
                this._renderer.setRenderTarget(yb, bb, _b),
                e.scissorTest = !1,
                Mb(e, 0, 0, e.width, e.height)
            }
            _fromTexture(e, t) {
                e.mapping === Yh || e.mapping === Qh ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
                yb = this._renderer.getRenderTarget(),
                bb = this._renderer.getActiveCubeFace(),
                _b = this._renderer.getActiveMipmapLevel();
                const n = t || this._allocateTargets();
                return this._textureToCubeUV(e, n),
                this._applyPMREM(n),
                this._cleanup(n),
                n
            }
            _allocateTargets() {
                const e = 3 * Math.max(this._cubeSize, 112)
                  , t = 4 * this._cubeSize
                  , n = {
                    magFilter: cp,
                    minFilter: cp,
                    generateMipmaps: !1,
                    type: Ap,
                    format: Mp,
                    colorSpace: Nf,
                    depthBuffer: !1
                }
                  , r = Eb(e, t, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                    null !== this._pingPongRenderTarget && this._dispose(),
                    this._pingPongRenderTarget = Eb(e, t, n);
                    const {_lodMax: r} = this;
                    ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function(e) {
                        const t = []
                          , n = []
                          , r = [];
                        let i = e;
                        const o = e - 4 + 1 + fb.length;
                        for (let a = 0; a < o; a++) {
                            const o = Math.pow(2, i);
                            n.push(o);
                            let s = 1 / o;
                            a > e - 4 ? s = fb[a - e + 4 - 1] : 0 === a && (s = 0),
                            r.push(s);
                            const l = 1 / (o - 2)
                              , c = -l
                              , u = 1 + l
                              , d = [c, c, u, c, u, u, c, c, u, u, c, u]
                              , h = 6
                              , p = 6
                              , f = 3
                              , m = 2
                              , g = 1
                              , v = new Float32Array(f * p * h)
                              , y = new Float32Array(m * p * h)
                              , b = new Float32Array(g * p * h);
                            for (let e = 0; e < h; e++) {
                                const t = e % 3 * 2 / 3 - 1
                                  , n = e > 2 ? 0 : -1
                                  , r = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                                v.set(r, f * p * e),
                                y.set(d, m * p * e);
                                const i = [e, e, e, e, e, e];
                                b.set(i, g * p * e)
                            }
                            const _ = new my;
                            _.setAttribute("position", new Qv(v,f)),
                            _.setAttribute("uv", new Qv(y,m)),
                            _.setAttribute("faceIndex", new Qv(b,g)),
                            t.push(_),
                            i > 4 && i--
                        }
                        return {
                            lodPlanes: t,
                            sizeLods: n,
                            sigmas: r
                        }
                    }(r)),
                    this._blurMaterial = function(e, t, n) {
                        const r = new Float32Array(mb)
                          , i = new Ag(0,1,0)
                          , o = new zy({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: mb,
                                CUBEUV_TEXEL_WIDTH: 1 / t,
                                CUBEUV_TEXEL_HEIGHT: 1 / n,
                                CUBEUV_MAX_MIP: `${e}.0`
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: r
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: i
                                }
                            },
                            vertexShader: Rb(),
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                            blending: ih,
                            depthTest: !1,
                            depthWrite: !1
                        });
                        return o
                    }(r, e, t)
                }
                return r
            }
            _compileMaterial(e) {
                const t = new Ly(this._lodPlanes[0],e);
                this._renderer.compile(t, gb)
            }
            _sceneToCubeUV(e, t, n, r) {
                const i = new Hy(90,1,t,n)
                  , o = [1, -1, 1, 1, 1, 1]
                  , a = [1, 1, 1, -1, -1, -1]
                  , s = this._renderer
                  , l = s.autoClear
                  , c = s.toneMapping;
                s.getClearColor(vb),
                s.toneMapping = Gh,
                s.autoClear = !1;
                const u = new jv({
                    name: "PMREM.Background",
                    side: th,
                    depthWrite: !1,
                    depthTest: !1
                })
                  , d = new Ly(new Dy,u);
                let h = !1;
                const p = e.background;
                p ? p.isColor && (u.color.copy(p),
                e.background = null,
                h = !0) : (u.color.copy(vb),
                h = !0);
                for (let f = 0; f < 6; f++) {
                    const t = f % 3;
                    0 === t ? (i.up.set(0, o[f], 0),
                    i.lookAt(a[f], 0, 0)) : 1 === t ? (i.up.set(0, 0, o[f]),
                    i.lookAt(0, a[f], 0)) : (i.up.set(0, o[f], 0),
                    i.lookAt(0, 0, a[f]));
                    const n = this._cubeSize;
                    Mb(r, t * n, f > 2 ? n : 0, n, n),
                    s.setRenderTarget(r),
                    h && s.render(d, i),
                    s.render(e, i)
                }
                d.geometry.dispose(),
                d.material.dispose(),
                s.toneMapping = c,
                s.autoClear = l,
                e.background = p
            }
            _textureToCubeUV(e, t) {
                const n = this._renderer
                  , r = e.mapping === Yh || e.mapping === Qh;
                r ? (null === this._cubemapMaterial && (this._cubemapMaterial = Tb()),
                this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Cb());
                const i = r ? this._cubemapMaterial : this._equirectMaterial
                  , o = new Ly(this._lodPlanes[0],i);
                i.uniforms.envMap.value = e;
                const a = this._cubeSize;
                Mb(t, 0, 0, 3 * a, 2 * a),
                n.setRenderTarget(t),
                n.render(o, gb)
            }
            _applyPMREM(e) {
                const t = this._renderer
                  , n = t.autoClear;
                t.autoClear = !1;
                for (let r = 1; r < this._lodPlanes.length; r++) {
                    const t = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1])
                      , n = Sb[(r - 1) % Sb.length];
                    this._blur(e, r - 1, r, t, n)
                }
                t.autoClear = n
            }
            _blur(e, t, n, r, i) {
                const o = this._pingPongRenderTarget;
                this._halfBlur(e, o, t, n, r, "latitudinal", i),
                this._halfBlur(o, e, n, n, r, "longitudinal", i)
            }
            _halfBlur(e, t, n, r, i, o, a) {
                const s = this._renderer
                  , l = this._blurMaterial;
                "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
                const c = new Ly(this._lodPlanes[r],l)
                  , u = l.uniforms
                  , d = this._sizeLods[n] - 1
                  , h = isFinite(i) ? Math.PI / (2 * d) : 2 * Math.PI / 39
                  , p = i / h
                  , f = isFinite(i) ? 1 + Math.floor(3 * p) : mb;
                f > mb && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                const m = [];
                let g = 0;
                for (let b = 0; b < mb; ++b) {
                    const e = b / p
                      , t = Math.exp(-e * e / 2);
                    m.push(t),
                    0 === b ? g += t : b < f && (g += 2 * t)
                }
                for (let b = 0; b < m.length; b++)
                    m[b] = m[b] / g;
                u.envMap.value = e.texture,
                u.samples.value = f,
                u.weights.value = m,
                u.latitudinal.value = "latitudinal" === o,
                a && (u.poleAxis.value = a);
                const {_lodMax: v} = this;
                u.dTheta.value = h,
                u.mipInt.value = v - n;
                const y = this._sizeLods[r];
                Mb(t, 3 * y * (r > v - 4 ? r - v + 4 : 0), 4 * (this._cubeSize - y), 3 * y, 2 * y),
                s.setRenderTarget(t),
                s.render(c, gb)
            }
        }
        function Eb(e, t, n) {
            const r = new fg(e,t,n);
            return r.texture.mapping = ep,
            r.texture.name = "PMREM.cubeUv",
            r.scissorTest = !0,
            r
        }
        function Mb(e, t, n, r, i) {
            e.viewport.set(t, n, r, i),
            e.scissor.set(t, n, r, i)
        }
        function Cb() {
            return new zy({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: Rb(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: ih,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function Tb() {
            return new zy({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: Rb(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: ih,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function Rb() {
            return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
        }
        function Pb(e) {
            let t = new WeakMap
              , n = null;
            function r(e) {
                const n = e.target;
                n.removeEventListener("dispose", r);
                const i = t.get(n);
                void 0 !== i && (t.delete(n),
                i.dispose())
            }
            return {
                get: function(i) {
                    if (i && i.isTexture) {
                        const o = i.mapping
                          , a = o === Zh || o === $h
                          , s = o === Yh || o === Qh;
                        if (a || s) {
                            if (i.isRenderTargetTexture && !0 === i.needsPMREMUpdate) {
                                i.needsPMREMUpdate = !1;
                                let r = t.get(i);
                                return null === n && (n = new wb(e)),
                                r = a ? n.fromEquirectangular(i, r) : n.fromCubemap(i, r),
                                t.set(i, r),
                                r.texture
                            }
                            if (t.has(i))
                                return t.get(i).texture;
                            {
                                const o = i.image;
                                if (a && o && o.height > 0 || s && o && function(e) {
                                    let t = 0;
                                    const n = 6;
                                    for (let r = 0; r < n; r++)
                                        void 0 !== e[r] && t++;
                                    return t === n
                                }(o)) {
                                    null === n && (n = new wb(e));
                                    const o = a ? n.fromEquirectangular(i) : n.fromCubemap(i);
                                    return t.set(i, o),
                                    i.addEventListener("dispose", r),
                                    o.texture
                                }
                                return null
                            }
                        }
                    }
                    return i
                },
                dispose: function() {
                    t = new WeakMap,
                    null !== n && (n.dispose(),
                    n = null)
                }
            }
        }
        function Bb(e) {
            const t = {};
            function n(n) {
                if (void 0 !== t[n])
                    return t[n];
                let r;
                switch (n) {
                case "WEBGL_depth_texture":
                    r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    r = e.getExtension(n)
                }
                return t[n] = r,
                r
            }
            return {
                has: function(e) {
                    return null !== n(e)
                },
                init: function(e) {
                    e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"),
                    n("OES_texture_float"),
                    n("OES_texture_half_float"),
                    n("OES_texture_half_float_linear"),
                    n("OES_standard_derivatives"),
                    n("OES_element_index_uint"),
                    n("OES_vertex_array_object"),
                    n("ANGLE_instanced_arrays")),
                    n("OES_texture_float_linear"),
                    n("EXT_color_buffer_half_float"),
                    n("WEBGL_multisampled_render_to_texture")
                },
                get: function(e) {
                    const t = n(e);
                    return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."),
                    t
                }
            }
        }
        function Ib(e, t, n, r) {
            const i = {}
              , o = new WeakMap;
            function a(e) {
                const s = e.target;
                null !== s.index && t.remove(s.index);
                for (const n in s.attributes)
                    t.remove(s.attributes[n]);
                for (const n in s.morphAttributes) {
                    const e = s.morphAttributes[n];
                    for (let n = 0, r = e.length; n < r; n++)
                        t.remove(e[n])
                }
                s.removeEventListener("dispose", a),
                delete i[s.id];
                const l = o.get(s);
                l && (t.remove(l),
                o.delete(s)),
                r.releaseStatesOfGeometry(s),
                !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount,
                n.memory.geometries--
            }
            function s(e) {
                const n = []
                  , r = e.index
                  , i = e.attributes.position;
                let a = 0;
                if (null !== r) {
                    const e = r.array;
                    a = r.version;
                    for (let t = 0, r = e.length; t < r; t += 3) {
                        const r = e[t + 0]
                          , i = e[t + 1]
                          , o = e[t + 2];
                        n.push(r, i, i, o, o, r)
                    }
                } else {
                    if (void 0 === i)
                        return;
                    {
                        const e = i.array;
                        a = i.version;
                        for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) {
                            const e = t + 0
                              , r = t + 1
                              , i = t + 2;
                            n.push(e, r, r, i, i, e)
                        }
                    }
                }
                const s = new (Vm(n) ? iy : ny)(n,1);
                s.version = a;
                const l = o.get(e);
                l && t.remove(l),
                o.set(e, s)
            }
            return {
                get: function(e, t) {
                    return !0 === i[t.id] || (t.addEventListener("dispose", a),
                    i[t.id] = !0,
                    n.memory.geometries++),
                    t
                },
                update: function(n) {
                    const r = n.attributes;
                    for (const o in r)
                        t.update(r[o], e.ARRAY_BUFFER);
                    const i = n.morphAttributes;
                    for (const o in i) {
                        const n = i[o];
                        for (let r = 0, i = n.length; r < i; r++)
                            t.update(n[r], e.ARRAY_BUFFER)
                    }
                },
                getWireframeAttribute: function(e) {
                    const t = o.get(e);
                    if (t) {
                        const n = e.index;
                        null !== n && t.version < n.version && s(e)
                    } else
                        s(e);
                    return o.get(e)
                }
            }
        }
        function Lb(e, t, n, r) {
            const i = r.isWebGL2;
            let o, a, s;
            this.setMode = function(e) {
                o = e
            }
            ,
            this.setIndex = function(e) {
                a = e.type,
                s = e.bytesPerElement
            }
            ,
            this.render = function(t, r) {
                e.drawElements(o, r, a, t * s),
                n.update(r, o, 1)
            }
            ,
            this.renderInstances = function(r, l, c) {
                if (0 === c)
                    return;
                let u, d;
                if (i)
                    u = e,
                    d = "drawElementsInstanced";
                else if (u = t.get("ANGLE_instanced_arrays"),
                d = "drawElementsInstancedANGLE",
                null === u)
                    return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                u[d](o, l, a, r * s, c),
                n.update(l, o, c)
            }
            ,
            this.renderMultiDraw = function(e, r, i) {
                if (0 === i)
                    return;
                const l = t.get("WEBGL_multi_draw");
                if (null === l)
                    for (let t = 0; t < i; t++)
                        this.render(e[t] / s, r[t]);
                else {
                    l.multiDrawElementsWEBGL(o, r, 0, a, e, 0, i);
                    let t = 0;
                    for (let e = 0; e < i; e++)
                        t += r[e];
                    n.update(t, o, 1)
                }
            }
        }
        function kb(e) {
            const t = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: t,
                programs: null,
                autoReset: !0,
                reset: function() {
                    t.calls = 0,
                    t.triangles = 0,
                    t.points = 0,
                    t.lines = 0
                },
                update: function(n, r, i) {
                    switch (t.calls++,
                    r) {
                    case e.TRIANGLES:
                        t.triangles += i * (n / 3);
                        break;
                    case e.LINES:
                        t.lines += i * (n / 2);
                        break;
                    case e.LINE_STRIP:
                        t.lines += i * (n - 1);
                        break;
                    case e.LINE_LOOP:
                        t.lines += i * n;
                        break;
                    case e.POINTS:
                        t.points += i * n;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                    }
                }
            }
        }
        function Db(e, t) {
            return e[0] - t[0]
        }
        function Ob(e, t) {
            return Math.abs(t[1]) - Math.abs(e[1])
        }
        function Nb(e, t, n) {
            const r = {}
              , i = new Float32Array(8)
              , o = new WeakMap
              , a = new hg
              , s = [];
            for (let l = 0; l < 8; l++)
                s[l] = [l, 0];
            return {
                update: function(l, c, u) {
                    const d = l.morphTargetInfluences;
                    if (!0 === t.isWebGL2) {
                        const h = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color
                          , p = void 0 !== h ? h.length : 0;
                        let f = o.get(c);
                        if (void 0 === f || f.count !== p) {
                            void 0 !== f && f.texture.dispose();
                            const v = void 0 !== c.morphAttributes.position
                              , y = void 0 !== c.morphAttributes.normal
                              , b = void 0 !== c.morphAttributes.color
                              , _ = c.morphAttributes.position || []
                              , A = c.morphAttributes.normal || []
                              , x = c.morphAttributes.color || [];
                            let S = 0;
                            !0 === v && (S = 1),
                            !0 === y && (S = 2),
                            !0 === b && (S = 3);
                            let w = c.attributes.position.count * S
                              , E = 1;
                            w > t.maxTextureSize && (E = Math.ceil(w / t.maxTextureSize),
                            w = t.maxTextureSize);
                            const M = new Float32Array(w * E * 4 * p)
                              , C = new mg(M,w,E,p);
                            C.type = _p,
                            C.needsUpdate = !0;
                            const T = 4 * S;
                            for (let P = 0; P < p; P++) {
                                const B = _[P]
                                  , I = A[P]
                                  , L = x[P]
                                  , k = w * E * 4 * P;
                                for (let D = 0; D < B.count; D++) {
                                    const O = D * T;
                                    !0 === v && (a.fromBufferAttribute(B, D),
                                    M[k + O + 0] = a.x,
                                    M[k + O + 1] = a.y,
                                    M[k + O + 2] = a.z,
                                    M[k + O + 3] = 0),
                                    !0 === y && (a.fromBufferAttribute(I, D),
                                    M[k + O + 4] = a.x,
                                    M[k + O + 5] = a.y,
                                    M[k + O + 6] = a.z,
                                    M[k + O + 7] = 0),
                                    !0 === b && (a.fromBufferAttribute(L, D),
                                    M[k + O + 8] = a.x,
                                    M[k + O + 9] = a.y,
                                    M[k + O + 10] = a.z,
                                    M[k + O + 11] = 4 === L.itemSize ? a.w : 1)
                                }
                            }
                            function R() {
                                C.dispose(),
                                o.delete(c),
                                c.removeEventListener("dispose", R)
                            }
                            f = {
                                count: p,
                                texture: C,
                                size: new Hm(w,E)
                            },
                            o.set(c, f),
                            c.addEventListener("dispose", R)
                        }
                        let m = 0;
                        for (let N = 0; N < d.length; N++)
                            m += d[N];
                        const g = c.morphTargetsRelative ? 1 : 1 - m;
                        u.getUniforms().setValue(e, "morphTargetBaseInfluence", g),
                        u.getUniforms().setValue(e, "morphTargetInfluences", d),
                        u.getUniforms().setValue(e, "morphTargetsTexture", f.texture, n),
                        u.getUniforms().setValue(e, "morphTargetsTextureSize", f.size)
                    } else {
                        const F = void 0 === d ? 0 : d.length;
                        let U = r[c.id];
                        if (void 0 === U || U.length !== F) {
                            U = [];
                            for (let W = 0; W < F; W++)
                                U[W] = [W, 0];
                            r[c.id] = U
                        }
                        for (let V = 0; V < F; V++) {
                            const X = U[V];
                            X[0] = V,
                            X[1] = d[V]
                        }
                        U.sort(Ob);
                        for (let J = 0; J < 8; J++)
                            J < F && U[J][1] ? (s[J][0] = U[J][0],
                            s[J][1] = U[J][1]) : (s[J][0] = Number.MAX_SAFE_INTEGER,
                            s[J][1] = 0);
                        s.sort(Db);
                        const z = c.morphAttributes.position
                          , G = c.morphAttributes.normal;
                        let H = 0;
                        for (let K = 0; K < 8; K++) {
                            const q = s[K]
                              , Y = q[0]
                              , Q = q[1];
                            Y !== Number.MAX_SAFE_INTEGER && Q ? (z && c.getAttribute("morphTarget" + K) !== z[Y] && c.setAttribute("morphTarget" + K, z[Y]),
                            G && c.getAttribute("morphNormal" + K) !== G[Y] && c.setAttribute("morphNormal" + K, G[Y]),
                            i[K] = Q,
                            H += Q) : (z && !0 === c.hasAttribute("morphTarget" + K) && c.deleteAttribute("morphTarget" + K),
                            G && !0 === c.hasAttribute("morphNormal" + K) && c.deleteAttribute("morphNormal" + K),
                            i[K] = 0)
                        }
                        const j = c.morphTargetsRelative ? 1 : 1 - H;
                        u.getUniforms().setValue(e, "morphTargetBaseInfluence", j),
                        u.getUniforms().setValue(e, "morphTargetInfluences", i)
                    }
                }
            }
        }
        function Fb(e, t, n, r) {
            let i = new WeakMap;
            function o(e) {
                const t = e.target;
                t.removeEventListener("dispose", o),
                n.remove(t.instanceMatrix),
                null !== t.instanceColor && n.remove(t.instanceColor)
            }
            return {
                update: function(a) {
                    const s = r.render.frame
                      , l = a.geometry
                      , c = t.get(a, l);
                    if (i.get(c) !== s && (t.update(c),
                    i.set(c, s)),
                    a.isInstancedMesh && (!1 === a.hasEventListener("dispose", o) && a.addEventListener("dispose", o),
                    i.get(a) !== s && (n.update(a.instanceMatrix, e.ARRAY_BUFFER),
                    null !== a.instanceColor && n.update(a.instanceColor, e.ARRAY_BUFFER),
                    i.set(a, s))),
                    a.isSkinnedMesh) {
                        const e = a.skeleton;
                        i.get(e) !== s && (e.update(),
                        i.set(e, s))
                    }
                    return c
                },
                dispose: function() {
                    i = new WeakMap
                }
            }
        }
        class Ub extends dg {
            constructor(e, t, n, r, i, o, a, s, l, c) {
                if ((c = void 0 !== c ? c : Rp) !== Rp && c !== Pp)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === Rp && (n = bp),
                void 0 === n && c === Pp && (n = wp),
                super(null, r, i, o, a, s, c, n, l),
                this.isDepthTexture = !0,
                this.image = {
                    width: e,
                    height: t
                },
                this.magFilter = void 0 !== a ? a : ip,
                this.minFilter = void 0 !== s ? s : ip,
                this.flipY = !1,
                this.generateMipmaps = !1,
                this.compareFunction = null
            }
            copy(e) {
                return super.copy(e),
                this.compareFunction = e.compareFunction,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return null !== this.compareFunction && (t.compareFunction = this.compareFunction),
                t
            }
        }
        const zb = new dg
          , Gb = new Ub(1,1);
        Gb.compareFunction = cm;
        const Hb = new mg
          , jb = new vg
          , Wb = new Vy
          , Vb = []
          , Xb = []
          , Jb = new Float32Array(16)
          , Kb = new Float32Array(9)
          , qb = new Float32Array(4);
        function Yb(e, t, n) {
            const r = e[0];
            if (r <= 0 || r > 0)
                return e;
            const i = t * n;
            let o = Vb[i];
            if (void 0 === o && (o = new Float32Array(i),
            Vb[i] = o),
            0 !== t) {
                r.toArray(o, 0);
                for (let r = 1, i = 0; r !== t; ++r)
                    i += n,
                    e[r].toArray(o, i)
            }
            return o
        }
        function Qb(e, t) {
            if (e.length !== t.length)
                return !1;
            for (let n = 0, r = e.length; n < r; n++)
                if (e[n] !== t[n])
                    return !1;
            return !0
        }
        function Zb(e, t) {
            for (let n = 0, r = t.length; n < r; n++)
                e[n] = t[n]
        }
        function $b(e, t) {
            let n = Xb[t];
            void 0 === n && (n = new Int32Array(t),
            Xb[t] = n);
            for (let r = 0; r !== t; ++r)
                n[r] = e.allocateTextureUnit();
            return n
        }
        function e_(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1f(this.addr, t),
            n[0] = t)
        }
        function t_(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
                n[0] = t.x,
                n[1] = t.y);
            else {
                if (Qb(n, t))
                    return;
                e.uniform2fv(this.addr, t),
                Zb(n, t)
            }
        }
        function n_(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z);
            else if (void 0 !== t.r)
                n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
                n[0] = t.r,
                n[1] = t.g,
                n[2] = t.b);
            else {
                if (Qb(n, t))
                    return;
                e.uniform3fv(this.addr, t),
                Zb(n, t)
            }
        }
        function r_(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z,
                n[3] = t.w);
            else {
                if (Qb(n, t))
                    return;
                e.uniform4fv(this.addr, t),
                Zb(n, t)
            }
        }
        function i_(e, t) {
            const n = this.cache
              , r = t.elements;
            if (void 0 === r) {
                if (Qb(n, t))
                    return;
                e.uniformMatrix2fv(this.addr, !1, t),
                Zb(n, t)
            } else {
                if (Qb(n, r))
                    return;
                qb.set(r),
                e.uniformMatrix2fv(this.addr, !1, qb),
                Zb(n, r)
            }
        }
        function o_(e, t) {
            const n = this.cache
              , r = t.elements;
            if (void 0 === r) {
                if (Qb(n, t))
                    return;
                e.uniformMatrix3fv(this.addr, !1, t),
                Zb(n, t)
            } else {
                if (Qb(n, r))
                    return;
                Kb.set(r),
                e.uniformMatrix3fv(this.addr, !1, Kb),
                Zb(n, r)
            }
        }
        function a_(e, t) {
            const n = this.cache
              , r = t.elements;
            if (void 0 === r) {
                if (Qb(n, t))
                    return;
                e.uniformMatrix4fv(this.addr, !1, t),
                Zb(n, t)
            } else {
                if (Qb(n, r))
                    return;
                Jb.set(r),
                e.uniformMatrix4fv(this.addr, !1, Jb),
                Zb(n, r)
            }
        }
        function s_(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1i(this.addr, t),
            n[0] = t)
        }
        function l_(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y),
                n[0] = t.x,
                n[1] = t.y);
            else {
                if (Qb(n, t))
                    return;
                e.uniform2iv(this.addr, t),
                Zb(n, t)
            }
        }
        function c_(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z);
            else {
                if (Qb(n, t))
                    return;
                e.uniform3iv(this.addr, t),
                Zb(n, t)
            }
        }
        function u_(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z,
                n[3] = t.w);
            else {
                if (Qb(n, t))
                    return;
                e.uniform4iv(this.addr, t),
                Zb(n, t)
            }
        }
        function d_(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1ui(this.addr, t),
            n[0] = t)
        }
        function h_(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y),
                n[0] = t.x,
                n[1] = t.y);
            else {
                if (Qb(n, t))
                    return;
                e.uniform2uiv(this.addr, t),
                Zb(n, t)
            }
        }
        function p_(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z);
            else {
                if (Qb(n, t))
                    return;
                e.uniform3uiv(this.addr, t),
                Zb(n, t)
            }
        }
        function f_(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z,
                n[3] = t.w);
            else {
                if (Qb(n, t))
                    return;
                e.uniform4uiv(this.addr, t),
                Zb(n, t)
            }
        }
        function m_(e, t, n) {
            const r = this.cache
              , i = n.allocateTextureUnit();
            r[0] !== i && (e.uniform1i(this.addr, i),
            r[0] = i);
            const o = this.type === e.SAMPLER_2D_SHADOW ? Gb : zb;
            n.setTexture2D(t || o, i)
        }
        function g_(e, t, n) {
            const r = this.cache
              , i = n.allocateTextureUnit();
            r[0] !== i && (e.uniform1i(this.addr, i),
            r[0] = i),
            n.setTexture3D(t || jb, i)
        }
        function v_(e, t, n) {
            const r = this.cache
              , i = n.allocateTextureUnit();
            r[0] !== i && (e.uniform1i(this.addr, i),
            r[0] = i),
            n.setTextureCube(t || Wb, i)
        }
        function y_(e, t, n) {
            const r = this.cache
              , i = n.allocateTextureUnit();
            r[0] !== i && (e.uniform1i(this.addr, i),
            r[0] = i),
            n.setTexture2DArray(t || Hb, i)
        }
        function b_(e, t) {
            e.uniform1fv(this.addr, t)
        }
        function __(e, t) {
            const n = Yb(t, this.size, 2);
            e.uniform2fv(this.addr, n)
        }
        function A_(e, t) {
            const n = Yb(t, this.size, 3);
            e.uniform3fv(this.addr, n)
        }
        function x_(e, t) {
            const n = Yb(t, this.size, 4);
            e.uniform4fv(this.addr, n)
        }
        function S_(e, t) {
            const n = Yb(t, this.size, 4);
            e.uniformMatrix2fv(this.addr, !1, n)
        }
        function w_(e, t) {
            const n = Yb(t, this.size, 9);
            e.uniformMatrix3fv(this.addr, !1, n)
        }
        function E_(e, t) {
            const n = Yb(t, this.size, 16);
            e.uniformMatrix4fv(this.addr, !1, n)
        }
        function M_(e, t) {
            e.uniform1iv(this.addr, t)
        }
        function C_(e, t) {
            e.uniform2iv(this.addr, t)
        }
        function T_(e, t) {
            e.uniform3iv(this.addr, t)
        }
        function R_(e, t) {
            e.uniform4iv(this.addr, t)
        }
        function P_(e, t) {
            e.uniform1uiv(this.addr, t)
        }
        function B_(e, t) {
            e.uniform2uiv(this.addr, t)
        }
        function I_(e, t) {
            e.uniform3uiv(this.addr, t)
        }
        function L_(e, t) {
            e.uniform4uiv(this.addr, t)
        }
        function k_(e, t, n) {
            const r = this.cache
              , i = t.length
              , o = $b(n, i);
            Qb(r, o) || (e.uniform1iv(this.addr, o),
            Zb(r, o));
            for (let a = 0; a !== i; ++a)
                n.setTexture2D(t[a] || zb, o[a])
        }
        function D_(e, t, n) {
            const r = this.cache
              , i = t.length
              , o = $b(n, i);
            Qb(r, o) || (e.uniform1iv(this.addr, o),
            Zb(r, o));
            for (let a = 0; a !== i; ++a)
                n.setTexture3D(t[a] || jb, o[a])
        }
        function O_(e, t, n) {
            const r = this.cache
              , i = t.length
              , o = $b(n, i);
            Qb(r, o) || (e.uniform1iv(this.addr, o),
            Zb(r, o));
            for (let a = 0; a !== i; ++a)
                n.setTextureCube(t[a] || Wb, o[a])
        }
        function N_(e, t, n) {
            const r = this.cache
              , i = t.length
              , o = $b(n, i);
            Qb(r, o) || (e.uniform1iv(this.addr, o),
            Zb(r, o));
            for (let a = 0; a !== i; ++a)
                n.setTexture2DArray(t[a] || Hb, o[a])
        }
        class F_ {
            constructor(e, t, n) {
                this.id = e,
                this.addr = n,
                this.cache = [],
                this.type = t.type,
                this.setValue = function(e) {
                    switch (e) {
                    case 5126:
                        return e_;
                    case 35664:
                        return t_;
                    case 35665:
                        return n_;
                    case 35666:
                        return r_;
                    case 35674:
                        return i_;
                    case 35675:
                        return o_;
                    case 35676:
                        return a_;
                    case 5124:
                    case 35670:
                        return s_;
                    case 35667:
                    case 35671:
                        return l_;
                    case 35668:
                    case 35672:
                        return c_;
                    case 35669:
                    case 35673:
                        return u_;
                    case 5125:
                        return d_;
                    case 36294:
                        return h_;
                    case 36295:
                        return p_;
                    case 36296:
                        return f_;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return m_;
                    case 35679:
                    case 36299:
                    case 36307:
                        return g_;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return v_;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return y_
                    }
                }(t.type)
            }
        }
        class U_ {
            constructor(e, t, n) {
                this.id = e,
                this.addr = n,
                this.cache = [],
                this.type = t.type,
                this.size = t.size,
                this.setValue = function(e) {
                    switch (e) {
                    case 5126:
                        return b_;
                    case 35664:
                        return __;
                    case 35665:
                        return A_;
                    case 35666:
                        return x_;
                    case 35674:
                        return S_;
                    case 35675:
                        return w_;
                    case 35676:
                        return E_;
                    case 5124:
                    case 35670:
                        return M_;
                    case 35667:
                    case 35671:
                        return C_;
                    case 35668:
                    case 35672:
                        return T_;
                    case 35669:
                    case 35673:
                        return R_;
                    case 5125:
                        return P_;
                    case 36294:
                        return B_;
                    case 36295:
                        return I_;
                    case 36296:
                        return L_;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return k_;
                    case 35679:
                    case 36299:
                    case 36307:
                        return D_;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return O_;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return N_
                    }
                }(t.type)
            }
        }
        class z_ {
            constructor(e) {
                this.id = e,
                this.seq = [],
                this.map = {}
            }
            setValue(e, t, n) {
                const r = this.seq;
                for (let i = 0, o = r.length; i !== o; ++i) {
                    const o = r[i];
                    o.setValue(e, t[o.id], n)
                }
            }
        }
        const G_ = /(\w+)(\])?(\[|\.)?/g;
        function H_(e, t) {
            e.seq.push(t),
            e.map[t.id] = t
        }
        function j_(e, t, n) {
            const r = e.name
              , i = r.length;
            for (G_.lastIndex = 0; ; ) {
                const o = G_.exec(r)
                  , a = G_.lastIndex;
                let s = o[1];
                const l = "]" === o[2]
                  , c = o[3];
                if (l && (s |= 0),
                void 0 === c || "[" === c && a + 2 === i) {
                    H_(n, void 0 === c ? new F_(s,e,t) : new U_(s,e,t));
                    break
                }
                {
                    let e = n.map[s];
                    void 0 === e && (e = new z_(s),
                    H_(n, e)),
                    n = e
                }
            }
        }
        class W_ {
            constructor(e, t) {
                this.seq = [],
                this.map = {};
                const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                for (let r = 0; r < n; ++r) {
                    const n = e.getActiveUniform(t, r);
                    j_(n, e.getUniformLocation(t, n.name), this)
                }
            }
            setValue(e, t, n, r) {
                const i = this.map[t];
                void 0 !== i && i.setValue(e, n, r)
            }
            setOptional(e, t, n) {
                const r = t[n];
                void 0 !== r && this.setValue(e, n, r)
            }
            static upload(e, t, n, r) {
                for (let i = 0, o = t.length; i !== o; ++i) {
                    const o = t[i]
                      , a = n[o.id];
                    !1 !== a.needsUpdate && o.setValue(e, a.value, r)
                }
            }
            static seqWithValue(e, t) {
                const n = [];
                for (let r = 0, i = e.length; r !== i; ++r) {
                    const i = e[r];
                    i.id in t && n.push(i)
                }
                return n
            }
        }
        function V_(e, t, n) {
            const r = e.createShader(t);
            return e.shaderSource(r, n),
            e.compileShader(r),
            r
        }
        let X_ = 0;
        function J_(e, t, n) {
            const r = e.getShaderParameter(t, e.COMPILE_STATUS)
              , i = e.getShaderInfoLog(t).trim();
            if (r && "" === i)
                return "";
            const o = /ERROR: 0:(\d+)/.exec(i);
            if (o) {
                const r = parseInt(o[1]);
                return n.toUpperCase() + "\n\n" + i + "\n\n" + function(e, t) {
                    const n = e.split("\n")
                      , r = []
                      , i = Math.max(t - 6, 0)
                      , o = Math.min(t + 6, n.length);
                    for (let a = i; a < o; a++) {
                        const e = a + 1;
                        r.push(`${e === t ? ">" : " "} ${e}: ${n[a]}`)
                    }
                    return r.join("\n")
                }(e.getShaderSource(t), r)
            }
            return i
        }
        function K_(e, t) {
            const n = function(e) {
                const t = ng.getPrimaries(ng.workingColorSpace)
                  , n = ng.getPrimaries(e);
                let r;
                switch (t === n ? r = "" : t === jf && n === Hf ? r = "LinearDisplayP3ToLinearSRGB" : t === Hf && n === jf && (r = "LinearSRGBToLinearDisplayP3"),
                e) {
                case Nf:
                case Uf:
                    return [r, "LinearTransferOETF"];
                case Of:
                case Ff:
                    return [r, "sRGBTransferOETF"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported color space:", e),
                    [r, "LinearTransferOETF"]
                }
            }(t);
            return `vec4 ${e}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`
        }
        function q_(e, t) {
            let n;
            switch (t) {
            case Hh:
                n = "Linear";
                break;
            case jh:
                n = "Reinhard";
                break;
            case Wh:
                n = "OptimizedCineon";
                break;
            case Vh:
                n = "ACESFilmic";
                break;
            case Xh:
                n = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
                n = "Linear"
            }
            return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }
        function Y_(e) {
            return "" !== e
        }
        function Q_(e, t) {
            const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
            return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
        }
        function Z_(e, t) {
            return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
        }
        const $_ = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function eA(e) {
            return e.replace($_, nA)
        }
        const tA = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
        function nA(e, t) {
            let n = rb[t];
            if (void 0 === n) {
                const e = tA.get(t);
                if (void 0 === e)
                    throw new Error("Can not resolve #include <" + t + ">");
                n = rb[e],
                console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e)
            }
            return eA(n)
        }
        const rA = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function iA(e) {
            return e.replace(rA, oA)
        }
        function oA(e, t, n, r) {
            let i = "";
            for (let o = parseInt(t); o < parseInt(n); o++)
                i += r.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
            return i
        }
        function aA(e) {
            let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
            return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
            t
        }
        function sA(e, t, n, r) {
            const i = e.getContext()
              , o = n.defines;
            let a = n.vertexShader
              , s = n.fragmentShader;
            const l = function(e) {
                let t = "SHADOWMAP_TYPE_BASIC";
                return e.shadowMapType === Qd ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === Zd ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === $d && (t = "SHADOWMAP_TYPE_VSM"),
                t
            }(n)
              , c = function(e) {
                let t = "ENVMAP_TYPE_CUBE";
                if (e.envMap)
                    switch (e.envMapMode) {
                    case Yh:
                    case Qh:
                        t = "ENVMAP_TYPE_CUBE";
                        break;
                    case ep:
                        t = "ENVMAP_TYPE_CUBE_UV"
                    }
                return t
            }(n)
              , u = function(e) {
                let t = "ENVMAP_MODE_REFLECTION";
                e.envMap && e.envMapMode === Qh && (t = "ENVMAP_MODE_REFRACTION");
                return t
            }(n)
              , d = function(e) {
                let t = "ENVMAP_BLENDING_NONE";
                if (e.envMap)
                    switch (e.combine) {
                    case Fh:
                        t = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case Uh:
                        t = "ENVMAP_BLENDING_MIX";
                        break;
                    case zh:
                        t = "ENVMAP_BLENDING_ADD"
                    }
                return t
            }(n)
              , h = function(e) {
                const t = e.envMapCubeUVHeight;
                if (null === t)
                    return null;
                const n = Math.log2(t) - 2
                  , r = 1 / t;
                return {
                    texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                    texelHeight: r,
                    maxMip: n
                }
            }(n)
              , p = n.isWebGL2 ? "" : function(e) {
                return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.normalMapTangentSpace || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Y_).join("\n")
            }(n)
              , f = function(e) {
                const t = [];
                for (const n in e) {
                    const r = e[n];
                    !1 !== r && t.push("#define " + n + " " + r)
                }
                return t.join("\n")
            }(o)
              , m = i.createProgram();
            let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(Y_).join("\n"),
            g.length > 0 && (g += "\n"),
            v = [p, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(Y_).join("\n"),
            v.length > 0 && (v += "\n")) : (g = [aA(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.batching ? "#define USE_BATCHING" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Y_).join("\n"),
            v = [p, aA(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + d : "", h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "", h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "", h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Gh ? "#define TONE_MAPPING" : "", n.toneMapping !== Gh ? rb.tonemapping_pars_fragment : "", n.toneMapping !== Gh ? q_("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", rb.colorspace_pars_fragment, K_("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Y_).join("\n")),
            a = eA(a),
            a = Q_(a, n),
            a = Z_(a, n),
            s = eA(s),
            s = Q_(s, n),
            s = Z_(s, n),
            a = iA(a),
            s = iA(s),
            n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n",
            g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
            v = ["precision mediump sampler2DArray;", "#define varying in", n.glslVersion === wm ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === wm ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
            const b = y + g + a
              , _ = y + v + s
              , A = V_(i, i.VERTEX_SHADER, b)
              , x = V_(i, i.FRAGMENT_SHADER, _);
            function S(t) {
                if (e.debug.checkShaderErrors) {
                    const n = i.getProgramInfoLog(m).trim()
                      , r = i.getShaderInfoLog(A).trim()
                      , o = i.getShaderInfoLog(x).trim();
                    let a = !0
                      , s = !0;
                    if (!1 === i.getProgramParameter(m, i.LINK_STATUS))
                        if (a = !1,
                        "function" === typeof e.debug.onShaderError)
                            e.debug.onShaderError(i, m, A, x);
                        else {
                            const e = J_(i, A, "vertex")
                              , t = J_(i, x, "fragment");
                            console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(m, i.VALIDATE_STATUS) + "\n\nProgram Info Log: " + n + "\n" + e + "\n" + t)
                        }
                    else
                        "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : "" !== r && "" !== o || (s = !1);
                    s && (t.diagnostics = {
                        runnable: a,
                        programLog: n,
                        vertexShader: {
                            log: r,
                            prefix: g
                        },
                        fragmentShader: {
                            log: o,
                            prefix: v
                        }
                    })
                }
                i.deleteShader(A),
                i.deleteShader(x),
                w = new W_(i,m),
                E = function(e, t) {
                    const n = {}
                      , r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                    for (let i = 0; i < r; i++) {
                        const r = e.getActiveAttrib(t, i)
                          , o = r.name;
                        let a = 1;
                        r.type === e.FLOAT_MAT2 && (a = 2),
                        r.type === e.FLOAT_MAT3 && (a = 3),
                        r.type === e.FLOAT_MAT4 && (a = 4),
                        n[o] = {
                            type: r.type,
                            location: e.getAttribLocation(t, o),
                            locationSize: a
                        }
                    }
                    return n
                }(i, m)
            }
            let w, E;
            i.attachShader(m, A),
            i.attachShader(m, x),
            void 0 !== n.index0AttributeName ? i.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(m, 0, "position"),
            i.linkProgram(m),
            this.getUniforms = function() {
                return void 0 === w && S(this),
                w
            }
            ,
            this.getAttributes = function() {
                return void 0 === E && S(this),
                E
            }
            ;
            let M = !1 === n.rendererExtensionParallelShaderCompile;
            return this.isReady = function() {
                return !1 === M && (M = i.getProgramParameter(m, 37297)),
                M
            }
            ,
            this.destroy = function() {
                r.releaseStatesOfProgram(this),
                i.deleteProgram(m),
                this.program = void 0
            }
            ,
            this.type = n.shaderType,
            this.name = n.shaderName,
            this.id = X_++,
            this.cacheKey = t,
            this.usedTimes = 1,
            this.program = m,
            this.vertexShader = A,
            this.fragmentShader = x,
            this
        }
        let lA = 0;
        class cA {
            constructor() {
                this.shaderCache = new Map,
                this.materialCache = new Map
            }
            update(e) {
                const t = e.vertexShader
                  , n = e.fragmentShader
                  , r = this._getShaderStage(t)
                  , i = this._getShaderStage(n)
                  , o = this._getShaderCacheForMaterial(e);
                return !1 === o.has(r) && (o.add(r),
                r.usedTimes++),
                !1 === o.has(i) && (o.add(i),
                i.usedTimes++),
                this
            }
            remove(e) {
                const t = this.materialCache.get(e);
                for (const n of t)
                    n.usedTimes--,
                    0 === n.usedTimes && this.shaderCache.delete(n.code);
                return this.materialCache.delete(e),
                this
            }
            getVertexShaderID(e) {
                return this._getShaderStage(e.vertexShader).id
            }
            getFragmentShaderID(e) {
                return this._getShaderStage(e.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(),
                this.materialCache.clear()
            }
            _getShaderCacheForMaterial(e) {
                const t = this.materialCache;
                let n = t.get(e);
                return void 0 === n && (n = new Set,
                t.set(e, n)),
                n
            }
            _getShaderStage(e) {
                const t = this.shaderCache;
                let n = t.get(e);
                return void 0 === n && (n = new uA(e),
                t.set(e, n)),
                n
            }
        }
        class uA {
            constructor(e) {
                this.id = lA++,
                this.code = e,
                this.usedTimes = 0
            }
        }
        function dA(e, t, n, r, i, o, a) {
            const s = new lv
              , l = new cA
              , c = []
              , u = i.isWebGL2
              , d = i.logarithmicDepthBuffer
              , h = i.vertexTextures;
            let p = i.precision;
            const f = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };
            function m(e) {
                return 0 === e ? "uv" : `uv${e}`
            }
            return {
                getParameters: function(o, s, c, g, v) {
                    const y = g.fog
                      , b = v.geometry
                      , _ = o.isMeshStandardMaterial ? g.environment : null
                      , A = (o.isMeshStandardMaterial ? n : t).get(o.envMap || _)
                      , x = A && A.mapping === ep ? A.image.height : null
                      , S = f[o.type];
                    null !== o.precision && (p = i.getMaxPrecision(o.precision),
                    p !== o.precision && console.warn("THREE.WebGLProgram.getParameters:", o.precision, "not supported, using", p, "instead."));
                    const w = b.morphAttributes.position || b.morphAttributes.normal || b.morphAttributes.color
                      , E = void 0 !== w ? w.length : 0;
                    let M, C, T, R, P = 0;
                    if (void 0 !== b.morphAttributes.position && (P = 1),
                    void 0 !== b.morphAttributes.normal && (P = 2),
                    void 0 !== b.morphAttributes.color && (P = 3),
                    S) {
                        const e = ob[S];
                        M = e.vertexShader,
                        C = e.fragmentShader
                    } else
                        M = o.vertexShader,
                        C = o.fragmentShader,
                        l.update(o),
                        T = l.getVertexShaderID(o),
                        R = l.getFragmentShaderID(o);
                    const B = e.getRenderTarget()
                      , I = !0 === v.isInstancedMesh
                      , L = !0 === v.isBatchedMesh
                      , k = !!o.map
                      , D = !!o.matcap
                      , O = !!A
                      , N = !!o.aoMap
                      , F = !!o.lightMap
                      , U = !!o.bumpMap
                      , z = !!o.normalMap
                      , G = !!o.displacementMap
                      , H = !!o.emissiveMap
                      , j = !!o.metalnessMap
                      , W = !!o.roughnessMap
                      , V = o.anisotropy > 0
                      , X = o.clearcoat > 0
                      , J = o.iridescence > 0
                      , K = o.sheen > 0
                      , q = o.transmission > 0
                      , Y = V && !!o.anisotropyMap
                      , Q = X && !!o.clearcoatMap
                      , Z = X && !!o.clearcoatNormalMap
                      , $ = X && !!o.clearcoatRoughnessMap
                      , ee = J && !!o.iridescenceMap
                      , te = J && !!o.iridescenceThicknessMap
                      , ne = K && !!o.sheenColorMap
                      , re = K && !!o.sheenRoughnessMap
                      , ie = !!o.specularMap
                      , oe = !!o.specularColorMap
                      , ae = !!o.specularIntensityMap
                      , se = q && !!o.transmissionMap
                      , le = q && !!o.thicknessMap
                      , ce = !!o.gradientMap
                      , ue = !!o.alphaMap
                      , de = o.alphaTest > 0
                      , he = !!o.alphaHash
                      , pe = !!o.extensions
                      , fe = !!b.attributes.uv1
                      , me = !!b.attributes.uv2
                      , ge = !!b.attributes.uv3;
                    let ve = Gh;
                    return o.toneMapped && (null !== B && !0 !== B.isXRRenderTarget || (ve = e.toneMapping)),
                    {
                        isWebGL2: u,
                        shaderID: S,
                        shaderType: o.type,
                        shaderName: o.name,
                        vertexShader: M,
                        fragmentShader: C,
                        defines: o.defines,
                        customVertexShaderID: T,
                        customFragmentShaderID: R,
                        isRawShaderMaterial: !0 === o.isRawShaderMaterial,
                        glslVersion: o.glslVersion,
                        precision: p,
                        batching: L,
                        instancing: I,
                        instancingColor: I && null !== v.instanceColor,
                        supportsVertexTextures: h,
                        outputColorSpace: null === B ? e.outputColorSpace : !0 === B.isXRRenderTarget ? B.texture.colorSpace : Nf,
                        map: k,
                        matcap: D,
                        envMap: O,
                        envMapMode: O && A.mapping,
                        envMapCubeUVHeight: x,
                        aoMap: N,
                        lightMap: F,
                        bumpMap: U,
                        normalMap: z,
                        displacementMap: h && G,
                        emissiveMap: H,
                        normalMapObjectSpace: z && o.normalMapType === kf,
                        normalMapTangentSpace: z && o.normalMapType === Lf,
                        metalnessMap: j,
                        roughnessMap: W,
                        anisotropy: V,
                        anisotropyMap: Y,
                        clearcoat: X,
                        clearcoatMap: Q,
                        clearcoatNormalMap: Z,
                        clearcoatRoughnessMap: $,
                        iridescence: J,
                        iridescenceMap: ee,
                        iridescenceThicknessMap: te,
                        sheen: K,
                        sheenColorMap: ne,
                        sheenRoughnessMap: re,
                        specularMap: ie,
                        specularColorMap: oe,
                        specularIntensityMap: ae,
                        transmission: q,
                        transmissionMap: se,
                        thicknessMap: le,
                        gradientMap: ce,
                        opaque: !1 === o.transparent && o.blending === oh,
                        alphaMap: ue,
                        alphaTest: de,
                        alphaHash: he,
                        combine: o.combine,
                        mapUv: k && m(o.map.channel),
                        aoMapUv: N && m(o.aoMap.channel),
                        lightMapUv: F && m(o.lightMap.channel),
                        bumpMapUv: U && m(o.bumpMap.channel),
                        normalMapUv: z && m(o.normalMap.channel),
                        displacementMapUv: G && m(o.displacementMap.channel),
                        emissiveMapUv: H && m(o.emissiveMap.channel),
                        metalnessMapUv: j && m(o.metalnessMap.channel),
                        roughnessMapUv: W && m(o.roughnessMap.channel),
                        anisotropyMapUv: Y && m(o.anisotropyMap.channel),
                        clearcoatMapUv: Q && m(o.clearcoatMap.channel),
                        clearcoatNormalMapUv: Z && m(o.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: $ && m(o.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: ee && m(o.iridescenceMap.channel),
                        iridescenceThicknessMapUv: te && m(o.iridescenceThicknessMap.channel),
                        sheenColorMapUv: ne && m(o.sheenColorMap.channel),
                        sheenRoughnessMapUv: re && m(o.sheenRoughnessMap.channel),
                        specularMapUv: ie && m(o.specularMap.channel),
                        specularColorMapUv: oe && m(o.specularColorMap.channel),
                        specularIntensityMapUv: ae && m(o.specularIntensityMap.channel),
                        transmissionMapUv: se && m(o.transmissionMap.channel),
                        thicknessMapUv: le && m(o.thicknessMap.channel),
                        alphaMapUv: ue && m(o.alphaMap.channel),
                        vertexTangents: !!b.attributes.tangent && (z || V),
                        vertexColors: o.vertexColors,
                        vertexAlphas: !0 === o.vertexColors && !!b.attributes.color && 4 === b.attributes.color.itemSize,
                        vertexUv1s: fe,
                        vertexUv2s: me,
                        vertexUv3s: ge,
                        pointsUvs: !0 === v.isPoints && !!b.attributes.uv && (k || ue),
                        fog: !!y,
                        useFog: !0 === o.fog,
                        fogExp2: y && y.isFogExp2,
                        flatShading: !0 === o.flatShading,
                        sizeAttenuation: !0 === o.sizeAttenuation,
                        logarithmicDepthBuffer: d,
                        skinning: !0 === v.isSkinnedMesh,
                        morphTargets: void 0 !== b.morphAttributes.position,
                        morphNormals: void 0 !== b.morphAttributes.normal,
                        morphColors: void 0 !== b.morphAttributes.color,
                        morphTargetsCount: E,
                        morphTextureStride: P,
                        numDirLights: s.directional.length,
                        numPointLights: s.point.length,
                        numSpotLights: s.spot.length,
                        numSpotLightMaps: s.spotLightMap.length,
                        numRectAreaLights: s.rectArea.length,
                        numHemiLights: s.hemi.length,
                        numDirLightShadows: s.directionalShadowMap.length,
                        numPointLightShadows: s.pointShadowMap.length,
                        numSpotLightShadows: s.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: s.numSpotLightShadowsWithMaps,
                        numLightProbes: s.numLightProbes,
                        numClippingPlanes: a.numPlanes,
                        numClipIntersection: a.numIntersection,
                        dithering: o.dithering,
                        shadowMapEnabled: e.shadowMap.enabled && c.length > 0,
                        shadowMapType: e.shadowMap.type,
                        toneMapping: ve,
                        useLegacyLights: e._useLegacyLights,
                        decodeVideoTexture: k && !0 === o.map.isVideoTexture && ng.getTransfer(o.map.colorSpace) === Gf,
                        premultipliedAlpha: o.premultipliedAlpha,
                        doubleSided: o.side === nh,
                        flipSided: o.side === th,
                        useDepthPacking: o.depthPacking >= 0,
                        depthPacking: o.depthPacking || 0,
                        index0AttributeName: o.index0AttributeName,
                        extensionDerivatives: pe && !0 === o.extensions.derivatives,
                        extensionFragDepth: pe && !0 === o.extensions.fragDepth,
                        extensionDrawBuffers: pe && !0 === o.extensions.drawBuffers,
                        extensionShaderTextureLOD: pe && !0 === o.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: u || r.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: u || r.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: u || r.has("EXT_shader_texture_lod"),
                        rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
                        customProgramCacheKey: o.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(t) {
                    const n = [];
                    if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID),
                    n.push(t.customFragmentShaderID)),
                    void 0 !== t.defines)
                        for (const e in t.defines)
                            n.push(e),
                            n.push(t.defines[e]);
                    return !1 === t.isRawShaderMaterial && (!function(e, t) {
                        e.push(t.precision),
                        e.push(t.outputColorSpace),
                        e.push(t.envMapMode),
                        e.push(t.envMapCubeUVHeight),
                        e.push(t.mapUv),
                        e.push(t.alphaMapUv),
                        e.push(t.lightMapUv),
                        e.push(t.aoMapUv),
                        e.push(t.bumpMapUv),
                        e.push(t.normalMapUv),
                        e.push(t.displacementMapUv),
                        e.push(t.emissiveMapUv),
                        e.push(t.metalnessMapUv),
                        e.push(t.roughnessMapUv),
                        e.push(t.anisotropyMapUv),
                        e.push(t.clearcoatMapUv),
                        e.push(t.clearcoatNormalMapUv),
                        e.push(t.clearcoatRoughnessMapUv),
                        e.push(t.iridescenceMapUv),
                        e.push(t.iridescenceThicknessMapUv),
                        e.push(t.sheenColorMapUv),
                        e.push(t.sheenRoughnessMapUv),
                        e.push(t.specularMapUv),
                        e.push(t.specularColorMapUv),
                        e.push(t.specularIntensityMapUv),
                        e.push(t.transmissionMapUv),
                        e.push(t.thicknessMapUv),
                        e.push(t.combine),
                        e.push(t.fogExp2),
                        e.push(t.sizeAttenuation),
                        e.push(t.morphTargetsCount),
                        e.push(t.morphAttributeCount),
                        e.push(t.numDirLights),
                        e.push(t.numPointLights),
                        e.push(t.numSpotLights),
                        e.push(t.numSpotLightMaps),
                        e.push(t.numHemiLights),
                        e.push(t.numRectAreaLights),
                        e.push(t.numDirLightShadows),
                        e.push(t.numPointLightShadows),
                        e.push(t.numSpotLightShadows),
                        e.push(t.numSpotLightShadowsWithMaps),
                        e.push(t.numLightProbes),
                        e.push(t.shadowMapType),
                        e.push(t.toneMapping),
                        e.push(t.numClippingPlanes),
                        e.push(t.numClipIntersection),
                        e.push(t.depthPacking)
                    }(n, t),
                    function(e, t) {
                        s.disableAll(),
                        t.isWebGL2 && s.enable(0);
                        t.supportsVertexTextures && s.enable(1);
                        t.instancing && s.enable(2);
                        t.instancingColor && s.enable(3);
                        t.matcap && s.enable(4);
                        t.envMap && s.enable(5);
                        t.normalMapObjectSpace && s.enable(6);
                        t.normalMapTangentSpace && s.enable(7);
                        t.clearcoat && s.enable(8);
                        t.iridescence && s.enable(9);
                        t.alphaTest && s.enable(10);
                        t.vertexColors && s.enable(11);
                        t.vertexAlphas && s.enable(12);
                        t.vertexUv1s && s.enable(13);
                        t.vertexUv2s && s.enable(14);
                        t.vertexUv3s && s.enable(15);
                        t.vertexTangents && s.enable(16);
                        t.anisotropy && s.enable(17);
                        t.alphaHash && s.enable(18);
                        t.batching && s.enable(19);
                        e.push(s.mask),
                        s.disableAll(),
                        t.fog && s.enable(0);
                        t.useFog && s.enable(1);
                        t.flatShading && s.enable(2);
                        t.logarithmicDepthBuffer && s.enable(3);
                        t.skinning && s.enable(4);
                        t.morphTargets && s.enable(5);
                        t.morphNormals && s.enable(6);
                        t.morphColors && s.enable(7);
                        t.premultipliedAlpha && s.enable(8);
                        t.shadowMapEnabled && s.enable(9);
                        t.useLegacyLights && s.enable(10);
                        t.doubleSided && s.enable(11);
                        t.flipSided && s.enable(12);
                        t.useDepthPacking && s.enable(13);
                        t.dithering && s.enable(14);
                        t.transmission && s.enable(15);
                        t.sheen && s.enable(16);
                        t.opaque && s.enable(17);
                        t.pointsUvs && s.enable(18);
                        t.decodeVideoTexture && s.enable(19);
                        e.push(s.mask)
                    }(n, t),
                    n.push(e.outputColorSpace)),
                    n.push(t.customProgramCacheKey),
                    n.join()
                },
                getUniforms: function(e) {
                    const t = f[e.type];
                    let n;
                    if (t) {
                        const e = ob[t];
                        n = Uy.clone(e.uniforms)
                    } else
                        n = e.uniforms;
                    return n
                },
                acquireProgram: function(t, n) {
                    let r;
                    for (let e = 0, i = c.length; e < i; e++) {
                        const t = c[e];
                        if (t.cacheKey === n) {
                            r = t,
                            ++r.usedTimes;
                            break
                        }
                    }
                    return void 0 === r && (r = new sA(e,n,t,o),
                    c.push(r)),
                    r
                },
                releaseProgram: function(e) {
                    if (0 === --e.usedTimes) {
                        const t = c.indexOf(e);
                        c[t] = c[c.length - 1],
                        c.pop(),
                        e.destroy()
                    }
                },
                releaseShaderCache: function(e) {
                    l.remove(e)
                },
                programs: c,
                dispose: function() {
                    l.dispose()
                }
            }
        }
        function hA() {
            let e = new WeakMap;
            return {
                get: function(t) {
                    let n = e.get(t);
                    return void 0 === n && (n = {},
                    e.set(t, n)),
                    n
                },
                remove: function(t) {
                    e.delete(t)
                },
                update: function(t, n, r) {
                    e.get(t)[n] = r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        function pA(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
        }
        function fA(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
        }
        function mA() {
            const e = [];
            let t = 0;
            const n = []
              , r = []
              , i = [];
            function o(n, r, i, o, a, s) {
                let l = e[t];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: r,
                    material: i,
                    groupOrder: o,
                    renderOrder: n.renderOrder,
                    z: a,
                    group: s
                },
                e[t] = l) : (l.id = n.id,
                l.object = n,
                l.geometry = r,
                l.material = i,
                l.groupOrder = o,
                l.renderOrder = n.renderOrder,
                l.z = a,
                l.group = s),
                t++,
                l
            }
            return {
                opaque: n,
                transmissive: r,
                transparent: i,
                init: function() {
                    t = 0,
                    n.length = 0,
                    r.length = 0,
                    i.length = 0
                },
                push: function(e, t, a, s, l, c) {
                    const u = o(e, t, a, s, l, c);
                    a.transmission > 0 ? r.push(u) : !0 === a.transparent ? i.push(u) : n.push(u)
                },
                unshift: function(e, t, a, s, l, c) {
                    const u = o(e, t, a, s, l, c);
                    a.transmission > 0 ? r.unshift(u) : !0 === a.transparent ? i.unshift(u) : n.unshift(u)
                },
                finish: function() {
                    for (let n = t, r = e.length; n < r; n++) {
                        const t = e[n];
                        if (null === t.id)
                            break;
                        t.id = null,
                        t.object = null,
                        t.geometry = null,
                        t.material = null,
                        t.group = null
                    }
                },
                sort: function(e, t) {
                    n.length > 1 && n.sort(e || pA),
                    r.length > 1 && r.sort(t || fA),
                    i.length > 1 && i.sort(t || fA)
                }
            }
        }
        function gA() {
            let e = new WeakMap;
            return {
                get: function(t, n) {
                    const r = e.get(t);
                    let i;
                    return void 0 === r ? (i = new mA,
                    e.set(t, [i])) : n >= r.length ? (i = new mA,
                    r.push(i)) : i = r[n],
                    i
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        function vA() {
            const e = {};
            return {
                get: function(t) {
                    if (void 0 !== e[t.id])
                        return e[t.id];
                    let n;
                    switch (t.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new Ag,
                            color: new Uv
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new Ag,
                            direction: new Ag,
                            color: new Uv,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new Ag,
                            color: new Uv,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new Ag,
                            skyColor: new Uv,
                            groundColor: new Uv
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new Uv,
                            position: new Ag,
                            halfWidth: new Ag,
                            halfHeight: new Ag
                        }
                    }
                    return e[t.id] = n,
                    n
                }
            }
        }
        let yA = 0;
        function bA(e, t) {
            return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
        }
        function _A(e, t) {
            const n = new vA
              , r = function() {
                const e = {};
                return {
                    get: function(t) {
                        if (void 0 !== e[t.id])
                            return e[t.id];
                        let n;
                        switch (t.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Hm
                            };
                            break;
                        case "PointLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Hm,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                        }
                        return e[t.id] = n,
                        n
                    }
                }
            }()
              , i = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1,
                    numLightProbes: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0,
                numLightProbes: 0
            };
            for (let l = 0; l < 9; l++)
                i.probe.push(new Ag);
            const o = new Ag
              , a = new Qg
              , s = new Qg;
            return {
                setup: function(o, a) {
                    let s = 0
                      , l = 0
                      , c = 0;
                    for (let e = 0; e < 9; e++)
                        i.probe[e].set(0, 0, 0);
                    let u = 0
                      , d = 0
                      , h = 0
                      , p = 0
                      , f = 0
                      , m = 0
                      , g = 0
                      , v = 0
                      , y = 0
                      , b = 0
                      , _ = 0;
                    o.sort(bA);
                    const A = !0 === a ? Math.PI : 1;
                    for (let e = 0, t = o.length; e < t; e++) {
                        const t = o[e]
                          , a = t.color
                          , x = t.intensity
                          , S = t.distance
                          , w = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                        if (t.isAmbientLight)
                            s += a.r * x * A,
                            l += a.g * x * A,
                            c += a.b * x * A;
                        else if (t.isLightProbe) {
                            for (let e = 0; e < 9; e++)
                                i.probe[e].addScaledVector(t.sh.coefficients[e], x);
                            _++
                        } else if (t.isDirectionalLight) {
                            const e = n.get(t);
                            if (e.color.copy(t.color).multiplyScalar(t.intensity * A),
                            t.castShadow) {
                                const e = t.shadow
                                  , n = r.get(t);
                                n.shadowBias = e.bias,
                                n.shadowNormalBias = e.normalBias,
                                n.shadowRadius = e.radius,
                                n.shadowMapSize = e.mapSize,
                                i.directionalShadow[u] = n,
                                i.directionalShadowMap[u] = w,
                                i.directionalShadowMatrix[u] = t.shadow.matrix,
                                m++
                            }
                            i.directional[u] = e,
                            u++
                        } else if (t.isSpotLight) {
                            const e = n.get(t);
                            e.position.setFromMatrixPosition(t.matrixWorld),
                            e.color.copy(a).multiplyScalar(x * A),
                            e.distance = S,
                            e.coneCos = Math.cos(t.angle),
                            e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)),
                            e.decay = t.decay,
                            i.spot[h] = e;
                            const o = t.shadow;
                            if (t.map && (i.spotLightMap[y] = t.map,
                            y++,
                            o.updateMatrices(t),
                            t.castShadow && b++),
                            i.spotLightMatrix[h] = o.matrix,
                            t.castShadow) {
                                const e = r.get(t);
                                e.shadowBias = o.bias,
                                e.shadowNormalBias = o.normalBias,
                                e.shadowRadius = o.radius,
                                e.shadowMapSize = o.mapSize,
                                i.spotShadow[h] = e,
                                i.spotShadowMap[h] = w,
                                v++
                            }
                            h++
                        } else if (t.isRectAreaLight) {
                            const e = n.get(t);
                            e.color.copy(a).multiplyScalar(x),
                            e.halfWidth.set(.5 * t.width, 0, 0),
                            e.halfHeight.set(0, .5 * t.height, 0),
                            i.rectArea[p] = e,
                            p++
                        } else if (t.isPointLight) {
                            const e = n.get(t);
                            if (e.color.copy(t.color).multiplyScalar(t.intensity * A),
                            e.distance = t.distance,
                            e.decay = t.decay,
                            t.castShadow) {
                                const e = t.shadow
                                  , n = r.get(t);
                                n.shadowBias = e.bias,
                                n.shadowNormalBias = e.normalBias,
                                n.shadowRadius = e.radius,
                                n.shadowMapSize = e.mapSize,
                                n.shadowCameraNear = e.camera.near,
                                n.shadowCameraFar = e.camera.far,
                                i.pointShadow[d] = n,
                                i.pointShadowMap[d] = w,
                                i.pointShadowMatrix[d] = t.shadow.matrix,
                                g++
                            }
                            i.point[d] = e,
                            d++
                        } else if (t.isHemisphereLight) {
                            const e = n.get(t);
                            e.skyColor.copy(t.color).multiplyScalar(x * A),
                            e.groundColor.copy(t.groundColor).multiplyScalar(x * A),
                            i.hemi[f] = e,
                            f++
                        }
                    }
                    p > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = ib.LTC_FLOAT_1,
                    i.rectAreaLTC2 = ib.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = ib.LTC_HALF_1,
                    i.rectAreaLTC2 = ib.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                    i.ambient[0] = s,
                    i.ambient[1] = l,
                    i.ambient[2] = c;
                    const x = i.hash;
                    x.directionalLength === u && x.pointLength === d && x.spotLength === h && x.rectAreaLength === p && x.hemiLength === f && x.numDirectionalShadows === m && x.numPointShadows === g && x.numSpotShadows === v && x.numSpotMaps === y && x.numLightProbes === _ || (i.directional.length = u,
                    i.spot.length = h,
                    i.rectArea.length = p,
                    i.point.length = d,
                    i.hemi.length = f,
                    i.directionalShadow.length = m,
                    i.directionalShadowMap.length = m,
                    i.pointShadow.length = g,
                    i.pointShadowMap.length = g,
                    i.spotShadow.length = v,
                    i.spotShadowMap.length = v,
                    i.directionalShadowMatrix.length = m,
                    i.pointShadowMatrix.length = g,
                    i.spotLightMatrix.length = v + y - b,
                    i.spotLightMap.length = y,
                    i.numSpotLightShadowsWithMaps = b,
                    i.numLightProbes = _,
                    x.directionalLength = u,
                    x.pointLength = d,
                    x.spotLength = h,
                    x.rectAreaLength = p,
                    x.hemiLength = f,
                    x.numDirectionalShadows = m,
                    x.numPointShadows = g,
                    x.numSpotShadows = v,
                    x.numSpotMaps = y,
                    x.numLightProbes = _,
                    i.version = yA++)
                },
                setupView: function(e, t) {
                    let n = 0
                      , r = 0
                      , l = 0
                      , c = 0
                      , u = 0;
                    const d = t.matrixWorldInverse;
                    for (let h = 0, p = e.length; h < p; h++) {
                        const t = e[h];
                        if (t.isDirectionalLight) {
                            const e = i.directional[n];
                            e.direction.setFromMatrixPosition(t.matrixWorld),
                            o.setFromMatrixPosition(t.target.matrixWorld),
                            e.direction.sub(o),
                            e.direction.transformDirection(d),
                            n++
                        } else if (t.isSpotLight) {
                            const e = i.spot[l];
                            e.position.setFromMatrixPosition(t.matrixWorld),
                            e.position.applyMatrix4(d),
                            e.direction.setFromMatrixPosition(t.matrixWorld),
                            o.setFromMatrixPosition(t.target.matrixWorld),
                            e.direction.sub(o),
                            e.direction.transformDirection(d),
                            l++
                        } else if (t.isRectAreaLight) {
                            const e = i.rectArea[c];
                            e.position.setFromMatrixPosition(t.matrixWorld),
                            e.position.applyMatrix4(d),
                            s.identity(),
                            a.copy(t.matrixWorld),
                            a.premultiply(d),
                            s.extractRotation(a),
                            e.halfWidth.set(.5 * t.width, 0, 0),
                            e.halfHeight.set(0, .5 * t.height, 0),
                            e.halfWidth.applyMatrix4(s),
                            e.halfHeight.applyMatrix4(s),
                            c++
                        } else if (t.isPointLight) {
                            const e = i.point[r];
                            e.position.setFromMatrixPosition(t.matrixWorld),
                            e.position.applyMatrix4(d),
                            r++
                        } else if (t.isHemisphereLight) {
                            const e = i.hemi[u];
                            e.direction.setFromMatrixPosition(t.matrixWorld),
                            e.direction.transformDirection(d),
                            u++
                        }
                    }
                },
                state: i
            }
        }
        function AA(e, t) {
            const n = new _A(e,t)
              , r = []
              , i = [];
            return {
                init: function() {
                    r.length = 0,
                    i.length = 0
                },
                state: {
                    lightsArray: r,
                    shadowsArray: i,
                    lights: n
                },
                setupLights: function(e) {
                    n.setup(r, e)
                },
                setupLightsView: function(e) {
                    n.setupView(r, e)
                },
                pushLight: function(e) {
                    r.push(e)
                },
                pushShadow: function(e) {
                    i.push(e)
                }
            }
        }
        function xA(e, t) {
            let n = new WeakMap;
            return {
                get: function(r) {
                    let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    const o = n.get(r);
                    let a;
                    return void 0 === o ? (a = new AA(e,t),
                    n.set(r, [a])) : i >= o.length ? (a = new AA(e,t),
                    o.push(a)) : a = o[i],
                    a
                },
                dispose: function() {
                    n = new WeakMap
                }
            }
        }
        class SA extends Hv {
            constructor(e) {
                super(),
                this.isMeshDepthMaterial = !0,
                this.type = "MeshDepthMaterial",
                this.depthPacking = Bf,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.depthPacking = e.depthPacking,
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this
            }
        }
        class wA extends Hv {
            constructor(e) {
                super(),
                this.isMeshDistanceMaterial = !0,
                this.type = "MeshDistanceMaterial",
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this
            }
        }
        function EA(e, t, n) {
            let r = new $y;
            const i = new Hm
              , o = new Hm
              , a = new hg
              , s = new SA({
                depthPacking: If
            })
              , l = new wA
              , c = {}
              , u = n.maxTextureSize
              , d = {
                [eh]: th,
                [th]: eh,
                [nh]: nh
            }
              , h = new zy({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new Hm
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
            })
              , p = h.clone();
            p.defines.HORIZONTAL_PASS = 1;
            const f = new my;
            f.setAttribute("position", new Qv(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const m = new Ly(f,h)
              , g = this;
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = Qd;
            let v = this.type;
            function y(n, r) {
                const o = t.update(m);
                h.defines.VSM_SAMPLES !== n.blurSamples && (h.defines.VSM_SAMPLES = n.blurSamples,
                p.defines.VSM_SAMPLES = n.blurSamples,
                h.needsUpdate = !0,
                p.needsUpdate = !0),
                null === n.mapPass && (n.mapPass = new fg(i.x,i.y)),
                h.uniforms.shadow_pass.value = n.map.texture,
                h.uniforms.resolution.value = n.mapSize,
                h.uniforms.radius.value = n.radius,
                e.setRenderTarget(n.mapPass),
                e.clear(),
                e.renderBufferDirect(r, null, o, h, m, null),
                p.uniforms.shadow_pass.value = n.mapPass.texture,
                p.uniforms.resolution.value = n.mapSize,
                p.uniforms.radius.value = n.radius,
                e.setRenderTarget(n.map),
                e.clear(),
                e.renderBufferDirect(r, null, o, p, m, null)
            }
            function b(t, n, r, i) {
                let o = null;
                const a = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                if (void 0 !== a)
                    o = a;
                else if (o = !0 === r.isPointLight ? l : s,
                e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                    const e = o.uuid
                      , t = n.uuid;
                    let r = c[e];
                    void 0 === r && (r = {},
                    c[e] = r);
                    let i = r[t];
                    void 0 === i && (i = o.clone(),
                    r[t] = i),
                    o = i
                }
                if (o.visible = n.visible,
                o.wireframe = n.wireframe,
                o.side = i === $d ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : d[n.side],
                o.alphaMap = n.alphaMap,
                o.alphaTest = n.alphaTest,
                o.map = n.map,
                o.clipShadows = n.clipShadows,
                o.clippingPlanes = n.clippingPlanes,
                o.clipIntersection = n.clipIntersection,
                o.displacementMap = n.displacementMap,
                o.displacementScale = n.displacementScale,
                o.displacementBias = n.displacementBias,
                o.wireframeLinewidth = n.wireframeLinewidth,
                o.linewidth = n.linewidth,
                !0 === r.isPointLight && !0 === o.isMeshDistanceMaterial) {
                    e.properties.get(o).light = r
                }
                return o
            }
            function _(n, i, o, a, s) {
                if (!1 === n.visible)
                    return;
                if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && s === $d) && (!n.frustumCulled || r.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                    const r = t.update(n)
                      , l = n.material;
                    if (Array.isArray(l)) {
                        const t = r.groups;
                        for (let c = 0, u = t.length; c < u; c++) {
                            const u = t[c]
                              , d = l[u.materialIndex];
                            if (d && d.visible) {
                                const t = b(n, d, a, s);
                                n.onBeforeShadow(e, n, i, o, r, t, u),
                                e.renderBufferDirect(o, null, r, t, n, u),
                                n.onAfterShadow(e, n, i, o, r, t, u)
                            }
                        }
                    } else if (l.visible) {
                        const t = b(n, l, a, s);
                        n.onBeforeShadow(e, n, i, o, r, t, null),
                        e.renderBufferDirect(o, null, r, t, n, null),
                        n.onAfterShadow(e, n, i, o, r, t, null)
                    }
                }
                const l = n.children;
                for (let e = 0, t = l.length; e < t; e++)
                    _(l[e], i, o, a, s)
            }
            this.render = function(t, n, s) {
                if (!1 === g.enabled)
                    return;
                if (!1 === g.autoUpdate && !1 === g.needsUpdate)
                    return;
                if (0 === t.length)
                    return;
                const l = e.getRenderTarget()
                  , c = e.getActiveCubeFace()
                  , d = e.getActiveMipmapLevel()
                  , h = e.state;
                h.setBlending(ih),
                h.buffers.color.setClear(1, 1, 1, 1),
                h.buffers.depth.setTest(!0),
                h.setScissorTest(!1);
                const p = v !== $d && this.type === $d
                  , f = v === $d && this.type !== $d;
                for (let m = 0, g = t.length; m < g; m++) {
                    const l = t[m]
                      , c = l.shadow;
                    if (void 0 === c) {
                        console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
                        continue
                    }
                    if (!1 === c.autoUpdate && !1 === c.needsUpdate)
                        continue;
                    i.copy(c.mapSize);
                    const d = c.getFrameExtents();
                    if (i.multiply(d),
                    o.copy(c.mapSize),
                    (i.x > u || i.y > u) && (i.x > u && (o.x = Math.floor(u / d.x),
                    i.x = o.x * d.x,
                    c.mapSize.x = o.x),
                    i.y > u && (o.y = Math.floor(u / d.y),
                    i.y = o.y * d.y,
                    c.mapSize.y = o.y)),
                    null === c.map || !0 === p || !0 === f) {
                        const e = this.type !== $d ? {
                            minFilter: ip,
                            magFilter: ip
                        } : {};
                        null !== c.map && c.map.dispose(),
                        c.map = new fg(i.x,i.y,e),
                        c.map.texture.name = l.name + ".shadowMap",
                        c.camera.updateProjectionMatrix()
                    }
                    e.setRenderTarget(c.map),
                    e.clear();
                    const g = c.getViewportCount();
                    for (let e = 0; e < g; e++) {
                        const t = c.getViewport(e);
                        a.set(o.x * t.x, o.y * t.y, o.x * t.z, o.y * t.w),
                        h.viewport(a),
                        c.updateMatrices(l, e),
                        r = c.getFrustum(),
                        _(n, s, c.camera, l, this.type)
                    }
                    !0 !== c.isPointLightShadow && this.type === $d && y(c, s),
                    c.needsUpdate = !1
                }
                v = this.type,
                g.needsUpdate = !1,
                e.setRenderTarget(l, c, d)
            }
        }
        function MA(e, t, n) {
            const r = n.isWebGL2;
            const i = new function() {
                let t = !1;
                const n = new hg;
                let r = null;
                const i = new hg(0,0,0,0);
                return {
                    setMask: function(n) {
                        r === n || t || (e.colorMask(n, n, n, n),
                        r = n)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t, r, o, a, s) {
                        !0 === s && (t *= a,
                        r *= a,
                        o *= a),
                        n.set(t, r, o, a),
                        !1 === i.equals(n) && (e.clearColor(t, r, o, a),
                        i.copy(n))
                    },
                    reset: function() {
                        t = !1,
                        r = null,
                        i.set(-1, 0, 0, 0)
                    }
                }
            }
              , o = new function() {
                let t = !1
                  , n = null
                  , r = null
                  , i = null;
                return {
                    setTest: function(t) {
                        t ? H(e.DEPTH_TEST) : j(e.DEPTH_TEST)
                    },
                    setMask: function(r) {
                        n === r || t || (e.depthMask(r),
                        n = r)
                    },
                    setFunc: function(t) {
                        if (r !== t) {
                            switch (t) {
                            case Ph:
                                e.depthFunc(e.NEVER);
                                break;
                            case Bh:
                                e.depthFunc(e.ALWAYS);
                                break;
                            case Ih:
                                e.depthFunc(e.LESS);
                                break;
                            case Lh:
                                e.depthFunc(e.LEQUAL);
                                break;
                            case kh:
                                e.depthFunc(e.EQUAL);
                                break;
                            case Dh:
                                e.depthFunc(e.GEQUAL);
                                break;
                            case Oh:
                                e.depthFunc(e.GREATER);
                                break;
                            case Nh:
                                e.depthFunc(e.NOTEQUAL);
                                break;
                            default:
                                e.depthFunc(e.LEQUAL)
                            }
                            r = t
                        }
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        i !== t && (e.clearDepth(t),
                        i = t)
                    },
                    reset: function() {
                        t = !1,
                        n = null,
                        r = null,
                        i = null
                    }
                }
            }
              , a = new function() {
                let t = !1
                  , n = null
                  , r = null
                  , i = null
                  , o = null
                  , a = null
                  , s = null
                  , l = null
                  , c = null;
                return {
                    setTest: function(n) {
                        t || (n ? H(e.STENCIL_TEST) : j(e.STENCIL_TEST))
                    },
                    setMask: function(r) {
                        n === r || t || (e.stencilMask(r),
                        n = r)
                    },
                    setFunc: function(t, n, a) {
                        r === t && i === n && o === a || (e.stencilFunc(t, n, a),
                        r = t,
                        i = n,
                        o = a)
                    },
                    setOp: function(t, n, r) {
                        a === t && s === n && l === r || (e.stencilOp(t, n, r),
                        a = t,
                        s = n,
                        l = r)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        c !== t && (e.clearStencil(t),
                        c = t)
                    },
                    reset: function() {
                        t = !1,
                        n = null,
                        r = null,
                        i = null,
                        o = null,
                        a = null,
                        s = null,
                        l = null,
                        c = null
                    }
                }
            }
              , s = new WeakMap
              , l = new WeakMap;
            let c = {}
              , u = {}
              , d = new WeakMap
              , h = []
              , p = null
              , f = !1
              , m = null
              , g = null
              , v = null
              , y = null
              , b = null
              , _ = null
              , A = null
              , x = new Uv(0,0,0)
              , S = 0
              , w = !1
              , E = null
              , M = null
              , C = null
              , T = null
              , R = null;
            const P = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let B = !1
              , I = 0;
            const L = e.getParameter(e.VERSION);
            -1 !== L.indexOf("WebGL") ? (I = parseFloat(/^WebGL (\d)/.exec(L)[1]),
            B = I >= 1) : -1 !== L.indexOf("OpenGL ES") && (I = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]),
            B = I >= 2);
            let k = null
              , D = {};
            const O = e.getParameter(e.SCISSOR_BOX)
              , N = e.getParameter(e.VIEWPORT)
              , F = (new hg).fromArray(O)
              , U = (new hg).fromArray(N);
            function z(t, n, i, o) {
                const a = new Uint8Array(4)
                  , s = e.createTexture();
                e.bindTexture(t, s),
                e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
                e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
                for (let l = 0; l < i; l++)
                    !r || t !== e.TEXTURE_3D && t !== e.TEXTURE_2D_ARRAY ? e.texImage2D(n + l, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, a) : e.texImage3D(n, 0, e.RGBA, 1, 1, o, 0, e.RGBA, e.UNSIGNED_BYTE, a);
                return s
            }
            const G = {};
            function H(t) {
                !0 !== c[t] && (e.enable(t),
                c[t] = !0)
            }
            function j(t) {
                !1 !== c[t] && (e.disable(t),
                c[t] = !1)
            }
            G[e.TEXTURE_2D] = z(e.TEXTURE_2D, e.TEXTURE_2D, 1),
            G[e.TEXTURE_CUBE_MAP] = z(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
            r && (G[e.TEXTURE_2D_ARRAY] = z(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1),
            G[e.TEXTURE_3D] = z(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1)),
            i.setClear(0, 0, 0, 1),
            o.setClear(1),
            a.setClear(0),
            H(e.DEPTH_TEST),
            o.setFunc(Lh),
            J(!1),
            K(Jd),
            H(e.CULL_FACE),
            X(ih);
            const W = {
                [uh]: e.FUNC_ADD,
                [dh]: e.FUNC_SUBTRACT,
                [hh]: e.FUNC_REVERSE_SUBTRACT
            };
            if (r)
                W[ph] = e.MIN,
                W[fh] = e.MAX;
            else {
                const e = t.get("EXT_blend_minmax");
                null !== e && (W[ph] = e.MIN_EXT,
                W[fh] = e.MAX_EXT)
            }
            const V = {
                [mh]: e.ZERO,
                [gh]: e.ONE,
                [vh]: e.SRC_COLOR,
                [bh]: e.SRC_ALPHA,
                [Eh]: e.SRC_ALPHA_SATURATE,
                [Sh]: e.DST_COLOR,
                [Ah]: e.DST_ALPHA,
                [yh]: e.ONE_MINUS_SRC_COLOR,
                [_h]: e.ONE_MINUS_SRC_ALPHA,
                [wh]: e.ONE_MINUS_DST_COLOR,
                [xh]: e.ONE_MINUS_DST_ALPHA,
                [Mh]: e.CONSTANT_COLOR,
                [Ch]: e.ONE_MINUS_CONSTANT_COLOR,
                [Th]: e.CONSTANT_ALPHA,
                [Rh]: e.ONE_MINUS_CONSTANT_ALPHA
            };
            function X(t, n, r, i, o, a, s, l, c, u) {
                if (t !== ih) {
                    if (!1 === f && (H(e.BLEND),
                    f = !0),
                    t === ch)
                        o = o || n,
                        a = a || r,
                        s = s || i,
                        n === g && o === b || (e.blendEquationSeparate(W[n], W[o]),
                        g = n,
                        b = o),
                        r === v && i === y && a === _ && s === A || (e.blendFuncSeparate(V[r], V[i], V[a], V[s]),
                        v = r,
                        y = i,
                        _ = a,
                        A = s),
                        !1 !== l.equals(x) && c === S || (e.blendColor(l.r, l.g, l.b, c),
                        x.copy(l),
                        S = c),
                        m = t,
                        w = !1;
                    else if (t !== m || u !== w) {
                        if (g === uh && b === uh || (e.blendEquation(e.FUNC_ADD),
                        g = uh,
                        b = uh),
                        u)
                            switch (t) {
                            case oh:
                                e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                break;
                            case ah:
                                e.blendFunc(e.ONE, e.ONE);
                                break;
                            case sh:
                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                break;
                            case lh:
                                e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                        else
                            switch (t) {
                            case oh:
                                e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                break;
                            case ah:
                                e.blendFunc(e.SRC_ALPHA, e.ONE);
                                break;
                            case sh:
                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                break;
                            case lh:
                                e.blendFunc(e.ZERO, e.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                        v = null,
                        y = null,
                        _ = null,
                        A = null,
                        x.set(0, 0, 0),
                        S = 0,
                        m = t,
                        w = u
                    }
                } else
                    !0 === f && (j(e.BLEND),
                    f = !1)
            }
            function J(t) {
                E !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW),
                E = t)
            }
            function K(t) {
                t !== Xd ? (H(e.CULL_FACE),
                t !== M && (t === Jd ? e.cullFace(e.BACK) : t === Kd ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : j(e.CULL_FACE),
                M = t
            }
            function q(t, n, r) {
                t ? (H(e.POLYGON_OFFSET_FILL),
                T === n && R === r || (e.polygonOffset(n, r),
                T = n,
                R = r)) : j(e.POLYGON_OFFSET_FILL)
            }
            return {
                buffers: {
                    color: i,
                    depth: o,
                    stencil: a
                },
                enable: H,
                disable: j,
                bindFramebuffer: function(t, n) {
                    return u[t] !== n && (e.bindFramebuffer(t, n),
                    u[t] = n,
                    r && (t === e.DRAW_FRAMEBUFFER && (u[e.FRAMEBUFFER] = n),
                    t === e.FRAMEBUFFER && (u[e.DRAW_FRAMEBUFFER] = n)),
                    !0)
                },
                drawBuffers: function(r, i) {
                    let o = h
                      , a = !1;
                    if (r)
                        if (o = d.get(i),
                        void 0 === o && (o = [],
                        d.set(i, o)),
                        r.isWebGLMultipleRenderTargets) {
                            const t = r.texture;
                            if (o.length !== t.length || o[0] !== e.COLOR_ATTACHMENT0) {
                                for (let n = 0, r = t.length; n < r; n++)
                                    o[n] = e.COLOR_ATTACHMENT0 + n;
                                o.length = t.length,
                                a = !0
                            }
                        } else
                            o[0] !== e.COLOR_ATTACHMENT0 && (o[0] = e.COLOR_ATTACHMENT0,
                            a = !0);
                    else
                        o[0] !== e.BACK && (o[0] = e.BACK,
                        a = !0);
                    a && (n.isWebGL2 ? e.drawBuffers(o) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(o))
                },
                useProgram: function(t) {
                    return p !== t && (e.useProgram(t),
                    p = t,
                    !0)
                },
                setBlending: X,
                setMaterial: function(t, n) {
                    t.side === nh ? j(e.CULL_FACE) : H(e.CULL_FACE);
                    let r = t.side === th;
                    n && (r = !r),
                    J(r),
                    t.blending === oh && !1 === t.transparent ? X(ih) : X(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha),
                    o.setFunc(t.depthFunc),
                    o.setTest(t.depthTest),
                    o.setMask(t.depthWrite),
                    i.setMask(t.colorWrite);
                    const s = t.stencilWrite;
                    a.setTest(s),
                    s && (a.setMask(t.stencilWriteMask),
                    a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                    a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                    q(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                    !0 === t.alphaToCoverage ? H(e.SAMPLE_ALPHA_TO_COVERAGE) : j(e.SAMPLE_ALPHA_TO_COVERAGE)
                },
                setFlipSided: J,
                setCullFace: K,
                setLineWidth: function(t) {
                    t !== C && (B && e.lineWidth(t),
                    C = t)
                },
                setPolygonOffset: q,
                setScissorTest: function(t) {
                    t ? H(e.SCISSOR_TEST) : j(e.SCISSOR_TEST)
                },
                activeTexture: function(t) {
                    void 0 === t && (t = e.TEXTURE0 + P - 1),
                    k !== t && (e.activeTexture(t),
                    k = t)
                },
                bindTexture: function(t, n, r) {
                    void 0 === r && (r = null === k ? e.TEXTURE0 + P - 1 : k);
                    let i = D[r];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    },
                    D[r] = i),
                    i.type === t && i.texture === n || (k !== r && (e.activeTexture(r),
                    k = r),
                    e.bindTexture(t, n || G[t]),
                    i.type = t,
                    i.texture = n)
                },
                unbindTexture: function() {
                    const t = D[k];
                    void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
                    t.type = void 0,
                    t.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        e.compressedTexImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexImage3D: function() {
                    try {
                        e.compressedTexImage3D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        e.texImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function() {
                    try {
                        e.texImage3D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                updateUBOMapping: function(t, n) {
                    let r = l.get(n);
                    void 0 === r && (r = new WeakMap,
                    l.set(n, r));
                    let i = r.get(t);
                    void 0 === i && (i = e.getUniformBlockIndex(n, t.name),
                    r.set(t, i))
                },
                uniformBlockBinding: function(t, n) {
                    const r = l.get(n).get(t);
                    s.get(n) !== r && (e.uniformBlockBinding(n, r, t.__bindingPointIndex),
                    s.set(n, r))
                },
                texStorage2D: function() {
                    try {
                        e.texStorage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texStorage3D: function() {
                    try {
                        e.texStorage3D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage2D: function() {
                    try {
                        e.texSubImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage3D: function() {
                    try {
                        e.texSubImage3D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage2D: function() {
                    try {
                        e.compressedTexSubImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage3D: function() {
                    try {
                        e.compressedTexSubImage3D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(t) {
                    !1 === F.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                    F.copy(t))
                },
                viewport: function(t) {
                    !1 === U.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                    U.copy(t))
                },
                reset: function() {
                    e.disable(e.BLEND),
                    e.disable(e.CULL_FACE),
                    e.disable(e.DEPTH_TEST),
                    e.disable(e.POLYGON_OFFSET_FILL),
                    e.disable(e.SCISSOR_TEST),
                    e.disable(e.STENCIL_TEST),
                    e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
                    e.blendEquation(e.FUNC_ADD),
                    e.blendFunc(e.ONE, e.ZERO),
                    e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
                    e.blendColor(0, 0, 0, 0),
                    e.colorMask(!0, !0, !0, !0),
                    e.clearColor(0, 0, 0, 0),
                    e.depthMask(!0),
                    e.depthFunc(e.LESS),
                    e.clearDepth(1),
                    e.stencilMask(4294967295),
                    e.stencilFunc(e.ALWAYS, 0, 4294967295),
                    e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
                    e.clearStencil(0),
                    e.cullFace(e.BACK),
                    e.frontFace(e.CCW),
                    e.polygonOffset(0, 0),
                    e.activeTexture(e.TEXTURE0),
                    e.bindFramebuffer(e.FRAMEBUFFER, null),
                    !0 === r && (e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                    e.bindFramebuffer(e.READ_FRAMEBUFFER, null)),
                    e.useProgram(null),
                    e.lineWidth(1),
                    e.scissor(0, 0, e.canvas.width, e.canvas.height),
                    e.viewport(0, 0, e.canvas.width, e.canvas.height),
                    c = {},
                    k = null,
                    D = {},
                    u = {},
                    d = new WeakMap,
                    h = [],
                    p = null,
                    f = !1,
                    m = null,
                    g = null,
                    v = null,
                    y = null,
                    b = null,
                    _ = null,
                    A = null,
                    x = new Uv(0,0,0),
                    S = 0,
                    w = !1,
                    E = null,
                    M = null,
                    C = null,
                    T = null,
                    R = null,
                    F.set(0, 0, e.canvas.width, e.canvas.height),
                    U.set(0, 0, e.canvas.width, e.canvas.height),
                    i.reset(),
                    o.reset(),
                    a.reset()
                }
            }
        }
        function CA(e, t, n, r, i, o, a) {
            const s = i.isWebGL2
              , l = i.maxTextures
              , c = i.maxCubemapSize
              , u = i.maxTextureSize
              , d = i.maxSamples
              , h = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null
              , p = "undefined" !== typeof navigator && /OculusBrowser/g.test(navigator.userAgent)
              , f = new WeakMap;
            let m;
            const g = new WeakMap;
            let v = !1;
            try {
                v = "undefined" !== typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
            } catch (j) {}
            function y(e, t) {
                return v ? new OffscreenCanvas(e,t) : Km("canvas")
            }
            function b(e, t, n, r) {
                let i = 1;
                if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)),
                i < 1 || !0 === t) {
                    if ("undefined" !== typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && e instanceof ImageBitmap) {
                        const r = t ? Fm : Math.floor
                          , o = r(i * e.width)
                          , a = r(i * e.height);
                        void 0 === m && (m = y(o, a));
                        const s = n ? y(o, a) : m;
                        s.width = o,
                        s.height = a;
                        return s.getContext("2d").drawImage(e, 0, 0, o, a),
                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + o + "x" + a + ")."),
                        s
                    }
                    return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."),
                    e
                }
                return e
            }
            function _(e) {
                return Nm(e.width) && Nm(e.height)
            }
            function A(e, t) {
                return e.generateMipmaps && t && e.minFilter !== ip && e.minFilter !== cp
            }
            function x(t) {
                e.generateMipmap(t)
            }
            function S(n, r, i, o) {
                let a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                if (!1 === s)
                    return r;
                if (null !== n) {
                    if (void 0 !== e[n])
                        return e[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let l = r;
                if (r === e.RED && (i === e.FLOAT && (l = e.R32F),
                i === e.HALF_FLOAT && (l = e.R16F),
                i === e.UNSIGNED_BYTE && (l = e.R8)),
                r === e.RED_INTEGER && (i === e.UNSIGNED_BYTE && (l = e.R8UI),
                i === e.UNSIGNED_SHORT && (l = e.R16UI),
                i === e.UNSIGNED_INT && (l = e.R32UI),
                i === e.BYTE && (l = e.R8I),
                i === e.SHORT && (l = e.R16I),
                i === e.INT && (l = e.R32I)),
                r === e.RG && (i === e.FLOAT && (l = e.RG32F),
                i === e.HALF_FLOAT && (l = e.RG16F),
                i === e.UNSIGNED_BYTE && (l = e.RG8)),
                r === e.RGBA) {
                    const t = a ? zf : ng.getTransfer(o);
                    i === e.FLOAT && (l = e.RGBA32F),
                    i === e.HALF_FLOAT && (l = e.RGBA16F),
                    i === e.UNSIGNED_BYTE && (l = t === Gf ? e.SRGB8_ALPHA8 : e.RGBA8),
                    i === e.UNSIGNED_SHORT_4_4_4_4 && (l = e.RGBA4),
                    i === e.UNSIGNED_SHORT_5_5_5_1 && (l = e.RGB5_A1)
                }
                return l !== e.R16F && l !== e.R32F && l !== e.RG16F && l !== e.RG32F && l !== e.RGBA16F && l !== e.RGBA32F || t.get("EXT_color_buffer_float"),
                l
            }
            function w(e, t, n) {
                return !0 === A(e, n) || e.isFramebufferTexture && e.minFilter !== ip && e.minFilter !== cp ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
            }
            function E(t) {
                return t === ip || t === op || t === sp ? e.NEAREST : e.LINEAR
            }
            function M(e) {
                const t = e.target;
                t.removeEventListener("dispose", M),
                function(e) {
                    const t = r.get(e);
                    if (void 0 === t.__webglInit)
                        return;
                    const n = e.source
                      , i = g.get(n);
                    if (i) {
                        const r = i[t.__cacheKey];
                        r.usedTimes--,
                        0 === r.usedTimes && T(e),
                        0 === Object.keys(i).length && g.delete(n)
                    }
                    r.remove(e)
                }(t),
                t.isVideoTexture && f.delete(t)
            }
            function C(t) {
                const n = t.target;
                n.removeEventListener("dispose", C),
                function(t) {
                    const n = t.texture
                      , i = r.get(t)
                      , o = r.get(n);
                    void 0 !== o.__webglTexture && (e.deleteTexture(o.__webglTexture),
                    a.memory.textures--);
                    t.depthTexture && t.depthTexture.dispose();
                    if (t.isWebGLCubeRenderTarget)
                        for (let r = 0; r < 6; r++) {
                            if (Array.isArray(i.__webglFramebuffer[r]))
                                for (let t = 0; t < i.__webglFramebuffer[r].length; t++)
                                    e.deleteFramebuffer(i.__webglFramebuffer[r][t]);
                            else
                                e.deleteFramebuffer(i.__webglFramebuffer[r]);
                            i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[r])
                        }
                    else {
                        if (Array.isArray(i.__webglFramebuffer))
                            for (let t = 0; t < i.__webglFramebuffer.length; t++)
                                e.deleteFramebuffer(i.__webglFramebuffer[t]);
                        else
                            e.deleteFramebuffer(i.__webglFramebuffer);
                        if (i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer),
                        i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer),
                        i.__webglColorRenderbuffer)
                            for (let t = 0; t < i.__webglColorRenderbuffer.length; t++)
                                i.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(i.__webglColorRenderbuffer[t]);
                        i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer)
                    }
                    if (t.isWebGLMultipleRenderTargets)
                        for (let s = 0, l = n.length; s < l; s++) {
                            const t = r.get(n[s]);
                            t.__webglTexture && (e.deleteTexture(t.__webglTexture),
                            a.memory.textures--),
                            r.remove(n[s])
                        }
                    r.remove(n),
                    r.remove(t)
                }(n)
            }
            function T(t) {
                const n = r.get(t);
                e.deleteTexture(n.__webglTexture);
                const i = t.source;
                delete g.get(i)[n.__cacheKey],
                a.memory.textures--
            }
            let R = 0;
            function P(t, i) {
                const o = r.get(t);
                if (t.isVideoTexture && function(e) {
                    const t = a.render.frame;
                    f.get(e) !== t && (f.set(e, t),
                    e.update())
                }(t),
                !1 === t.isRenderTargetTexture && t.version > 0 && o.__version !== t.version) {
                    const e = t.image;
                    if (null === e)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (!1 !== e.complete)
                            return void O(o, t, i);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.bindTexture(e.TEXTURE_2D, o.__webglTexture, e.TEXTURE0 + i)
            }
            const B = {
                [tp]: e.REPEAT,
                [np]: e.CLAMP_TO_EDGE,
                [rp]: e.MIRRORED_REPEAT
            }
              , I = {
                [ip]: e.NEAREST,
                [op]: e.NEAREST_MIPMAP_NEAREST,
                [sp]: e.NEAREST_MIPMAP_LINEAR,
                [cp]: e.LINEAR,
                [up]: e.LINEAR_MIPMAP_NEAREST,
                [hp]: e.LINEAR_MIPMAP_LINEAR
            }
              , L = {
                [am]: e.NEVER,
                [pm]: e.ALWAYS,
                [sm]: e.LESS,
                [cm]: e.LEQUAL,
                [lm]: e.EQUAL,
                [hm]: e.GEQUAL,
                [um]: e.GREATER,
                [dm]: e.NOTEQUAL
            };
            function k(n, o, a) {
                if (a ? (e.texParameteri(n, e.TEXTURE_WRAP_S, B[o.wrapS]),
                e.texParameteri(n, e.TEXTURE_WRAP_T, B[o.wrapT]),
                n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, B[o.wrapR]),
                e.texParameteri(n, e.TEXTURE_MAG_FILTER, I[o.magFilter]),
                e.texParameteri(n, e.TEXTURE_MIN_FILTER, I[o.minFilter])) : (e.texParameteri(n, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                e.texParameteri(n, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
                n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, e.CLAMP_TO_EDGE),
                o.wrapS === np && o.wrapT === np || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                e.texParameteri(n, e.TEXTURE_MAG_FILTER, E(o.magFilter)),
                e.texParameteri(n, e.TEXTURE_MIN_FILTER, E(o.minFilter)),
                o.minFilter !== ip && o.minFilter !== cp && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
                o.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
                e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, L[o.compareFunction])),
                !0 === t.has("EXT_texture_filter_anisotropic")) {
                    const a = t.get("EXT_texture_filter_anisotropic");
                    if (o.magFilter === ip)
                        return;
                    if (o.minFilter !== sp && o.minFilter !== hp)
                        return;
                    if (o.type === _p && !1 === t.has("OES_texture_float_linear"))
                        return;
                    if (!1 === s && o.type === Ap && !1 === t.has("OES_texture_half_float_linear"))
                        return;
                    (o.anisotropy > 1 || r.get(o).__currentAnisotropy) && (e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, i.getMaxAnisotropy())),
                    r.get(o).__currentAnisotropy = o.anisotropy)
                }
            }
            function D(t, n) {
                let r = !1;
                void 0 === t.__webglInit && (t.__webglInit = !0,
                n.addEventListener("dispose", M));
                const i = n.source;
                let o = g.get(i);
                void 0 === o && (o = {},
                g.set(i, o));
                const s = function(e) {
                    const t = [];
                    return t.push(e.wrapS),
                    t.push(e.wrapT),
                    t.push(e.wrapR || 0),
                    t.push(e.magFilter),
                    t.push(e.minFilter),
                    t.push(e.anisotropy),
                    t.push(e.internalFormat),
                    t.push(e.format),
                    t.push(e.type),
                    t.push(e.generateMipmaps),
                    t.push(e.premultiplyAlpha),
                    t.push(e.flipY),
                    t.push(e.unpackAlignment),
                    t.push(e.colorSpace),
                    t.join()
                }(n);
                if (s !== t.__cacheKey) {
                    void 0 === o[s] && (o[s] = {
                        texture: e.createTexture(),
                        usedTimes: 0
                    },
                    a.memory.textures++,
                    r = !0),
                    o[s].usedTimes++;
                    const i = o[t.__cacheKey];
                    void 0 !== i && (o[t.__cacheKey].usedTimes--,
                    0 === i.usedTimes && T(n)),
                    t.__cacheKey = s,
                    t.__webglTexture = o[s].texture
                }
                return r
            }
            function O(t, i, a) {
                let l = e.TEXTURE_2D;
                (i.isDataArrayTexture || i.isCompressedArrayTexture) && (l = e.TEXTURE_2D_ARRAY),
                i.isData3DTexture && (l = e.TEXTURE_3D);
                const c = D(t, i)
                  , d = i.source;
                n.bindTexture(l, t.__webglTexture, e.TEXTURE0 + a);
                const h = r.get(d);
                if (d.version !== h.__version || !0 === c) {
                    n.activeTexture(e.TEXTURE0 + a);
                    const t = ng.getPrimaries(ng.workingColorSpace)
                      , r = i.colorSpace === Df ? null : ng.getPrimaries(i.colorSpace)
                      , p = i.colorSpace === Df || t === r ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                    e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, i.flipY),
                    e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
                    e.pixelStorei(e.UNPACK_ALIGNMENT, i.unpackAlignment),
                    e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
                    const f = function(e) {
                        return !s && (e.wrapS !== np || e.wrapT !== np || e.minFilter !== ip && e.minFilter !== cp)
                    }(i) && !1 === _(i.image);
                    let m = b(i.image, f, !1, u);
                    m = H(i, m);
                    const g = _(m) || s
                      , v = o.convert(i.format, i.colorSpace);
                    let y, E = o.convert(i.type), M = S(i.internalFormat, v, E, i.colorSpace, i.isVideoTexture);
                    k(l, i, g);
                    const C = i.mipmaps
                      , T = s && !0 !== i.isVideoTexture && M !== Wp
                      , R = void 0 === h.__version || !0 === c
                      , P = w(i, m, g);
                    if (i.isDepthTexture)
                        M = e.DEPTH_COMPONENT,
                        s ? M = i.type === _p ? e.DEPTH_COMPONENT32F : i.type === bp ? e.DEPTH_COMPONENT24 : i.type === wp ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT16 : i.type === _p && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                        i.format === Rp && M === e.DEPTH_COMPONENT && i.type !== vp && i.type !== bp && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                        i.type = bp,
                        E = o.convert(i.type)),
                        i.format === Pp && M === e.DEPTH_COMPONENT && (M = e.DEPTH_STENCIL,
                        i.type !== wp && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                        i.type = wp,
                        E = o.convert(i.type))),
                        R && (T ? n.texStorage2D(e.TEXTURE_2D, 1, M, m.width, m.height) : n.texImage2D(e.TEXTURE_2D, 0, M, m.width, m.height, 0, v, E, null));
                    else if (i.isDataTexture)
                        if (C.length > 0 && g) {
                            T && R && n.texStorage2D(e.TEXTURE_2D, P, M, C[0].width, C[0].height);
                            for (let t = 0, r = C.length; t < r; t++)
                                y = C[t],
                                T ? n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, y.width, y.height, v, E, y.data) : n.texImage2D(e.TEXTURE_2D, t, M, y.width, y.height, 0, v, E, y.data);
                            i.generateMipmaps = !1
                        } else
                            T ? (R && n.texStorage2D(e.TEXTURE_2D, P, M, m.width, m.height),
                            n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, m.width, m.height, v, E, m.data)) : n.texImage2D(e.TEXTURE_2D, 0, M, m.width, m.height, 0, v, E, m.data);
                    else if (i.isCompressedTexture)
                        if (i.isCompressedArrayTexture) {
                            T && R && n.texStorage3D(e.TEXTURE_2D_ARRAY, P, M, C[0].width, C[0].height, m.depth);
                            for (let t = 0, r = C.length; t < r; t++)
                                y = C[t],
                                i.format !== Mp ? null !== v ? T ? n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, y.width, y.height, m.depth, v, y.data, 0, 0) : n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, M, y.width, y.height, m.depth, 0, y.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : T ? n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, y.width, y.height, m.depth, v, E, y.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, M, y.width, y.height, m.depth, 0, v, E, y.data)
                        } else {
                            T && R && n.texStorage2D(e.TEXTURE_2D, P, M, C[0].width, C[0].height);
                            for (let t = 0, r = C.length; t < r; t++)
                                y = C[t],
                                i.format !== Mp ? null !== v ? T ? n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, y.width, y.height, v, y.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, M, y.width, y.height, 0, y.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : T ? n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, y.width, y.height, v, E, y.data) : n.texImage2D(e.TEXTURE_2D, t, M, y.width, y.height, 0, v, E, y.data)
                        }
                    else if (i.isDataArrayTexture)
                        T ? (R && n.texStorage3D(e.TEXTURE_2D_ARRAY, P, M, m.width, m.height, m.depth),
                        n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, m.width, m.height, m.depth, v, E, m.data)) : n.texImage3D(e.TEXTURE_2D_ARRAY, 0, M, m.width, m.height, m.depth, 0, v, E, m.data);
                    else if (i.isData3DTexture)
                        T ? (R && n.texStorage3D(e.TEXTURE_3D, P, M, m.width, m.height, m.depth),
                        n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, m.width, m.height, m.depth, v, E, m.data)) : n.texImage3D(e.TEXTURE_3D, 0, M, m.width, m.height, m.depth, 0, v, E, m.data);
                    else if (i.isFramebufferTexture) {
                        if (R)
                            if (T)
                                n.texStorage2D(e.TEXTURE_2D, P, M, m.width, m.height);
                            else {
                                let t = m.width
                                  , r = m.height;
                                for (let i = 0; i < P; i++)
                                    n.texImage2D(e.TEXTURE_2D, i, M, t, r, 0, v, E, null),
                                    t >>= 1,
                                    r >>= 1
                            }
                    } else if (C.length > 0 && g) {
                        T && R && n.texStorage2D(e.TEXTURE_2D, P, M, C[0].width, C[0].height);
                        for (let t = 0, r = C.length; t < r; t++)
                            y = C[t],
                            T ? n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, v, E, y) : n.texImage2D(e.TEXTURE_2D, t, M, v, E, y);
                        i.generateMipmaps = !1
                    } else
                        T ? (R && n.texStorage2D(e.TEXTURE_2D, P, M, m.width, m.height),
                        n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, v, E, m)) : n.texImage2D(e.TEXTURE_2D, 0, M, v, E, m);
                    A(i, g) && x(l),
                    h.__version = d.version,
                    i.onUpdate && i.onUpdate(i)
                }
                t.__version = i.version
            }
            function N(t, i, a, s, l, c) {
                const u = o.convert(a.format, a.colorSpace)
                  , d = o.convert(a.type)
                  , p = S(a.internalFormat, u, d, a.colorSpace);
                if (!r.get(i).__hasExternalTextures) {
                    const t = Math.max(1, i.width >> c)
                      , r = Math.max(1, i.height >> c);
                    l === e.TEXTURE_3D || l === e.TEXTURE_2D_ARRAY ? n.texImage3D(l, c, p, t, r, i.depth, 0, u, d, null) : n.texImage2D(l, c, p, t, r, 0, u, d, null)
                }
                n.bindFramebuffer(e.FRAMEBUFFER, t),
                G(i) ? h.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, s, l, r.get(a).__webglTexture, 0, z(i)) : (l === e.TEXTURE_2D || l >= e.TEXTURE_CUBE_MAP_POSITIVE_X && l <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, s, l, r.get(a).__webglTexture, c),
                n.bindFramebuffer(e.FRAMEBUFFER, null)
            }
            function F(t, n, r) {
                if (e.bindRenderbuffer(e.RENDERBUFFER, t),
                n.depthBuffer && !n.stencilBuffer) {
                    let i = !0 === s ? e.DEPTH_COMPONENT24 : e.DEPTH_COMPONENT16;
                    if (r || G(n)) {
                        const t = n.depthTexture;
                        t && t.isDepthTexture && (t.type === _p ? i = e.DEPTH_COMPONENT32F : t.type === bp && (i = e.DEPTH_COMPONENT24));
                        const r = z(n);
                        G(n) ? h.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, r, i, n.width, n.height) : e.renderbufferStorageMultisample(e.RENDERBUFFER, r, i, n.width, n.height)
                    } else
                        e.renderbufferStorage(e.RENDERBUFFER, i, n.width, n.height);
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const i = z(n);
                    r && !1 === G(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, i, e.DEPTH24_STENCIL8, n.width, n.height) : G(n) ? h.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, i, e.DEPTH24_STENCIL8, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, n.width, n.height),
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t)
                } else {
                    const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
                    for (let i = 0; i < t.length; i++) {
                        const a = t[i]
                          , s = o.convert(a.format, a.colorSpace)
                          , l = o.convert(a.type)
                          , c = S(a.internalFormat, s, l, a.colorSpace)
                          , u = z(n);
                        r && !1 === G(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, u, c, n.width, n.height) : G(n) ? h.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, u, c, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, c, n.width, n.height)
                    }
                }
                e.bindRenderbuffer(e.RENDERBUFFER, null)
            }
            function U(t) {
                const i = r.get(t)
                  , o = !0 === t.isWebGLCubeRenderTarget;
                if (t.depthTexture && !i.__autoAllocateDepthBuffer) {
                    if (o)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    !function(t, i) {
                        if (i && i.isWebGLCubeRenderTarget)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(e.FRAMEBUFFER, t),
                        !i.depthTexture || !i.depthTexture.isDepthTexture)
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width,
                        i.depthTexture.image.height = i.height,
                        i.depthTexture.needsUpdate = !0),
                        P(i.depthTexture, 0);
                        const o = r.get(i.depthTexture).__webglTexture
                          , a = z(i);
                        if (i.depthTexture.format === Rp)
                            G(i) ? h.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, o, 0, a) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, o, 0);
                        else {
                            if (i.depthTexture.format !== Pp)
                                throw new Error("Unknown depthTexture format");
                            G(i) ? h.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, o, 0, a) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, o, 0)
                        }
                    }(i.__webglFramebuffer, t)
                } else if (o) {
                    i.__webglDepthbuffer = [];
                    for (let r = 0; r < 6; r++)
                        n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer[r]),
                        i.__webglDepthbuffer[r] = e.createRenderbuffer(),
                        F(i.__webglDepthbuffer[r], t, !1)
                } else
                    n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer),
                    i.__webglDepthbuffer = e.createRenderbuffer(),
                    F(i.__webglDepthbuffer, t, !1);
                n.bindFramebuffer(e.FRAMEBUFFER, null)
            }
            function z(e) {
                return Math.min(d, e.samples)
            }
            function G(e) {
                const n = r.get(e);
                return s && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }
            function H(e, n) {
                const r = e.colorSpace
                  , i = e.format
                  , o = e.type;
                return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === Em || r !== Nf && r !== Df && (ng.getTransfer(r) === Gf ? !1 === s ? !0 === t.has("EXT_sRGB") && i === Mp ? (e.format = Em,
                e.minFilter = cp,
                e.generateMipmaps = !1) : n = ag.sRGBToLinear(n) : i === Mp && o === fp || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", r)),
                n
            }
            this.allocateTextureUnit = function() {
                const e = R;
                return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l),
                R += 1,
                e
            }
            ,
            this.resetTextureUnits = function() {
                R = 0
            }
            ,
            this.setTexture2D = P,
            this.setTexture2DArray = function(t, i) {
                const o = r.get(t);
                t.version > 0 && o.__version !== t.version ? O(o, t, i) : n.bindTexture(e.TEXTURE_2D_ARRAY, o.__webglTexture, e.TEXTURE0 + i)
            }
            ,
            this.setTexture3D = function(t, i) {
                const o = r.get(t);
                t.version > 0 && o.__version !== t.version ? O(o, t, i) : n.bindTexture(e.TEXTURE_3D, o.__webglTexture, e.TEXTURE0 + i)
            }
            ,
            this.setTextureCube = function(t, i) {
                const a = r.get(t);
                t.version > 0 && a.__version !== t.version ? function(t, i, a) {
                    if (6 !== i.image.length)
                        return;
                    const l = D(t, i)
                      , u = i.source;
                    n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + a);
                    const d = r.get(u);
                    if (u.version !== d.__version || !0 === l) {
                        n.activeTexture(e.TEXTURE0 + a);
                        const t = ng.getPrimaries(ng.workingColorSpace)
                          , r = i.colorSpace === Df ? null : ng.getPrimaries(i.colorSpace)
                          , h = i.colorSpace === Df || t === r ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, i.flipY),
                        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
                        e.pixelStorei(e.UNPACK_ALIGNMENT, i.unpackAlignment),
                        e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, h);
                        const p = i.isCompressedTexture || i.image[0].isCompressedTexture
                          , f = i.image[0] && i.image[0].isDataTexture
                          , m = [];
                        for (let e = 0; e < 6; e++)
                            m[e] = p || f ? f ? i.image[e].image : i.image[e] : b(i.image[e], !1, !0, c),
                            m[e] = H(i, m[e]);
                        const g = m[0]
                          , v = _(g) || s
                          , y = o.convert(i.format, i.colorSpace)
                          , E = o.convert(i.type)
                          , M = S(i.internalFormat, y, E, i.colorSpace)
                          , C = s && !0 !== i.isVideoTexture
                          , T = void 0 === d.__version || !0 === l;
                        let R, P = w(i, g, v);
                        if (k(e.TEXTURE_CUBE_MAP, i, v),
                        p) {
                            C && T && n.texStorage2D(e.TEXTURE_CUBE_MAP, P, M, g.width, g.height);
                            for (let t = 0; t < 6; t++) {
                                R = m[t].mipmaps;
                                for (let r = 0; r < R.length; r++) {
                                    const o = R[r];
                                    i.format !== Mp ? null !== y ? C ? n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, o.width, o.height, y, o.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, M, o.width, o.height, 0, o.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : C ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, o.width, o.height, y, E, o.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, M, o.width, o.height, 0, y, E, o.data)
                                }
                            }
                        } else {
                            R = i.mipmaps,
                            C && T && (R.length > 0 && P++,
                            n.texStorage2D(e.TEXTURE_CUBE_MAP, P, M, m[0].width, m[0].height));
                            for (let t = 0; t < 6; t++)
                                if (f) {
                                    C ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, m[t].width, m[t].height, y, E, m[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, M, m[t].width, m[t].height, 0, y, E, m[t].data);
                                    for (let r = 0; r < R.length; r++) {
                                        const i = R[r].image[t].image;
                                        C ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, 0, 0, i.width, i.height, y, E, i.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, M, i.width, i.height, 0, y, E, i.data)
                                    }
                                } else {
                                    C ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, y, E, m[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, M, y, E, m[t]);
                                    for (let r = 0; r < R.length; r++) {
                                        const i = R[r];
                                        C ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, 0, 0, y, E, i.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, M, y, E, i.image[t])
                                    }
                                }
                        }
                        A(i, v) && x(e.TEXTURE_CUBE_MAP),
                        d.__version = u.version,
                        i.onUpdate && i.onUpdate(i)
                    }
                    t.__version = i.version
                }(a, t, i) : n.bindTexture(e.TEXTURE_CUBE_MAP, a.__webglTexture, e.TEXTURE0 + i)
            }
            ,
            this.rebindTextures = function(t, n, i) {
                const o = r.get(t);
                void 0 !== n && N(o.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0),
                void 0 !== i && U(t)
            }
            ,
            this.setupRenderTarget = function(t) {
                const l = t.texture
                  , c = r.get(t)
                  , u = r.get(l);
                t.addEventListener("dispose", C),
                !0 !== t.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = e.createTexture()),
                u.__version = l.version,
                a.memory.textures++);
                const d = !0 === t.isWebGLCubeRenderTarget
                  , h = !0 === t.isWebGLMultipleRenderTargets
                  , p = _(t) || s;
                if (d) {
                    c.__webglFramebuffer = [];
                    for (let t = 0; t < 6; t++)
                        if (s && l.mipmaps && l.mipmaps.length > 0) {
                            c.__webglFramebuffer[t] = [];
                            for (let n = 0; n < l.mipmaps.length; n++)
                                c.__webglFramebuffer[t][n] = e.createFramebuffer()
                        } else
                            c.__webglFramebuffer[t] = e.createFramebuffer()
                } else {
                    if (s && l.mipmaps && l.mipmaps.length > 0) {
                        c.__webglFramebuffer = [];
                        for (let t = 0; t < l.mipmaps.length; t++)
                            c.__webglFramebuffer[t] = e.createFramebuffer()
                    } else
                        c.__webglFramebuffer = e.createFramebuffer();
                    if (h)
                        if (i.drawBuffers) {
                            const n = t.texture;
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = r.get(n[t]);
                                void 0 === i.__webglTexture && (i.__webglTexture = e.createTexture(),
                                a.memory.textures++)
                            }
                        } else
                            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    if (s && t.samples > 0 && !1 === G(t)) {
                        const r = h ? l : [l];
                        c.__webglMultisampledFramebuffer = e.createFramebuffer(),
                        c.__webglColorRenderbuffer = [],
                        n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer);
                        for (let n = 0; n < r.length; n++) {
                            const i = r[n];
                            c.__webglColorRenderbuffer[n] = e.createRenderbuffer(),
                            e.bindRenderbuffer(e.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                            const a = o.convert(i.format, i.colorSpace)
                              , s = o.convert(i.type)
                              , l = S(i.internalFormat, a, s, i.colorSpace, !0 === t.isXRRenderTarget)
                              , u = z(t);
                            e.renderbufferStorageMultisample(e.RENDERBUFFER, u, l, t.width, t.height),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, c.__webglColorRenderbuffer[n])
                        }
                        e.bindRenderbuffer(e.RENDERBUFFER, null),
                        t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(),
                        F(c.__webglDepthRenderbuffer, t, !0)),
                        n.bindFramebuffer(e.FRAMEBUFFER, null)
                    }
                }
                if (d) {
                    n.bindTexture(e.TEXTURE_CUBE_MAP, u.__webglTexture),
                    k(e.TEXTURE_CUBE_MAP, l, p);
                    for (let n = 0; n < 6; n++)
                        if (s && l.mipmaps && l.mipmaps.length > 0)
                            for (let r = 0; r < l.mipmaps.length; r++)
                                N(c.__webglFramebuffer[n][r], t, l, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, r);
                        else
                            N(c.__webglFramebuffer[n], t, l, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                    A(l, p) && x(e.TEXTURE_CUBE_MAP),
                    n.unbindTexture()
                } else if (h) {
                    const i = t.texture;
                    for (let o = 0, a = i.length; o < a; o++) {
                        const a = i[o]
                          , s = r.get(a);
                        n.bindTexture(e.TEXTURE_2D, s.__webglTexture),
                        k(e.TEXTURE_2D, a, p),
                        N(c.__webglFramebuffer, t, a, e.COLOR_ATTACHMENT0 + o, e.TEXTURE_2D, 0),
                        A(a, p) && x(e.TEXTURE_2D)
                    }
                    n.unbindTexture()
                } else {
                    let r = e.TEXTURE_2D;
                    if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (s ? r = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
                    n.bindTexture(r, u.__webglTexture),
                    k(r, l, p),
                    s && l.mipmaps && l.mipmaps.length > 0)
                        for (let n = 0; n < l.mipmaps.length; n++)
                            N(c.__webglFramebuffer[n], t, l, e.COLOR_ATTACHMENT0, r, n);
                    else
                        N(c.__webglFramebuffer, t, l, e.COLOR_ATTACHMENT0, r, 0);
                    A(l, p) && x(r),
                    n.unbindTexture()
                }
                t.depthBuffer && U(t)
            }
            ,
            this.updateRenderTargetMipmap = function(t) {
                const i = _(t) || s
                  , o = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                for (let a = 0, s = o.length; a < s; a++) {
                    const s = o[a];
                    if (A(s, i)) {
                        const i = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D
                          , o = r.get(s).__webglTexture;
                        n.bindTexture(i, o),
                        x(i),
                        n.unbindTexture()
                    }
                }
            }
            ,
            this.updateMultisampleRenderTarget = function(t) {
                if (s && t.samples > 0 && !1 === G(t)) {
                    const i = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture]
                      , o = t.width
                      , a = t.height;
                    let s = e.COLOR_BUFFER_BIT;
                    const l = []
                      , c = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                      , u = r.get(t)
                      , d = !0 === t.isWebGLMultipleRenderTargets;
                    if (d)
                        for (let t = 0; t < i.length; t++)
                            n.bindFramebuffer(e.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null),
                            n.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer),
                            e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                    n.bindFramebuffer(e.READ_FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                    n.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
                    for (let n = 0; n < i.length; n++) {
                        l.push(e.COLOR_ATTACHMENT0 + n),
                        t.depthBuffer && l.push(c);
                        const h = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
                        if (!1 === h && (t.depthBuffer && (s |= e.DEPTH_BUFFER_BIT),
                        t.stencilBuffer && (s |= e.STENCIL_BUFFER_BIT)),
                        d && e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, u.__webglColorRenderbuffer[n]),
                        !0 === h && (e.invalidateFramebuffer(e.READ_FRAMEBUFFER, [c]),
                        e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [c])),
                        d) {
                            const t = r.get(i[n]).__webglTexture;
                            e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                        }
                        e.blitFramebuffer(0, 0, o, a, 0, 0, o, a, s, e.NEAREST),
                        p && e.invalidateFramebuffer(e.READ_FRAMEBUFFER, l)
                    }
                    if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                    n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                    d)
                        for (let t = 0; t < i.length; t++) {
                            n.bindFramebuffer(e.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, u.__webglColorRenderbuffer[t]);
                            const o = r.get(i[t]).__webglTexture;
                            n.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer),
                            e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, o, 0)
                        }
                    n.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglMultisampledFramebuffer)
                }
            }
            ,
            this.setupDepthRenderbuffer = U,
            this.setupFrameBufferTexture = N,
            this.useMultisampledRTT = G
        }
        function TA(e, t, n) {
            const r = n.isWebGL2;
            return {
                convert: function(n) {
                    let i, o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Df;
                    const a = ng.getTransfer(o);
                    if (n === fp)
                        return e.UNSIGNED_BYTE;
                    if (n === xp)
                        return e.UNSIGNED_SHORT_4_4_4_4;
                    if (n === Sp)
                        return e.UNSIGNED_SHORT_5_5_5_1;
                    if (n === mp)
                        return e.BYTE;
                    if (n === gp)
                        return e.SHORT;
                    if (n === vp)
                        return e.UNSIGNED_SHORT;
                    if (n === yp)
                        return e.INT;
                    if (n === bp)
                        return e.UNSIGNED_INT;
                    if (n === _p)
                        return e.FLOAT;
                    if (n === Ap)
                        return r ? e.HALF_FLOAT : (i = t.get("OES_texture_half_float"),
                        null !== i ? i.HALF_FLOAT_OES : null);
                    if (n === Ep)
                        return e.ALPHA;
                    if (n === Mp)
                        return e.RGBA;
                    if (n === Cp)
                        return e.LUMINANCE;
                    if (n === Tp)
                        return e.LUMINANCE_ALPHA;
                    if (n === Rp)
                        return e.DEPTH_COMPONENT;
                    if (n === Pp)
                        return e.DEPTH_STENCIL;
                    if (n === Em)
                        return i = t.get("EXT_sRGB"),
                        null !== i ? i.SRGB_ALPHA_EXT : null;
                    if (n === Bp)
                        return e.RED;
                    if (n === Ip)
                        return e.RED_INTEGER;
                    if (n === Lp)
                        return e.RG;
                    if (n === kp)
                        return e.RG_INTEGER;
                    if (n === Dp)
                        return e.RGBA_INTEGER;
                    if (n === Op || n === Np || n === Fp || n === Up)
                        if (a === Gf) {
                            if (i = t.get("WEBGL_compressed_texture_s3tc_srgb"),
                            null === i)
                                return null;
                            if (n === Op)
                                return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (n === Np)
                                return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (n === Fp)
                                return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (n === Up)
                                return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (i = t.get("WEBGL_compressed_texture_s3tc"),
                            null === i)
                                return null;
                            if (n === Op)
                                return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === Np)
                                return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === Fp)
                                return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === Up)
                                return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                    if (n === zp || n === Gp || n === Hp || n === jp) {
                        if (i = t.get("WEBGL_compressed_texture_pvrtc"),
                        null === i)
                            return null;
                        if (n === zp)
                            return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (n === Gp)
                            return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (n === Hp)
                            return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (n === jp)
                            return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (n === Wp)
                        return i = t.get("WEBGL_compressed_texture_etc1"),
                        null !== i ? i.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (n === Vp || n === Xp) {
                        if (i = t.get("WEBGL_compressed_texture_etc"),
                        null === i)
                            return null;
                        if (n === Vp)
                            return a === Gf ? i.COMPRESSED_SRGB8_ETC2 : i.COMPRESSED_RGB8_ETC2;
                        if (n === Xp)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : i.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (n === Jp || n === Kp || n === qp || n === Yp || n === Qp || n === Zp || n === $p || n === ef || n === tf || n === nf || n === rf || n === of || n === af || n === sf) {
                        if (i = t.get("WEBGL_compressed_texture_astc"),
                        null === i)
                            return null;
                        if (n === Jp)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : i.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (n === Kp)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : i.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (n === qp)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : i.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (n === Yp)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : i.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (n === Qp)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : i.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (n === Zp)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : i.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (n === $p)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : i.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (n === ef)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : i.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (n === tf)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : i.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (n === nf)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : i.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (n === rf)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : i.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (n === of)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : i.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (n === af)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : i.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (n === sf)
                            return a === Gf ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : i.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (n === lf || n === cf || n === uf) {
                        if (i = t.get("EXT_texture_compression_bptc"),
                        null === i)
                            return null;
                        if (n === lf)
                            return a === Gf ? i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : i.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                        if (n === cf)
                            return i.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                        if (n === uf)
                            return i.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                    }
                    if (n === df || n === hf || n === pf || n === ff) {
                        if (i = t.get("EXT_texture_compression_rgtc"),
                        null === i)
                            return null;
                        if (n === lf)
                            return i.COMPRESSED_RED_RGTC1_EXT;
                        if (n === hf)
                            return i.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (n === pf)
                            return i.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (n === ff)
                            return i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    }
                    return n === wp ? r ? e.UNSIGNED_INT_24_8 : (i = t.get("WEBGL_depth_texture"),
                    null !== i ? i.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e[n] ? e[n] : null
                }
            }
        }
        class RA extends Hy {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                super(),
                this.isArrayCamera = !0,
                this.cameras = e
            }
        }
        class PA extends xv {
            constructor() {
                super(),
                this.isGroup = !0,
                this.type = "Group"
            }
        }
        const BA = {
            type: "move"
        };
        class IA {
            constructor() {
                this._targetRay = null,
                this._grip = null,
                this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new PA,
                this._hand.matrixAutoUpdate = !1,
                this._hand.visible = !1,
                this._hand.joints = {},
                this._hand.inputState = {
                    pinching: !1
                }),
                this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new PA,
                this._targetRay.matrixAutoUpdate = !1,
                this._targetRay.visible = !1,
                this._targetRay.hasLinearVelocity = !1,
                this._targetRay.linearVelocity = new Ag,
                this._targetRay.hasAngularVelocity = !1,
                this._targetRay.angularVelocity = new Ag),
                this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new PA,
                this._grip.matrixAutoUpdate = !1,
                this._grip.visible = !1,
                this._grip.hasLinearVelocity = !1,
                this._grip.linearVelocity = new Ag,
                this._grip.hasAngularVelocity = !1,
                this._grip.angularVelocity = new Ag),
                this._grip
            }
            dispatchEvent(e) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(e),
                null !== this._grip && this._grip.dispatchEvent(e),
                null !== this._hand && this._hand.dispatchEvent(e),
                this
            }
            connect(e) {
                if (e && e.hand) {
                    const t = this._hand;
                    if (t)
                        for (const n of e.hand.values())
                            this._getHandJoint(t, n)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: e
                }),
                this
            }
            disconnect(e) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: e
                }),
                null !== this._targetRay && (this._targetRay.visible = !1),
                null !== this._grip && (this._grip.visible = !1),
                null !== this._hand && (this._hand.visible = !1),
                this
            }
            update(e, t, n) {
                let r = null
                  , i = null
                  , o = null;
                const a = this._targetRay
                  , s = this._grip
                  , l = this._hand;
                if (e && "visible-blurred" !== t.session.visibilityState) {
                    if (l && e.hand) {
                        o = !0;
                        for (const o of e.hand.values()) {
                            const e = t.getJointPose(o, n)
                              , r = this._getHandJoint(l, o);
                            null !== e && (r.matrix.fromArray(e.transform.matrix),
                            r.matrix.decompose(r.position, r.rotation, r.scale),
                            r.matrixWorldNeedsUpdate = !0,
                            r.jointRadius = e.radius),
                            r.visible = null !== e
                        }
                        const r = l.joints["index-finger-tip"]
                          , i = l.joints["thumb-tip"]
                          , a = r.position.distanceTo(i.position)
                          , s = .02
                          , c = .005;
                        l.inputState.pinching && a > s + c ? (l.inputState.pinching = !1,
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: e.handedness,
                            target: this
                        })) : !l.inputState.pinching && a <= s - c && (l.inputState.pinching = !0,
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: e.handedness,
                            target: this
                        }))
                    } else
                        null !== s && e.gripSpace && (i = t.getPose(e.gripSpace, n),
                        null !== i && (s.matrix.fromArray(i.transform.matrix),
                        s.matrix.decompose(s.position, s.rotation, s.scale),
                        s.matrixWorldNeedsUpdate = !0,
                        i.linearVelocity ? (s.hasLinearVelocity = !0,
                        s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1,
                        i.angularVelocity ? (s.hasAngularVelocity = !0,
                        s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1));
                    null !== a && (r = t.getPose(e.targetRaySpace, n),
                    null === r && null !== i && (r = i),
                    null !== r && (a.matrix.fromArray(r.transform.matrix),
                    a.matrix.decompose(a.position, a.rotation, a.scale),
                    a.matrixWorldNeedsUpdate = !0,
                    r.linearVelocity ? (a.hasLinearVelocity = !0,
                    a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
                    r.angularVelocity ? (a.hasAngularVelocity = !0,
                    a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1,
                    this.dispatchEvent(BA)))
                }
                return null !== a && (a.visible = null !== r),
                null !== s && (s.visible = null !== i),
                null !== l && (l.visible = null !== o),
                this
            }
            _getHandJoint(e, t) {
                if (void 0 === e.joints[t.jointName]) {
                    const n = new PA;
                    n.matrixAutoUpdate = !1,
                    n.visible = !1,
                    e.joints[t.jointName] = n,
                    e.add(n)
                }
                return e.joints[t.jointName]
            }
        }
        class LA extends Tm {
            constructor(e, t) {
                super();
                const n = this;
                let r = null
                  , i = 1
                  , o = null
                  , a = "local-floor"
                  , s = 1
                  , l = null
                  , c = null
                  , u = null
                  , d = null
                  , h = null
                  , p = null;
                const f = t.getContextAttributes();
                let m = null
                  , g = null;
                const v = []
                  , y = []
                  , b = new Hm;
                let _ = null;
                const A = new Hy;
                A.layers.enable(1),
                A.viewport = new hg;
                const x = new Hy;
                x.layers.enable(2),
                x.viewport = new hg;
                const S = [A, x]
                  , w = new RA;
                w.layers.enable(1),
                w.layers.enable(2);
                let E = null
                  , M = null;
                function C(e) {
                    const t = y.indexOf(e.inputSource);
                    if (-1 === t)
                        return;
                    const n = v[t];
                    void 0 !== n && (n.update(e.inputSource, e.frame, l || o),
                    n.dispatchEvent({
                        type: e.type,
                        data: e.inputSource
                    }))
                }
                function T() {
                    r.removeEventListener("select", C),
                    r.removeEventListener("selectstart", C),
                    r.removeEventListener("selectend", C),
                    r.removeEventListener("squeeze", C),
                    r.removeEventListener("squeezestart", C),
                    r.removeEventListener("squeezeend", C),
                    r.removeEventListener("end", T),
                    r.removeEventListener("inputsourceschange", R);
                    for (let e = 0; e < v.length; e++) {
                        const t = y[e];
                        null !== t && (y[e] = null,
                        v[e].disconnect(t))
                    }
                    E = null,
                    M = null,
                    e.setRenderTarget(m),
                    h = null,
                    d = null,
                    u = null,
                    r = null,
                    g = null,
                    k.stop(),
                    n.isPresenting = !1,
                    e.setPixelRatio(_),
                    e.setSize(b.width, b.height, !1),
                    n.dispatchEvent({
                        type: "sessionend"
                    })
                }
                function R(e) {
                    for (let t = 0; t < e.removed.length; t++) {
                        const n = e.removed[t]
                          , r = y.indexOf(n);
                        r >= 0 && (y[r] = null,
                        v[r].disconnect(n))
                    }
                    for (let t = 0; t < e.added.length; t++) {
                        const n = e.added[t];
                        let r = y.indexOf(n);
                        if (-1 === r) {
                            for (let e = 0; e < v.length; e++) {
                                if (e >= y.length) {
                                    y.push(n),
                                    r = e;
                                    break
                                }
                                if (null === y[e]) {
                                    y[e] = n,
                                    r = e;
                                    break
                                }
                            }
                            if (-1 === r)
                                break
                        }
                        const i = v[r];
                        i && i.connect(n)
                    }
                }
                this.cameraAutoUpdate = !0,
                this.enabled = !1,
                this.isPresenting = !1,
                this.getController = function(e) {
                    let t = v[e];
                    return void 0 === t && (t = new IA,
                    v[e] = t),
                    t.getTargetRaySpace()
                }
                ,
                this.getControllerGrip = function(e) {
                    let t = v[e];
                    return void 0 === t && (t = new IA,
                    v[e] = t),
                    t.getGripSpace()
                }
                ,
                this.getHand = function(e) {
                    let t = v[e];
                    return void 0 === t && (t = new IA,
                    v[e] = t),
                    t.getHandSpace()
                }
                ,
                this.setFramebufferScaleFactor = function(e) {
                    i = e,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }
                ,
                this.setReferenceSpaceType = function(e) {
                    a = e,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }
                ,
                this.getReferenceSpace = function() {
                    return l || o
                }
                ,
                this.setReferenceSpace = function(e) {
                    l = e
                }
                ,
                this.getBaseLayer = function() {
                    return null !== d ? d : h
                }
                ,
                this.getBinding = function() {
                    return u
                }
                ,
                this.getFrame = function() {
                    return p
                }
                ,
                this.getSession = function() {
                    return r
                }
                ,
                this.setSession = async function(c) {
                    if (r = c,
                    null !== r) {
                        if (m = e.getRenderTarget(),
                        r.addEventListener("select", C),
                        r.addEventListener("selectstart", C),
                        r.addEventListener("selectend", C),
                        r.addEventListener("squeeze", C),
                        r.addEventListener("squeezestart", C),
                        r.addEventListener("squeezeend", C),
                        r.addEventListener("end", T),
                        r.addEventListener("inputsourceschange", R),
                        !0 !== f.xrCompatible && await t.makeXRCompatible(),
                        _ = e.getPixelRatio(),
                        e.getSize(b),
                        void 0 === r.renderState.layers || !1 === e.capabilities.isWebGL2) {
                            const n = {
                                antialias: void 0 !== r.renderState.layers || f.antialias,
                                alpha: !0,
                                depth: f.depth,
                                stencil: f.stencil,
                                framebufferScaleFactor: i
                            };
                            h = new XRWebGLLayer(r,t,n),
                            r.updateRenderState({
                                baseLayer: h
                            }),
                            e.setPixelRatio(1),
                            e.setSize(h.framebufferWidth, h.framebufferHeight, !1),
                            g = new fg(h.framebufferWidth,h.framebufferHeight,{
                                format: Mp,
                                type: fp,
                                colorSpace: e.outputColorSpace,
                                stencilBuffer: f.stencil
                            })
                        } else {
                            let n = null
                              , o = null
                              , a = null;
                            f.depth && (a = f.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                            n = f.stencil ? Pp : Rp,
                            o = f.stencil ? wp : bp);
                            const s = {
                                colorFormat: t.RGBA8,
                                depthFormat: a,
                                scaleFactor: i
                            };
                            u = new XRWebGLBinding(r,t),
                            d = u.createProjectionLayer(s),
                            r.updateRenderState({
                                layers: [d]
                            }),
                            e.setPixelRatio(1),
                            e.setSize(d.textureWidth, d.textureHeight, !1),
                            g = new fg(d.textureWidth,d.textureHeight,{
                                format: Mp,
                                type: fp,
                                depthTexture: new Ub(d.textureWidth,d.textureHeight,o,void 0,void 0,void 0,void 0,void 0,void 0,n),
                                stencilBuffer: f.stencil,
                                colorSpace: e.outputColorSpace,
                                samples: f.antialias ? 4 : 0
                            });
                            e.properties.get(g).__ignoreDepthValues = d.ignoreDepthValues
                        }
                        g.isXRRenderTarget = !0,
                        this.setFoveation(s),
                        l = null,
                        o = await r.requestReferenceSpace(a),
                        k.setContext(r),
                        k.start(),
                        n.isPresenting = !0,
                        n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }
                ,
                this.getEnvironmentBlendMode = function() {
                    if (null !== r)
                        return r.environmentBlendMode
                }
                ;
                const P = new Ag
                  , B = new Ag;
                function I(e, t) {
                    null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
                    e.matrixWorldInverse.copy(e.matrixWorld).invert()
                }
                this.updateCamera = function(e) {
                    if (null === r)
                        return;
                    w.near = x.near = A.near = e.near,
                    w.far = x.far = A.far = e.far,
                    E === w.near && M === w.far || (r.updateRenderState({
                        depthNear: w.near,
                        depthFar: w.far
                    }),
                    E = w.near,
                    M = w.far);
                    const t = e.parent
                      , n = w.cameras;
                    I(w, t);
                    for (let r = 0; r < n.length; r++)
                        I(n[r], t);
                    2 === n.length ? function(e, t, n) {
                        P.setFromMatrixPosition(t.matrixWorld),
                        B.setFromMatrixPosition(n.matrixWorld);
                        const r = P.distanceTo(B)
                          , i = t.projectionMatrix.elements
                          , o = n.projectionMatrix.elements
                          , a = i[14] / (i[10] - 1)
                          , s = i[14] / (i[10] + 1)
                          , l = (i[9] + 1) / i[5]
                          , c = (i[9] - 1) / i[5]
                          , u = (i[8] - 1) / i[0]
                          , d = (o[8] + 1) / o[0]
                          , h = a * u
                          , p = a * d
                          , f = r / (-u + d)
                          , m = f * -u;
                        t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                        e.translateX(m),
                        e.translateZ(f),
                        e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                        e.matrixWorldInverse.copy(e.matrixWorld).invert();
                        const g = a + f
                          , v = s + f
                          , y = h - m
                          , b = p + (r - m)
                          , _ = l * s / v * g
                          , A = c * s / v * g;
                        e.projectionMatrix.makePerspective(y, b, _, A, g, v),
                        e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                    }(w, A, x) : w.projectionMatrix.copy(A.projectionMatrix),
                    function(e, t, n) {
                        null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld),
                        e.matrix.invert(),
                        e.matrix.multiply(t.matrixWorld));
                        e.matrix.decompose(e.position, e.quaternion, e.scale),
                        e.updateMatrixWorld(!0),
                        e.projectionMatrix.copy(t.projectionMatrix),
                        e.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                        e.isPerspectiveCamera && (e.fov = 2 * Im * Math.atan(1 / e.projectionMatrix.elements[5]),
                        e.zoom = 1)
                    }(e, w, t)
                }
                ,
                this.getCamera = function() {
                    return w
                }
                ,
                this.getFoveation = function() {
                    if (null !== d || null !== h)
                        return s
                }
                ,
                this.setFoveation = function(e) {
                    s = e,
                    null !== d && (d.fixedFoveation = e),
                    null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = e)
                }
                ;
                let L = null;
                const k = new eb;
                k.setAnimationLoop((function(t, r) {
                    if (c = r.getViewerPose(l || o),
                    p = r,
                    null !== c) {
                        const t = c.views;
                        null !== h && (e.setRenderTargetFramebuffer(g, h.framebuffer),
                        e.setRenderTarget(g));
                        let n = !1;
                        t.length !== w.cameras.length && (w.cameras.length = 0,
                        n = !0);
                        for (let r = 0; r < t.length; r++) {
                            const i = t[r];
                            let o = null;
                            if (null !== h)
                                o = h.getViewport(i);
                            else {
                                const t = u.getViewSubImage(d, i);
                                o = t.viewport,
                                0 === r && (e.setRenderTargetTextures(g, t.colorTexture, d.ignoreDepthValues ? void 0 : t.depthStencilTexture),
                                e.setRenderTarget(g))
                            }
                            let a = S[r];
                            void 0 === a && (a = new Hy,
                            a.layers.enable(r),
                            a.viewport = new hg,
                            S[r] = a),
                            a.matrix.fromArray(i.transform.matrix),
                            a.matrix.decompose(a.position, a.quaternion, a.scale),
                            a.projectionMatrix.fromArray(i.projectionMatrix),
                            a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
                            a.viewport.set(o.x, o.y, o.width, o.height),
                            0 === r && (w.matrix.copy(a.matrix),
                            w.matrix.decompose(w.position, w.quaternion, w.scale)),
                            !0 === n && w.cameras.push(a)
                        }
                    }
                    for (let e = 0; e < v.length; e++) {
                        const t = y[e]
                          , n = v[e];
                        null !== t && void 0 !== n && n.update(t, r, l || o)
                    }
                    L && L(t, r),
                    r.detectedPlanes && n.dispatchEvent({
                        type: "planesdetected",
                        data: r
                    }),
                    p = null
                }
                )),
                this.setAnimationLoop = function(e) {
                    L = e
                }
                ,
                this.dispose = function() {}
            }
        }
        function kA(e, t) {
            function n(e, t) {
                !0 === e.matrixAutoUpdate && e.updateMatrix(),
                t.value.copy(e.matrix)
            }
            function r(r, i) {
                r.opacity.value = i.opacity,
                i.color && r.diffuse.value.copy(i.color),
                i.emissive && r.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
                i.map && (r.map.value = i.map,
                n(i.map, r.mapTransform)),
                i.alphaMap && (r.alphaMap.value = i.alphaMap,
                n(i.alphaMap, r.alphaMapTransform)),
                i.bumpMap && (r.bumpMap.value = i.bumpMap,
                n(i.bumpMap, r.bumpMapTransform),
                r.bumpScale.value = i.bumpScale,
                i.side === th && (r.bumpScale.value *= -1)),
                i.normalMap && (r.normalMap.value = i.normalMap,
                n(i.normalMap, r.normalMapTransform),
                r.normalScale.value.copy(i.normalScale),
                i.side === th && r.normalScale.value.negate()),
                i.displacementMap && (r.displacementMap.value = i.displacementMap,
                n(i.displacementMap, r.displacementMapTransform),
                r.displacementScale.value = i.displacementScale,
                r.displacementBias.value = i.displacementBias),
                i.emissiveMap && (r.emissiveMap.value = i.emissiveMap,
                n(i.emissiveMap, r.emissiveMapTransform)),
                i.specularMap && (r.specularMap.value = i.specularMap,
                n(i.specularMap, r.specularMapTransform)),
                i.alphaTest > 0 && (r.alphaTest.value = i.alphaTest);
                const o = t.get(i).envMap;
                if (o && (r.envMap.value = o,
                r.flipEnvMap.value = o.isCubeTexture && !1 === o.isRenderTargetTexture ? -1 : 1,
                r.reflectivity.value = i.reflectivity,
                r.ior.value = i.ior,
                r.refractionRatio.value = i.refractionRatio),
                i.lightMap) {
                    r.lightMap.value = i.lightMap;
                    const t = !0 === e._useLegacyLights ? Math.PI : 1;
                    r.lightMapIntensity.value = i.lightMapIntensity * t,
                    n(i.lightMap, r.lightMapTransform)
                }
                i.aoMap && (r.aoMap.value = i.aoMap,
                r.aoMapIntensity.value = i.aoMapIntensity,
                n(i.aoMap, r.aoMapTransform))
            }
            return {
                refreshFogUniforms: function(t, n) {
                    n.color.getRGB(t.fogColor.value, Fy(e)),
                    n.isFog ? (t.fogNear.value = n.near,
                    t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
                },
                refreshMaterialUniforms: function(e, i, o, a, s) {
                    i.isMeshBasicMaterial || i.isMeshLambertMaterial ? r(e, i) : i.isMeshToonMaterial ? (r(e, i),
                    function(e, t) {
                        t.gradientMap && (e.gradientMap.value = t.gradientMap)
                    }(e, i)) : i.isMeshPhongMaterial ? (r(e, i),
                    function(e, t) {
                        e.specular.value.copy(t.specular),
                        e.shininess.value = Math.max(t.shininess, 1e-4)
                    }(e, i)) : i.isMeshStandardMaterial ? (r(e, i),
                    function(e, r) {
                        e.metalness.value = r.metalness,
                        r.metalnessMap && (e.metalnessMap.value = r.metalnessMap,
                        n(r.metalnessMap, e.metalnessMapTransform));
                        e.roughness.value = r.roughness,
                        r.roughnessMap && (e.roughnessMap.value = r.roughnessMap,
                        n(r.roughnessMap, e.roughnessMapTransform));
                        const i = t.get(r).envMap;
                        i && (e.envMapIntensity.value = r.envMapIntensity)
                    }(e, i),
                    i.isMeshPhysicalMaterial && function(e, t, r) {
                        e.ior.value = t.ior,
                        t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),
                        e.sheenRoughness.value = t.sheenRoughness,
                        t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap,
                        n(t.sheenColorMap, e.sheenColorMapTransform)),
                        t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap,
                        n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform)));
                        t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat,
                        e.clearcoatRoughness.value = t.clearcoatRoughness,
                        t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap,
                        n(t.clearcoatMap, e.clearcoatMapTransform)),
                        t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap,
                        n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)),
                        t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                        n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform),
                        e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                        t.side === th && e.clearcoatNormalScale.value.negate()));
                        t.iridescence > 0 && (e.iridescence.value = t.iridescence,
                        e.iridescenceIOR.value = t.iridescenceIOR,
                        e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0],
                        e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1],
                        t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap,
                        n(t.iridescenceMap, e.iridescenceMapTransform)),
                        t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap,
                        n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform)));
                        t.transmission > 0 && (e.transmission.value = t.transmission,
                        e.transmissionSamplerMap.value = r.texture,
                        e.transmissionSamplerSize.value.set(r.width, r.height),
                        t.transmissionMap && (e.transmissionMap.value = t.transmissionMap,
                        n(t.transmissionMap, e.transmissionMapTransform)),
                        e.thickness.value = t.thickness,
                        t.thicknessMap && (e.thicknessMap.value = t.thicknessMap,
                        n(t.thicknessMap, e.thicknessMapTransform)),
                        e.attenuationDistance.value = t.attenuationDistance,
                        e.attenuationColor.value.copy(t.attenuationColor));
                        t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)),
                        t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap,
                        n(t.anisotropyMap, e.anisotropyMapTransform)));
                        e.specularIntensity.value = t.specularIntensity,
                        e.specularColor.value.copy(t.specularColor),
                        t.specularColorMap && (e.specularColorMap.value = t.specularColorMap,
                        n(t.specularColorMap, e.specularColorMapTransform));
                        t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap,
                        n(t.specularIntensityMap, e.specularIntensityMapTransform))
                    }(e, i, s)) : i.isMeshMatcapMaterial ? (r(e, i),
                    function(e, t) {
                        t.matcap && (e.matcap.value = t.matcap)
                    }(e, i)) : i.isMeshDepthMaterial ? r(e, i) : i.isMeshDistanceMaterial ? (r(e, i),
                    function(e, n) {
                        const r = t.get(n).light;
                        e.referencePosition.value.setFromMatrixPosition(r.matrixWorld),
                        e.nearDistance.value = r.shadow.camera.near,
                        e.farDistance.value = r.shadow.camera.far
                    }(e, i)) : i.isMeshNormalMaterial ? r(e, i) : i.isLineBasicMaterial ? (function(e, t) {
                        e.diffuse.value.copy(t.color),
                        e.opacity.value = t.opacity,
                        t.map && (e.map.value = t.map,
                        n(t.map, e.mapTransform))
                    }(e, i),
                    i.isLineDashedMaterial && function(e, t) {
                        e.dashSize.value = t.dashSize,
                        e.totalSize.value = t.dashSize + t.gapSize,
                        e.scale.value = t.scale
                    }(e, i)) : i.isPointsMaterial ? function(e, t, r, i) {
                        e.diffuse.value.copy(t.color),
                        e.opacity.value = t.opacity,
                        e.size.value = t.size * r,
                        e.scale.value = .5 * i,
                        t.map && (e.map.value = t.map,
                        n(t.map, e.uvTransform));
                        t.alphaMap && (e.alphaMap.value = t.alphaMap,
                        n(t.alphaMap, e.alphaMapTransform));
                        t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                    }(e, i, o, a) : i.isSpriteMaterial ? function(e, t) {
                        e.diffuse.value.copy(t.color),
                        e.opacity.value = t.opacity,
                        e.rotation.value = t.rotation,
                        t.map && (e.map.value = t.map,
                        n(t.map, e.mapTransform));
                        t.alphaMap && (e.alphaMap.value = t.alphaMap,
                        n(t.alphaMap, e.alphaMapTransform));
                        t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                    }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color),
                    e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                }
            }
        }
        function DA(e, t, n, r) {
            let i = {}
              , o = {}
              , a = [];
            const s = n.isWebGL2 ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
            function l(e, t, n) {
                const r = e.value;
                if (void 0 === n[t]) {
                    if ("number" === typeof r)
                        n[t] = r;
                    else {
                        const e = Array.isArray(r) ? r : [r]
                          , i = [];
                        for (let t = 0; t < e.length; t++)
                            i.push(e[t].clone());
                        n[t] = i
                    }
                    return !0
                }
                if ("number" === typeof r) {
                    if (n[t] !== r)
                        return n[t] = r,
                        !0
                } else {
                    const e = Array.isArray(n[t]) ? n[t] : [n[t]]
                      , i = Array.isArray(r) ? r : [r];
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        if (!1 === n.equals(i[t]))
                            return n.copy(i[t]),
                            !0
                    }
                }
                return !1
            }
            function c(e) {
                const t = {
                    boundary: 0,
                    storage: 0
                };
                return "number" === typeof e ? (t.boundary = 4,
                t.storage = 4) : e.isVector2 ? (t.boundary = 8,
                t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16,
                t.storage = 12) : e.isVector4 ? (t.boundary = 16,
                t.storage = 16) : e.isMatrix3 ? (t.boundary = 48,
                t.storage = 48) : e.isMatrix4 ? (t.boundary = 64,
                t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e),
                t
            }
            function u(t) {
                const n = t.target;
                n.removeEventListener("dispose", u);
                const r = a.indexOf(n.__bindingPointIndex);
                a.splice(r, 1),
                e.deleteBuffer(i[n.id]),
                delete i[n.id],
                delete o[n.id]
            }
            return {
                bind: function(e, t) {
                    const n = t.program;
                    r.uniformBlockBinding(e, n)
                },
                update: function(n, d) {
                    let h = i[n.id];
                    void 0 === h && (!function(e) {
                        const t = e.uniforms;
                        let n = 0;
                        const r = 16;
                        let i = 0;
                        for (let o = 0, a = t.length; o < a; o++) {
                            const e = t[o]
                              , a = {
                                boundary: 0,
                                storage: 0
                            }
                              , s = Array.isArray(e.value) ? e.value : [e.value];
                            for (let t = 0, n = s.length; t < n; t++) {
                                const e = c(s[t]);
                                a.boundary += e.boundary,
                                a.storage += e.storage
                            }
                            if (e.__data = new Float32Array(a.storage / Float32Array.BYTES_PER_ELEMENT),
                            e.__offset = n,
                            o > 0) {
                                i = n % r;
                                0 !== i && r - i - a.boundary < 0 && (n += r - i,
                                e.__offset = n)
                            }
                            n += a.storage
                        }
                        i = n % r,
                        i > 0 && (n += r - i);
                        e.__size = n,
                        e.__cache = {}
                    }(n),
                    h = function(t) {
                        const n = function() {
                            for (let e = 0; e < s; e++)
                                if (-1 === a.indexOf(e))
                                    return a.push(e),
                                    e;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                            0
                        }();
                        t.__bindingPointIndex = n;
                        const r = e.createBuffer()
                          , i = t.__size
                          , o = t.usage;
                        return e.bindBuffer(e.UNIFORM_BUFFER, r),
                        e.bufferData(e.UNIFORM_BUFFER, i, o),
                        e.bindBuffer(e.UNIFORM_BUFFER, null),
                        e.bindBufferBase(e.UNIFORM_BUFFER, n, r),
                        r
                    }(n),
                    i[n.id] = h,
                    n.addEventListener("dispose", u));
                    const p = d.program;
                    r.updateUBOMapping(n, p);
                    const f = t.render.frame;
                    o[n.id] !== f && (!function(t) {
                        const n = i[t.id]
                          , r = t.uniforms
                          , o = t.__cache;
                        e.bindBuffer(e.UNIFORM_BUFFER, n);
                        for (let i = 0, a = r.length; i < a; i++) {
                            const t = r[i];
                            if (!0 === l(t, i, o)) {
                                const n = t.__offset
                                  , r = Array.isArray(t.value) ? t.value : [t.value];
                                let i = 0;
                                for (let o = 0; o < r.length; o++) {
                                    const a = r[o]
                                      , s = c(a);
                                    "number" === typeof a ? (t.__data[0] = a,
                                    e.bufferSubData(e.UNIFORM_BUFFER, n + i, t.__data)) : a.isMatrix3 ? (t.__data[0] = a.elements[0],
                                    t.__data[1] = a.elements[1],
                                    t.__data[2] = a.elements[2],
                                    t.__data[3] = a.elements[0],
                                    t.__data[4] = a.elements[3],
                                    t.__data[5] = a.elements[4],
                                    t.__data[6] = a.elements[5],
                                    t.__data[7] = a.elements[0],
                                    t.__data[8] = a.elements[6],
                                    t.__data[9] = a.elements[7],
                                    t.__data[10] = a.elements[8],
                                    t.__data[11] = a.elements[0]) : (a.toArray(t.__data, i),
                                    i += s.storage / Float32Array.BYTES_PER_ELEMENT)
                                }
                                e.bufferSubData(e.UNIFORM_BUFFER, n, t.__data)
                            }
                        }
                        e.bindBuffer(e.UNIFORM_BUFFER, null)
                    }(n),
                    o[n.id] = f)
                },
                dispose: function() {
                    for (const t in i)
                        e.deleteBuffer(i[t]);
                    a = [],
                    i = {},
                    o = {}
                }
            }
        }
        class OA {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const {canvas: t=qm(), context: n=null, depth: r=!0, stencil: i=!0, alpha: o=!1, antialias: a=!1, premultipliedAlpha: s=!0, preserveDrawingBuffer: l=!1, powerPreference: c="default", failIfMajorPerformanceCaveat: u=!1} = e;
                let d;
                this.isWebGLRenderer = !0,
                d = null !== n ? n.getContextAttributes().alpha : o;
                const h = new Uint32Array(4)
                  , p = new Int32Array(4);
                let f = null
                  , m = null;
                const g = []
                  , v = [];
                this.domElement = t,
                this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                },
                this.autoClear = !0,
                this.autoClearColor = !0,
                this.autoClearDepth = !0,
                this.autoClearStencil = !0,
                this.sortObjects = !0,
                this.clippingPlanes = [],
                this.localClippingEnabled = !1,
                this._outputColorSpace = Of,
                this._useLegacyLights = !1,
                this.toneMapping = Gh,
                this.toneMappingExposure = 1;
                const y = this;
                let b = !1
                  , _ = 0
                  , A = 0
                  , x = null
                  , S = -1
                  , w = null;
                const E = new hg
                  , M = new hg;
                let C = null;
                const T = new Uv(0);
                let R = 0
                  , P = t.width
                  , B = t.height
                  , I = 1
                  , L = null
                  , k = null;
                const D = new hg(0,0,P,B)
                  , O = new hg(0,0,P,B);
                let N = !1;
                const F = new $y;
                let U = !1
                  , z = !1
                  , G = null;
                const H = new Qg
                  , j = new Hm
                  , W = new Ag
                  , V = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };
                function X() {
                    return null === x ? I : 1
                }
                let J, K, q, Y, Q, Z, $, ee, te, ne, re, ie, oe, ae, se, le, ce, ue, de, he, pe, fe, me, ge, ve = n;
                function ye(e, n) {
                    for (let r = 0; r < e.length; r++) {
                        const i = e[r]
                          , o = t.getContext(i, n);
                        if (null !== o)
                            return o
                    }
                    return null
                }
                try {
                    const e = {
                        alpha: !0,
                        depth: r,
                        stencil: i,
                        antialias: a,
                        premultipliedAlpha: s,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: u
                    };
                    if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${jd}`),
                    t.addEventListener("webglcontextlost", Ae, !1),
                    t.addEventListener("webglcontextrestored", xe, !1),
                    t.addEventListener("webglcontextcreationerror", Se, !1),
                    null === ve) {
                        const t = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === y.isWebGL1Renderer && t.shift(),
                        ve = ye(t, e),
                        null === ve)
                            throw ye(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    "undefined" !== typeof WebGLRenderingContext && ve instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),
                    void 0 === ve.getShaderPrecisionFormat && (ve.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    }
                    )
                } catch (Ne) {
                    throw console.error("THREE.WebGLRenderer: " + Ne.message),
                    Ne
                }
                function be() {
                    J = new Bb(ve),
                    K = new ub(ve,J,e),
                    J.init(K),
                    fe = new TA(ve,J,K),
                    q = new MA(ve,J,K),
                    Y = new kb(ve),
                    Q = new hA,
                    Z = new CA(ve,J,q,Q,K,fe,Y),
                    $ = new hb(y),
                    ee = new Pb(y),
                    te = new tb(ve,K),
                    me = new lb(ve,J,te,K),
                    ne = new Ib(ve,te,Y,me),
                    re = new Fb(ve,ne,te,Y),
                    de = new Nb(ve,K,Z),
                    le = new db(Q),
                    ie = new dA(y,$,ee,J,K,me,le),
                    oe = new kA(y,Q),
                    ae = new gA,
                    se = new xA(J,K),
                    ue = new sb(y,$,ee,q,re,d,s),
                    ce = new EA(y,re,K),
                    ge = new DA(ve,Y,K,q),
                    he = new cb(ve,J,Y,K),
                    pe = new Lb(ve,J,Y,K),
                    Y.programs = ie.programs,
                    y.capabilities = K,
                    y.extensions = J,
                    y.properties = Q,
                    y.renderLists = ae,
                    y.shadowMap = ce,
                    y.state = q,
                    y.info = Y
                }
                be();
                const _e = new LA(y,ve);
                function Ae(e) {
                    e.preventDefault(),
                    console.log("THREE.WebGLRenderer: Context Lost."),
                    b = !0
                }
                function xe() {
                    console.log("THREE.WebGLRenderer: Context Restored."),
                    b = !1;
                    const e = Y.autoReset
                      , t = ce.enabled
                      , n = ce.autoUpdate
                      , r = ce.needsUpdate
                      , i = ce.type;
                    be(),
                    Y.autoReset = e,
                    ce.enabled = t,
                    ce.autoUpdate = n,
                    ce.needsUpdate = r,
                    ce.type = i
                }
                function Se(e) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                }
                function we(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", we),
                    function(e) {
                        (function(e) {
                            const t = Q.get(e).programs;
                            void 0 !== t && (t.forEach((function(e) {
                                ie.releaseProgram(e)
                            }
                            )),
                            e.isShaderMaterial && ie.releaseShaderCache(e))
                        }
                        )(e),
                        Q.remove(e)
                    }(t)
                }
                function Ee(e, t, n) {
                    !0 === e.transparent && e.side === nh && !1 === e.forceSinglePass ? (e.side = th,
                    e.needsUpdate = !0,
                    ke(e, t, n),
                    e.side = eh,
                    e.needsUpdate = !0,
                    ke(e, t, n),
                    e.side = nh) : ke(e, t, n)
                }
                this.xr = _e,
                this.getContext = function() {
                    return ve
                }
                ,
                this.getContextAttributes = function() {
                    return ve.getContextAttributes()
                }
                ,
                this.forceContextLoss = function() {
                    const e = J.get("WEBGL_lose_context");
                    e && e.loseContext()
                }
                ,
                this.forceContextRestore = function() {
                    const e = J.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }
                ,
                this.getPixelRatio = function() {
                    return I
                }
                ,
                this.setPixelRatio = function(e) {
                    void 0 !== e && (I = e,
                    this.setSize(P, B, !1))
                }
                ,
                this.getSize = function(e) {
                    return e.set(P, B)
                }
                ,
                this.setSize = function(e, n) {
                    let r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    _e.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (P = e,
                    B = n,
                    t.width = Math.floor(e * I),
                    t.height = Math.floor(n * I),
                    !0 === r && (t.style.width = e + "px",
                    t.style.height = n + "px"),
                    this.setViewport(0, 0, e, n))
                }
                ,
                this.getDrawingBufferSize = function(e) {
                    return e.set(P * I, B * I).floor()
                }
                ,
                this.setDrawingBufferSize = function(e, n, r) {
                    P = e,
                    B = n,
                    I = r,
                    t.width = Math.floor(e * r),
                    t.height = Math.floor(n * r),
                    this.setViewport(0, 0, e, n)
                }
                ,
                this.getCurrentViewport = function(e) {
                    return e.copy(E)
                }
                ,
                this.getViewport = function(e) {
                    return e.copy(D)
                }
                ,
                this.setViewport = function(e, t, n, r) {
                    e.isVector4 ? D.set(e.x, e.y, e.z, e.w) : D.set(e, t, n, r),
                    q.viewport(E.copy(D).multiplyScalar(I).floor())
                }
                ,
                this.getScissor = function(e) {
                    return e.copy(O)
                }
                ,
                this.setScissor = function(e, t, n, r) {
                    e.isVector4 ? O.set(e.x, e.y, e.z, e.w) : O.set(e, t, n, r),
                    q.scissor(M.copy(O).multiplyScalar(I).floor())
                }
                ,
                this.getScissorTest = function() {
                    return N
                }
                ,
                this.setScissorTest = function(e) {
                    q.setScissorTest(N = e)
                }
                ,
                this.setOpaqueSort = function(e) {
                    L = e
                }
                ,
                this.setTransparentSort = function(e) {
                    k = e
                }
                ,
                this.getClearColor = function(e) {
                    return e.copy(ue.getClearColor())
                }
                ,
                this.setClearColor = function() {
                    ue.setClearColor.apply(ue, arguments)
                }
                ,
                this.getClearAlpha = function() {
                    return ue.getClearAlpha()
                }
                ,
                this.setClearAlpha = function() {
                    ue.setClearAlpha.apply(ue, arguments)
                }
                ,
                this.clear = function() {
                    let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                      , t = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                      , n = 0;
                    if (!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]) {
                        let e = !1;
                        if (null !== x) {
                            const t = x.texture.format;
                            e = t === Dp || t === kp || t === Ip
                        }
                        if (e) {
                            const e = x.texture.type
                              , t = e === fp || e === bp || e === vp || e === wp || e === xp || e === Sp
                              , n = ue.getClearColor()
                              , r = ue.getClearAlpha()
                              , i = n.r
                              , o = n.g
                              , a = n.b;
                            t ? (h[0] = i,
                            h[1] = o,
                            h[2] = a,
                            h[3] = r,
                            ve.clearBufferuiv(ve.COLOR, 0, h)) : (p[0] = i,
                            p[1] = o,
                            p[2] = a,
                            p[3] = r,
                            ve.clearBufferiv(ve.COLOR, 0, p))
                        } else
                            n |= ve.COLOR_BUFFER_BIT
                    }
                    e && (n |= ve.DEPTH_BUFFER_BIT),
                    t && (n |= ve.STENCIL_BUFFER_BIT,
                    this.state.buffers.stencil.setMask(4294967295)),
                    ve.clear(n)
                }
                ,
                this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }
                ,
                this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }
                ,
                this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }
                ,
                this.dispose = function() {
                    t.removeEventListener("webglcontextlost", Ae, !1),
                    t.removeEventListener("webglcontextrestored", xe, !1),
                    t.removeEventListener("webglcontextcreationerror", Se, !1),
                    ae.dispose(),
                    se.dispose(),
                    Q.dispose(),
                    $.dispose(),
                    ee.dispose(),
                    re.dispose(),
                    me.dispose(),
                    ge.dispose(),
                    ie.dispose(),
                    _e.dispose(),
                    _e.removeEventListener("sessionstart", Ce),
                    _e.removeEventListener("sessionend", Te),
                    G && (G.dispose(),
                    G = null),
                    Re.stop()
                }
                ,
                this.renderBufferDirect = function(e, t, n, r, i, o) {
                    null === t && (t = V);
                    const a = i.isMesh && i.matrixWorld.determinant() < 0
                      , s = function(e, t, n, r, i) {
                        !0 !== t.isScene && (t = V);
                        Z.resetTextureUnits();
                        const o = t.fog
                          , a = r.isMeshStandardMaterial ? t.environment : null
                          , s = null === x ? y.outputColorSpace : !0 === x.isXRRenderTarget ? x.texture.colorSpace : Nf
                          , l = (r.isMeshStandardMaterial ? ee : $).get(r.envMap || a)
                          , c = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize
                          , u = !!n.attributes.tangent && (!!r.normalMap || r.anisotropy > 0)
                          , d = !!n.morphAttributes.position
                          , h = !!n.morphAttributes.normal
                          , p = !!n.morphAttributes.color;
                        let f = Gh;
                        r.toneMapped && (null !== x && !0 !== x.isXRRenderTarget || (f = y.toneMapping));
                        const g = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color
                          , v = void 0 !== g ? g.length : 0
                          , b = Q.get(r)
                          , _ = m.state.lights;
                        if (!0 === U && (!0 === z || e !== w)) {
                            const t = e === w && r.id === S;
                            le.setState(r, e, t)
                        }
                        let A = !1;
                        r.version === b.__version ? b.needsLights && b.lightsStateVersion !== _.state.version || b.outputColorSpace !== s || i.isBatchedMesh && !1 === b.batching ? A = !0 : i.isBatchedMesh || !0 !== b.batching ? i.isInstancedMesh && !1 === b.instancing ? A = !0 : i.isInstancedMesh || !0 !== b.instancing ? i.isSkinnedMesh && !1 === b.skinning ? A = !0 : i.isSkinnedMesh || !0 !== b.skinning ? i.isInstancedMesh && !0 === b.instancingColor && null === i.instanceColor || i.isInstancedMesh && !1 === b.instancingColor && null !== i.instanceColor || b.envMap !== l || !0 === r.fog && b.fog !== o ? A = !0 : void 0 === b.numClippingPlanes || b.numClippingPlanes === le.numPlanes && b.numIntersection === le.numIntersection ? (b.vertexAlphas !== c || b.vertexTangents !== u || b.morphTargets !== d || b.morphNormals !== h || b.morphColors !== p || b.toneMapping !== f || !0 === K.isWebGL2 && b.morphTargetsCount !== v) && (A = !0) : A = !0 : A = !0 : A = !0 : A = !0 : (A = !0,
                        b.__version = r.version);
                        let E = b.currentProgram;
                        !0 === A && (E = ke(r, t, i));
                        let M = !1
                          , C = !1
                          , T = !1;
                        const R = E.getUniforms()
                          , P = b.uniforms;
                        q.useProgram(E.program) && (M = !0,
                        C = !0,
                        T = !0);
                        r.id !== S && (S = r.id,
                        C = !0);
                        if (M || w !== e) {
                            R.setValue(ve, "projectionMatrix", e.projectionMatrix),
                            R.setValue(ve, "viewMatrix", e.matrixWorldInverse);
                            const t = R.map.cameraPosition;
                            void 0 !== t && t.setValue(ve, W.setFromMatrixPosition(e.matrixWorld)),
                            K.logarithmicDepthBuffer && R.setValue(ve, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                            (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && R.setValue(ve, "isOrthographic", !0 === e.isOrthographicCamera),
                            w !== e && (w = e,
                            C = !0,
                            T = !0)
                        }
                        if (i.isSkinnedMesh) {
                            R.setOptional(ve, i, "bindMatrix"),
                            R.setOptional(ve, i, "bindMatrixInverse");
                            const e = i.skeleton;
                            e && (K.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(),
                            R.setValue(ve, "boneTexture", e.boneTexture, Z)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                        }
                        i.isBatchedMesh && (R.setOptional(ve, i, "batchingTexture"),
                        R.setValue(ve, "batchingTexture", i._matricesTexture, Z));
                        const L = n.morphAttributes;
                        (void 0 !== L.position || void 0 !== L.normal || void 0 !== L.color && !0 === K.isWebGL2) && de.update(i, n, E);
                        (C || b.receiveShadow !== i.receiveShadow) && (b.receiveShadow = i.receiveShadow,
                        R.setValue(ve, "receiveShadow", i.receiveShadow));
                        r.isMeshGouraudMaterial && null !== r.envMap && (P.envMap.value = l,
                        P.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1);
                        C && (R.setValue(ve, "toneMappingExposure", y.toneMappingExposure),
                        b.needsLights && (D = T,
                        (k = P).ambientLightColor.needsUpdate = D,
                        k.lightProbe.needsUpdate = D,
                        k.directionalLights.needsUpdate = D,
                        k.directionalLightShadows.needsUpdate = D,
                        k.pointLights.needsUpdate = D,
                        k.pointLightShadows.needsUpdate = D,
                        k.spotLights.needsUpdate = D,
                        k.spotLightShadows.needsUpdate = D,
                        k.rectAreaLights.needsUpdate = D,
                        k.hemisphereLights.needsUpdate = D),
                        o && !0 === r.fog && oe.refreshFogUniforms(P, o),
                        oe.refreshMaterialUniforms(P, r, I, B, G),
                        W_.upload(ve, De(b), P, Z));
                        var k, D;
                        r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (W_.upload(ve, De(b), P, Z),
                        r.uniformsNeedUpdate = !1);
                        r.isSpriteMaterial && R.setValue(ve, "center", i.center);
                        if (R.setValue(ve, "modelViewMatrix", i.modelViewMatrix),
                        R.setValue(ve, "normalMatrix", i.normalMatrix),
                        R.setValue(ve, "modelMatrix", i.matrixWorld),
                        r.isShaderMaterial || r.isRawShaderMaterial) {
                            const e = r.uniformsGroups;
                            for (let t = 0, n = e.length; t < n; t++)
                                if (K.isWebGL2) {
                                    const n = e[t];
                                    ge.update(n, E),
                                    ge.bind(n, E)
                                } else
                                    console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                        }
                        return E
                    }(e, t, n, r, i);
                    q.setMaterial(r, a);
                    let l = n.index
                      , c = 1;
                    if (!0 === r.wireframe) {
                        if (l = ne.getWireframeAttribute(n),
                        void 0 === l)
                            return;
                        c = 2
                    }
                    const u = n.drawRange
                      , d = n.attributes.position;
                    let h = u.start * c
                      , p = (u.start + u.count) * c;
                    null !== o && (h = Math.max(h, o.start * c),
                    p = Math.min(p, (o.start + o.count) * c)),
                    null !== l ? (h = Math.max(h, 0),
                    p = Math.min(p, l.count)) : void 0 !== d && null !== d && (h = Math.max(h, 0),
                    p = Math.min(p, d.count));
                    const f = p - h;
                    if (f < 0 || f === 1 / 0)
                        return;
                    let g;
                    me.setup(i, r, s, n, l);
                    let v = he;
                    if (null !== l && (g = te.get(l),
                    v = pe,
                    v.setIndex(g)),
                    i.isMesh)
                        !0 === r.wireframe ? (q.setLineWidth(r.wireframeLinewidth * X()),
                        v.setMode(ve.LINES)) : v.setMode(ve.TRIANGLES);
                    else if (i.isLine) {
                        let e = r.linewidth;
                        void 0 === e && (e = 1),
                        q.setLineWidth(e * X()),
                        i.isLineSegments ? v.setMode(ve.LINES) : i.isLineLoop ? v.setMode(ve.LINE_LOOP) : v.setMode(ve.LINE_STRIP)
                    } else
                        i.isPoints ? v.setMode(ve.POINTS) : i.isSprite && v.setMode(ve.TRIANGLES);
                    if (i.isBatchedMesh)
                        v.renderMultiDraw(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount);
                    else if (i.isInstancedMesh)
                        v.renderInstances(h, f, i.count);
                    else if (n.isInstancedBufferGeometry) {
                        const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0
                          , t = Math.min(n.instanceCount, e);
                        v.renderInstances(h, f, t)
                    } else
                        v.render(h, f)
                }
                ,
                this.compile = function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                    null === n && (n = e),
                    m = se.get(n),
                    m.init(),
                    v.push(m),
                    n.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (m.pushLight(e),
                        e.castShadow && m.pushShadow(e))
                    }
                    )),
                    e !== n && e.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (m.pushLight(e),
                        e.castShadow && m.pushShadow(e))
                    }
                    )),
                    m.setupLights(y._useLegacyLights);
                    const r = new Set;
                    return e.traverse((function(e) {
                        const t = e.material;
                        if (t)
                            if (Array.isArray(t))
                                for (let i = 0; i < t.length; i++) {
                                    const o = t[i];
                                    Ee(o, n, e),
                                    r.add(o)
                                }
                            else
                                Ee(t, n, e),
                                r.add(t)
                    }
                    )),
                    v.pop(),
                    m = null,
                    r
                }
                ,
                this.compileAsync = function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                    const r = this.compile(e, t, n);
                    return new Promise((t => {
                        function n() {
                            r.forEach((function(e) {
                                Q.get(e).currentProgram.isReady() && r.delete(e)
                            }
                            )),
                            0 !== r.size ? setTimeout(n, 10) : t(e)
                        }
                        null !== J.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                    }
                    ))
                }
                ;
                let Me = null;
                function Ce() {
                    Re.stop()
                }
                function Te() {
                    Re.start()
                }
                const Re = new eb;
                function Pe(e, t, n, r) {
                    if (!1 === e.visible)
                        return;
                    if (e.layers.test(t.layers))
                        if (e.isGroup)
                            n = e.renderOrder;
                        else if (e.isLOD)
                            !0 === e.autoUpdate && e.update(t);
                        else if (e.isLight)
                            m.pushLight(e),
                            e.castShadow && m.pushShadow(e);
                        else if (e.isSprite) {
                            if (!e.frustumCulled || F.intersectsSprite(e)) {
                                r && W.setFromMatrixPosition(e.matrixWorld).applyMatrix4(H);
                                const t = re.update(e)
                                  , i = e.material;
                                i.visible && f.push(e, t, i, n, W.z, null)
                            }
                        } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || F.intersectsObject(e))) {
                            const t = re.update(e)
                              , i = e.material;
                            if (r && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(),
                            W.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(),
                            W.copy(t.boundingSphere.center)),
                            W.applyMatrix4(e.matrixWorld).applyMatrix4(H)),
                            Array.isArray(i)) {
                                const r = t.groups;
                                for (let o = 0, a = r.length; o < a; o++) {
                                    const a = r[o]
                                      , s = i[a.materialIndex];
                                    s && s.visible && f.push(e, t, s, n, W.z, a)
                                }
                            } else
                                i.visible && f.push(e, t, i, n, W.z, null)
                        }
                    const i = e.children;
                    for (let o = 0, a = i.length; o < a; o++)
                        Pe(i[o], t, n, r)
                }
                function Be(e, t, n, r) {
                    const i = e.opaque
                      , o = e.transmissive
                      , a = e.transparent;
                    m.setupLightsView(n),
                    !0 === U && le.setGlobalState(y.clippingPlanes, n),
                    o.length > 0 && function(e, t, n, r) {
                        const i = !0 === n.isScene ? n.overrideMaterial : null;
                        if (null !== i)
                            return;
                        const o = K.isWebGL2;
                        null === G && (G = new fg(1,1,{
                            generateMipmaps: !0,
                            type: J.has("EXT_color_buffer_half_float") ? Ap : fp,
                            minFilter: hp,
                            samples: o ? 4 : 0
                        }));
                        y.getDrawingBufferSize(j),
                        o ? G.setSize(j.x, j.y) : G.setSize(Fm(j.x), Fm(j.y));
                        const a = y.getRenderTarget();
                        y.setRenderTarget(G),
                        y.getClearColor(T),
                        R = y.getClearAlpha(),
                        R < 1 && y.setClearColor(16777215, .5);
                        y.clear();
                        const s = y.toneMapping;
                        y.toneMapping = Gh,
                        Ie(e, n, r),
                        Z.updateMultisampleRenderTarget(G),
                        Z.updateRenderTargetMipmap(G);
                        let l = !1;
                        for (let c = 0, u = t.length; c < u; c++) {
                            const e = t[c]
                              , i = e.object
                              , o = e.geometry
                              , a = e.material
                              , s = e.group;
                            if (a.side === nh && i.layers.test(r.layers)) {
                                const e = a.side;
                                a.side = th,
                                a.needsUpdate = !0,
                                Le(i, n, r, o, a, s),
                                a.side = e,
                                a.needsUpdate = !0,
                                l = !0
                            }
                        }
                        !0 === l && (Z.updateMultisampleRenderTarget(G),
                        Z.updateRenderTargetMipmap(G));
                        y.setRenderTarget(a),
                        y.setClearColor(T, R),
                        y.toneMapping = s
                    }(i, o, t, n),
                    r && q.viewport(E.copy(r)),
                    i.length > 0 && Ie(i, t, n),
                    o.length > 0 && Ie(o, t, n),
                    a.length > 0 && Ie(a, t, n),
                    q.buffers.depth.setTest(!0),
                    q.buffers.depth.setMask(!0),
                    q.buffers.color.setMask(!0),
                    q.setPolygonOffset(!1)
                }
                function Ie(e, t, n) {
                    const r = !0 === t.isScene ? t.overrideMaterial : null;
                    for (let i = 0, o = e.length; i < o; i++) {
                        const o = e[i]
                          , a = o.object
                          , s = o.geometry
                          , l = null === r ? o.material : r
                          , c = o.group;
                        a.layers.test(n.layers) && Le(a, t, n, s, l, c)
                    }
                }
                function Le(e, t, n, r, i, o) {
                    e.onBeforeRender(y, t, n, r, i, o),
                    e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
                    e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
                    i.onBeforeRender(y, t, n, r, e, o),
                    !0 === i.transparent && i.side === nh && !1 === i.forceSinglePass ? (i.side = th,
                    i.needsUpdate = !0,
                    y.renderBufferDirect(n, t, r, i, e, o),
                    i.side = eh,
                    i.needsUpdate = !0,
                    y.renderBufferDirect(n, t, r, i, e, o),
                    i.side = nh) : y.renderBufferDirect(n, t, r, i, e, o),
                    e.onAfterRender(y, t, n, r, i, o)
                }
                function ke(e, t, n) {
                    !0 !== t.isScene && (t = V);
                    const r = Q.get(e)
                      , i = m.state.lights
                      , o = m.state.shadowsArray
                      , a = i.state.version
                      , s = ie.getParameters(e, i.state, o, t, n)
                      , l = ie.getProgramCacheKey(s);
                    let c = r.programs;
                    r.environment = e.isMeshStandardMaterial ? t.environment : null,
                    r.fog = t.fog,
                    r.envMap = (e.isMeshStandardMaterial ? ee : $).get(e.envMap || r.environment),
                    void 0 === c && (e.addEventListener("dispose", we),
                    c = new Map,
                    r.programs = c);
                    let u = c.get(l);
                    if (void 0 !== u) {
                        if (r.currentProgram === u && r.lightsStateVersion === a)
                            return Oe(e, s),
                            u
                    } else
                        s.uniforms = ie.getUniforms(e),
                        e.onBuild(n, s, y),
                        e.onBeforeCompile(s, y),
                        u = ie.acquireProgram(s, l),
                        c.set(l, u),
                        r.uniforms = s.uniforms;
                    const d = r.uniforms;
                    return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (d.clippingPlanes = le.uniform),
                    Oe(e, s),
                    r.needsLights = function(e) {
                        return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                    }(e),
                    r.lightsStateVersion = a,
                    r.needsLights && (d.ambientLightColor.value = i.state.ambient,
                    d.lightProbe.value = i.state.probe,
                    d.directionalLights.value = i.state.directional,
                    d.directionalLightShadows.value = i.state.directionalShadow,
                    d.spotLights.value = i.state.spot,
                    d.spotLightShadows.value = i.state.spotShadow,
                    d.rectAreaLights.value = i.state.rectArea,
                    d.ltc_1.value = i.state.rectAreaLTC1,
                    d.ltc_2.value = i.state.rectAreaLTC2,
                    d.pointLights.value = i.state.point,
                    d.pointLightShadows.value = i.state.pointShadow,
                    d.hemisphereLights.value = i.state.hemi,
                    d.directionalShadowMap.value = i.state.directionalShadowMap,
                    d.directionalShadowMatrix.value = i.state.directionalShadowMatrix,
                    d.spotShadowMap.value = i.state.spotShadowMap,
                    d.spotLightMatrix.value = i.state.spotLightMatrix,
                    d.spotLightMap.value = i.state.spotLightMap,
                    d.pointShadowMap.value = i.state.pointShadowMap,
                    d.pointShadowMatrix.value = i.state.pointShadowMatrix),
                    r.currentProgram = u,
                    r.uniformsList = null,
                    u
                }
                function De(e) {
                    if (null === e.uniformsList) {
                        const t = e.currentProgram.getUniforms();
                        e.uniformsList = W_.seqWithValue(t.seq, e.uniforms)
                    }
                    return e.uniformsList
                }
                function Oe(e, t) {
                    const n = Q.get(e);
                    n.outputColorSpace = t.outputColorSpace,
                    n.batching = t.batching,
                    n.instancing = t.instancing,
                    n.instancingColor = t.instancingColor,
                    n.skinning = t.skinning,
                    n.morphTargets = t.morphTargets,
                    n.morphNormals = t.morphNormals,
                    n.morphColors = t.morphColors,
                    n.morphTargetsCount = t.morphTargetsCount,
                    n.numClippingPlanes = t.numClippingPlanes,
                    n.numIntersection = t.numClipIntersection,
                    n.vertexAlphas = t.vertexAlphas,
                    n.vertexTangents = t.vertexTangents,
                    n.toneMapping = t.toneMapping
                }
                Re.setAnimationLoop((function(e) {
                    Me && Me(e)
                }
                )),
                "undefined" !== typeof self && Re.setContext(self),
                this.setAnimationLoop = function(e) {
                    Me = e,
                    _e.setAnimationLoop(e),
                    null === e ? Re.stop() : Re.start()
                }
                ,
                _e.addEventListener("sessionstart", Ce),
                _e.addEventListener("sessionend", Te),
                this.render = function(e, t) {
                    if (void 0 !== t && !0 !== t.isCamera)
                        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === b)
                        return;
                    !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                    null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                    !0 === _e.enabled && !0 === _e.isPresenting && (!0 === _e.cameraAutoUpdate && _e.updateCamera(t),
                    t = _e.getCamera()),
                    !0 === e.isScene && e.onBeforeRender(y, e, t, x),
                    m = se.get(e, v.length),
                    m.init(),
                    v.push(m),
                    H.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                    F.setFromProjectionMatrix(H),
                    z = this.localClippingEnabled,
                    U = le.init(this.clippingPlanes, z),
                    f = ae.get(e, g.length),
                    f.init(),
                    g.push(f),
                    Pe(e, t, 0, y.sortObjects),
                    f.finish(),
                    !0 === y.sortObjects && f.sort(L, k),
                    this.info.render.frame++,
                    !0 === U && le.beginShadows();
                    const n = m.state.shadowsArray;
                    if (ce.render(n, e, t),
                    !0 === U && le.endShadows(),
                    !0 === this.info.autoReset && this.info.reset(),
                    ue.render(f, e),
                    m.setupLights(y._useLegacyLights),
                    t.isArrayCamera) {
                        const n = t.cameras;
                        for (let t = 0, r = n.length; t < r; t++) {
                            const r = n[t];
                            Be(f, e, r, r.viewport)
                        }
                    } else
                        Be(f, e, t);
                    null !== x && (Z.updateMultisampleRenderTarget(x),
                    Z.updateRenderTargetMipmap(x)),
                    !0 === e.isScene && e.onAfterRender(y, e, t),
                    me.resetDefaultState(),
                    S = -1,
                    w = null,
                    v.pop(),
                    m = v.length > 0 ? v[v.length - 1] : null,
                    g.pop(),
                    f = g.length > 0 ? g[g.length - 1] : null
                }
                ,
                this.getActiveCubeFace = function() {
                    return _
                }
                ,
                this.getActiveMipmapLevel = function() {
                    return A
                }
                ,
                this.getRenderTarget = function() {
                    return x
                }
                ,
                this.setRenderTargetTextures = function(e, t, n) {
                    Q.get(e.texture).__webglTexture = t,
                    Q.get(e.depthTexture).__webglTexture = n;
                    const r = Q.get(e);
                    r.__hasExternalTextures = !0,
                    r.__hasExternalTextures && (r.__autoAllocateDepthBuffer = void 0 === n,
                    r.__autoAllocateDepthBuffer || !0 === J.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
                    r.__useRenderToTexture = !1))
                }
                ,
                this.setRenderTargetFramebuffer = function(e, t) {
                    const n = Q.get(e);
                    n.__webglFramebuffer = t,
                    n.__useDefaultFramebuffer = void 0 === t
                }
                ,
                this.setRenderTarget = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                      , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                    x = e,
                    _ = t,
                    A = n;
                    let r = !0
                      , i = null
                      , o = !1
                      , a = !1;
                    if (e) {
                        const s = Q.get(e);
                        void 0 !== s.__useDefaultFramebuffer ? (q.bindFramebuffer(ve.FRAMEBUFFER, null),
                        r = !1) : void 0 === s.__webglFramebuffer ? Z.setupRenderTarget(e) : s.__hasExternalTextures && Z.rebindTextures(e, Q.get(e.texture).__webglTexture, Q.get(e.depthTexture).__webglTexture);
                        const l = e.texture;
                        (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (a = !0);
                        const c = Q.get(e).__webglFramebuffer;
                        e.isWebGLCubeRenderTarget ? (i = Array.isArray(c[t]) ? c[t][n] : c[t],
                        o = !0) : i = K.isWebGL2 && e.samples > 0 && !1 === Z.useMultisampledRTT(e) ? Q.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c,
                        E.copy(e.viewport),
                        M.copy(e.scissor),
                        C = e.scissorTest
                    } else
                        E.copy(D).multiplyScalar(I).floor(),
                        M.copy(O).multiplyScalar(I).floor(),
                        C = N;
                    if (q.bindFramebuffer(ve.FRAMEBUFFER, i) && K.drawBuffers && r && q.drawBuffers(e, i),
                    q.viewport(E),
                    q.scissor(M),
                    q.setScissorTest(C),
                    o) {
                        const r = Q.get(e.texture);
                        ve.framebufferTexture2D(ve.FRAMEBUFFER, ve.COLOR_ATTACHMENT0, ve.TEXTURE_CUBE_MAP_POSITIVE_X + t, r.__webglTexture, n)
                    } else if (a) {
                        const r = Q.get(e.texture)
                          , i = t || 0;
                        ve.framebufferTextureLayer(ve.FRAMEBUFFER, ve.COLOR_ATTACHMENT0, r.__webglTexture, n || 0, i)
                    }
                    S = -1
                }
                ,
                this.readRenderTargetPixels = function(e, t, n, r, i, o, a) {
                    if (!e || !e.isWebGLRenderTarget)
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let s = Q.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== a && (s = s[a]),
                    s) {
                        q.bindFramebuffer(ve.FRAMEBUFFER, s);
                        try {
                            const a = e.texture
                              , s = a.format
                              , l = a.type;
                            if (s !== Mp && fe.convert(s) !== ve.getParameter(ve.IMPLEMENTATION_COLOR_READ_FORMAT))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const c = l === Ap && (J.has("EXT_color_buffer_half_float") || K.isWebGL2 && J.has("EXT_color_buffer_float"));
                            if (l !== fp && fe.convert(l) !== ve.getParameter(ve.IMPLEMENTATION_COLOR_READ_TYPE) && (l !== _p || !(K.isWebGL2 || J.has("OES_texture_float") || J.has("WEBGL_color_buffer_float"))) && !c)
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && ve.readPixels(t, n, r, i, fe.convert(s), fe.convert(l), o)
                        } finally {
                            const e = null !== x ? Q.get(x).__webglFramebuffer : null;
                            q.bindFramebuffer(ve.FRAMEBUFFER, e)
                        }
                    }
                }
                ,
                this.copyFramebufferToTexture = function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                    const r = Math.pow(2, -n)
                      , i = Math.floor(t.image.width * r)
                      , o = Math.floor(t.image.height * r);
                    Z.setTexture2D(t, 0),
                    ve.copyTexSubImage2D(ve.TEXTURE_2D, n, 0, 0, e.x, e.y, i, o),
                    q.unbindTexture()
                }
                ,
                this.copyTextureToTexture = function(e, t, n) {
                    let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                    const i = t.image.width
                      , o = t.image.height
                      , a = fe.convert(n.format)
                      , s = fe.convert(n.type);
                    Z.setTexture2D(n, 0),
                    ve.pixelStorei(ve.UNPACK_FLIP_Y_WEBGL, n.flipY),
                    ve.pixelStorei(ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha),
                    ve.pixelStorei(ve.UNPACK_ALIGNMENT, n.unpackAlignment),
                    t.isDataTexture ? ve.texSubImage2D(ve.TEXTURE_2D, r, e.x, e.y, i, o, a, s, t.image.data) : t.isCompressedTexture ? ve.compressedTexSubImage2D(ve.TEXTURE_2D, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, a, t.mipmaps[0].data) : ve.texSubImage2D(ve.TEXTURE_2D, r, e.x, e.y, a, s, t.image),
                    0 === r && n.generateMipmaps && ve.generateMipmap(ve.TEXTURE_2D),
                    q.unbindTexture()
                }
                ,
                this.copyTextureToTexture3D = function(e, t, n, r) {
                    let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                    if (y.isWebGL1Renderer)
                        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const o = e.max.x - e.min.x + 1
                      , a = e.max.y - e.min.y + 1
                      , s = e.max.z - e.min.z + 1
                      , l = fe.convert(r.format)
                      , c = fe.convert(r.type);
                    let u;
                    if (r.isData3DTexture)
                        Z.setTexture3D(r, 0),
                        u = ve.TEXTURE_3D;
                    else {
                        if (!r.isDataArrayTexture)
                            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        Z.setTexture2DArray(r, 0),
                        u = ve.TEXTURE_2D_ARRAY
                    }
                    ve.pixelStorei(ve.UNPACK_FLIP_Y_WEBGL, r.flipY),
                    ve.pixelStorei(ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha),
                    ve.pixelStorei(ve.UNPACK_ALIGNMENT, r.unpackAlignment);
                    const d = ve.getParameter(ve.UNPACK_ROW_LENGTH)
                      , h = ve.getParameter(ve.UNPACK_IMAGE_HEIGHT)
                      , p = ve.getParameter(ve.UNPACK_SKIP_PIXELS)
                      , f = ve.getParameter(ve.UNPACK_SKIP_ROWS)
                      , m = ve.getParameter(ve.UNPACK_SKIP_IMAGES)
                      , g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                    ve.pixelStorei(ve.UNPACK_ROW_LENGTH, g.width),
                    ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT, g.height),
                    ve.pixelStorei(ve.UNPACK_SKIP_PIXELS, e.min.x),
                    ve.pixelStorei(ve.UNPACK_SKIP_ROWS, e.min.y),
                    ve.pixelStorei(ve.UNPACK_SKIP_IMAGES, e.min.z),
                    n.isDataTexture || n.isData3DTexture ? ve.texSubImage3D(u, i, t.x, t.y, t.z, o, a, s, l, c, g.data) : n.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
                    ve.compressedTexSubImage3D(u, i, t.x, t.y, t.z, o, a, s, l, g.data)) : ve.texSubImage3D(u, i, t.x, t.y, t.z, o, a, s, l, c, g),
                    ve.pixelStorei(ve.UNPACK_ROW_LENGTH, d),
                    ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT, h),
                    ve.pixelStorei(ve.UNPACK_SKIP_PIXELS, p),
                    ve.pixelStorei(ve.UNPACK_SKIP_ROWS, f),
                    ve.pixelStorei(ve.UNPACK_SKIP_IMAGES, m),
                    0 === i && r.generateMipmaps && ve.generateMipmap(u),
                    q.unbindTexture()
                }
                ,
                this.initTexture = function(e) {
                    e.isCubeTexture ? Z.setTextureCube(e, 0) : e.isData3DTexture ? Z.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? Z.setTexture2DArray(e, 0) : Z.setTexture2D(e, 0),
                    q.unbindTexture()
                }
                ,
                this.resetState = function() {
                    _ = 0,
                    A = 0,
                    x = null,
                    q.reset(),
                    me.reset()
                }
                ,
                "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            get coordinateSystem() {
                return Mm
            }
            get outputColorSpace() {
                return this._outputColorSpace
            }
            set outputColorSpace(e) {
                this._outputColorSpace = e;
                const t = this.getContext();
                t.drawingBufferColorSpace = e === Ff ? "display-p3" : "srgb",
                t.unpackColorSpace = ng.workingColorSpace === Uf ? "display-p3" : "srgb"
            }
            get physicallyCorrectLights() {
                return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
                !this.useLegacyLights
            }
            set physicallyCorrectLights(e) {
                console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
                this.useLegacyLights = !e
            }
            get outputEncoding() {
                return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
                this.outputColorSpace === Of ? Pf : Rf
            }
            set outputEncoding(e) {
                console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
                this.outputColorSpace = e === Pf ? Of : Nf
            }
            get useLegacyLights() {
                return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                this._useLegacyLights
            }
            set useLegacyLights(e) {
                console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                this._useLegacyLights = e
            }
        }
        class NA extends OA {
        }
        NA.prototype.isWebGL1Renderer = !0;
        class FA {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 25e-5;
                this.isFogExp2 = !0,
                this.name = "",
                this.color = new Uv(e),
                this.density = t
            }
            clone() {
                return new FA(this.color,this.density)
            }
            toJSON() {
                return {
                    type: "FogExp2",
                    name: this.name,
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }
        class UA {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e3;
                this.isFog = !0,
                this.name = "",
                this.color = new Uv(e),
                this.near = t,
                this.far = n
            }
            clone() {
                return new UA(this.color,this.near,this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    name: this.name,
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        class zA extends xv {
            constructor() {
                super(),
                this.isScene = !0,
                this.type = "Scene",
                this.background = null,
                this.environment = null,
                this.fog = null,
                this.backgroundBlurriness = 0,
                this.backgroundIntensity = 1,
                this.overrideMaterial = null,
                "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(e, t) {
                return super.copy(e, t),
                null !== e.background && (this.background = e.background.clone()),
                null !== e.environment && (this.environment = e.environment.clone()),
                null !== e.fog && (this.fog = e.fog.clone()),
                this.backgroundBlurriness = e.backgroundBlurriness,
                this.backgroundIntensity = e.backgroundIntensity,
                null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return null !== this.fog && (t.object.fog = this.fog.toJSON()),
                this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
                1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity),
                t
            }
        }
        class GA {
            constructor(e, t) {
                this.isInterleavedBuffer = !0,
                this.array = e,
                this.stride = t,
                this.count = void 0 !== e ? e.length / t : 0,
                this.usage = fm,
                this._updateRange = {
                    offset: 0,
                    count: -1
                },
                this.updateRanges = [],
                this.version = 0,
                this.uuid = Lm()
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            get updateRange() {
                return console.warn('THREE.InterleavedBuffer: "updateRange" is deprecated and removed in r169. Use "addUpdateRange()" instead.'),
                this._updateRange
            }
            setUsage(e) {
                return this.usage = e,
                this
            }
            addUpdateRange(e, t) {
                this.updateRanges.push({
                    start: e,
                    count: t
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(e) {
                return this.array = new e.array.constructor(e.array),
                this.count = e.count,
                this.stride = e.stride,
                this.usage = e.usage,
                this
            }
            copyAt(e, t, n) {
                e *= this.stride,
                n *= t.stride;
                for (let r = 0, i = this.stride; r < i; r++)
                    this.array[e + r] = t.array[n + r];
                return this
            }
            set(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.array.set(e, t),
                this
            }
            clone(e) {
                void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Lm()),
                void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
                  , n = new this.constructor(t,this.stride);
                return n.setUsage(this.usage),
                n
            }
            onUpload(e) {
                return this.onUploadCallback = e,
                this
            }
            toJSON(e) {
                return void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Lm()),
                void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const HA = new Ag;
        class jA {
            constructor(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                this.isInterleavedBufferAttribute = !0,
                this.name = "",
                this.data = e,
                this.itemSize = t,
                this.offset = n,
                this.normalized = r
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(e) {
                this.data.needsUpdate = e
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.data.count; t < n; t++)
                    HA.fromBufferAttribute(this, t),
                    HA.applyMatrix4(e),
                    this.setXYZ(t, HA.x, HA.y, HA.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    HA.fromBufferAttribute(this, t),
                    HA.applyNormalMatrix(e),
                    this.setXYZ(t, HA.x, HA.y, HA.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    HA.fromBufferAttribute(this, t),
                    HA.transformDirection(e),
                    this.setXYZ(t, HA.x, HA.y, HA.z);
                return this
            }
            setX(e, t) {
                return this.normalized && (t = zm(t, this.array)),
                this.data.array[e * this.data.stride + this.offset] = t,
                this
            }
            setY(e, t) {
                return this.normalized && (t = zm(t, this.array)),
                this.data.array[e * this.data.stride + this.offset + 1] = t,
                this
            }
            setZ(e, t) {
                return this.normalized && (t = zm(t, this.array)),
                this.data.array[e * this.data.stride + this.offset + 2] = t,
                this
            }
            setW(e, t) {
                return this.normalized && (t = zm(t, this.array)),
                this.data.array[e * this.data.stride + this.offset + 3] = t,
                this
            }
            getX(e) {
                let t = this.data.array[e * this.data.stride + this.offset];
                return this.normalized && (t = Um(t, this.array)),
                t
            }
            getY(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 1];
                return this.normalized && (t = Um(t, this.array)),
                t
            }
            getZ(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 2];
                return this.normalized && (t = Um(t, this.array)),
                t
            }
            getW(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 3];
                return this.normalized && (t = Um(t, this.array)),
                t
            }
            setXY(e, t, n) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (t = zm(t, this.array),
                n = zm(n, this.array)),
                this.data.array[e + 0] = t,
                this.data.array[e + 1] = n,
                this
            }
            setXYZ(e, t, n, r) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (t = zm(t, this.array),
                n = zm(n, this.array),
                r = zm(r, this.array)),
                this.data.array[e + 0] = t,
                this.data.array[e + 1] = n,
                this.data.array[e + 2] = r,
                this
            }
            setXYZW(e, t, n, r, i) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (t = zm(t, this.array),
                n = zm(n, this.array),
                r = zm(r, this.array),
                i = zm(i, this.array)),
                this.data.array[e + 0] = t,
                this.data.array[e + 1] = n,
                this.data.array[e + 2] = r,
                this.data.array[e + 3] = i,
                this
            }
            clone(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++)
                            e.push(this.data.array[n + t])
                    }
                    return new Qv(new this.array.constructor(e),this.itemSize,this.normalized)
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
                new jA(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
            }
            toJSON(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++)
                            e.push(this.data.array[n + t])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: e,
                        normalized: this.normalized
                    }
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
                {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        class WA extends Hv {
            constructor(e) {
                super(),
                this.isSpriteMaterial = !0,
                this.type = "SpriteMaterial",
                this.color = new Uv(16777215),
                this.map = null,
                this.alphaMap = null,
                this.rotation = 0,
                this.sizeAttenuation = !0,
                this.transparent = !0,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.rotation = e.rotation,
                this.sizeAttenuation = e.sizeAttenuation,
                this.fog = e.fog,
                this
            }
        }
        let VA;
        const XA = new Ag
          , JA = new Ag
          , KA = new Ag
          , qA = new Hm
          , YA = new Hm
          , QA = new Qg
          , ZA = new Ag
          , $A = new Ag
          , ex = new Ag
          , tx = new Hm
          , nx = new Hm
          , rx = new Hm;
        class ix extends xv {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new WA;
                if (super(),
                this.isSprite = !0,
                this.type = "Sprite",
                void 0 === VA) {
                    VA = new my;
                    const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
                      , t = new GA(e,5);
                    VA.setIndex([0, 1, 2, 0, 2, 3]),
                    VA.setAttribute("position", new jA(t,3,0,!1)),
                    VA.setAttribute("uv", new jA(t,2,3,!1))
                }
                this.geometry = VA,
                this.material = e,
                this.center = new Hm(.5,.5)
            }
            raycast(e, t) {
                null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                JA.setFromMatrixScale(this.matrixWorld),
                QA.copy(e.camera.matrixWorld),
                this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
                KA.setFromMatrixPosition(this.modelViewMatrix),
                e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && JA.multiplyScalar(-KA.z);
                const n = this.material.rotation;
                let r, i;
                0 !== n && (i = Math.cos(n),
                r = Math.sin(n));
                const o = this.center;
                ox(ZA.set(-.5, -.5, 0), KA, o, JA, r, i),
                ox($A.set(.5, -.5, 0), KA, o, JA, r, i),
                ox(ex.set(.5, .5, 0), KA, o, JA, r, i),
                tx.set(0, 0),
                nx.set(1, 0),
                rx.set(1, 1);
                let a = e.ray.intersectTriangle(ZA, $A, ex, !1, XA);
                if (null === a && (ox($A.set(-.5, .5, 0), KA, o, JA, r, i),
                nx.set(0, 1),
                a = e.ray.intersectTriangle(ZA, ex, $A, !1, XA),
                null === a))
                    return;
                const s = e.ray.origin.distanceTo(XA);
                s < e.near || s > e.far || t.push({
                    distance: s,
                    point: XA.clone(),
                    uv: kv.getInterpolation(XA, ZA, $A, ex, tx, nx, rx, new Hm),
                    face: null,
                    object: this
                })
            }
            copy(e, t) {
                return super.copy(e, t),
                void 0 !== e.center && this.center.copy(e.center),
                this.material = e.material,
                this
            }
        }
        function ox(e, t, n, r, i, o) {
            qA.subVectors(e, n).addScalar(.5).multiply(r),
            void 0 !== i ? (YA.x = o * qA.x - i * qA.y,
            YA.y = i * qA.x + o * qA.y) : YA.copy(qA),
            e.copy(t),
            e.x += YA.x,
            e.y += YA.y,
            e.applyMatrix4(QA)
        }
        const ax = new Ag
          , sx = new Ag;
        class lx extends xv {
            constructor() {
                super(),
                this._currentLevel = 0,
                this.type = "LOD",
                Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    },
                    isLOD: {
                        value: !0
                    }
                }),
                this.autoUpdate = !0
            }
            copy(e) {
                super.copy(e, !1);
                const t = e.levels;
                for (let n = 0, r = t.length; n < r; n++) {
                    const e = t[n];
                    this.addLevel(e.object.clone(), e.distance, e.hysteresis)
                }
                return this.autoUpdate = e.autoUpdate,
                this
            }
            addLevel(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                t = Math.abs(t);
                const r = this.levels;
                let i;
                for (i = 0; i < r.length && !(t < r[i].distance); i++)
                    ;
                return r.splice(i, 0, {
                    distance: t,
                    hysteresis: n,
                    object: e
                }),
                this.add(e),
                this
            }
            getCurrentLevel() {
                return this._currentLevel
            }
            getObjectForDistance(e) {
                const t = this.levels;
                if (t.length > 0) {
                    let n, r;
                    for (n = 1,
                    r = t.length; n < r; n++) {
                        let r = t[n].distance;
                        if (t[n].object.visible && (r -= r * t[n].hysteresis),
                        e < r)
                            break
                    }
                    return t[n - 1].object
                }
                return null
            }
            raycast(e, t) {
                if (this.levels.length > 0) {
                    ax.setFromMatrixPosition(this.matrixWorld);
                    const n = e.ray.origin.distanceTo(ax);
                    this.getObjectForDistance(n).raycast(e, t)
                }
            }
            update(e) {
                const t = this.levels;
                if (t.length > 1) {
                    ax.setFromMatrixPosition(e.matrixWorld),
                    sx.setFromMatrixPosition(this.matrixWorld);
                    const n = ax.distanceTo(sx) / e.zoom;
                    let r, i;
                    for (t[0].object.visible = !0,
                    r = 1,
                    i = t.length; r < i; r++) {
                        let e = t[r].distance;
                        if (t[r].object.visible && (e -= e * t[r].hysteresis),
                        !(n >= e))
                            break;
                        t[r - 1].object.visible = !1,
                        t[r].object.visible = !0
                    }
                    for (this._currentLevel = r - 1; r < i; r++)
                        t[r].object.visible = !1
                }
            }
            toJSON(e) {
                const t = super.toJSON(e);
                !1 === this.autoUpdate && (t.object.autoUpdate = !1),
                t.object.levels = [];
                const n = this.levels;
                for (let r = 0, i = n.length; r < i; r++) {
                    const e = n[r];
                    t.object.levels.push({
                        object: e.object.uuid,
                        distance: e.distance,
                        hysteresis: e.hysteresis
                    })
                }
                return t
            }
        }
        const cx = new Ag
          , ux = new hg
          , dx = new hg
          , hx = new Ag
          , px = new Qg
          , fx = new Ag
          , mx = new Hg
          , gx = new Qg
          , vx = new Yg;
        class yx extends Ly {
            constructor(e, t) {
                super(e, t),
                this.isSkinnedMesh = !0,
                this.type = "SkinnedMesh",
                this.bindMode = Jh,
                this.bindMatrix = new Qg,
                this.bindMatrixInverse = new Qg,
                this.boundingBox = null,
                this.boundingSphere = null
            }
            computeBoundingBox() {
                const e = this.geometry;
                null === this.boundingBox && (this.boundingBox = new wg),
                this.boundingBox.makeEmpty();
                const t = e.getAttribute("position");
                for (let n = 0; n < t.count; n++)
                    this.getVertexPosition(n, fx),
                    this.boundingBox.expandByPoint(fx)
            }
            computeBoundingSphere() {
                const e = this.geometry;
                null === this.boundingSphere && (this.boundingSphere = new Hg),
                this.boundingSphere.makeEmpty();
                const t = e.getAttribute("position");
                for (let n = 0; n < t.count; n++)
                    this.getVertexPosition(n, fx),
                    this.boundingSphere.expandByPoint(fx)
            }
            copy(e, t) {
                return super.copy(e, t),
                this.bindMode = e.bindMode,
                this.bindMatrix.copy(e.bindMatrix),
                this.bindMatrixInverse.copy(e.bindMatrixInverse),
                this.skeleton = e.skeleton,
                null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                this
            }
            raycast(e, t) {
                const n = this.material
                  , r = this.matrixWorld;
                void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(),
                mx.copy(this.boundingSphere),
                mx.applyMatrix4(r),
                !1 !== e.ray.intersectsSphere(mx) && (gx.copy(r).invert(),
                vx.copy(e.ray).applyMatrix4(gx),
                null !== this.boundingBox && !1 === vx.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, vx)))
            }
            getVertexPosition(e, t) {
                return super.getVertexPosition(e, t),
                this.applyBoneTransform(e, t),
                t
            }
            bind(e, t) {
                this.skeleton = e,
                void 0 === t && (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                t = this.matrixWorld),
                this.bindMatrix.copy(t),
                this.bindMatrixInverse.copy(t).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const e = new hg
                  , t = this.geometry.attributes.skinWeight;
                for (let n = 0, r = t.count; n < r; n++) {
                    e.fromBufferAttribute(t, n);
                    const r = 1 / e.manhattanLength();
                    r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
                    t.setXYZW(n, e.x, e.y, e.z, e.w)
                }
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e),
                this.bindMode === Jh ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Kh ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            applyBoneTransform(e, t) {
                const n = this.skeleton
                  , r = this.geometry;
                ux.fromBufferAttribute(r.attributes.skinIndex, e),
                dx.fromBufferAttribute(r.attributes.skinWeight, e),
                cx.copy(t).applyMatrix4(this.bindMatrix),
                t.set(0, 0, 0);
                for (let i = 0; i < 4; i++) {
                    const e = dx.getComponent(i);
                    if (0 !== e) {
                        const r = ux.getComponent(i);
                        px.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                        t.addScaledVector(hx.copy(cx).applyMatrix4(px), e)
                    }
                }
                return t.applyMatrix4(this.bindMatrixInverse)
            }
            boneTransform(e, t) {
                return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),
                this.applyBoneTransform(e, t)
            }
        }
        class bx extends xv {
            constructor() {
                super(),
                this.isBone = !0,
                this.type = "Bone"
            }
        }
        class _x extends dg {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                super(null, arguments.length > 5 ? arguments[5] : void 0, arguments.length > 6 ? arguments[6] : void 0, arguments.length > 7 ? arguments[7] : void 0, arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : ip, arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : ip, arguments.length > 3 ? arguments[3] : void 0, arguments.length > 4 ? arguments[4] : void 0, arguments.length > 10 ? arguments[10] : void 0, arguments.length > 11 ? arguments[11] : void 0),
                this.isDataTexture = !0,
                this.image = {
                    data: e,
                    width: t,
                    height: n
                },
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        const Ax = new Qg
          , xx = new Qg;
        class Sx {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                this.uuid = Lm(),
                this.bones = e.slice(0),
                this.boneInverses = t,
                this.boneMatrices = null,
                this.boneTexture = null,
                this.init()
            }
            init() {
                const e = this.bones
                  , t = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * e.length),
                0 === t.length)
                    this.calculateInverses();
                else if (e.length !== t.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                    this.boneInverses = [];
                    for (let e = 0, t = this.bones.length; e < t; e++)
                        this.boneInverses.push(new Qg)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = new Qg;
                    this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
                    this.boneInverses.push(t)
                }
            }
            pose() {
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                }
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                    t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                    t.matrix.decompose(t.position, t.quaternion, t.scale))
                }
            }
            update() {
                const e = this.bones
                  , t = this.boneInverses
                  , n = this.boneMatrices
                  , r = this.boneTexture;
                for (let i = 0, o = e.length; i < o; i++) {
                    const r = e[i] ? e[i].matrixWorld : xx;
                    Ax.multiplyMatrices(r, t[i]),
                    Ax.toArray(n, 16 * i)
                }
                null !== r && (r.needsUpdate = !0)
            }
            clone() {
                return new Sx(this.bones,this.boneInverses)
            }
            computeBoneTexture() {
                let e = Math.sqrt(4 * this.bones.length);
                e = 4 * Math.ceil(e / 4),
                e = Math.max(e, 4);
                const t = new Float32Array(e * e * 4);
                t.set(this.boneMatrices);
                const n = new _x(t,e,e,Mp,_p);
                return n.needsUpdate = !0,
                this.boneMatrices = t,
                this.boneTexture = n,
                this
            }
            getBoneByName(e) {
                for (let t = 0, n = this.bones.length; t < n; t++) {
                    const n = this.bones[t];
                    if (n.name === e)
                        return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(),
                this.boneTexture = null)
            }
            fromJSON(e, t) {
                this.uuid = e.uuid;
                for (let n = 0, r = e.bones.length; n < r; n++) {
                    const r = e.bones[n];
                    let i = t[r];
                    void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r),
                    i = new bx),
                    this.bones.push(i),
                    this.boneInverses.push((new Qg).fromArray(e.boneInverses[n]))
                }
                return this.init(),
                this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                e.uuid = this.uuid;
                const t = this.bones
                  , n = this.boneInverses;
                for (let r = 0, i = t.length; r < i; r++) {
                    const i = t[r];
                    e.bones.push(i.uuid);
                    const o = n[r];
                    e.boneInverses.push(o.toArray())
                }
                return e
            }
        }
        class wx extends Qv {
            constructor(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                super(e, t, n),
                this.isInstancedBufferAttribute = !0,
                this.meshPerAttribute = r
            }
            copy(e) {
                return super.copy(e),
                this.meshPerAttribute = e.meshPerAttribute,
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.meshPerAttribute = this.meshPerAttribute,
                e.isInstancedBufferAttribute = !0,
                e
            }
        }
        const Ex = new Qg
          , Mx = new Qg
          , Cx = []
          , Tx = new wg
          , Rx = new Qg
          , Px = new Ly
          , Bx = new Hg;
        class Ix extends Ly {
            constructor(e, t, n) {
                super(e, t),
                this.isInstancedMesh = !0,
                this.instanceMatrix = new wx(new Float32Array(16 * n),16),
                this.instanceColor = null,
                this.count = n,
                this.boundingBox = null,
                this.boundingSphere = null;
                for (let r = 0; r < n; r++)
                    this.setMatrixAt(r, Rx)
            }
            computeBoundingBox() {
                const e = this.geometry
                  , t = this.count;
                null === this.boundingBox && (this.boundingBox = new wg),
                null === e.boundingBox && e.computeBoundingBox(),
                this.boundingBox.makeEmpty();
                for (let n = 0; n < t; n++)
                    this.getMatrixAt(n, Ex),
                    Tx.copy(e.boundingBox).applyMatrix4(Ex),
                    this.boundingBox.union(Tx)
            }
            computeBoundingSphere() {
                const e = this.geometry
                  , t = this.count;
                null === this.boundingSphere && (this.boundingSphere = new Hg),
                null === e.boundingSphere && e.computeBoundingSphere(),
                this.boundingSphere.makeEmpty();
                for (let n = 0; n < t; n++)
                    this.getMatrixAt(n, Ex),
                    Bx.copy(e.boundingSphere).applyMatrix4(Ex),
                    this.boundingSphere.union(Bx)
            }
            copy(e, t) {
                return super.copy(e, t),
                this.instanceMatrix.copy(e.instanceMatrix),
                null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()),
                this.count = e.count,
                null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                this
            }
            getColorAt(e, t) {
                t.fromArray(this.instanceColor.array, 3 * e)
            }
            getMatrixAt(e, t) {
                t.fromArray(this.instanceMatrix.array, 16 * e)
            }
            raycast(e, t) {
                const n = this.matrixWorld
                  , r = this.count;
                if (Px.geometry = this.geometry,
                Px.material = this.material,
                void 0 !== Px.material && (null === this.boundingSphere && this.computeBoundingSphere(),
                Bx.copy(this.boundingSphere),
                Bx.applyMatrix4(n),
                !1 !== e.ray.intersectsSphere(Bx)))
                    for (let i = 0; i < r; i++) {
                        this.getMatrixAt(i, Ex),
                        Mx.multiplyMatrices(n, Ex),
                        Px.matrixWorld = Mx,
                        Px.raycast(e, Cx);
                        for (let e = 0, n = Cx.length; e < n; e++) {
                            const n = Cx[e];
                            n.instanceId = i,
                            n.object = this,
                            t.push(n)
                        }
                        Cx.length = 0
                    }
            }
            setColorAt(e, t) {
                null === this.instanceColor && (this.instanceColor = new wx(new Float32Array(3 * this.instanceMatrix.count),3)),
                t.toArray(this.instanceColor.array, 3 * e)
            }
            setMatrixAt(e, t) {
                t.toArray(this.instanceMatrix.array, 16 * e)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        function Lx(e, t) {
            return e.z - t.z
        }
        function kx(e, t) {
            return t.z - e.z
        }
        class Dx {
            constructor() {
                this.index = 0,
                this.pool = [],
                this.list = []
            }
            push(e, t) {
                const n = this.pool
                  , r = this.list;
                this.index >= n.length && n.push({
                    start: -1,
                    count: -1,
                    z: -1
                });
                const i = n[this.index];
                r.push(i),
                this.index++,
                i.start = e.start,
                i.count = e.count,
                i.z = t
            }
            reset() {
                this.list.length = 0,
                this.index = 0
            }
        }
        const Ox = "batchId"
          , Nx = new Qg
          , Fx = new Qg
          , Ux = new Qg
          , zx = new Qg
          , Gx = new $y
          , Hx = new wg
          , jx = new Hg
          , Wx = new Ag
          , Vx = new Dx
          , Xx = new Ly
          , Jx = [];
        function Kx(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            const r = t.itemSize;
            if (e.isInterleavedBufferAttribute || e.array.constructor !== t.array.constructor) {
                const i = e.count;
                for (let o = 0; o < i; o++)
                    for (let i = 0; i < r; i++)
                        t.setComponent(o + n, i, e.getComponent(o, i))
            } else
                t.array.set(e.array, n * r);
            t.needsUpdate = !0
        }
        class qx extends Ly {
            get maxGeometryCount() {
                return this._maxGeometryCount
            }
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2 * t
                  , r = arguments.length > 3 ? arguments[3] : void 0;
                super(new my, r),
                this.isBatchedMesh = !0,
                this.perObjectFrustumCulled = !0,
                this.sortObjects = !0,
                this.boundingBox = null,
                this.boundingSphere = null,
                this.customSort = null,
                this._drawRanges = [],
                this._reservedRanges = [],
                this._visibility = [],
                this._active = [],
                this._bounds = [],
                this._maxGeometryCount = e,
                this._maxVertexCount = t,
                this._maxIndexCount = n,
                this._geometryInitialized = !1,
                this._geometryCount = 0,
                this._multiDrawCounts = new Int32Array(e),
                this._multiDrawStarts = new Int32Array(e),
                this._multiDrawCount = 0,
                this._visibilityChanged = !0,
                this._matricesTexture = null,
                this._initMatricesTexture()
            }
            _initMatricesTexture() {
                let e = Math.sqrt(4 * this._maxGeometryCount);
                e = 4 * Math.ceil(e / 4),
                e = Math.max(e, 4);
                const t = new Float32Array(e * e * 4)
                  , n = new _x(t,e,e,Mp,_p);
                this._matricesTexture = n
            }
            _initializeGeometry(e) {
                const t = this.geometry
                  , n = this._maxVertexCount
                  , r = this._maxGeometryCount
                  , i = this._maxIndexCount;
                if (!1 === this._geometryInitialized) {
                    for (const r in e.attributes) {
                        const i = e.getAttribute(r)
                          , {array: o, itemSize: a, normalized: s} = i
                          , l = new o.constructor(n * a)
                          , c = new i.constructor(l,a,s);
                        c.setUsage(i.usage),
                        t.setAttribute(r, c)
                    }
                    if (null !== e.getIndex()) {
                        const e = n > 65536 ? new Uint32Array(i) : new Uint16Array(i);
                        t.setIndex(new Qv(e,1))
                    }
                    const o = r > 65536 ? new Uint32Array(n) : new Uint16Array(n);
                    t.setAttribute(Ox, new Qv(o,1)),
                    this._geometryInitialized = !0
                }
            }
            _validateGeometry(e) {
                if (e.getAttribute(Ox))
                    throw new Error(`BatchedMesh: Geometry cannot use attribute "${Ox}"`);
                const t = this.geometry;
                if (Boolean(e.getIndex()) !== Boolean(t.getIndex()))
                    throw new Error('BatchedMesh: All geometries must consistently have "index".');
                for (const n in t.attributes) {
                    if (n === Ox)
                        continue;
                    if (!e.hasAttribute(n))
                        throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
                    const r = e.getAttribute(n)
                      , i = t.getAttribute(n);
                    if (r.itemSize !== i.itemSize || r.normalized !== i.normalized)
                        throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
                }
            }
            setCustomSort(e) {
                return this.customSort = e,
                this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new wg);
                const e = this._geometryCount
                  , t = this.boundingBox
                  , n = this._active;
                t.makeEmpty();
                for (let r = 0; r < e; r++)
                    !1 !== n[r] && (this.getMatrixAt(r, Nx),
                    this.getBoundingBoxAt(r, Hx).applyMatrix4(Nx),
                    t.union(Hx))
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Hg);
                const e = this._geometryCount
                  , t = this.boundingSphere
                  , n = this._active;
                t.makeEmpty();
                for (let r = 0; r < e; r++)
                    !1 !== n[r] && (this.getMatrixAt(r, Nx),
                    this.getBoundingSphereAt(r, jx).applyMatrix4(Nx),
                    t.union(jx))
            }
            addGeometry(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1;
                if (this._initializeGeometry(e),
                this._validateGeometry(e),
                this._geometryCount >= this._maxGeometryCount)
                    throw new Error("BatchedMesh: Maximum geometry count reached.");
                const r = {
                    vertexStart: -1,
                    vertexCount: -1,
                    indexStart: -1,
                    indexCount: -1
                };
                let i = null;
                const o = this._reservedRanges
                  , a = this._drawRanges
                  , s = this._bounds;
                0 !== this._geometryCount && (i = o[o.length - 1]),
                r.vertexCount = -1 === t ? e.getAttribute("position").count : t,
                r.vertexStart = null === i ? 0 : i.vertexStart + i.vertexCount;
                const l = e.getIndex()
                  , c = null !== l;
                if (c && (r.indexCount = -1 === n ? l.count : n,
                r.indexStart = null === i ? 0 : i.indexStart + i.indexCount),
                -1 !== r.indexStart && r.indexStart + r.indexCount > this._maxIndexCount || r.vertexStart + r.vertexCount > this._maxVertexCount)
                    throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
                const u = this._visibility
                  , d = this._active
                  , h = this._matricesTexture
                  , p = this._matricesTexture.image.data;
                u.push(!0),
                d.push(!0);
                const f = this._geometryCount;
                this._geometryCount++,
                Ux.toArray(p, 16 * f),
                h.needsUpdate = !0,
                o.push(r),
                a.push({
                    start: c ? r.indexStart : r.vertexStart,
                    count: -1
                }),
                s.push({
                    boxInitialized: !1,
                    box: new wg,
                    sphereInitialized: !1,
                    sphere: new Hg
                });
                const m = this.geometry.getAttribute(Ox);
                for (let g = 0; g < r.vertexCount; g++)
                    m.setX(r.vertexStart + g, f);
                return m.needsUpdate = !0,
                this.setGeometryAt(f, e),
                f
            }
            setGeometryAt(e, t) {
                if (e >= this._geometryCount)
                    throw new Error("BatchedMesh: Maximum geometry count reached.");
                this._validateGeometry(t);
                const n = this.geometry
                  , r = null !== n.getIndex()
                  , i = n.getIndex()
                  , o = t.getIndex()
                  , a = this._reservedRanges[e];
                if (r && o.count > a.indexCount || t.attributes.position.count > a.vertexCount)
                    throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
                const s = a.vertexStart
                  , l = a.vertexCount;
                for (const h in n.attributes) {
                    if (h === Ox)
                        continue;
                    const e = t.getAttribute(h)
                      , r = n.getAttribute(h);
                    Kx(e, r, s);
                    const i = e.itemSize;
                    for (let t = e.count, n = l; t < n; t++) {
                        const e = s + t;
                        for (let t = 0; t < i; t++)
                            r.setComponent(e, t, 0)
                    }
                    r.needsUpdate = !0
                }
                if (r) {
                    const e = a.indexStart;
                    for (let t = 0; t < o.count; t++)
                        i.setX(e + t, s + o.getX(t));
                    for (let t = o.count, n = a.indexCount; t < n; t++)
                        i.setX(e + t, s);
                    i.needsUpdate = !0
                }
                const c = this._bounds[e];
                null !== t.boundingBox ? (c.box.copy(t.boundingBox),
                c.boxInitialized = !0) : c.boxInitialized = !1,
                null !== t.boundingSphere ? (c.sphere.copy(t.boundingSphere),
                c.sphereInitialized = !0) : c.sphereInitialized = !1;
                const u = this._drawRanges[e]
                  , d = t.getAttribute("position");
                return u.count = r ? o.count : d.count,
                this._visibilityChanged = !0,
                e
            }
            deleteGeometry(e) {
                const t = this._active;
                return e >= t.length || !1 === t[e] || (t[e] = !1,
                this._visibilityChanged = !0),
                this
            }
            getBoundingBoxAt(e, t) {
                if (!1 === this._active[e])
                    return this;
                const n = this._bounds[e]
                  , r = n.box
                  , i = this.geometry;
                if (!1 === n.boxInitialized) {
                    r.makeEmpty();
                    const t = i.index
                      , o = i.attributes.position
                      , a = this._drawRanges[e];
                    for (let e = a.start, n = a.start + a.count; e < n; e++) {
                        let n = e;
                        t && (n = t.getX(n)),
                        r.expandByPoint(Wx.fromBufferAttribute(o, n))
                    }
                    n.boxInitialized = !0
                }
                return t.copy(r),
                t
            }
            getBoundingSphereAt(e, t) {
                if (!1 === this._active[e])
                    return this;
                const n = this._bounds[e]
                  , r = n.sphere
                  , i = this.geometry;
                if (!1 === n.sphereInitialized) {
                    r.makeEmpty(),
                    this.getBoundingBoxAt(e, Hx),
                    Hx.getCenter(r.center);
                    const t = i.index
                      , o = i.attributes.position
                      , a = this._drawRanges[e];
                    let s = 0;
                    for (let e = a.start, n = a.start + a.count; e < n; e++) {
                        let n = e;
                        t && (n = t.getX(n)),
                        Wx.fromBufferAttribute(o, n),
                        s = Math.max(s, r.center.distanceToSquared(Wx))
                    }
                    r.radius = Math.sqrt(s),
                    n.sphereInitialized = !0
                }
                return t.copy(r),
                t
            }
            setMatrixAt(e, t) {
                const n = this._active
                  , r = this._matricesTexture
                  , i = this._matricesTexture.image.data;
                return e >= this._geometryCount || !1 === n[e] || (t.toArray(i, 16 * e),
                r.needsUpdate = !0),
                this
            }
            getMatrixAt(e, t) {
                const n = this._active
                  , r = this._matricesTexture.image.data;
                return e >= this._geometryCount || !1 === n[e] ? null : t.fromArray(r, 16 * e)
            }
            setVisibleAt(e, t) {
                const n = this._visibility
                  , r = this._active;
                return e >= this._geometryCount || !1 === r[e] || n[e] === t || (n[e] = t,
                this._visibilityChanged = !0),
                this
            }
            getVisibleAt(e) {
                const t = this._visibility
                  , n = this._active;
                return !(e >= this._geometryCount || !1 === n[e]) && t[e]
            }
            raycast(e, t) {
                const n = this._visibility
                  , r = this._active
                  , i = this._drawRanges
                  , o = this._geometryCount
                  , a = this.matrixWorld
                  , s = this.geometry;
                Xx.material = this.material,
                Xx.geometry.index = s.index,
                Xx.geometry.attributes = s.attributes,
                null === Xx.geometry.boundingBox && (Xx.geometry.boundingBox = new wg),
                null === Xx.geometry.boundingSphere && (Xx.geometry.boundingSphere = new Hg);
                for (let l = 0; l < o; l++) {
                    if (!n[l] || !r[l])
                        continue;
                    const o = i[l];
                    Xx.geometry.setDrawRange(o.start, o.count),
                    this.getMatrixAt(l, Xx.matrixWorld).premultiply(a),
                    this.getBoundingBoxAt(l, Xx.geometry.boundingBox),
                    this.getBoundingSphereAt(l, Xx.geometry.boundingSphere),
                    Xx.raycast(e, Jx);
                    for (let e = 0, n = Jx.length; e < n; e++) {
                        const n = Jx[e];
                        n.object = this,
                        n.batchId = l,
                        t.push(n)
                    }
                    Jx.length = 0
                }
                Xx.material = null,
                Xx.geometry.index = null,
                Xx.geometry.attributes = {},
                Xx.geometry.setDrawRange(0, 1 / 0)
            }
            copy(e) {
                return super.copy(e),
                this.geometry = e.geometry.clone(),
                this.perObjectFrustumCulled = e.perObjectFrustumCulled,
                this.sortObjects = e.sortObjects,
                this.boundingBox = null !== e.boundingBox ? e.boundingBox.clone() : null,
                this.boundingSphere = null !== e.boundingSphere ? e.boundingSphere.clone() : null,
                this._drawRanges = e._drawRanges.map((e => ({
                    ...e
                }))),
                this._reservedRanges = e._reservedRanges.map((e => ({
                    ...e
                }))),
                this._visibility = e._visibility.slice(),
                this._active = e._active.slice(),
                this._bounds = e._bounds.map((e => ({
                    boxInitialized: e.boxInitialized,
                    box: e.box.clone(),
                    sphereInitialized: e.sphereInitialized,
                    sphere: e.sphere.clone()
                }))),
                this._maxGeometryCount = e._maxGeometryCount,
                this._maxVertexCount = e._maxVertexCount,
                this._maxIndexCount = e._maxIndexCount,
                this._geometryInitialized = e._geometryInitialized,
                this._geometryCount = e._geometryCount,
                this._multiDrawCounts = e._multiDrawCounts.slice(),
                this._multiDrawStarts = e._multiDrawStarts.slice(),
                this._matricesTexture = e._matricesTexture.clone(),
                this._matricesTexture.image.data = this._matricesTexture.image.slice(),
                this
            }
            dispose() {
                return this.geometry.dispose(),
                this._matricesTexture.dispose(),
                this._matricesTexture = null,
                this
            }
            onBeforeRender(e, t, n, r, i) {
                if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
                    return;
                const o = r.getIndex()
                  , a = null === o ? 1 : o.array.BYTES_PER_ELEMENT
                  , s = this._visibility
                  , l = this._multiDrawStarts
                  , c = this._multiDrawCounts
                  , u = this._drawRanges
                  , d = this.perObjectFrustumCulled;
                d && (zx.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld),
                Gx.setFromProjectionMatrix(zx, e.isWebGPURenderer ? Cm : Mm));
                let h = 0;
                if (this.sortObjects) {
                    Fx.copy(this.matrixWorld).invert(),
                    Wx.setFromMatrixPosition(n.matrixWorld).applyMatrix4(Fx);
                    for (let n = 0, r = s.length; n < r; n++)
                        if (s[n]) {
                            this.getMatrixAt(n, Nx),
                            this.getBoundingSphereAt(n, jx).applyMatrix4(Nx);
                            let e = !1;
                            if (d && (e = !Gx.intersectsSphere(jx)),
                            !e) {
                                const e = Wx.distanceTo(jx.center);
                                Vx.push(u[n], e)
                            }
                        }
                    const e = Vx.list
                      , t = this.customSort;
                    null === t ? e.sort(i.transparent ? kx : Lx) : t.call(this, e, n);
                    for (let n = 0, r = e.length; n < r; n++) {
                        const t = e[n];
                        l[h] = t.start * a,
                        c[h] = t.count,
                        h++
                    }
                    Vx.reset()
                } else
                    for (let p = 0, f = s.length; p < f; p++)
                        if (s[p]) {
                            let e = !1;
                            if (d && (this.getMatrixAt(p, Nx),
                            this.getBoundingSphereAt(p, jx).applyMatrix4(Nx),
                            e = !Gx.intersectsSphere(jx)),
                            !e) {
                                const e = u[p];
                                l[h] = e.start * a,
                                c[h] = e.count,
                                h++
                            }
                        }
                this._multiDrawCount = h,
                this._visibilityChanged = !1
            }
            onBeforeShadow(e, t, n, r, i, o) {
                this.onBeforeRender(e, null, r, i, o)
            }
        }
        class Yx extends Hv {
            constructor(e) {
                super(),
                this.isLineBasicMaterial = !0,
                this.type = "LineBasicMaterial",
                this.color = new Uv(16777215),
                this.map = null,
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.linewidth = e.linewidth,
                this.linecap = e.linecap,
                this.linejoin = e.linejoin,
                this.fog = e.fog,
                this
            }
        }
        const Qx = new Ag
          , Zx = new Ag
          , $x = new Qg
          , eS = new Yg
          , tS = new Hg;
        class nS extends xv {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new my
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Yx;
                super(),
                this.isLine = !0,
                this.type = "Line",
                this.geometry = e,
                this.material = t,
                this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                this.geometry = e.geometry,
                this
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position
                      , n = [0];
                    for (let e = 1, r = t.count; e < r; e++)
                        Qx.fromBufferAttribute(t, e - 1),
                        Zx.fromBufferAttribute(t, e),
                        n[e] = n[e - 1],
                        n[e] += Qx.distanceTo(Zx);
                    e.setAttribute("lineDistance", new ay(n,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(e, t) {
                const n = this.geometry
                  , r = this.matrixWorld
                  , i = e.params.Line.threshold
                  , o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                tS.copy(n.boundingSphere),
                tS.applyMatrix4(r),
                tS.radius += i,
                !1 === e.ray.intersectsSphere(tS))
                    return;
                $x.copy(r).invert(),
                eS.copy(e.ray).applyMatrix4($x);
                const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , s = a * a
                  , l = new Ag
                  , c = new Ag
                  , u = new Ag
                  , d = new Ag
                  , h = this.isLineSegments ? 2 : 1
                  , p = n.index
                  , f = n.attributes.position;
                if (null !== p) {
                    for (let n = Math.max(0, o.start), r = Math.min(p.count, o.start + o.count) - 1; n < r; n += h) {
                        const r = p.getX(n)
                          , i = p.getX(n + 1);
                        l.fromBufferAttribute(f, r),
                        c.fromBufferAttribute(f, i);
                        if (eS.distanceSqToSegment(l, c, d, u) > s)
                            continue;
                        d.applyMatrix4(this.matrixWorld);
                        const o = e.ray.origin.distanceTo(d);
                        o < e.near || o > e.far || t.push({
                            distance: o,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                } else {
                    for (let n = Math.max(0, o.start), r = Math.min(f.count, o.start + o.count) - 1; n < r; n += h) {
                        l.fromBufferAttribute(f, n),
                        c.fromBufferAttribute(f, n + 1);
                        if (eS.distanceSqToSegment(l, c, d, u) > s)
                            continue;
                        d.applyMatrix4(this.matrixWorld);
                        const r = e.ray.origin.distanceTo(d);
                        r < e.near || r > e.far || t.push({
                            distance: r,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes
                  , t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }
        const rS = new Ag
          , iS = new Ag;
        class oS extends nS {
            constructor(e, t) {
                super(e, t),
                this.isLineSegments = !0,
                this.type = "LineSegments"
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position
                      , n = [];
                    for (let e = 0, r = t.count; e < r; e += 2)
                        rS.fromBufferAttribute(t, e),
                        iS.fromBufferAttribute(t, e + 1),
                        n[e] = 0 === e ? 0 : n[e - 1],
                        n[e + 1] = n[e] + rS.distanceTo(iS);
                    e.setAttribute("lineDistance", new ay(n,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class aS extends nS {
            constructor(e, t) {
                super(e, t),
                this.isLineLoop = !0,
                this.type = "LineLoop"
            }
        }
        class sS extends Hv {
            constructor(e) {
                super(),
                this.isPointsMaterial = !0,
                this.type = "PointsMaterial",
                this.color = new Uv(16777215),
                this.map = null,
                this.alphaMap = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.size = e.size,
                this.sizeAttenuation = e.sizeAttenuation,
                this.fog = e.fog,
                this
            }
        }
        const lS = new Qg
          , cS = new Yg
          , uS = new Hg
          , dS = new Ag;
        class hS extends xv {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new my
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new sS;
                super(),
                this.isPoints = !0,
                this.type = "Points",
                this.geometry = e,
                this.material = t,
                this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                this.geometry = e.geometry,
                this
            }
            raycast(e, t) {
                const n = this.geometry
                  , r = this.matrixWorld
                  , i = e.params.Points.threshold
                  , o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                uS.copy(n.boundingSphere),
                uS.applyMatrix4(r),
                uS.radius += i,
                !1 === e.ray.intersectsSphere(uS))
                    return;
                lS.copy(r).invert(),
                cS.copy(e.ray).applyMatrix4(lS);
                const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , s = a * a
                  , l = n.index
                  , c = n.attributes.position;
                if (null !== l) {
                    for (let n = Math.max(0, o.start), i = Math.min(l.count, o.start + o.count); n < i; n++) {
                        const i = l.getX(n);
                        dS.fromBufferAttribute(c, i),
                        pS(dS, i, s, r, e, t, this)
                    }
                } else {
                    for (let n = Math.max(0, o.start), i = Math.min(c.count, o.start + o.count); n < i; n++)
                        dS.fromBufferAttribute(c, n),
                        pS(dS, n, s, r, e, t, this)
                }
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes
                  , t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }
        function pS(e, t, n, r, i, o, a) {
            const s = cS.distanceSqToPoint(e);
            if (s < n) {
                const n = new Ag;
                cS.closestPointToPoint(e, n),
                n.applyMatrix4(r);
                const l = i.ray.origin.distanceTo(n);
                if (l < i.near || l > i.far)
                    return;
                o.push({
                    distance: l,
                    distanceToRay: Math.sqrt(s),
                    point: n,
                    index: t,
                    face: null,
                    object: a
                })
            }
        }
        class fS extends dg {
            constructor(e, t, n, r, i, o, a, s, l) {
                super(e, t, n, r, i, o, a, s, l),
                this.isVideoTexture = !0,
                this.minFilter = void 0 !== o ? o : cp,
                this.magFilter = void 0 !== i ? i : cp,
                this.generateMipmaps = !1;
                const c = this;
                "requestVideoFrameCallback"in e && e.requestVideoFrameCallback((function t() {
                    c.needsUpdate = !0,
                    e.requestVideoFrameCallback(t)
                }
                ))
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const e = this.image;
                !1 === "requestVideoFrameCallback"in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        class mS extends dg {
            constructor(e, t) {
                super({
                    width: e,
                    height: t
                }),
                this.isFramebufferTexture = !0,
                this.magFilter = ip,
                this.minFilter = ip,
                this.generateMipmaps = !1,
                this.needsUpdate = !0
            }
        }
        class gS extends dg {
            constructor(e, t, n, r, i, o, a, s, l, c, u, d) {
                super(null, o, a, s, l, c, r, i, u, d),
                this.isCompressedTexture = !0,
                this.image = {
                    width: t,
                    height: n
                },
                this.mipmaps = e,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        class vS extends gS {
            constructor(e, t, n, r, i, o) {
                super(e, t, n, i, o),
                this.isCompressedArrayTexture = !0,
                this.image.depth = r,
                this.wrapR = np
            }
        }
        class yS extends gS {
            constructor(e, t, n) {
                super(void 0, e[0].width, e[0].height, t, n, Yh),
                this.isCompressedCubeTexture = !0,
                this.isCubeTexture = !0,
                this.image = e
            }
        }
        class bS extends dg {
            constructor(e, t, n, r, i, o, a, s, l) {
                super(e, t, n, r, i, o, a, s, l),
                this.isCanvasTexture = !0,
                this.needsUpdate = !0
            }
        }
        class _S {
            constructor() {
                this.type = "Curve",
                this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."),
                null
            }
            getPointAt(e, t) {
                const n = this.getUtoTmapping(e);
                return this.getPoint(n, t)
            }
            getPoints() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5;
                const t = [];
                for (let n = 0; n <= e; n++)
                    t.push(this.getPoint(n / e));
                return t
            }
            getSpacedPoints() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5;
                const t = [];
                for (let n = 0; n <= e; n++)
                    t.push(this.getPointAt(n / e));
                return t
            }
            getLength() {
                const e = this.getLengths();
                return e[e.length - 1]
            }
            getLengths() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.arcLengthDivisions;
                if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                    return this.cacheArcLengths;
                this.needsUpdate = !1;
                const t = [];
                let n, r = this.getPoint(0), i = 0;
                t.push(0);
                for (let o = 1; o <= e; o++)
                    n = this.getPoint(o / e),
                    i += n.distanceTo(r),
                    t.push(i),
                    r = n;
                return this.cacheArcLengths = t,
                t
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.getLengths()
            }
            getUtoTmapping(e, t) {
                const n = this.getLengths();
                let r = 0;
                const i = n.length;
                let o;
                o = t || e * n[i - 1];
                let a, s = 0, l = i - 1;
                for (; s <= l; )
                    if (r = Math.floor(s + (l - s) / 2),
                    a = n[r] - o,
                    a < 0)
                        s = r + 1;
                    else {
                        if (!(a > 0)) {
                            l = r;
                            break
                        }
                        l = r - 1
                    }
                if (r = l,
                n[r] === o)
                    return r / (i - 1);
                const c = n[r];
                return (r + (o - c) / (n[r + 1] - c)) / (i - 1)
            }
            getTangent(e, t) {
                const n = 1e-4;
                let r = e - n
                  , i = e + n;
                r < 0 && (r = 0),
                i > 1 && (i = 1);
                const o = this.getPoint(r)
                  , a = this.getPoint(i)
                  , s = t || (o.isVector2 ? new Hm : new Ag);
                return s.copy(a).sub(o).normalize(),
                s
            }
            getTangentAt(e, t) {
                const n = this.getUtoTmapping(e);
                return this.getTangent(n, t)
            }
            computeFrenetFrames(e, t) {
                const n = new Ag
                  , r = []
                  , i = []
                  , o = []
                  , a = new Ag
                  , s = new Qg;
                for (let h = 0; h <= e; h++) {
                    const t = h / e;
                    r[h] = this.getTangentAt(t, new Ag)
                }
                i[0] = new Ag,
                o[0] = new Ag;
                let l = Number.MAX_VALUE;
                const c = Math.abs(r[0].x)
                  , u = Math.abs(r[0].y)
                  , d = Math.abs(r[0].z);
                c <= l && (l = c,
                n.set(1, 0, 0)),
                u <= l && (l = u,
                n.set(0, 1, 0)),
                d <= l && n.set(0, 0, 1),
                a.crossVectors(r[0], n).normalize(),
                i[0].crossVectors(r[0], a),
                o[0].crossVectors(r[0], i[0]);
                for (let h = 1; h <= e; h++) {
                    if (i[h] = i[h - 1].clone(),
                    o[h] = o[h - 1].clone(),
                    a.crossVectors(r[h - 1], r[h]),
                    a.length() > Number.EPSILON) {
                        a.normalize();
                        const e = Math.acos(km(r[h - 1].dot(r[h]), -1, 1));
                        i[h].applyMatrix4(s.makeRotationAxis(a, e))
                    }
                    o[h].crossVectors(r[h], i[h])
                }
                if (!0 === t) {
                    let t = Math.acos(km(i[0].dot(i[e]), -1, 1));
                    t /= e,
                    r[0].dot(a.crossVectors(i[0], i[e])) > 0 && (t = -t);
                    for (let n = 1; n <= e; n++)
                        i[n].applyMatrix4(s.makeRotationAxis(r[n], t * n)),
                        o[n].crossVectors(r[n], i[n])
                }
                return {
                    tangents: r,
                    normals: i,
                    binormals: o
                }
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions,
                this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return e.arcLengthDivisions = this.arcLengthDivisions,
                e.type = this.type,
                e
            }
            fromJSON(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions,
                this
            }
        }
        class AS extends _S {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0
                  , o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2 * Math.PI
                  , a = arguments.length > 6 && void 0 !== arguments[6] && arguments[6]
                  , s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0;
                super(),
                this.isEllipseCurve = !0,
                this.type = "EllipseCurve",
                this.aX = e,
                this.aY = t,
                this.xRadius = n,
                this.yRadius = r,
                this.aStartAngle = i,
                this.aEndAngle = o,
                this.aClockwise = a,
                this.aRotation = s
            }
            getPoint(e, t) {
                const n = t || new Hm
                  , r = 2 * Math.PI;
                let i = this.aEndAngle - this.aStartAngle;
                const o = Math.abs(i) < Number.EPSILON;
                for (; i < 0; )
                    i += r;
                for (; i > r; )
                    i -= r;
                i < Number.EPSILON && (i = o ? 0 : r),
                !0 !== this.aClockwise || o || (i === r ? i = -r : i -= r);
                const a = this.aStartAngle + e * i;
                let s = this.aX + this.xRadius * Math.cos(a)
                  , l = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    const e = Math.cos(this.aRotation)
                      , t = Math.sin(this.aRotation)
                      , n = s - this.aX
                      , r = l - this.aY;
                    s = n * e - r * t + this.aX,
                    l = n * t + r * e + this.aY
                }
                return n.set(s, l)
            }
            copy(e) {
                return super.copy(e),
                this.aX = e.aX,
                this.aY = e.aY,
                this.xRadius = e.xRadius,
                this.yRadius = e.yRadius,
                this.aStartAngle = e.aStartAngle,
                this.aEndAngle = e.aEndAngle,
                this.aClockwise = e.aClockwise,
                this.aRotation = e.aRotation,
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.aX = this.aX,
                e.aY = this.aY,
                e.xRadius = this.xRadius,
                e.yRadius = this.yRadius,
                e.aStartAngle = this.aStartAngle,
                e.aEndAngle = this.aEndAngle,
                e.aClockwise = this.aClockwise,
                e.aRotation = this.aRotation,
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.aX = e.aX,
                this.aY = e.aY,
                this.xRadius = e.xRadius,
                this.yRadius = e.yRadius,
                this.aStartAngle = e.aStartAngle,
                this.aEndAngle = e.aEndAngle,
                this.aClockwise = e.aClockwise,
                this.aRotation = e.aRotation,
                this
            }
        }
        class xS extends AS {
            constructor(e, t, n, r, i, o) {
                super(e, t, n, n, r, i, o),
                this.isArcCurve = !0,
                this.type = "ArcCurve"
            }
        }
        function SS() {
            let e = 0
              , t = 0
              , n = 0
              , r = 0;
            function i(i, o, a, s) {
                e = i,
                t = a,
                n = -3 * i + 3 * o - 2 * a - s,
                r = 2 * i - 2 * o + a + s
            }
            return {
                initCatmullRom: function(e, t, n, r, o) {
                    i(t, n, o * (n - e), o * (r - t))
                },
                initNonuniformCatmullRom: function(e, t, n, r, o, a, s) {
                    let l = (t - e) / o - (n - e) / (o + a) + (n - t) / a
                      , c = (n - t) / a - (r - t) / (a + s) + (r - n) / s;
                    l *= a,
                    c *= a,
                    i(t, n, l, c)
                },
                calc: function(i) {
                    const o = i * i;
                    return e + t * i + n * o + r * (o * i)
                }
            }
        }
        const wS = new Ag
          , ES = new SS
          , MS = new SS
          , CS = new SS;
        class TS extends _S {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "centripetal"
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
                super(),
                this.isCatmullRomCurve3 = !0,
                this.type = "CatmullRomCurve3",
                this.points = e,
                this.closed = t,
                this.curveType = n,
                this.tension = r
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ag
                  , n = this.points
                  , r = n.length
                  , i = (r - (this.closed ? 0 : 1)) * e;
                let o, a, s = Math.floor(i), l = i - s;
                this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / r) + 1) * r : 0 === l && s === r - 1 && (s = r - 2,
                l = 1),
                this.closed || s > 0 ? o = n[(s - 1) % r] : (wS.subVectors(n[0], n[1]).add(n[0]),
                o = wS);
                const c = n[s % r]
                  , u = n[(s + 1) % r];
                if (this.closed || s + 2 < r ? a = n[(s + 2) % r] : (wS.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]),
                a = wS),
                "centripetal" === this.curveType || "chordal" === this.curveType) {
                    const e = "chordal" === this.curveType ? .5 : .25;
                    let t = Math.pow(o.distanceToSquared(c), e)
                      , n = Math.pow(c.distanceToSquared(u), e)
                      , r = Math.pow(u.distanceToSquared(a), e);
                    n < 1e-4 && (n = 1),
                    t < 1e-4 && (t = n),
                    r < 1e-4 && (r = n),
                    ES.initNonuniformCatmullRom(o.x, c.x, u.x, a.x, t, n, r),
                    MS.initNonuniformCatmullRom(o.y, c.y, u.y, a.y, t, n, r),
                    CS.initNonuniformCatmullRom(o.z, c.z, u.z, a.z, t, n, r)
                } else
                    "catmullrom" === this.curveType && (ES.initCatmullRom(o.x, c.x, u.x, a.x, this.tension),
                    MS.initCatmullRom(o.y, c.y, u.y, a.y, this.tension),
                    CS.initCatmullRom(o.z, c.z, u.z, a.z, this.tension));
                return t.set(ES.calc(l), MS.calc(l), CS.calc(l)),
                t
            }
            copy(e) {
                super.copy(e),
                this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push(n.clone())
                }
                return this.closed = e.closed,
                this.curveType = e.curveType,
                this.tension = e.tension,
                this
            }
            toJSON() {
                const e = super.toJSON();
                e.points = [];
                for (let t = 0, n = this.points.length; t < n; t++) {
                    const n = this.points[t];
                    e.points.push(n.toArray())
                }
                return e.closed = this.closed,
                e.curveType = this.curveType,
                e.tension = this.tension,
                e
            }
            fromJSON(e) {
                super.fromJSON(e),
                this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push((new Ag).fromArray(n))
                }
                return this.closed = e.closed,
                this.curveType = e.curveType,
                this.tension = e.tension,
                this
            }
        }
        function RS(e, t, n, r, i) {
            const o = .5 * (r - t)
              , a = .5 * (i - n)
              , s = e * e;
            return (2 * n - 2 * r + o + a) * (e * s) + (-3 * n + 3 * r - 2 * o - a) * s + o * e + n
        }
        function PS(e, t, n, r) {
            return function(e, t) {
                const n = 1 - e;
                return n * n * t
            }(e, t) + function(e, t) {
                return 2 * (1 - e) * e * t
            }(e, n) + function(e, t) {
                return e * e * t
            }(e, r)
        }
        function BS(e, t, n, r, i) {
            return function(e, t) {
                const n = 1 - e;
                return n * n * n * t
            }(e, t) + function(e, t) {
                const n = 1 - e;
                return 3 * n * n * e * t
            }(e, n) + function(e, t) {
                return 3 * (1 - e) * e * e * t
            }(e, r) + function(e, t) {
                return e * e * e * t
            }(e, i)
        }
        class IS extends _S {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Hm
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Hm
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Hm
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new Hm;
                super(),
                this.isCubicBezierCurve = !0,
                this.type = "CubicBezierCurve",
                this.v0 = e,
                this.v1 = t,
                this.v2 = n,
                this.v3 = r
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Hm
                  , n = this.v0
                  , r = this.v1
                  , i = this.v2
                  , o = this.v3;
                return t.set(BS(e, n.x, r.x, i.x, o.x), BS(e, n.y, r.y, i.y, o.y)),
                t
            }
            copy(e) {
                return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this.v3.copy(e.v3),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e.v3 = this.v3.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this.v3.fromArray(e.v3),
                this
            }
        }
        class LS extends _S {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Ag
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ag
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Ag
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new Ag;
                super(),
                this.isCubicBezierCurve3 = !0,
                this.type = "CubicBezierCurve3",
                this.v0 = e,
                this.v1 = t,
                this.v2 = n,
                this.v3 = r
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ag
                  , n = this.v0
                  , r = this.v1
                  , i = this.v2
                  , o = this.v3;
                return t.set(BS(e, n.x, r.x, i.x, o.x), BS(e, n.y, r.y, i.y, o.y), BS(e, n.z, r.z, i.z, o.z)),
                t
            }
            copy(e) {
                return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this.v3.copy(e.v3),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e.v3 = this.v3.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this.v3.fromArray(e.v3),
                this
            }
        }
        class kS extends _S {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Hm
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Hm;
                super(),
                this.isLineCurve = !0,
                this.type = "LineCurve",
                this.v1 = e,
                this.v2 = t
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Hm;
                return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1),
                t.multiplyScalar(e).add(this.v1)),
                t
            }
            getPointAt(e, t) {
                return this.getPoint(e, t)
            }
            getTangent(e) {
                return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Hm).subVectors(this.v2, this.v1).normalize()
            }
            getTangentAt(e, t) {
                return this.getTangent(e, t)
            }
            copy(e) {
                return super.copy(e),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
        }
        class DS extends _S {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Ag
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ag;
                super(),
                this.isLineCurve3 = !0,
                this.type = "LineCurve3",
                this.v1 = e,
                this.v2 = t
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ag;
                return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1),
                t.multiplyScalar(e).add(this.v1)),
                t
            }
            getPointAt(e, t) {
                return this.getPoint(e, t)
            }
            getTangent(e) {
                return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ag).subVectors(this.v2, this.v1).normalize()
            }
            getTangentAt(e, t) {
                return this.getTangent(e, t)
            }
            copy(e) {
                return super.copy(e),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
        }
        class OS extends _S {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Hm
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Hm
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Hm;
                super(),
                this.isQuadraticBezierCurve = !0,
                this.type = "QuadraticBezierCurve",
                this.v0 = e,
                this.v1 = t,
                this.v2 = n
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Hm
                  , n = this.v0
                  , r = this.v1
                  , i = this.v2;
                return t.set(PS(e, n.x, r.x, i.x), PS(e, n.y, r.y, i.y)),
                t
            }
            copy(e) {
                return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
        }
        class NS extends _S {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Ag
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ag
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Ag;
                super(),
                this.isQuadraticBezierCurve3 = !0,
                this.type = "QuadraticBezierCurve3",
                this.v0 = e,
                this.v1 = t,
                this.v2 = n
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ag
                  , n = this.v0
                  , r = this.v1
                  , i = this.v2;
                return t.set(PS(e, n.x, r.x, i.x), PS(e, n.y, r.y, i.y), PS(e, n.z, r.z, i.z)),
                t
            }
            copy(e) {
                return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
        }
        class FS extends _S {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                super(),
                this.isSplineCurve = !0,
                this.type = "SplineCurve",
                this.points = e
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Hm
                  , n = this.points
                  , r = (n.length - 1) * e
                  , i = Math.floor(r)
                  , o = r - i
                  , a = n[0 === i ? i : i - 1]
                  , s = n[i]
                  , l = n[i > n.length - 2 ? n.length - 1 : i + 1]
                  , c = n[i > n.length - 3 ? n.length - 1 : i + 2];
                return t.set(RS(o, a.x, s.x, l.x, c.x), RS(o, a.y, s.y, l.y, c.y)),
                t
            }
            copy(e) {
                super.copy(e),
                this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push(n.clone())
                }
                return this
            }
            toJSON() {
                const e = super.toJSON();
                e.points = [];
                for (let t = 0, n = this.points.length; t < n; t++) {
                    const n = this.points[t];
                    e.points.push(n.toArray())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e),
                this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push((new Hm).fromArray(n))
                }
                return this
            }
        }
        var US = Object.freeze({
            __proto__: null,
            ArcCurve: xS,
            CatmullRomCurve3: TS,
            CubicBezierCurve: IS,
            CubicBezierCurve3: LS,
            EllipseCurve: AS,
            LineCurve: kS,
            LineCurve3: DS,
            QuadraticBezierCurve: OS,
            QuadraticBezierCurve3: NS,
            SplineCurve: FS
        });
        class zS extends _S {
            constructor() {
                super(),
                this.type = "CurvePath",
                this.curves = [],
                this.autoClose = !1
            }
            add(e) {
                this.curves.push(e)
            }
            closePath() {
                const e = this.curves[0].getPoint(0)
                  , t = this.curves[this.curves.length - 1].getPoint(1);
                if (!e.equals(t)) {
                    const n = !0 === e.isVector2 ? "LineCurve" : "LineCurve3";
                    this.curves.push(new US[n](t,e))
                }
                return this
            }
            getPoint(e, t) {
                const n = e * this.getLength()
                  , r = this.getCurveLengths();
                let i = 0;
                for (; i < r.length; ) {
                    if (r[i] >= n) {
                        const e = r[i] - n
                          , o = this.curves[i]
                          , a = o.getLength()
                          , s = 0 === a ? 0 : 1 - e / a;
                        return o.getPointAt(s, t)
                    }
                    i++
                }
                return null
            }
            getLength() {
                const e = this.getCurveLengths();
                return e[e.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.cacheLengths = null,
                this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                    return this.cacheLengths;
                const e = [];
                let t = 0;
                for (let n = 0, r = this.curves.length; n < r; n++)
                    t += this.curves[n].getLength(),
                    e.push(t);
                return this.cacheLengths = e,
                e
            }
            getSpacedPoints() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 40;
                const t = [];
                for (let n = 0; n <= e; n++)
                    t.push(this.getPoint(n / e));
                return this.autoClose && t.push(t[0]),
                t
            }
            getPoints() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 12;
                const t = [];
                let n;
                for (let r = 0, i = this.curves; r < i.length; r++) {
                    const o = i[r]
                      , a = o.isEllipseCurve ? 2 * e : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e
                      , s = o.getPoints(a);
                    for (let e = 0; e < s.length; e++) {
                        const r = s[e];
                        n && n.equals(r) || (t.push(r),
                        n = r)
                    }
                }
                return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
                t
            }
            copy(e) {
                super.copy(e),
                this.curves = [];
                for (let t = 0, n = e.curves.length; t < n; t++) {
                    const n = e.curves[t];
                    this.curves.push(n.clone())
                }
                return this.autoClose = e.autoClose,
                this
            }
            toJSON() {
                const e = super.toJSON();
                e.autoClose = this.autoClose,
                e.curves = [];
                for (let t = 0, n = this.curves.length; t < n; t++) {
                    const n = this.curves[t];
                    e.curves.push(n.toJSON())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e),
                this.autoClose = e.autoClose,
                this.curves = [];
                for (let t = 0, n = e.curves.length; t < n; t++) {
                    const n = e.curves[t];
                    this.curves.push((new US[n.type]).fromJSON(n))
                }
                return this
            }
        }
        class GS extends zS {
            constructor(e) {
                super(),
                this.type = "Path",
                this.currentPoint = new Hm,
                e && this.setFromPoints(e)
            }
            setFromPoints(e) {
                this.moveTo(e[0].x, e[0].y);
                for (let t = 1, n = e.length; t < n; t++)
                    this.lineTo(e[t].x, e[t].y);
                return this
            }
            moveTo(e, t) {
                return this.currentPoint.set(e, t),
                this
            }
            lineTo(e, t) {
                const n = new kS(this.currentPoint.clone(),new Hm(e,t));
                return this.curves.push(n),
                this.currentPoint.set(e, t),
                this
            }
            quadraticCurveTo(e, t, n, r) {
                const i = new OS(this.currentPoint.clone(),new Hm(e,t),new Hm(n,r));
                return this.curves.push(i),
                this.currentPoint.set(n, r),
                this
            }
            bezierCurveTo(e, t, n, r, i, o) {
                const a = new IS(this.currentPoint.clone(),new Hm(e,t),new Hm(n,r),new Hm(i,o));
                return this.curves.push(a),
                this.currentPoint.set(i, o),
                this
            }
            splineThru(e) {
                const t = [this.currentPoint.clone()].concat(e)
                  , n = new FS(t);
                return this.curves.push(n),
                this.currentPoint.copy(e[e.length - 1]),
                this
            }
            arc(e, t, n, r, i, o) {
                const a = this.currentPoint.x
                  , s = this.currentPoint.y;
                return this.absarc(e + a, t + s, n, r, i, o),
                this
            }
            absarc(e, t, n, r, i, o) {
                return this.absellipse(e, t, n, n, r, i, o),
                this
            }
            ellipse(e, t, n, r, i, o, a, s) {
                const l = this.currentPoint.x
                  , c = this.currentPoint.y;
                return this.absellipse(e + l, t + c, n, r, i, o, a, s),
                this
            }
            absellipse(e, t, n, r, i, o, a, s) {
                const l = new AS(e,t,n,r,i,o,a,s);
                if (this.curves.length > 0) {
                    const e = l.getPoint(0);
                    e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
                }
                this.curves.push(l);
                const c = l.getPoint(1);
                return this.currentPoint.copy(c),
                this
            }
            copy(e) {
                return super.copy(e),
                this.currentPoint.copy(e.currentPoint),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.currentPoint = this.currentPoint.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.currentPoint.fromArray(e.currentPoint),
                this
            }
        }
        class HS extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [new Hm(0,-.5), new Hm(.5,0), new Hm(0,.5)]
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 12
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2 * Math.PI;
                super(),
                this.type = "LatheGeometry",
                this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: n,
                    phiLength: r
                },
                t = Math.floor(t),
                r = km(r, 0, 2 * Math.PI);
                const i = []
                  , o = []
                  , a = []
                  , s = []
                  , l = []
                  , c = 1 / t
                  , u = new Ag
                  , d = new Hm
                  , h = new Ag
                  , p = new Ag
                  , f = new Ag;
                let m = 0
                  , g = 0;
                for (let v = 0; v <= e.length - 1; v++)
                    switch (v) {
                    case 0:
                        m = e[v + 1].x - e[v].x,
                        g = e[v + 1].y - e[v].y,
                        h.x = 1 * g,
                        h.y = -m,
                        h.z = 0 * g,
                        f.copy(h),
                        h.normalize(),
                        s.push(h.x, h.y, h.z);
                        break;
                    case e.length - 1:
                        s.push(f.x, f.y, f.z);
                        break;
                    default:
                        m = e[v + 1].x - e[v].x,
                        g = e[v + 1].y - e[v].y,
                        h.x = 1 * g,
                        h.y = -m,
                        h.z = 0 * g,
                        p.copy(h),
                        h.x += f.x,
                        h.y += f.y,
                        h.z += f.z,
                        h.normalize(),
                        s.push(h.x, h.y, h.z),
                        f.copy(p)
                    }
                for (let v = 0; v <= t; v++) {
                    const i = n + v * c * r
                      , h = Math.sin(i)
                      , p = Math.cos(i);
                    for (let n = 0; n <= e.length - 1; n++) {
                        u.x = e[n].x * h,
                        u.y = e[n].y,
                        u.z = e[n].x * p,
                        o.push(u.x, u.y, u.z),
                        d.x = v / t,
                        d.y = n / (e.length - 1),
                        a.push(d.x, d.y);
                        const r = s[3 * n + 0] * h
                          , i = s[3 * n + 1]
                          , c = s[3 * n + 0] * p;
                        l.push(r, i, c)
                    }
                }
                for (let v = 0; v < t; v++)
                    for (let t = 0; t < e.length - 1; t++) {
                        const n = t + v * e.length
                          , r = n
                          , o = n + e.length
                          , a = n + e.length + 1
                          , s = n + 1;
                        i.push(r, o, s),
                        i.push(a, s, o)
                    }
                this.setIndex(i),
                this.setAttribute("position", new ay(o,3)),
                this.setAttribute("uv", new ay(a,2)),
                this.setAttribute("normal", new ay(l,3))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new HS(e.points,e.segments,e.phiStart,e.phiLength)
            }
        }
        class jS extends HS {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 4
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8;
                const i = new GS;
                i.absarc(0, -t / 2, e, 1.5 * Math.PI, 0),
                i.absarc(0, t / 2, e, 0, .5 * Math.PI),
                super(i.getPoints(n), r),
                this.type = "CapsuleGeometry",
                this.parameters = {
                    radius: e,
                    length: t,
                    capSegments: n,
                    radialSegments: r
                }
            }
            static fromJSON(e) {
                return new jS(e.radius,e.length,e.capSegments,e.radialSegments)
            }
        }
        class WS extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 32
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2 * Math.PI;
                super(),
                this.type = "CircleGeometry",
                this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: n,
                    thetaLength: r
                },
                t = Math.max(3, t);
                const i = []
                  , o = []
                  , a = []
                  , s = []
                  , l = new Ag
                  , c = new Hm;
                o.push(0, 0, 0),
                a.push(0, 0, 1),
                s.push(.5, .5);
                for (let u = 0, d = 3; u <= t; u++,
                d += 3) {
                    const i = n + u / t * r;
                    l.x = e * Math.cos(i),
                    l.y = e * Math.sin(i),
                    o.push(l.x, l.y, l.z),
                    a.push(0, 0, 1),
                    c.x = (o[d] / e + 1) / 2,
                    c.y = (o[d + 1] / e + 1) / 2,
                    s.push(c.x, c.y)
                }
                for (let u = 1; u <= t; u++)
                    i.push(u, u + 1, 0);
                this.setIndex(i),
                this.setAttribute("position", new ay(o,3)),
                this.setAttribute("normal", new ay(a,3)),
                this.setAttribute("uv", new ay(s,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new WS(e.radius,e.segments,e.thetaStart,e.thetaLength)
            }
        }
        class VS extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 32
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1
                  , o = arguments.length > 5 && void 0 !== arguments[5] && arguments[5]
                  , a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0
                  , s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 2 * Math.PI;
                super(),
                this.type = "CylinderGeometry",
                this.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: n,
                    radialSegments: r,
                    heightSegments: i,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                };
                const l = this;
                r = Math.floor(r),
                i = Math.floor(i);
                const c = []
                  , u = []
                  , d = []
                  , h = [];
                let p = 0;
                const f = []
                  , m = n / 2;
                let g = 0;
                function v(n) {
                    const i = p
                      , o = new Hm
                      , f = new Ag;
                    let v = 0;
                    const y = !0 === n ? e : t
                      , b = !0 === n ? 1 : -1;
                    for (let e = 1; e <= r; e++)
                        u.push(0, m * b, 0),
                        d.push(0, b, 0),
                        h.push(.5, .5),
                        p++;
                    const _ = p;
                    for (let e = 0; e <= r; e++) {
                        const t = e / r * s + a
                          , n = Math.cos(t)
                          , i = Math.sin(t);
                        f.x = y * i,
                        f.y = m * b,
                        f.z = y * n,
                        u.push(f.x, f.y, f.z),
                        d.push(0, b, 0),
                        o.x = .5 * n + .5,
                        o.y = .5 * i * b + .5,
                        h.push(o.x, o.y),
                        p++
                    }
                    for (let e = 0; e < r; e++) {
                        const t = i + e
                          , r = _ + e;
                        !0 === n ? c.push(r, r + 1, t) : c.push(r + 1, r, t),
                        v += 3
                    }
                    l.addGroup(g, v, !0 === n ? 1 : 2),
                    g += v
                }
                !function() {
                    const o = new Ag
                      , v = new Ag;
                    let y = 0;
                    const b = (t - e) / n;
                    for (let l = 0; l <= i; l++) {
                        const c = []
                          , g = l / i
                          , y = g * (t - e) + e;
                        for (let e = 0; e <= r; e++) {
                            const t = e / r
                              , i = t * s + a
                              , l = Math.sin(i)
                              , f = Math.cos(i);
                            v.x = y * l,
                            v.y = -g * n + m,
                            v.z = y * f,
                            u.push(v.x, v.y, v.z),
                            o.set(l, b, f).normalize(),
                            d.push(o.x, o.y, o.z),
                            h.push(t, 1 - g),
                            c.push(p++)
                        }
                        f.push(c)
                    }
                    for (let e = 0; e < r; e++)
                        for (let t = 0; t < i; t++) {
                            const n = f[t][e]
                              , r = f[t + 1][e]
                              , i = f[t + 1][e + 1]
                              , o = f[t][e + 1];
                            c.push(n, r, o),
                            c.push(r, i, o),
                            y += 6
                        }
                    l.addGroup(g, y, 0),
                    g += y
                }(),
                !1 === o && (e > 0 && v(!0),
                t > 0 && v(!1)),
                this.setIndex(c),
                this.setAttribute("position", new ay(u,3)),
                this.setAttribute("normal", new ay(d,3)),
                this.setAttribute("uv", new ay(h,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new VS(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
            }
        }
        class XS extends VS {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1
                  , i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]
                  , o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0
                  , a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 2 * Math.PI;
                super(0, e, t, n, r, i, o, a),
                this.type = "ConeGeometry",
                this.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: i,
                    thetaStart: o,
                    thetaLength: a
                }
            }
            static fromJSON(e) {
                return new XS(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
            }
        }
        class JS extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                super(),
                this.type = "PolyhedronGeometry",
                this.parameters = {
                    vertices: e,
                    indices: t,
                    radius: n,
                    detail: r
                };
                const i = []
                  , o = [];
                function a(e, t, n, r) {
                    const i = r + 1
                      , o = [];
                    for (let a = 0; a <= i; a++) {
                        o[a] = [];
                        const r = e.clone().lerp(n, a / i)
                          , s = t.clone().lerp(n, a / i)
                          , l = i - a;
                        for (let e = 0; e <= l; e++)
                            o[a][e] = 0 === e && a === i ? r : r.clone().lerp(s, e / l)
                    }
                    for (let a = 0; a < i; a++)
                        for (let e = 0; e < 2 * (i - a) - 1; e++) {
                            const t = Math.floor(e / 2);
                            e % 2 === 0 ? (s(o[a][t + 1]),
                            s(o[a + 1][t]),
                            s(o[a][t])) : (s(o[a][t + 1]),
                            s(o[a + 1][t + 1]),
                            s(o[a + 1][t]))
                        }
                }
                function s(e) {
                    i.push(e.x, e.y, e.z)
                }
                function l(t, n) {
                    const r = 3 * t;
                    n.x = e[r + 0],
                    n.y = e[r + 1],
                    n.z = e[r + 2]
                }
                function c(e, t, n, r) {
                    r < 0 && 1 === e.x && (o[t] = e.x - 1),
                    0 === n.x && 0 === n.z && (o[t] = r / 2 / Math.PI + .5)
                }
                function u(e) {
                    return Math.atan2(e.z, -e.x)
                }
                !function(e) {
                    const n = new Ag
                      , r = new Ag
                      , i = new Ag;
                    for (let o = 0; o < t.length; o += 3)
                        l(t[o + 0], n),
                        l(t[o + 1], r),
                        l(t[o + 2], i),
                        a(n, r, i, e)
                }(r),
                function(e) {
                    const t = new Ag;
                    for (let n = 0; n < i.length; n += 3)
                        t.x = i[n + 0],
                        t.y = i[n + 1],
                        t.z = i[n + 2],
                        t.normalize().multiplyScalar(e),
                        i[n + 0] = t.x,
                        i[n + 1] = t.y,
                        i[n + 2] = t.z
                }(n),
                function() {
                    const e = new Ag;
                    for (let n = 0; n < i.length; n += 3) {
                        e.x = i[n + 0],
                        e.y = i[n + 1],
                        e.z = i[n + 2];
                        const r = u(e) / 2 / Math.PI + .5
                          , a = (t = e,
                        Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5);
                        o.push(r, 1 - a)
                    }
                    var t;
                    (function() {
                        const e = new Ag
                          , t = new Ag
                          , n = new Ag
                          , r = new Ag
                          , a = new Hm
                          , s = new Hm
                          , l = new Hm;
                        for (let d = 0, h = 0; d < i.length; d += 9,
                        h += 6) {
                            e.set(i[d + 0], i[d + 1], i[d + 2]),
                            t.set(i[d + 3], i[d + 4], i[d + 5]),
                            n.set(i[d + 6], i[d + 7], i[d + 8]),
                            a.set(o[h + 0], o[h + 1]),
                            s.set(o[h + 2], o[h + 3]),
                            l.set(o[h + 4], o[h + 5]),
                            r.copy(e).add(t).add(n).divideScalar(3);
                            const p = u(r);
                            c(a, h + 0, e, p),
                            c(s, h + 2, t, p),
                            c(l, h + 4, n, p)
                        }
                    }
                    )(),
                    function() {
                        for (let e = 0; e < o.length; e += 6) {
                            const t = o[e + 0]
                              , n = o[e + 2]
                              , r = o[e + 4]
                              , i = Math.max(t, n, r)
                              , a = Math.min(t, n, r);
                            i > .9 && a < .1 && (t < .2 && (o[e + 0] += 1),
                            n < .2 && (o[e + 2] += 1),
                            r < .2 && (o[e + 4] += 1))
                        }
                    }()
                }(),
                this.setAttribute("position", new ay(i,3)),
                this.setAttribute("normal", new ay(i.slice(),3)),
                this.setAttribute("uv", new ay(o,2)),
                0 === r ? this.computeVertexNormals() : this.normalizeNormals()
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new JS(e.vertices,e.indices,e.radius,e.details)
            }
        }
        class KS extends JS {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = (1 + Math.sqrt(5)) / 2
                  , r = 1 / n;
                super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t),
                this.type = "DodecahedronGeometry",
                this.parameters = {
                    radius: e,
                    detail: t
                }
            }
            static fromJSON(e) {
                return new KS(e.radius,e.detail)
            }
        }
        const qS = new Ag
          , YS = new Ag
          , QS = new Ag
          , ZS = new kv;
        class $S extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                if (super(),
                this.type = "EdgesGeometry",
                this.parameters = {
                    geometry: e,
                    thresholdAngle: t
                },
                null !== e) {
                    const n = 4
                      , r = Math.pow(10, n)
                      , i = Math.cos(Bm * t)
                      , o = e.getIndex()
                      , a = e.getAttribute("position")
                      , s = o ? o.count : a.count
                      , l = [0, 0, 0]
                      , c = ["a", "b", "c"]
                      , u = new Array(3)
                      , d = {}
                      , h = [];
                    for (let e = 0; e < s; e += 3) {
                        o ? (l[0] = o.getX(e),
                        l[1] = o.getX(e + 1),
                        l[2] = o.getX(e + 2)) : (l[0] = e,
                        l[1] = e + 1,
                        l[2] = e + 2);
                        const {a: t, b: n, c: s} = ZS;
                        if (t.fromBufferAttribute(a, l[0]),
                        n.fromBufferAttribute(a, l[1]),
                        s.fromBufferAttribute(a, l[2]),
                        ZS.getNormal(QS),
                        u[0] = `${Math.round(t.x * r)},${Math.round(t.y * r)},${Math.round(t.z * r)}`,
                        u[1] = `${Math.round(n.x * r)},${Math.round(n.y * r)},${Math.round(n.z * r)}`,
                        u[2] = `${Math.round(s.x * r)},${Math.round(s.y * r)},${Math.round(s.z * r)}`,
                        u[0] !== u[1] && u[1] !== u[2] && u[2] !== u[0])
                            for (let e = 0; e < 3; e++) {
                                const t = (e + 1) % 3
                                  , n = u[e]
                                  , r = u[t]
                                  , o = ZS[c[e]]
                                  , a = ZS[c[t]]
                                  , s = `${n}_${r}`
                                  , p = `${r}_${n}`;
                                p in d && d[p] ? (QS.dot(d[p].normal) <= i && (h.push(o.x, o.y, o.z),
                                h.push(a.x, a.y, a.z)),
                                d[p] = null) : s in d || (d[s] = {
                                    index0: l[e],
                                    index1: l[t],
                                    normal: QS.clone()
                                })
                            }
                    }
                    for (const e in d)
                        if (d[e]) {
                            const {index0: t, index1: n} = d[e];
                            qS.fromBufferAttribute(a, t),
                            YS.fromBufferAttribute(a, n),
                            h.push(qS.x, qS.y, qS.z),
                            h.push(YS.x, YS.y, YS.z)
                        }
                    this.setAttribute("position", new ay(h,3))
                }
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
        }
        class ew extends GS {
            constructor(e) {
                super(e),
                this.uuid = Lm(),
                this.type = "Shape",
                this.holes = []
            }
            getPointsHoles(e) {
                const t = [];
                for (let n = 0, r = this.holes.length; n < r; n++)
                    t[n] = this.holes[n].getPoints(e);
                return t
            }
            extractPoints(e) {
                return {
                    shape: this.getPoints(e),
                    holes: this.getPointsHoles(e)
                }
            }
            copy(e) {
                super.copy(e),
                this.holes = [];
                for (let t = 0, n = e.holes.length; t < n; t++) {
                    const n = e.holes[t];
                    this.holes.push(n.clone())
                }
                return this
            }
            toJSON() {
                const e = super.toJSON();
                e.uuid = this.uuid,
                e.holes = [];
                for (let t = 0, n = this.holes.length; t < n; t++) {
                    const n = this.holes[t];
                    e.holes.push(n.toJSON())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e),
                this.uuid = e.uuid,
                this.holes = [];
                for (let t = 0, n = e.holes.length; t < n; t++) {
                    const n = e.holes[t];
                    this.holes.push((new GS).fromJSON(n))
                }
                return this
            }
        }
        const tw = function(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2;
            const r = t && t.length
              , i = r ? t[0] * n : e.length;
            let o = nw(e, 0, i, n, !0);
            const a = [];
            if (!o || o.next === o.prev)
                return a;
            let s, l, c, u, d, h, p;
            if (r && (o = function(e, t, n, r) {
                const i = [];
                let o, a, s, l, c;
                for (o = 0,
                a = t.length; o < a; o++)
                    s = t[o] * r,
                    l = o < a - 1 ? t[o + 1] * r : e.length,
                    c = nw(e, s, l, r, !1),
                    c === c.next && (c.steiner = !0),
                    i.push(pw(c));
                for (i.sort(cw),
                o = 0; o < i.length; o++)
                    n = uw(i[o], n);
                return n
            }(e, t, o, n)),
            e.length > 80 * n) {
                s = c = e[0],
                l = u = e[1];
                for (let t = n; t < i; t += n)
                    d = e[t],
                    h = e[t + 1],
                    d < s && (s = d),
                    h < l && (l = h),
                    d > c && (c = d),
                    h > u && (u = h);
                p = Math.max(c - s, u - l),
                p = 0 !== p ? 32767 / p : 0
            }
            return iw(o, a, n, s, l, p, 0),
            a
        };
        function nw(e, t, n, r, i) {
            let o, a;
            if (i === function(e, t, n, r) {
                let i = 0;
                for (let o = t, a = n - r; o < n; o += r)
                    i += (e[a] - e[o]) * (e[o + 1] + e[a + 1]),
                    a = o;
                return i
            }(e, t, n, r) > 0)
                for (o = t; o < n; o += r)
                    a = Sw(o, e[o], e[o + 1], a);
            else
                for (o = n - r; o >= t; o -= r)
                    a = Sw(o, e[o], e[o + 1], a);
            return a && vw(a, a.next) && (ww(a),
            a = a.next),
            a
        }
        function rw(e, t) {
            if (!e)
                return e;
            t || (t = e);
            let n, r = e;
            do {
                if (n = !1,
                r.steiner || !vw(r, r.next) && 0 !== gw(r.prev, r, r.next))
                    r = r.next;
                else {
                    if (ww(r),
                    r = t = r.prev,
                    r === r.next)
                        break;
                    n = !0
                }
            } while (n || r !== t);
            return t
        }
        function iw(e, t, n, r, i, o, a) {
            if (!e)
                return;
            !a && o && function(e, t, n, r) {
                let i = e;
                do {
                    0 === i.z && (i.z = hw(i.x, i.y, t, n, r)),
                    i.prevZ = i.prev,
                    i.nextZ = i.next,
                    i = i.next
                } while (i !== e);
                i.prevZ.nextZ = null,
                i.prevZ = null,
                function(e) {
                    let t, n, r, i, o, a, s, l, c = 1;
                    do {
                        for (n = e,
                        e = null,
                        o = null,
                        a = 0; n; ) {
                            for (a++,
                            r = n,
                            s = 0,
                            t = 0; t < c && (s++,
                            r = r.nextZ,
                            r); t++)
                                ;
                            for (l = c; s > 0 || l > 0 && r; )
                                0 !== s && (0 === l || !r || n.z <= r.z) ? (i = n,
                                n = n.nextZ,
                                s--) : (i = r,
                                r = r.nextZ,
                                l--),
                                o ? o.nextZ = i : e = i,
                                i.prevZ = o,
                                o = i;
                            n = r
                        }
                        o.nextZ = null,
                        c *= 2
                    } while (a > 1)
                }(i)
            }(e, r, i, o);
            let s, l, c = e;
            for (; e.prev !== e.next; )
                if (s = e.prev,
                l = e.next,
                o ? aw(e, r, i, o) : ow(e))
                    t.push(s.i / n | 0),
                    t.push(e.i / n | 0),
                    t.push(l.i / n | 0),
                    ww(e),
                    e = l.next,
                    c = l.next;
                else if ((e = l) === c) {
                    a ? 1 === a ? iw(e = sw(rw(e), t, n), t, n, r, i, o, 2) : 2 === a && lw(e, t, n, r, i, o) : iw(rw(e), t, n, r, i, o, 1);
                    break
                }
        }
        function ow(e) {
            const t = e.prev
              , n = e
              , r = e.next;
            if (gw(t, n, r) >= 0)
                return !1;
            const i = t.x
              , o = n.x
              , a = r.x
              , s = t.y
              , l = n.y
              , c = r.y
              , u = i < o ? i < a ? i : a : o < a ? o : a
              , d = s < l ? s < c ? s : c : l < c ? l : c
              , h = i > o ? i > a ? i : a : o > a ? o : a
              , p = s > l ? s > c ? s : c : l > c ? l : c;
            let f = r.next;
            for (; f !== t; ) {
                if (f.x >= u && f.x <= h && f.y >= d && f.y <= p && fw(i, s, o, l, a, c, f.x, f.y) && gw(f.prev, f, f.next) >= 0)
                    return !1;
                f = f.next
            }
            return !0
        }
        function aw(e, t, n, r) {
            const i = e.prev
              , o = e
              , a = e.next;
            if (gw(i, o, a) >= 0)
                return !1;
            const s = i.x
              , l = o.x
              , c = a.x
              , u = i.y
              , d = o.y
              , h = a.y
              , p = s < l ? s < c ? s : c : l < c ? l : c
              , f = u < d ? u < h ? u : h : d < h ? d : h
              , m = s > l ? s > c ? s : c : l > c ? l : c
              , g = u > d ? u > h ? u : h : d > h ? d : h
              , v = hw(p, f, t, n, r)
              , y = hw(m, g, t, n, r);
            let b = e.prevZ
              , _ = e.nextZ;
            for (; b && b.z >= v && _ && _.z <= y; ) {
                if (b.x >= p && b.x <= m && b.y >= f && b.y <= g && b !== i && b !== a && fw(s, u, l, d, c, h, b.x, b.y) && gw(b.prev, b, b.next) >= 0)
                    return !1;
                if (b = b.prevZ,
                _.x >= p && _.x <= m && _.y >= f && _.y <= g && _ !== i && _ !== a && fw(s, u, l, d, c, h, _.x, _.y) && gw(_.prev, _, _.next) >= 0)
                    return !1;
                _ = _.nextZ
            }
            for (; b && b.z >= v; ) {
                if (b.x >= p && b.x <= m && b.y >= f && b.y <= g && b !== i && b !== a && fw(s, u, l, d, c, h, b.x, b.y) && gw(b.prev, b, b.next) >= 0)
                    return !1;
                b = b.prevZ
            }
            for (; _ && _.z <= y; ) {
                if (_.x >= p && _.x <= m && _.y >= f && _.y <= g && _ !== i && _ !== a && fw(s, u, l, d, c, h, _.x, _.y) && gw(_.prev, _, _.next) >= 0)
                    return !1;
                _ = _.nextZ
            }
            return !0
        }
        function sw(e, t, n) {
            let r = e;
            do {
                const i = r.prev
                  , o = r.next.next;
                !vw(i, o) && yw(i, r, r.next, o) && Aw(i, o) && Aw(o, i) && (t.push(i.i / n | 0),
                t.push(r.i / n | 0),
                t.push(o.i / n | 0),
                ww(r),
                ww(r.next),
                r = e = o),
                r = r.next
            } while (r !== e);
            return rw(r)
        }
        function lw(e, t, n, r, i, o) {
            let a = e;
            do {
                let e = a.next.next;
                for (; e !== a.prev; ) {
                    if (a.i !== e.i && mw(a, e)) {
                        let s = xw(a, e);
                        return a = rw(a, a.next),
                        s = rw(s, s.next),
                        iw(a, t, n, r, i, o, 0),
                        void iw(s, t, n, r, i, o, 0)
                    }
                    e = e.next
                }
                a = a.next
            } while (a !== e)
        }
        function cw(e, t) {
            return e.x - t.x
        }
        function uw(e, t) {
            const n = function(e, t) {
                let n, r = t, i = -1 / 0;
                const o = e.x
                  , a = e.y;
                do {
                    if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
                        const e = r.x + (a - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                        if (e <= o && e > i && (i = e,
                        n = r.x < r.next.x ? r : r.next,
                        e === o))
                            return n
                    }
                    r = r.next
                } while (r !== t);
                if (!n)
                    return null;
                const s = n
                  , l = n.x
                  , c = n.y;
                let u, d = 1 / 0;
                r = n;
                do {
                    o >= r.x && r.x >= l && o !== r.x && fw(a < c ? o : i, a, l, c, a < c ? i : o, a, r.x, r.y) && (u = Math.abs(a - r.y) / (o - r.x),
                    Aw(r, e) && (u < d || u === d && (r.x > n.x || r.x === n.x && dw(n, r))) && (n = r,
                    d = u)),
                    r = r.next
                } while (r !== s);
                return n
            }(e, t);
            if (!n)
                return t;
            const r = xw(n, e);
            return rw(r, r.next),
            rw(n, n.next)
        }
        function dw(e, t) {
            return gw(e.prev, e, t.prev) < 0 && gw(t.next, e, e.next) < 0
        }
        function hw(e, t, n, r, i) {
            return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }
        function pw(e) {
            let t = e
              , n = e;
            do {
                (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t),
                t = t.next
            } while (t !== e);
            return n
        }
        function fw(e, t, n, r, i, o, a, s) {
            return (i - a) * (t - s) >= (e - a) * (o - s) && (e - a) * (r - s) >= (n - a) * (t - s) && (n - a) * (o - s) >= (i - a) * (r - s)
        }
        function mw(e, t) {
            return e.next.i !== t.i && e.prev.i !== t.i && !function(e, t) {
                let n = e;
                do {
                    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && yw(n, n.next, e, t))
                        return !0;
                    n = n.next
                } while (n !== e);
                return !1
            }(e, t) && (Aw(e, t) && Aw(t, e) && function(e, t) {
                let n = e
                  , r = !1;
                const i = (e.x + t.x) / 2
                  , o = (e.y + t.y) / 2;
                do {
                    n.y > o !== n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r),
                    n = n.next
                } while (n !== e);
                return r
            }(e, t) && (gw(e.prev, e, t.prev) || gw(e, t.prev, t)) || vw(e, t) && gw(e.prev, e, e.next) > 0 && gw(t.prev, t, t.next) > 0)
        }
        function gw(e, t, n) {
            return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
        }
        function vw(e, t) {
            return e.x === t.x && e.y === t.y
        }
        function yw(e, t, n, r) {
            const i = _w(gw(e, t, n))
              , o = _w(gw(e, t, r))
              , a = _w(gw(n, r, e))
              , s = _w(gw(n, r, t));
            return i !== o && a !== s || (!(0 !== i || !bw(e, n, t)) || (!(0 !== o || !bw(e, r, t)) || (!(0 !== a || !bw(n, e, r)) || !(0 !== s || !bw(n, t, r)))))
        }
        function bw(e, t, n) {
            return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
        }
        function _w(e) {
            return e > 0 ? 1 : e < 0 ? -1 : 0
        }
        function Aw(e, t) {
            return gw(e.prev, e, e.next) < 0 ? gw(e, t, e.next) >= 0 && gw(e, e.prev, t) >= 0 : gw(e, t, e.prev) < 0 || gw(e, e.next, t) < 0
        }
        function xw(e, t) {
            const n = new Ew(e.i,e.x,e.y)
              , r = new Ew(t.i,t.x,t.y)
              , i = e.next
              , o = t.prev;
            return e.next = t,
            t.prev = e,
            n.next = i,
            i.prev = n,
            r.next = n,
            n.prev = r,
            o.next = r,
            r.prev = o,
            r
        }
        function Sw(e, t, n, r) {
            const i = new Ew(e,t,n);
            return r ? (i.next = r.next,
            i.prev = r,
            r.next.prev = i,
            r.next = i) : (i.prev = i,
            i.next = i),
            i
        }
        function ww(e) {
            e.next.prev = e.prev,
            e.prev.next = e.next,
            e.prevZ && (e.prevZ.nextZ = e.nextZ),
            e.nextZ && (e.nextZ.prevZ = e.prevZ)
        }
        function Ew(e, t, n) {
            this.i = e,
            this.x = t,
            this.y = n,
            this.prev = null,
            this.next = null,
            this.z = 0,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        class Mw {
            static area(e) {
                const t = e.length;
                let n = 0;
                for (let r = t - 1, i = 0; i < t; r = i++)
                    n += e[r].x * e[i].y - e[i].x * e[r].y;
                return .5 * n
            }
            static isClockWise(e) {
                return Mw.area(e) < 0
            }
            static triangulateShape(e, t) {
                const n = []
                  , r = []
                  , i = [];
                Cw(e),
                Tw(n, e);
                let o = e.length;
                t.forEach(Cw);
                for (let s = 0; s < t.length; s++)
                    r.push(o),
                    o += t[s].length,
                    Tw(n, t[s]);
                const a = tw(n, r);
                for (let s = 0; s < a.length; s += 3)
                    i.push(a.slice(s, s + 3));
                return i
            }
        }
        function Cw(e) {
            const t = e.length;
            t > 2 && e[t - 1].equals(e[0]) && e.pop()
        }
        function Tw(e, t) {
            for (let n = 0; n < t.length; n++)
                e.push(t[n].x),
                e.push(t[n].y)
        }
        class Rw extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ew([new Hm(.5,.5), new Hm(-.5,.5), new Hm(-.5,-.5), new Hm(.5,-.5)])
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                super(),
                this.type = "ExtrudeGeometry",
                this.parameters = {
                    shapes: e,
                    options: t
                },
                e = Array.isArray(e) ? e : [e];
                const n = this
                  , r = []
                  , i = [];
                for (let a = 0, s = e.length; a < s; a++) {
                    o(e[a])
                }
                function o(e) {
                    const o = []
                      , a = void 0 !== t.curveSegments ? t.curveSegments : 12
                      , s = void 0 !== t.steps ? t.steps : 1
                      , l = void 0 !== t.depth ? t.depth : 1;
                    let c = void 0 === t.bevelEnabled || t.bevelEnabled
                      , u = void 0 !== t.bevelThickness ? t.bevelThickness : .2
                      , d = void 0 !== t.bevelSize ? t.bevelSize : u - .1
                      , h = void 0 !== t.bevelOffset ? t.bevelOffset : 0
                      , p = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
                    const f = t.extrudePath
                      , m = void 0 !== t.UVGenerator ? t.UVGenerator : Pw;
                    let g, v, y, b, _, A = !1;
                    f && (g = f.getSpacedPoints(s),
                    A = !0,
                    c = !1,
                    v = f.computeFrenetFrames(s, !1),
                    y = new Ag,
                    b = new Ag,
                    _ = new Ag),
                    c || (p = 0,
                    u = 0,
                    d = 0,
                    h = 0);
                    const x = e.extractPoints(a);
                    let S = x.shape;
                    const w = x.holes;
                    if (!Mw.isClockWise(S)) {
                        S = S.reverse();
                        for (let e = 0, t = w.length; e < t; e++) {
                            const t = w[e];
                            Mw.isClockWise(t) && (w[e] = t.reverse())
                        }
                    }
                    const E = Mw.triangulateShape(S, w)
                      , M = S;
                    for (let t = 0, n = w.length; t < n; t++) {
                        const e = w[t];
                        S = S.concat(e)
                    }
                    function C(e, t, n) {
                        return t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                        e.clone().addScaledVector(t, n)
                    }
                    const T = S.length
                      , R = E.length;
                    function P(e, t, n) {
                        let r, i, o;
                        const a = e.x - t.x
                          , s = e.y - t.y
                          , l = n.x - e.x
                          , c = n.y - e.y
                          , u = a * a + s * s
                          , d = a * c - s * l;
                        if (Math.abs(d) > Number.EPSILON) {
                            const d = Math.sqrt(u)
                              , h = Math.sqrt(l * l + c * c)
                              , p = t.x - s / d
                              , f = t.y + a / d
                              , m = ((n.x - c / h - p) * c - (n.y + l / h - f) * l) / (a * c - s * l);
                            r = p + a * m - e.x,
                            i = f + s * m - e.y;
                            const g = r * r + i * i;
                            if (g <= 2)
                                return new Hm(r,i);
                            o = Math.sqrt(g / 2)
                        } else {
                            let e = !1;
                            a > Number.EPSILON ? l > Number.EPSILON && (e = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(s) === Math.sign(c) && (e = !0),
                            e ? (r = -s,
                            i = a,
                            o = Math.sqrt(u)) : (r = a,
                            i = s,
                            o = Math.sqrt(u / 2))
                        }
                        return new Hm(r / o,i / o)
                    }
                    const B = [];
                    for (let t = 0, n = M.length, r = n - 1, i = t + 1; t < n; t++,
                    r++,
                    i++)
                        r === n && (r = 0),
                        i === n && (i = 0),
                        B[t] = P(M[t], M[r], M[i]);
                    const I = [];
                    let L, k = B.concat();
                    for (let t = 0, n = w.length; t < n; t++) {
                        const e = w[t];
                        L = [];
                        for (let t = 0, n = e.length, r = n - 1, i = t + 1; t < n; t++,
                        r++,
                        i++)
                            r === n && (r = 0),
                            i === n && (i = 0),
                            L[t] = P(e[t], e[r], e[i]);
                        I.push(L),
                        k = k.concat(L)
                    }
                    for (let t = 0; t < p; t++) {
                        const e = t / p
                          , n = u * Math.cos(e * Math.PI / 2)
                          , r = d * Math.sin(e * Math.PI / 2) + h;
                        for (let t = 0, i = M.length; t < i; t++) {
                            const e = C(M[t], B[t], r);
                            N(e.x, e.y, -n)
                        }
                        for (let t = 0, i = w.length; t < i; t++) {
                            const e = w[t];
                            L = I[t];
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = C(e[t], L[t], r);
                                N(i.x, i.y, -n)
                            }
                        }
                    }
                    const D = d + h;
                    for (let t = 0; t < T; t++) {
                        const e = c ? C(S[t], k[t], D) : S[t];
                        A ? (b.copy(v.normals[0]).multiplyScalar(e.x),
                        y.copy(v.binormals[0]).multiplyScalar(e.y),
                        _.copy(g[0]).add(b).add(y),
                        N(_.x, _.y, _.z)) : N(e.x, e.y, 0)
                    }
                    for (let t = 1; t <= s; t++)
                        for (let e = 0; e < T; e++) {
                            const n = c ? C(S[e], k[e], D) : S[e];
                            A ? (b.copy(v.normals[t]).multiplyScalar(n.x),
                            y.copy(v.binormals[t]).multiplyScalar(n.y),
                            _.copy(g[t]).add(b).add(y),
                            N(_.x, _.y, _.z)) : N(n.x, n.y, l / s * t)
                        }
                    for (let t = p - 1; t >= 0; t--) {
                        const e = t / p
                          , n = u * Math.cos(e * Math.PI / 2)
                          , r = d * Math.sin(e * Math.PI / 2) + h;
                        for (let t = 0, i = M.length; t < i; t++) {
                            const e = C(M[t], B[t], r);
                            N(e.x, e.y, l + n)
                        }
                        for (let t = 0, i = w.length; t < i; t++) {
                            const e = w[t];
                            L = I[t];
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = C(e[t], L[t], r);
                                A ? N(i.x, i.y + g[s - 1].y, g[s - 1].x + n) : N(i.x, i.y, l + n)
                            }
                        }
                    }
                    function O(e, t) {
                        let n = e.length;
                        for (; --n >= 0; ) {
                            const r = n;
                            let i = n - 1;
                            i < 0 && (i = e.length - 1);
                            for (let e = 0, n = s + 2 * p; e < n; e++) {
                                const n = T * e
                                  , o = T * (e + 1);
                                U(t + r + n, t + i + n, t + i + o, t + r + o)
                            }
                        }
                    }
                    function N(e, t, n) {
                        o.push(e),
                        o.push(t),
                        o.push(n)
                    }
                    function F(e, t, i) {
                        z(e),
                        z(t),
                        z(i);
                        const o = r.length / 3
                          , a = m.generateTopUV(n, r, o - 3, o - 2, o - 1);
                        G(a[0]),
                        G(a[1]),
                        G(a[2])
                    }
                    function U(e, t, i, o) {
                        z(e),
                        z(t),
                        z(o),
                        z(t),
                        z(i),
                        z(o);
                        const a = r.length / 3
                          , s = m.generateSideWallUV(n, r, a - 6, a - 3, a - 2, a - 1);
                        G(s[0]),
                        G(s[1]),
                        G(s[3]),
                        G(s[1]),
                        G(s[2]),
                        G(s[3])
                    }
                    function z(e) {
                        r.push(o[3 * e + 0]),
                        r.push(o[3 * e + 1]),
                        r.push(o[3 * e + 2])
                    }
                    function G(e) {
                        i.push(e.x),
                        i.push(e.y)
                    }
                    !function() {
                        const e = r.length / 3;
                        if (c) {
                            let e = 0
                              , t = T * e;
                            for (let n = 0; n < R; n++) {
                                const e = E[n];
                                F(e[2] + t, e[1] + t, e[0] + t)
                            }
                            e = s + 2 * p,
                            t = T * e;
                            for (let n = 0; n < R; n++) {
                                const e = E[n];
                                F(e[0] + t, e[1] + t, e[2] + t)
                            }
                        } else {
                            for (let e = 0; e < R; e++) {
                                const t = E[e];
                                F(t[2], t[1], t[0])
                            }
                            for (let e = 0; e < R; e++) {
                                const t = E[e];
                                F(t[0] + T * s, t[1] + T * s, t[2] + T * s)
                            }
                        }
                        n.addGroup(e, r.length / 3 - e, 0)
                    }(),
                    function() {
                        const e = r.length / 3;
                        let t = 0;
                        O(M, t),
                        t += M.length;
                        for (let n = 0, r = w.length; n < r; n++) {
                            const e = w[n];
                            O(e, t),
                            t += e.length
                        }
                        n.addGroup(e, r.length / 3 - e, 1)
                    }()
                }
                this.setAttribute("position", new ay(r,3)),
                this.setAttribute("uv", new ay(i,2)),
                this.computeVertexNormals()
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return function(e, t, n) {
                    if (n.shapes = [],
                    Array.isArray(e))
                        for (let r = 0, i = e.length; r < i; r++) {
                            const t = e[r];
                            n.shapes.push(t.uuid)
                        }
                    else
                        n.shapes.push(e.uuid);
                    n.options = Object.assign({}, t),
                    void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON());
                    return n
                }(this.parameters.shapes, this.parameters.options, e)
            }
            static fromJSON(e, t) {
                const n = [];
                for (let i = 0, o = e.shapes.length; i < o; i++) {
                    const r = t[e.shapes[i]];
                    n.push(r)
                }
                const r = e.options.extrudePath;
                return void 0 !== r && (e.options.extrudePath = (new US[r.type]).fromJSON(r)),
                new Rw(n,e.options)
            }
        }
        const Pw = {
            generateTopUV: function(e, t, n, r, i) {
                const o = t[3 * n]
                  , a = t[3 * n + 1]
                  , s = t[3 * r]
                  , l = t[3 * r + 1]
                  , c = t[3 * i]
                  , u = t[3 * i + 1];
                return [new Hm(o,a), new Hm(s,l), new Hm(c,u)]
            },
            generateSideWallUV: function(e, t, n, r, i, o) {
                const a = t[3 * n]
                  , s = t[3 * n + 1]
                  , l = t[3 * n + 2]
                  , c = t[3 * r]
                  , u = t[3 * r + 1]
                  , d = t[3 * r + 2]
                  , h = t[3 * i]
                  , p = t[3 * i + 1]
                  , f = t[3 * i + 2]
                  , m = t[3 * o]
                  , g = t[3 * o + 1]
                  , v = t[3 * o + 2];
                return Math.abs(s - u) < Math.abs(a - c) ? [new Hm(a,1 - l), new Hm(c,1 - d), new Hm(h,1 - f), new Hm(m,1 - v)] : [new Hm(s,1 - l), new Hm(u,1 - d), new Hm(p,1 - f), new Hm(g,1 - v)]
            }
        };
        class Bw extends JS {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = (1 + Math.sqrt(5)) / 2;
                super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t),
                this.type = "IcosahedronGeometry",
                this.parameters = {
                    radius: e,
                    detail: t
                }
            }
            static fromJSON(e) {
                return new Bw(e.radius,e.detail)
            }
        }
        class Iw extends JS {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t),
                this.type = "OctahedronGeometry",
                this.parameters = {
                    radius: e,
                    detail: t
                }
            }
            static fromJSON(e) {
                return new Iw(e.radius,e.detail)
            }
        }
        class Lw extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0
                  , o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2 * Math.PI;
                super(),
                this.type = "RingGeometry",
                this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: n,
                    phiSegments: r,
                    thetaStart: i,
                    thetaLength: o
                },
                n = Math.max(3, n),
                r = Math.max(1, r);
                const a = []
                  , s = []
                  , l = []
                  , c = [];
                let u = e;
                const d = (t - e) / r
                  , h = new Ag
                  , p = new Hm;
                for (let f = 0; f <= r; f++) {
                    for (let e = 0; e <= n; e++) {
                        const r = i + e / n * o;
                        h.x = u * Math.cos(r),
                        h.y = u * Math.sin(r),
                        s.push(h.x, h.y, h.z),
                        l.push(0, 0, 1),
                        p.x = (h.x / t + 1) / 2,
                        p.y = (h.y / t + 1) / 2,
                        c.push(p.x, p.y)
                    }
                    u += d
                }
                for (let f = 0; f < r; f++) {
                    const e = f * (n + 1);
                    for (let t = 0; t < n; t++) {
                        const r = t + e
                          , i = r
                          , o = r + n + 1
                          , s = r + n + 2
                          , l = r + 1;
                        a.push(i, o, l),
                        a.push(o, s, l)
                    }
                }
                this.setIndex(a),
                this.setAttribute("position", new ay(s,3)),
                this.setAttribute("normal", new ay(l,3)),
                this.setAttribute("uv", new ay(c,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new Lw(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)
            }
        }
        class kw extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ew([new Hm(0,.5), new Hm(-.5,-.5), new Hm(.5,-.5)])
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 12;
                super(),
                this.type = "ShapeGeometry",
                this.parameters = {
                    shapes: e,
                    curveSegments: t
                };
                const n = []
                  , r = []
                  , i = []
                  , o = [];
                let a = 0
                  , s = 0;
                if (!1 === Array.isArray(e))
                    l(e);
                else
                    for (let c = 0; c < e.length; c++)
                        l(e[c]),
                        this.addGroup(a, s, c),
                        a += s,
                        s = 0;
                function l(e) {
                    const a = r.length / 3
                      , l = e.extractPoints(t);
                    let c = l.shape;
                    const u = l.holes;
                    !1 === Mw.isClockWise(c) && (c = c.reverse());
                    for (let t = 0, n = u.length; t < n; t++) {
                        const e = u[t];
                        !0 === Mw.isClockWise(e) && (u[t] = e.reverse())
                    }
                    const d = Mw.triangulateShape(c, u);
                    for (let t = 0, n = u.length; t < n; t++) {
                        const e = u[t];
                        c = c.concat(e)
                    }
                    for (let t = 0, n = c.length; t < n; t++) {
                        const e = c[t];
                        r.push(e.x, e.y, 0),
                        i.push(0, 0, 1),
                        o.push(e.x, e.y)
                    }
                    for (let t = 0, r = d.length; t < r; t++) {
                        const e = d[t]
                          , r = e[0] + a
                          , i = e[1] + a
                          , o = e[2] + a;
                        n.push(r, i, o),
                        s += 3
                    }
                }
                this.setIndex(n),
                this.setAttribute("position", new ay(r,3)),
                this.setAttribute("normal", new ay(i,3)),
                this.setAttribute("uv", new ay(o,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return function(e, t) {
                    if (t.shapes = [],
                    Array.isArray(e))
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            t.shapes.push(r.uuid)
                        }
                    else
                        t.shapes.push(e.uuid);
                    return t
                }(this.parameters.shapes, e)
            }
            static fromJSON(e, t) {
                const n = [];
                for (let r = 0, i = e.shapes.length; r < i; r++) {
                    const i = t[e.shapes[r]];
                    n.push(i)
                }
                return new kw(n,e.curveSegments)
            }
        }
        class Dw extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 32
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 16
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2 * Math.PI
                  , o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0
                  , a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : Math.PI;
                super(),
                this.type = "SphereGeometry",
                this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: i,
                    thetaStart: o,
                    thetaLength: a
                },
                t = Math.max(3, Math.floor(t)),
                n = Math.max(2, Math.floor(n));
                const s = Math.min(o + a, Math.PI);
                let l = 0;
                const c = []
                  , u = new Ag
                  , d = new Ag
                  , h = []
                  , p = []
                  , f = []
                  , m = [];
                for (let g = 0; g <= n; g++) {
                    const h = []
                      , v = g / n;
                    let y = 0;
                    0 === g && 0 === o ? y = .5 / t : g === n && s === Math.PI && (y = -.5 / t);
                    for (let n = 0; n <= t; n++) {
                        const s = n / t;
                        u.x = -e * Math.cos(r + s * i) * Math.sin(o + v * a),
                        u.y = e * Math.cos(o + v * a),
                        u.z = e * Math.sin(r + s * i) * Math.sin(o + v * a),
                        p.push(u.x, u.y, u.z),
                        d.copy(u).normalize(),
                        f.push(d.x, d.y, d.z),
                        m.push(s + y, 1 - v),
                        h.push(l++)
                    }
                    c.push(h)
                }
                for (let g = 0; g < n; g++)
                    for (let e = 0; e < t; e++) {
                        const t = c[g][e + 1]
                          , r = c[g][e]
                          , i = c[g + 1][e]
                          , a = c[g + 1][e + 1];
                        (0 !== g || o > 0) && h.push(t, r, a),
                        (g !== n - 1 || s < Math.PI) && h.push(r, i, a)
                    }
                this.setIndex(h),
                this.setAttribute("position", new ay(p,3)),
                this.setAttribute("normal", new ay(f,3)),
                this.setAttribute("uv", new ay(m,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new Dw(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
            }
        }
        class Ow extends JS {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t),
                this.type = "TetrahedronGeometry",
                this.parameters = {
                    radius: e,
                    detail: t
                }
            }
            static fromJSON(e) {
                return new Ow(e.radius,e.detail)
            }
        }
        class Nw extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .4
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 12
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 48
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2 * Math.PI;
                super(),
                this.type = "TorusGeometry",
                this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: r,
                    arc: i
                },
                n = Math.floor(n),
                r = Math.floor(r);
                const o = []
                  , a = []
                  , s = []
                  , l = []
                  , c = new Ag
                  , u = new Ag
                  , d = new Ag;
                for (let h = 0; h <= n; h++)
                    for (let o = 0; o <= r; o++) {
                        const p = o / r * i
                          , f = h / n * Math.PI * 2;
                        u.x = (e + t * Math.cos(f)) * Math.cos(p),
                        u.y = (e + t * Math.cos(f)) * Math.sin(p),
                        u.z = t * Math.sin(f),
                        a.push(u.x, u.y, u.z),
                        c.x = e * Math.cos(p),
                        c.y = e * Math.sin(p),
                        d.subVectors(u, c).normalize(),
                        s.push(d.x, d.y, d.z),
                        l.push(o / r),
                        l.push(h / n)
                    }
                for (let h = 1; h <= n; h++)
                    for (let e = 1; e <= r; e++) {
                        const t = (r + 1) * h + e - 1
                          , n = (r + 1) * (h - 1) + e - 1
                          , i = (r + 1) * (h - 1) + e
                          , a = (r + 1) * h + e;
                        o.push(t, n, a),
                        o.push(n, i, a)
                    }
                this.setIndex(o),
                this.setAttribute("position", new ay(a,3)),
                this.setAttribute("normal", new ay(s,3)),
                this.setAttribute("uv", new ay(l,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new Nw(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
            }
        }
        class Fw extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .4
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 64
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2
                  , o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 3;
                super(),
                this.type = "TorusKnotGeometry",
                this.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: n,
                    radialSegments: r,
                    p: i,
                    q: o
                },
                n = Math.floor(n),
                r = Math.floor(r);
                const a = []
                  , s = []
                  , l = []
                  , c = []
                  , u = new Ag
                  , d = new Ag
                  , h = new Ag
                  , p = new Ag
                  , f = new Ag
                  , m = new Ag
                  , g = new Ag;
                for (let y = 0; y <= n; ++y) {
                    const a = y / n * i * Math.PI * 2;
                    v(a, i, o, e, h),
                    v(a + .01, i, o, e, p),
                    m.subVectors(p, h),
                    g.addVectors(p, h),
                    f.crossVectors(m, g),
                    g.crossVectors(f, m),
                    f.normalize(),
                    g.normalize();
                    for (let e = 0; e <= r; ++e) {
                        const i = e / r * Math.PI * 2
                          , o = -t * Math.cos(i)
                          , a = t * Math.sin(i);
                        u.x = h.x + (o * g.x + a * f.x),
                        u.y = h.y + (o * g.y + a * f.y),
                        u.z = h.z + (o * g.z + a * f.z),
                        s.push(u.x, u.y, u.z),
                        d.subVectors(u, h).normalize(),
                        l.push(d.x, d.y, d.z),
                        c.push(y / n),
                        c.push(e / r)
                    }
                }
                for (let y = 1; y <= n; y++)
                    for (let e = 1; e <= r; e++) {
                        const t = (r + 1) * (y - 1) + (e - 1)
                          , n = (r + 1) * y + (e - 1)
                          , i = (r + 1) * y + e
                          , o = (r + 1) * (y - 1) + e;
                        a.push(t, n, o),
                        a.push(n, i, o)
                    }
                function v(e, t, n, r, i) {
                    const o = Math.cos(e)
                      , a = Math.sin(e)
                      , s = n / t * e
                      , l = Math.cos(s);
                    i.x = r * (2 + l) * .5 * o,
                    i.y = r * (2 + l) * a * .5,
                    i.z = r * Math.sin(s) * .5
                }
                this.setIndex(a),
                this.setAttribute("position", new ay(s,3)),
                this.setAttribute("normal", new ay(l,3)),
                this.setAttribute("uv", new ay(c,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new Fw(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)
            }
        }
        class Uw extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new NS(new Ag(-1,-1,0),new Ag(-1,1,0),new Ag(1,1,0))
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 64
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8
                  , i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                super(),
                this.type = "TubeGeometry",
                this.parameters = {
                    path: e,
                    tubularSegments: t,
                    radius: n,
                    radialSegments: r,
                    closed: i
                };
                const o = e.computeFrenetFrames(t, i);
                this.tangents = o.tangents,
                this.normals = o.normals,
                this.binormals = o.binormals;
                const a = new Ag
                  , s = new Ag
                  , l = new Hm;
                let c = new Ag;
                const u = []
                  , d = []
                  , h = []
                  , p = [];
                function f(i) {
                    c = e.getPointAt(i / t, c);
                    const l = o.normals[i]
                      , h = o.binormals[i];
                    for (let e = 0; e <= r; e++) {
                        const t = e / r * Math.PI * 2
                          , i = Math.sin(t)
                          , o = -Math.cos(t);
                        s.x = o * l.x + i * h.x,
                        s.y = o * l.y + i * h.y,
                        s.z = o * l.z + i * h.z,
                        s.normalize(),
                        d.push(s.x, s.y, s.z),
                        a.x = c.x + n * s.x,
                        a.y = c.y + n * s.y,
                        a.z = c.z + n * s.z,
                        u.push(a.x, a.y, a.z)
                    }
                }
                !function() {
                    for (let e = 0; e < t; e++)
                        f(e);
                    f(!1 === i ? t : 0),
                    function() {
                        for (let e = 0; e <= t; e++)
                            for (let n = 0; n <= r; n++)
                                l.x = e / t,
                                l.y = n / r,
                                h.push(l.x, l.y)
                    }(),
                    function() {
                        for (let e = 1; e <= t; e++)
                            for (let t = 1; t <= r; t++) {
                                const n = (r + 1) * (e - 1) + (t - 1)
                                  , i = (r + 1) * e + (t - 1)
                                  , o = (r + 1) * e + t
                                  , a = (r + 1) * (e - 1) + t;
                                p.push(n, i, a),
                                p.push(i, o, a)
                            }
                    }()
                }(),
                this.setIndex(p),
                this.setAttribute("position", new ay(u,3)),
                this.setAttribute("normal", new ay(d,3)),
                this.setAttribute("uv", new ay(h,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.path = this.parameters.path.toJSON(),
                e
            }
            static fromJSON(e) {
                return new Uw((new US[e.path.type]).fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
            }
        }
        class zw extends my {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                if (super(),
                this.type = "WireframeGeometry",
                this.parameters = {
                    geometry: e
                },
                null !== e) {
                    const t = []
                      , n = new Set
                      , r = new Ag
                      , i = new Ag;
                    if (null !== e.index) {
                        const o = e.attributes.position
                          , a = e.index;
                        let s = e.groups;
                        0 === s.length && (s = [{
                            start: 0,
                            count: a.count,
                            materialIndex: 0
                        }]);
                        for (let e = 0, l = s.length; e < l; ++e) {
                            const l = s[e]
                              , c = l.start;
                            for (let e = c, s = c + l.count; e < s; e += 3)
                                for (let l = 0; l < 3; l++) {
                                    const s = a.getX(e + l)
                                      , c = a.getX(e + (l + 1) % 3);
                                    r.fromBufferAttribute(o, s),
                                    i.fromBufferAttribute(o, c),
                                    !0 === Gw(r, i, n) && (t.push(r.x, r.y, r.z),
                                    t.push(i.x, i.y, i.z))
                                }
                        }
                    } else {
                        const o = e.attributes.position;
                        for (let e = 0, a = o.count / 3; e < a; e++)
                            for (let s = 0; s < 3; s++) {
                                const a = 3 * e + s
                                  , l = 3 * e + (s + 1) % 3;
                                r.fromBufferAttribute(o, a),
                                i.fromBufferAttribute(o, l),
                                !0 === Gw(r, i, n) && (t.push(r.x, r.y, r.z),
                                t.push(i.x, i.y, i.z))
                            }
                    }
                    this.setAttribute("position", new ay(t,3))
                }
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
        }
        function Gw(e, t, n) {
            const r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`
              , i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
            return !0 !== n.has(r) && !0 !== n.has(i) && (n.add(r),
            n.add(i),
            !0)
        }
        var Hw = Object.freeze({
            __proto__: null,
            BoxGeometry: Dy,
            CapsuleGeometry: jS,
            CircleGeometry: WS,
            ConeGeometry: XS,
            CylinderGeometry: VS,
            DodecahedronGeometry: KS,
            EdgesGeometry: $S,
            ExtrudeGeometry: Rw,
            IcosahedronGeometry: Bw,
            LatheGeometry: HS,
            OctahedronGeometry: Iw,
            PlaneGeometry: nb,
            PolyhedronGeometry: JS,
            RingGeometry: Lw,
            ShapeGeometry: kw,
            SphereGeometry: Dw,
            TetrahedronGeometry: Ow,
            TorusGeometry: Nw,
            TorusKnotGeometry: Fw,
            TubeGeometry: Uw,
            WireframeGeometry: zw
        });
        class jw extends Hv {
            constructor(e) {
                super(),
                this.isShadowMaterial = !0,
                this.type = "ShadowMaterial",
                this.color = new Uv(0),
                this.transparent = !0,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.fog = e.fog,
                this
            }
        }
        class Ww extends zy {
            constructor(e) {
                super(e),
                this.isRawShaderMaterial = !0,
                this.type = "RawShaderMaterial"
            }
        }
        class Vw extends Hv {
            constructor(e) {
                super(),
                this.isMeshStandardMaterial = !0,
                this.defines = {
                    STANDARD: ""
                },
                this.type = "MeshStandardMaterial",
                this.color = new Uv(16777215),
                this.roughness = 1,
                this.metalness = 0,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Uv(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = Lf,
                this.normalScale = new Hm(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.roughnessMap = null,
                this.metalnessMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapIntensity = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.defines = {
                    STANDARD: ""
                },
                this.color.copy(e.color),
                this.roughness = e.roughness,
                this.metalness = e.metalness,
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.roughnessMap = e.roughnessMap,
                this.metalnessMap = e.metalnessMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.envMapIntensity = e.envMapIntensity,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        class Xw extends Vw {
            constructor(e) {
                super(),
                this.isMeshPhysicalMaterial = !0,
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.type = "MeshPhysicalMaterial",
                this.anisotropyRotation = 0,
                this.anisotropyMap = null,
                this.clearcoatMap = null,
                this.clearcoatRoughness = 0,
                this.clearcoatRoughnessMap = null,
                this.clearcoatNormalScale = new Hm(1,1),
                this.clearcoatNormalMap = null,
                this.ior = 1.5,
                Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return km(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(e) {
                        this.ior = (1 + .4 * e) / (1 - .4 * e)
                    }
                }),
                this.iridescenceMap = null,
                this.iridescenceIOR = 1.3,
                this.iridescenceThicknessRange = [100, 400],
                this.iridescenceThicknessMap = null,
                this.sheenColor = new Uv(0),
                this.sheenColorMap = null,
                this.sheenRoughness = 1,
                this.sheenRoughnessMap = null,
                this.transmissionMap = null,
                this.thickness = 0,
                this.thicknessMap = null,
                this.attenuationDistance = 1 / 0,
                this.attenuationColor = new Uv(1,1,1),
                this.specularIntensity = 1,
                this.specularIntensityMap = null,
                this.specularColor = new Uv(1,1,1),
                this.specularColorMap = null,
                this._anisotropy = 0,
                this._clearcoat = 0,
                this._iridescence = 0,
                this._sheen = 0,
                this._transmission = 0,
                this.setValues(e)
            }
            get anisotropy() {
                return this._anisotropy
            }
            set anisotropy(e) {
                this._anisotropy > 0 !== e > 0 && this.version++,
                this._anisotropy = e
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(e) {
                this._clearcoat > 0 !== e > 0 && this.version++,
                this._clearcoat = e
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(e) {
                this._iridescence > 0 !== e > 0 && this.version++,
                this._iridescence = e
            }
            get sheen() {
                return this._sheen
            }
            set sheen(e) {
                this._sheen > 0 !== e > 0 && this.version++,
                this._sheen = e
            }
            get transmission() {
                return this._transmission
            }
            set transmission(e) {
                this._transmission > 0 !== e > 0 && this.version++,
                this._transmission = e
            }
            copy(e) {
                return super.copy(e),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.anisotropy = e.anisotropy,
                this.anisotropyRotation = e.anisotropyRotation,
                this.anisotropyMap = e.anisotropyMap,
                this.clearcoat = e.clearcoat,
                this.clearcoatMap = e.clearcoatMap,
                this.clearcoatRoughness = e.clearcoatRoughness,
                this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
                this.clearcoatNormalMap = e.clearcoatNormalMap,
                this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
                this.ior = e.ior,
                this.iridescence = e.iridescence,
                this.iridescenceMap = e.iridescenceMap,
                this.iridescenceIOR = e.iridescenceIOR,
                this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
                this.iridescenceThicknessMap = e.iridescenceThicknessMap,
                this.sheen = e.sheen,
                this.sheenColor.copy(e.sheenColor),
                this.sheenColorMap = e.sheenColorMap,
                this.sheenRoughness = e.sheenRoughness,
                this.sheenRoughnessMap = e.sheenRoughnessMap,
                this.transmission = e.transmission,
                this.transmissionMap = e.transmissionMap,
                this.thickness = e.thickness,
                this.thicknessMap = e.thicknessMap,
                this.attenuationDistance = e.attenuationDistance,
                this.attenuationColor.copy(e.attenuationColor),
                this.specularIntensity = e.specularIntensity,
                this.specularIntensityMap = e.specularIntensityMap,
                this.specularColor.copy(e.specularColor),
                this.specularColorMap = e.specularColorMap,
                this
            }
        }
        class Jw extends Hv {
            constructor(e) {
                super(),
                this.isMeshPhongMaterial = !0,
                this.type = "MeshPhongMaterial",
                this.color = new Uv(16777215),
                this.specular = new Uv(1118481),
                this.shininess = 30,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Uv(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = Lf,
                this.normalScale = new Hm(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = Fh,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.specular.copy(e.specular),
                this.shininess = e.shininess,
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.specularMap = e.specularMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.combine = e.combine,
                this.reflectivity = e.reflectivity,
                this.refractionRatio = e.refractionRatio,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        class Kw extends Hv {
            constructor(e) {
                super(),
                this.isMeshToonMaterial = !0,
                this.defines = {
                    TOON: ""
                },
                this.type = "MeshToonMaterial",
                this.color = new Uv(16777215),
                this.map = null,
                this.gradientMap = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Uv(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = Lf,
                this.normalScale = new Hm(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.gradientMap = e.gradientMap,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.alphaMap = e.alphaMap,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.fog = e.fog,
                this
            }
        }
        class qw extends Hv {
            constructor(e) {
                super(),
                this.isMeshNormalMaterial = !0,
                this.type = "MeshNormalMaterial",
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = Lf,
                this.normalScale = new Hm(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.flatShading = !1,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.flatShading = e.flatShading,
                this
            }
        }
        class Yw extends Hv {
            constructor(e) {
                super(),
                this.isMeshLambertMaterial = !0,
                this.type = "MeshLambertMaterial",
                this.color = new Uv(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Uv(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = Lf,
                this.normalScale = new Hm(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = Fh,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.specularMap = e.specularMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.combine = e.combine,
                this.reflectivity = e.reflectivity,
                this.refractionRatio = e.refractionRatio,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        class Qw extends Hv {
            constructor(e) {
                super(),
                this.isMeshMatcapMaterial = !0,
                this.defines = {
                    MATCAP: ""
                },
                this.type = "MeshMatcapMaterial",
                this.color = new Uv(16777215),
                this.matcap = null,
                this.map = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = Lf,
                this.normalScale = new Hm(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.defines = {
                    MATCAP: ""
                },
                this.color.copy(e.color),
                this.matcap = e.matcap,
                this.map = e.map,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.alphaMap = e.alphaMap,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        class Zw extends Yx {
            constructor(e) {
                super(),
                this.isLineDashedMaterial = !0,
                this.type = "LineDashedMaterial",
                this.scale = 1,
                this.dashSize = 3,
                this.gapSize = 1,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.scale = e.scale,
                this.dashSize = e.dashSize,
                this.gapSize = e.gapSize,
                this
            }
        }
        function $w(e, t, n) {
            return !e || !n && e.constructor === t ? e : "number" === typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        }
        function eE(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        }
        function tE(e) {
            const t = e.length
              , n = new Array(t);
            for (let r = 0; r !== t; ++r)
                n[r] = r;
            return n.sort((function(t, n) {
                return e[t] - e[n]
            }
            )),
            n
        }
        function nE(e, t, n) {
            const r = e.length
              , i = new e.constructor(r);
            for (let o = 0, a = 0; a !== r; ++o) {
                const r = n[o] * t;
                for (let n = 0; n !== t; ++n)
                    i[a++] = e[r + n]
            }
            return i
        }
        function rE(e, t, n, r) {
            let i = 1
              , o = e[0];
            for (; void 0 !== o && void 0 === o[r]; )
                o = e[i++];
            if (void 0 === o)
                return;
            let a = o[r];
            if (void 0 !== a)
                if (Array.isArray(a))
                    do {
                        a = o[r],
                        void 0 !== a && (t.push(o.time),
                        n.push.apply(n, a)),
                        o = e[i++]
                    } while (void 0 !== o);
                else if (void 0 !== a.toArray)
                    do {
                        a = o[r],
                        void 0 !== a && (t.push(o.time),
                        a.toArray(n, n.length)),
                        o = e[i++]
                    } while (void 0 !== o);
                else
                    do {
                        a = o[r],
                        void 0 !== a && (t.push(o.time),
                        n.push(a)),
                        o = e[i++]
                    } while (void 0 !== o)
        }
        const iE = {
            convertArray: $w,
            isTypedArray: eE,
            getKeyframeOrder: tE,
            sortedArray: nE,
            flattenJSON: rE,
            subclip: function(e, t, n, r) {
                let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 30;
                const o = e.clone();
                o.name = t;
                const a = [];
                for (let l = 0; l < o.tracks.length; ++l) {
                    const e = o.tracks[l]
                      , t = e.getValueSize()
                      , s = []
                      , c = [];
                    for (let o = 0; o < e.times.length; ++o) {
                        const a = e.times[o] * i;
                        if (!(a < n || a >= r)) {
                            s.push(e.times[o]);
                            for (let n = 0; n < t; ++n)
                                c.push(e.values[o * t + n])
                        }
                    }
                    0 !== s.length && (e.times = $w(s, e.times.constructor),
                    e.values = $w(c, e.values.constructor),
                    a.push(e))
                }
                o.tracks = a;
                let s = 1 / 0;
                for (let l = 0; l < o.tracks.length; ++l)
                    s > o.tracks[l].times[0] && (s = o.tracks[l].times[0]);
                for (let l = 0; l < o.tracks.length; ++l)
                    o.tracks[l].shift(-1 * s);
                return o.resetDuration(),
                o
            },
            makeClipAdditive: function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 30;
                r <= 0 && (r = 30);
                const i = n.tracks.length
                  , o = t / r;
                for (let a = 0; a < i; ++a) {
                    const t = n.tracks[a]
                      , r = t.ValueTypeName;
                    if ("bool" === r || "string" === r)
                        continue;
                    const i = e.tracks.find((function(e) {
                        return e.name === t.name && e.ValueTypeName === r
                    }
                    ));
                    if (void 0 === i)
                        continue;
                    let s = 0;
                    const l = t.getValueSize();
                    t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = l / 3);
                    let c = 0;
                    const u = i.getValueSize();
                    i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
                    const d = t.times.length - 1;
                    let h;
                    if (o <= t.times[0]) {
                        const e = s
                          , n = l - s;
                        h = t.values.slice(e, n)
                    } else if (o >= t.times[d]) {
                        const e = d * l + s
                          , n = e + l - s;
                        h = t.values.slice(e, n)
                    } else {
                        const e = t.createInterpolant()
                          , n = s
                          , r = l - s;
                        e.evaluate(o),
                        h = e.resultBuffer.slice(n, r)
                    }
                    if ("quaternion" === r) {
                        (new _g).fromArray(h).normalize().conjugate().toArray(h)
                    }
                    const p = i.times.length;
                    for (let e = 0; e < p; ++e) {
                        const t = e * u + c;
                        if ("quaternion" === r)
                            _g.multiplyQuaternionsFlat(i.values, t, h, 0, i.values, t);
                        else {
                            const e = u - 2 * c;
                            for (let n = 0; n < e; ++n)
                                i.values[t + n] -= h[n]
                        }
                    }
                }
                return e.blendMode = Ef,
                e
            }
        };
        class oE {
            constructor(e, t, n, r) {
                this.parameterPositions = e,
                this._cachedIndex = 0,
                this.resultBuffer = void 0 !== r ? r : new t.constructor(n),
                this.sampleValues = t,
                this.valueSize = n,
                this.settings = null,
                this.DefaultSettings_ = {}
            }
            evaluate(e) {
                const t = this.parameterPositions;
                let n = this._cachedIndex
                  , r = t[n]
                  , i = t[n - 1];
                e: {
                    t: {
                        let o;
                        n: {
                            r: if (!(e < r)) {
                                for (let o = n + 2; ; ) {
                                    if (void 0 === r) {
                                        if (e < i)
                                            break r;
                                        return n = t.length,
                                        this._cachedIndex = n,
                                        this.copySampleValue_(n - 1)
                                    }
                                    if (n === o)
                                        break;
                                    if (i = r,
                                    r = t[++n],
                                    e < r)
                                        break t
                                }
                                o = t.length;
                                break n
                            }
                            if (e >= i)
                                break e;
                            {
                                const a = t[1];
                                e < a && (n = 2,
                                i = a);
                                for (let o = n - 2; ; ) {
                                    if (void 0 === i)
                                        return this._cachedIndex = 0,
                                        this.copySampleValue_(0);
                                    if (n === o)
                                        break;
                                    if (r = i,
                                    i = t[--n - 1],
                                    e >= i)
                                        break t
                                }
                                o = n,
                                n = 0
                            }
                        }
                        for (; n < o; ) {
                            const r = n + o >>> 1;
                            e < t[r] ? o = r : n = r + 1
                        }
                        if (r = t[n],
                        i = t[n - 1],
                        void 0 === i)
                            return this._cachedIndex = 0,
                            this.copySampleValue_(0);
                        if (void 0 === r)
                            return n = t.length,
                            this._cachedIndex = n,
                            this.copySampleValue_(n - 1)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, i, r)
                }
                return this.interpolate_(n, i, e, r)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(e) {
                const t = this.resultBuffer
                  , n = this.sampleValues
                  , r = this.valueSize
                  , i = e * r;
                for (let o = 0; o !== r; ++o)
                    t[o] = n[i + o];
                return t
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class aE extends oE {
            constructor(e, t, n, r) {
                super(e, t, n, r),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0,
                this.DefaultSettings_ = {
                    endingStart: Af,
                    endingEnd: Af
                }
            }
            intervalChanged_(e, t, n) {
                const r = this.parameterPositions;
                let i = e - 2
                  , o = e + 1
                  , a = r[i]
                  , s = r[o];
                if (void 0 === a)
                    switch (this.getSettings_().endingStart) {
                    case xf:
                        i = e,
                        a = 2 * t - n;
                        break;
                    case Sf:
                        i = r.length - 2,
                        a = t + r[i] - r[i + 1];
                        break;
                    default:
                        i = e,
                        a = n
                    }
                if (void 0 === s)
                    switch (this.getSettings_().endingEnd) {
                    case xf:
                        o = e,
                        s = 2 * n - t;
                        break;
                    case Sf:
                        o = 1,
                        s = n + r[1] - r[0];
                        break;
                    default:
                        o = e - 1,
                        s = t
                    }
                const l = .5 * (n - t)
                  , c = this.valueSize;
                this._weightPrev = l / (t - a),
                this._weightNext = l / (s - n),
                this._offsetPrev = i * c,
                this._offsetNext = o * c
            }
            interpolate_(e, t, n, r) {
                const i = this.resultBuffer
                  , o = this.sampleValues
                  , a = this.valueSize
                  , s = e * a
                  , l = s - a
                  , c = this._offsetPrev
                  , u = this._offsetNext
                  , d = this._weightPrev
                  , h = this._weightNext
                  , p = (n - t) / (r - t)
                  , f = p * p
                  , m = f * p
                  , g = -d * m + 2 * d * f - d * p
                  , v = (1 + d) * m + (-1.5 - 2 * d) * f + (-.5 + d) * p + 1
                  , y = (-1 - h) * m + (1.5 + h) * f + .5 * p
                  , b = h * m - h * f;
                for (let _ = 0; _ !== a; ++_)
                    i[_] = g * o[c + _] + v * o[l + _] + y * o[s + _] + b * o[u + _];
                return i
            }
        }
        class sE extends oE {
            constructor(e, t, n, r) {
                super(e, t, n, r)
            }
            interpolate_(e, t, n, r) {
                const i = this.resultBuffer
                  , o = this.sampleValues
                  , a = this.valueSize
                  , s = e * a
                  , l = s - a
                  , c = (n - t) / (r - t)
                  , u = 1 - c;
                for (let d = 0; d !== a; ++d)
                    i[d] = o[l + d] * u + o[s + d] * c;
                return i
            }
        }
        class lE extends oE {
            constructor(e, t, n, r) {
                super(e, t, n, r)
            }
            interpolate_(e) {
                return this.copySampleValue_(e - 1)
            }
        }
        class cE {
            constructor(e, t, n, r) {
                if (void 0 === e)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === t || 0 === t.length)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e,
                this.times = $w(t, this.TimeBufferType),
                this.values = $w(n, this.ValueBufferType),
                this.setInterpolation(r || this.DefaultInterpolation)
            }
            static toJSON(e) {
                const t = e.constructor;
                let n;
                if (t.toJSON !== this.toJSON)
                    n = t.toJSON(e);
                else {
                    n = {
                        name: e.name,
                        times: $w(e.times, Array),
                        values: $w(e.values, Array)
                    };
                    const t = e.getInterpolation();
                    t !== e.DefaultInterpolation && (n.interpolation = t)
                }
                return n.type = e.ValueTypeName,
                n
            }
            InterpolantFactoryMethodDiscrete(e) {
                return new lE(this.times,this.values,this.getValueSize(),e)
            }
            InterpolantFactoryMethodLinear(e) {
                return new sE(this.times,this.values,this.getValueSize(),e)
            }
            InterpolantFactoryMethodSmooth(e) {
                return new aE(this.times,this.values,this.getValueSize(),e)
            }
            setInterpolation(e) {
                let t;
                switch (e) {
                case yf:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case bf:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case _f:
                    t = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === t) {
                    const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (e === this.DefaultInterpolation)
                            throw new Error(t);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", t),
                    this
                }
                return this.createInterpolant = t,
                this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return yf;
                case this.InterpolantFactoryMethodLinear:
                    return bf;
                case this.InterpolantFactoryMethodSmooth:
                    return _f
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(e) {
                if (0 !== e) {
                    const t = this.times;
                    for (let n = 0, r = t.length; n !== r; ++n)
                        t[n] += e
                }
                return this
            }
            scale(e) {
                if (1 !== e) {
                    const t = this.times;
                    for (let n = 0, r = t.length; n !== r; ++n)
                        t[n] *= e
                }
                return this
            }
            trim(e, t) {
                const n = this.times
                  , r = n.length;
                let i = 0
                  , o = r - 1;
                for (; i !== r && n[i] < e; )
                    ++i;
                for (; -1 !== o && n[o] > t; )
                    --o;
                if (++o,
                0 !== i || o !== r) {
                    i >= o && (o = Math.max(o, 1),
                    i = o - 1);
                    const e = this.getValueSize();
                    this.times = n.slice(i, o),
                    this.values = this.values.slice(i * e, o * e)
                }
                return this
            }
            validate() {
                let e = !0;
                const t = this.getValueSize();
                t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                e = !1);
                const n = this.times
                  , r = this.values
                  , i = n.length;
                0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                e = !1);
                let o = null;
                for (let a = 0; a !== i; a++) {
                    const t = n[a];
                    if ("number" === typeof t && isNaN(t)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, t),
                        e = !1;
                        break
                    }
                    if (null !== o && o > t) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, t, o),
                        e = !1;
                        break
                    }
                    o = t
                }
                if (void 0 !== r && eE(r))
                    for (let a = 0, s = r.length; a !== s; ++a) {
                        const t = r[a];
                        if (isNaN(t)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, t),
                            e = !1;
                            break
                        }
                    }
                return e
            }
            optimize() {
                const e = this.times.slice()
                  , t = this.values.slice()
                  , n = this.getValueSize()
                  , r = this.getInterpolation() === _f
                  , i = e.length - 1;
                let o = 1;
                for (let a = 1; a < i; ++a) {
                    let i = !1;
                    const s = e[a];
                    if (s !== e[a + 1] && (1 !== a || s !== e[0]))
                        if (r)
                            i = !0;
                        else {
                            const e = a * n
                              , r = e - n
                              , o = e + n;
                            for (let a = 0; a !== n; ++a) {
                                const n = t[e + a];
                                if (n !== t[r + a] || n !== t[o + a]) {
                                    i = !0;
                                    break
                                }
                            }
                        }
                    if (i) {
                        if (a !== o) {
                            e[o] = e[a];
                            const r = a * n
                              , i = o * n;
                            for (let e = 0; e !== n; ++e)
                                t[i + e] = t[r + e]
                        }
                        ++o
                    }
                }
                if (i > 0) {
                    e[o] = e[i];
                    for (let e = i * n, r = o * n, a = 0; a !== n; ++a)
                        t[r + a] = t[e + a];
                    ++o
                }
                return o !== e.length ? (this.times = e.slice(0, o),
                this.values = t.slice(0, o * n)) : (this.times = e,
                this.values = t),
                this
            }
            clone() {
                const e = this.times.slice()
                  , t = this.values.slice()
                  , n = new (0,
                this.constructor)(this.name,e,t);
                return n.createInterpolant = this.createInterpolant,
                n
            }
        }
        cE.prototype.TimeBufferType = Float32Array,
        cE.prototype.ValueBufferType = Float32Array,
        cE.prototype.DefaultInterpolation = bf;
        class uE extends cE {
        }
        uE.prototype.ValueTypeName = "bool",
        uE.prototype.ValueBufferType = Array,
        uE.prototype.DefaultInterpolation = yf,
        uE.prototype.InterpolantFactoryMethodLinear = void 0,
        uE.prototype.InterpolantFactoryMethodSmooth = void 0;
        class dE extends cE {
        }
        dE.prototype.ValueTypeName = "color";
        class hE extends cE {
        }
        hE.prototype.ValueTypeName = "number";
        class pE extends oE {
            constructor(e, t, n, r) {
                super(e, t, n, r)
            }
            interpolate_(e, t, n, r) {
                const i = this.resultBuffer
                  , o = this.sampleValues
                  , a = this.valueSize
                  , s = (n - t) / (r - t);
                let l = e * a;
                for (let c = l + a; l !== c; l += 4)
                    _g.slerpFlat(i, 0, o, l - a, o, l, s);
                return i
            }
        }
        class fE extends cE {
            InterpolantFactoryMethodLinear(e) {
                return new pE(this.times,this.values,this.getValueSize(),e)
            }
        }
        fE.prototype.ValueTypeName = "quaternion",
        fE.prototype.DefaultInterpolation = bf,
        fE.prototype.InterpolantFactoryMethodSmooth = void 0;
        class mE extends cE {
        }
        mE.prototype.ValueTypeName = "string",
        mE.prototype.ValueBufferType = Array,
        mE.prototype.DefaultInterpolation = yf,
        mE.prototype.InterpolantFactoryMethodLinear = void 0,
        mE.prototype.InterpolantFactoryMethodSmooth = void 0;
        class gE extends cE {
        }
        gE.prototype.ValueTypeName = "vector";
        class vE {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1
                  , n = arguments.length > 2 ? arguments[2] : void 0
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : wf;
                this.name = e,
                this.tracks = n,
                this.duration = t,
                this.blendMode = r,
                this.uuid = Lm(),
                this.duration < 0 && this.resetDuration()
            }
            static parse(e) {
                const t = []
                  , n = e.tracks
                  , r = 1 / (e.fps || 1);
                for (let o = 0, a = n.length; o !== a; ++o)
                    t.push(yE(n[o]).scale(r));
                const i = new this(e.name,e.duration,t,e.blendMode);
                return i.uuid = e.uuid,
                i
            }
            static toJSON(e) {
                const t = []
                  , n = e.tracks
                  , r = {
                    name: e.name,
                    duration: e.duration,
                    tracks: t,
                    uuid: e.uuid,
                    blendMode: e.blendMode
                };
                for (let i = 0, o = n.length; i !== o; ++i)
                    t.push(cE.toJSON(n[i]));
                return r
            }
            static CreateFromMorphTargetSequence(e, t, n, r) {
                const i = t.length
                  , o = [];
                for (let a = 0; a < i; a++) {
                    let e = []
                      , s = [];
                    e.push((a + i - 1) % i, a, (a + 1) % i),
                    s.push(0, 1, 0);
                    const l = tE(e);
                    e = nE(e, 1, l),
                    s = nE(s, 1, l),
                    r || 0 !== e[0] || (e.push(i),
                    s.push(s[0])),
                    o.push(new hE(".morphTargetInfluences[" + t[a].name + "]",e,s).scale(1 / n))
                }
                return new this(e,-1,o)
            }
            static findByName(e, t) {
                let n = e;
                if (!Array.isArray(e)) {
                    const t = e;
                    n = t.geometry && t.geometry.animations || t.animations
                }
                for (let r = 0; r < n.length; r++)
                    if (n[r].name === t)
                        return n[r];
                return null
            }
            static CreateClipsFromMorphTargetSequences(e, t, n) {
                const r = {}
                  , i = /^([\w-]*?)([\d]+)$/;
                for (let a = 0, s = e.length; a < s; a++) {
                    const t = e[a]
                      , n = t.name.match(i);
                    if (n && n.length > 1) {
                        const e = n[1];
                        let i = r[e];
                        i || (r[e] = i = []),
                        i.push(t)
                    }
                }
                const o = [];
                for (const a in r)
                    o.push(this.CreateFromMorphTargetSequence(a, r[a], t, n));
                return o
            }
            static parseAnimation(e, t) {
                if (!e)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                    null;
                const n = function(e, t, n, r, i) {
                    if (0 !== n.length) {
                        const o = []
                          , a = [];
                        rE(n, o, a, r),
                        0 !== o.length && i.push(new e(t,o,a))
                    }
                }
                  , r = []
                  , i = e.name || "default"
                  , o = e.fps || 30
                  , a = e.blendMode;
                let s = e.length || -1;
                const l = e.hierarchy || [];
                for (let c = 0; c < l.length; c++) {
                    const e = l[c].keys;
                    if (e && 0 !== e.length)
                        if (e[0].morphTargets) {
                            const t = {};
                            let n;
                            for (n = 0; n < e.length; n++)
                                if (e[n].morphTargets)
                                    for (let r = 0; r < e[n].morphTargets.length; r++)
                                        t[e[n].morphTargets[r]] = -1;
                            for (const i in t) {
                                const t = []
                                  , o = [];
                                for (let r = 0; r !== e[n].morphTargets.length; ++r) {
                                    const r = e[n];
                                    t.push(r.time),
                                    o.push(r.morphTarget === i ? 1 : 0)
                                }
                                r.push(new hE(".morphTargetInfluence[" + i + "]",t,o))
                            }
                            s = t.length * o
                        } else {
                            const i = ".bones[" + t[c].name + "]";
                            n(gE, i + ".position", e, "pos", r),
                            n(fE, i + ".quaternion", e, "rot", r),
                            n(gE, i + ".scale", e, "scl", r)
                        }
                }
                if (0 === r.length)
                    return null;
                return new this(i,s,r,a)
            }
            resetDuration() {
                let e = 0;
                for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                    const n = this.tracks[t];
                    e = Math.max(e, n.times[n.times.length - 1])
                }
                return this.duration = e,
                this
            }
            trim() {
                for (let e = 0; e < this.tracks.length; e++)
                    this.tracks[e].trim(0, this.duration);
                return this
            }
            validate() {
                let e = !0;
                for (let t = 0; t < this.tracks.length; t++)
                    e = e && this.tracks[t].validate();
                return e
            }
            optimize() {
                for (let e = 0; e < this.tracks.length; e++)
                    this.tracks[e].optimize();
                return this
            }
            clone() {
                const e = [];
                for (let t = 0; t < this.tracks.length; t++)
                    e.push(this.tracks[t].clone());
                return new this.constructor(this.name,this.duration,e,this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }
        function yE(e) {
            if (void 0 === e.type)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const t = function(e) {
                switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return hE;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return gE;
                case "color":
                    return dE;
                case "quaternion":
                    return fE;
                case "bool":
                case "boolean":
                    return uE;
                case "string":
                    return mE
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
            }(e.type);
            if (void 0 === e.times) {
                const t = []
                  , n = [];
                rE(e.keys, t, n, "value"),
                e.times = t,
                e.values = n
            }
            return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
        }
        const bE = {
            enabled: !1,
            files: {},
            add: function(e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function(e) {
                if (!1 !== this.enabled)
                    return this.files[e]
            },
            remove: function(e) {
                delete this.files[e]
            },
            clear: function() {
                this.files = {}
            }
        };
        class _E {
            constructor(e, t, n) {
                const r = this;
                let i, o = !1, a = 0, s = 0;
                const l = [];
                this.onStart = void 0,
                this.onLoad = e,
                this.onProgress = t,
                this.onError = n,
                this.itemStart = function(e) {
                    s++,
                    !1 === o && void 0 !== r.onStart && r.onStart(e, a, s),
                    o = !0
                }
                ,
                this.itemEnd = function(e) {
                    a++,
                    void 0 !== r.onProgress && r.onProgress(e, a, s),
                    a === s && (o = !1,
                    void 0 !== r.onLoad && r.onLoad())
                }
                ,
                this.itemError = function(e) {
                    void 0 !== r.onError && r.onError(e)
                }
                ,
                this.resolveURL = function(e) {
                    return i ? i(e) : e
                }
                ,
                this.setURLModifier = function(e) {
                    return i = e,
                    this
                }
                ,
                this.addHandler = function(e, t) {
                    return l.push(e, t),
                    this
                }
                ,
                this.removeHandler = function(e) {
                    const t = l.indexOf(e);
                    return -1 !== t && l.splice(t, 2),
                    this
                }
                ,
                this.getHandler = function(e) {
                    for (let t = 0, n = l.length; t < n; t += 2) {
                        const n = l[t]
                          , r = l[t + 1];
                        if (n.global && (n.lastIndex = 0),
                        n.test(e))
                            return r
                    }
                    return null
                }
            }
        }
        const AE = new _E;
        class xE {
            constructor(e) {
                this.manager = void 0 !== e ? e : AE,
                this.crossOrigin = "anonymous",
                this.withCredentials = !1,
                this.path = "",
                this.resourcePath = "",
                this.requestHeader = {}
            }
            load() {}
            loadAsync(e, t) {
                const n = this;
                return new Promise((function(r, i) {
                    n.load(e, r, t, i)
                }
                ))
            }
            parse() {}
            setCrossOrigin(e) {
                return this.crossOrigin = e,
                this
            }
            setWithCredentials(e) {
                return this.withCredentials = e,
                this
            }
            setPath(e) {
                return this.path = e,
                this
            }
            setResourcePath(e) {
                return this.resourcePath = e,
                this
            }
            setRequestHeader(e) {
                return this.requestHeader = e,
                this
            }
        }
        xE.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const SE = {};
        class wE extends Error {
            constructor(e, t) {
                super(e),
                this.response = t
            }
        }
        class EE extends xE {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                void 0 === e && (e = ""),
                void 0 !== this.path && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const i = bE.get(e);
                if (void 0 !== i)
                    return this.manager.itemStart(e),
                    setTimeout(( () => {
                        t && t(i),
                        this.manager.itemEnd(e)
                    }
                    ), 0),
                    i;
                if (void 0 !== SE[e])
                    return void SE[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: r
                    });
                SE[e] = [],
                SE[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: r
                });
                const o = new Request(e,{
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                })
                  , a = this.mimeType
                  , s = this.responseType;
                fetch(o).then((t => {
                    if (200 === t.status || 0 === t.status) {
                        if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                        "undefined" === typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader)
                            return t;
                        const n = SE[e]
                          , r = t.body.getReader()
                          , i = t.headers.get("Content-Length") || t.headers.get("X-File-Size")
                          , o = i ? parseInt(i) : 0
                          , a = 0 !== o;
                        let s = 0;
                        const l = new ReadableStream({
                            start(e) {
                                !function t() {
                                    r.read().then((r => {
                                        let {done: i, value: l} = r;
                                        if (i)
                                            e.close();
                                        else {
                                            s += l.byteLength;
                                            const r = new ProgressEvent("progress",{
                                                lengthComputable: a,
                                                loaded: s,
                                                total: o
                                            });
                                            for (let e = 0, t = n.length; e < t; e++) {
                                                const t = n[e];
                                                t.onProgress && t.onProgress(r)
                                            }
                                            e.enqueue(l),
                                            t()
                                        }
                                    }
                                    ))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw new wE(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,t)
                }
                )).then((e => {
                    switch (s) {
                    case "arraybuffer":
                        return e.arrayBuffer();
                    case "blob":
                        return e.blob();
                    case "document":
                        return e.text().then((e => (new DOMParser).parseFromString(e, a)));
                    case "json":
                        return e.json();
                    default:
                        if (void 0 === a)
                            return e.text();
                        {
                            const t = /charset="?([^;"\s]*)"?/i.exec(a)
                              , n = t && t[1] ? t[1].toLowerCase() : void 0
                              , r = new TextDecoder(n);
                            return e.arrayBuffer().then((e => r.decode(e)))
                        }
                    }
                }
                )).then((t => {
                    bE.add(e, t);
                    const n = SE[e];
                    delete SE[e];
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        r.onLoad && r.onLoad(t)
                    }
                }
                )).catch((t => {
                    const n = SE[e];
                    if (void 0 === n)
                        throw this.manager.itemError(e),
                        t;
                    delete SE[e];
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        r.onError && r.onError(t)
                    }
                    this.manager.itemError(e)
                }
                )).finally(( () => {
                    this.manager.itemEnd(e)
                }
                )),
                this.manager.itemStart(e)
            }
            setResponseType(e) {
                return this.responseType = e,
                this
            }
            setMimeType(e) {
                return this.mimeType = e,
                this
            }
        }
        class ME extends xE {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = this
                  , o = new EE(this.manager);
                o.setPath(this.path),
                o.setRequestHeader(this.requestHeader),
                o.setWithCredentials(this.withCredentials),
                o.load(e, (function(n) {
                    try {
                        t(i.parse(JSON.parse(n)))
                    } catch (o) {
                        r ? r(o) : console.error(o),
                        i.manager.itemError(e)
                    }
                }
                ), n, r)
            }
            parse(e) {
                const t = [];
                for (let n = 0; n < e.length; n++) {
                    const r = vE.parse(e[n]);
                    t.push(r)
                }
                return t
            }
        }
        class CE extends xE {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = this
                  , o = []
                  , a = new gS
                  , s = new EE(this.manager);
                s.setPath(this.path),
                s.setResponseType("arraybuffer"),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(i.withCredentials);
                let l = 0;
                function c(c) {
                    s.load(e[c], (function(e) {
                        const n = i.parse(e, !0);
                        o[c] = {
                            width: n.width,
                            height: n.height,
                            format: n.format,
                            mipmaps: n.mipmaps
                        },
                        l += 1,
                        6 === l && (1 === n.mipmapCount && (a.minFilter = cp),
                        a.image = o,
                        a.format = n.format,
                        a.needsUpdate = !0,
                        t && t(a))
                    }
                    ), n, r)
                }
                if (Array.isArray(e))
                    for (let u = 0, d = e.length; u < d; ++u)
                        c(u);
                else
                    s.load(e, (function(e) {
                        const n = i.parse(e, !0);
                        if (n.isCubemap) {
                            const e = n.mipmaps.length / n.mipmapCount;
                            for (let t = 0; t < e; t++) {
                                o[t] = {
                                    mipmaps: []
                                };
                                for (let e = 0; e < n.mipmapCount; e++)
                                    o[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]),
                                    o[t].format = n.format,
                                    o[t].width = n.width,
                                    o[t].height = n.height
                            }
                            a.image = o
                        } else
                            a.image.width = n.width,
                            a.image.height = n.height,
                            a.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (a.minFilter = cp),
                        a.format = n.format,
                        a.needsUpdate = !0,
                        t && t(a)
                    }
                    ), n, r);
                return a
            }
        }
        class TE extends xE {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                void 0 !== this.path && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const i = this
                  , o = bE.get(e);
                if (void 0 !== o)
                    return i.manager.itemStart(e),
                    setTimeout((function() {
                        t && t(o),
                        i.manager.itemEnd(e)
                    }
                    ), 0),
                    o;
                const a = Km("img");
                function s() {
                    c(),
                    bE.add(e, this),
                    t && t(this),
                    i.manager.itemEnd(e)
                }
                function l(t) {
                    c(),
                    r && r(t),
                    i.manager.itemError(e),
                    i.manager.itemEnd(e)
                }
                function c() {
                    a.removeEventListener("load", s, !1),
                    a.removeEventListener("error", l, !1)
                }
                return a.addEventListener("load", s, !1),
                a.addEventListener("error", l, !1),
                "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
                i.manager.itemStart(e),
                a.src = e,
                a
            }
        }
        class RE extends xE {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = new Vy;
                i.colorSpace = Of;
                const o = new TE(this.manager);
                o.setCrossOrigin(this.crossOrigin),
                o.setPath(this.path);
                let a = 0;
                function s(n) {
                    o.load(e[n], (function(e) {
                        i.images[n] = e,
                        a++,
                        6 === a && (i.needsUpdate = !0,
                        t && t(i))
                    }
                    ), void 0, r)
                }
                for (let l = 0; l < e.length; ++l)
                    s(l);
                return i
            }
        }
        class PE extends xE {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = this
                  , o = new _x
                  , a = new EE(this.manager);
                return a.setResponseType("arraybuffer"),
                a.setRequestHeader(this.requestHeader),
                a.setPath(this.path),
                a.setWithCredentials(i.withCredentials),
                a.load(e, (function(e) {
                    let n;
                    try {
                        n = i.parse(e)
                    } catch (a) {
                        if (void 0 === r)
                            return void console.error(a);
                        r(a)
                    }
                    void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width,
                    o.image.height = n.height,
                    o.image.data = n.data),
                    o.wrapS = void 0 !== n.wrapS ? n.wrapS : np,
                    o.wrapT = void 0 !== n.wrapT ? n.wrapT : np,
                    o.magFilter = void 0 !== n.magFilter ? n.magFilter : cp,
                    o.minFilter = void 0 !== n.minFilter ? n.minFilter : cp,
                    o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
                    void 0 !== n.colorSpace ? o.colorSpace = n.colorSpace : void 0 !== n.encoding && (o.encoding = n.encoding),
                    void 0 !== n.flipY && (o.flipY = n.flipY),
                    void 0 !== n.format && (o.format = n.format),
                    void 0 !== n.type && (o.type = n.type),
                    void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps,
                    o.minFilter = hp),
                    1 === n.mipmapCount && (o.minFilter = cp),
                    void 0 !== n.generateMipmaps && (o.generateMipmaps = n.generateMipmaps),
                    o.needsUpdate = !0,
                    t && t(o, n)
                }
                ), n, r),
                o
            }
        }
        class BE extends xE {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = new dg
                  , o = new TE(this.manager);
                return o.setCrossOrigin(this.crossOrigin),
                o.setPath(this.path),
                o.load(e, (function(e) {
                    i.image = e,
                    i.needsUpdate = !0,
                    void 0 !== t && t(i)
                }
                ), n, r),
                i
            }
        }
        class IE extends xv {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                super(),
                this.isLight = !0,
                this.type = "Light",
                this.color = new Uv(e),
                this.intensity = t
            }
            dispose() {}
            copy(e, t) {
                return super.copy(e, t),
                this.color.copy(e.color),
                this.intensity = e.intensity,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.color = this.color.getHex(),
                t.object.intensity = this.intensity,
                void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
                void 0 !== this.distance && (t.object.distance = this.distance),
                void 0 !== this.angle && (t.object.angle = this.angle),
                void 0 !== this.decay && (t.object.decay = this.decay),
                void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
                void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
                t
            }
        }
        class LE extends IE {
            constructor(e, t, n) {
                super(e, n),
                this.isHemisphereLight = !0,
                this.type = "HemisphereLight",
                this.position.copy(xv.DEFAULT_UP),
                this.updateMatrix(),
                this.groundColor = new Uv(t)
            }
            copy(e, t) {
                return super.copy(e, t),
                this.groundColor.copy(e.groundColor),
                this
            }
        }
        const kE = new Qg
          , DE = new Ag
          , OE = new Ag;
        class NE {
            constructor(e) {
                this.camera = e,
                this.bias = 0,
                this.normalBias = 0,
                this.radius = 1,
                this.blurSamples = 8,
                this.mapSize = new Hm(512,512),
                this.map = null,
                this.mapPass = null,
                this.matrix = new Qg,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this._frustum = new $y,
                this._frameExtents = new Hm(1,1),
                this._viewportCount = 1,
                this._viewports = [new hg(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(e) {
                const t = this.camera
                  , n = this.matrix;
                DE.setFromMatrixPosition(e.matrixWorld),
                t.position.copy(DE),
                OE.setFromMatrixPosition(e.target.matrixWorld),
                t.lookAt(OE),
                t.updateMatrixWorld(),
                kE.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(kE),
                n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                n.multiply(kE)
            }
            getViewport(e) {
                return this._viewports[e]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(),
                this.mapPass && this.mapPass.dispose()
            }
            copy(e) {
                return this.camera = e.camera.clone(),
                this.bias = e.bias,
                this.radius = e.radius,
                this.mapSize.copy(e.mapSize),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const e = {};
                return 0 !== this.bias && (e.bias = this.bias),
                0 !== this.normalBias && (e.normalBias = this.normalBias),
                1 !== this.radius && (e.radius = this.radius),
                512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
                e.camera = this.camera.toJSON(!1).object,
                delete e.camera.matrix,
                e
            }
        }
        class FE extends NE {
            constructor() {
                super(new Hy(50,1,.5,500)),
                this.isSpotLightShadow = !0,
                this.focus = 1
            }
            updateMatrices(e) {
                const t = this.camera
                  , n = 2 * Im * e.angle * this.focus
                  , r = this.mapSize.width / this.mapSize.height
                  , i = e.distance || t.far;
                n === t.fov && r === t.aspect && i === t.far || (t.fov = n,
                t.aspect = r,
                t.far = i,
                t.updateProjectionMatrix()),
                super.updateMatrices(e)
            }
            copy(e) {
                return super.copy(e),
                this.focus = e.focus,
                this
            }
        }
        class UE extends IE {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Math.PI / 3
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0
                  , o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2;
                super(e, t),
                this.isSpotLight = !0,
                this.type = "SpotLight",
                this.position.copy(xv.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new xv,
                this.distance = n,
                this.angle = r,
                this.penumbra = i,
                this.decay = o,
                this.map = null,
                this.shadow = new FE
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.distance = e.distance,
                this.angle = e.angle,
                this.penumbra = e.penumbra,
                this.decay = e.decay,
                this.target = e.target.clone(),
                this.shadow = e.shadow.clone(),
                this
            }
        }
        const zE = new Qg
          , GE = new Ag
          , HE = new Ag;
        class jE extends NE {
            constructor() {
                super(new Hy(90,1,.5,500)),
                this.isPointLightShadow = !0,
                this._frameExtents = new Hm(4,2),
                this._viewportCount = 6,
                this._viewports = [new hg(2,1,1,1), new hg(0,1,1,1), new hg(3,1,1,1), new hg(1,1,1,1), new hg(3,0,1,1), new hg(1,0,1,1)],
                this._cubeDirections = [new Ag(1,0,0), new Ag(-1,0,0), new Ag(0,0,1), new Ag(0,0,-1), new Ag(0,1,0), new Ag(0,-1,0)],
                this._cubeUps = [new Ag(0,1,0), new Ag(0,1,0), new Ag(0,1,0), new Ag(0,1,0), new Ag(0,0,1), new Ag(0,0,-1)]
            }
            updateMatrices(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.camera
                  , r = this.matrix
                  , i = e.distance || n.far;
                i !== n.far && (n.far = i,
                n.updateProjectionMatrix()),
                GE.setFromMatrixPosition(e.matrixWorld),
                n.position.copy(GE),
                HE.copy(n.position),
                HE.add(this._cubeDirections[t]),
                n.up.copy(this._cubeUps[t]),
                n.lookAt(HE),
                n.updateMatrixWorld(),
                r.makeTranslation(-GE.x, -GE.y, -GE.z),
                zE.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(zE)
            }
        }
        class WE extends IE {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2;
                super(e, t),
                this.isPointLight = !0,
                this.type = "PointLight",
                this.distance = n,
                this.decay = r,
                this.shadow = new jE
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.distance = e.distance,
                this.decay = e.decay,
                this.shadow = e.shadow.clone(),
                this
            }
        }
        class VE extends NE {
            constructor() {
                super(new pb(-5,5,5,-5,.5,500)),
                this.isDirectionalLightShadow = !0
            }
        }
        class XE extends IE {
            constructor(e, t) {
                super(e, t),
                this.isDirectionalLight = !0,
                this.type = "DirectionalLight",
                this.position.copy(xv.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new xv,
                this.shadow = new VE
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e) {
                return super.copy(e),
                this.target = e.target.clone(),
                this.shadow = e.shadow.clone(),
                this
            }
        }
        class JE extends IE {
            constructor(e, t) {
                super(e, t),
                this.isAmbientLight = !0,
                this.type = "AmbientLight"
            }
        }
        class KE extends IE {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 10;
                super(e, t),
                this.isRectAreaLight = !0,
                this.type = "RectAreaLight",
                this.width = n,
                this.height = r
            }
            get power() {
                return this.intensity * this.width * this.height * Math.PI
            }
            set power(e) {
                this.intensity = e / (this.width * this.height * Math.PI)
            }
            copy(e) {
                return super.copy(e),
                this.width = e.width,
                this.height = e.height,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.width = this.width,
                t.object.height = this.height,
                t
            }
        }
        class qE {
            constructor() {
                this.isSphericalHarmonics3 = !0,
                this.coefficients = [];
                for (let e = 0; e < 9; e++)
                    this.coefficients.push(new Ag)
            }
            set(e) {
                for (let t = 0; t < 9; t++)
                    this.coefficients[t].copy(e[t]);
                return this
            }
            zero() {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].set(0, 0, 0);
                return this
            }
            getAt(e, t) {
                const n = e.x
                  , r = e.y
                  , i = e.z
                  , o = this.coefficients;
                return t.copy(o[0]).multiplyScalar(.282095),
                t.addScaledVector(o[1], .488603 * r),
                t.addScaledVector(o[2], .488603 * i),
                t.addScaledVector(o[3], .488603 * n),
                t.addScaledVector(o[4], n * r * 1.092548),
                t.addScaledVector(o[5], r * i * 1.092548),
                t.addScaledVector(o[6], .315392 * (3 * i * i - 1)),
                t.addScaledVector(o[7], n * i * 1.092548),
                t.addScaledVector(o[8], .546274 * (n * n - r * r)),
                t
            }
            getIrradianceAt(e, t) {
                const n = e.x
                  , r = e.y
                  , i = e.z
                  , o = this.coefficients;
                return t.copy(o[0]).multiplyScalar(.886227),
                t.addScaledVector(o[1], 1.023328 * r),
                t.addScaledVector(o[2], 1.023328 * i),
                t.addScaledVector(o[3], 1.023328 * n),
                t.addScaledVector(o[4], .858086 * n * r),
                t.addScaledVector(o[5], .858086 * r * i),
                t.addScaledVector(o[6], .743125 * i * i - .247708),
                t.addScaledVector(o[7], .858086 * n * i),
                t.addScaledVector(o[8], .429043 * (n * n - r * r)),
                t
            }
            add(e) {
                for (let t = 0; t < 9; t++)
                    this.coefficients[t].add(e.coefficients[t]);
                return this
            }
            addScaledSH(e, t) {
                for (let n = 0; n < 9; n++)
                    this.coefficients[n].addScaledVector(e.coefficients[n], t);
                return this
            }
            scale(e) {
                for (let t = 0; t < 9; t++)
                    this.coefficients[t].multiplyScalar(e);
                return this
            }
            lerp(e, t) {
                for (let n = 0; n < 9; n++)
                    this.coefficients[n].lerp(e.coefficients[n], t);
                return this
            }
            equals(e) {
                for (let t = 0; t < 9; t++)
                    if (!this.coefficients[t].equals(e.coefficients[t]))
                        return !1;
                return !0
            }
            copy(e) {
                return this.set(e.coefficients)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.coefficients;
                for (let r = 0; r < 9; r++)
                    n[r].fromArray(e, t + 3 * r);
                return this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.coefficients;
                for (let r = 0; r < 9; r++)
                    n[r].toArray(e, t + 3 * r);
                return e
            }
            static getBasisAt(e, t) {
                const n = e.x
                  , r = e.y
                  , i = e.z;
                t[0] = .282095,
                t[1] = .488603 * r,
                t[2] = .488603 * i,
                t[3] = .488603 * n,
                t[4] = 1.092548 * n * r,
                t[5] = 1.092548 * r * i,
                t[6] = .315392 * (3 * i * i - 1),
                t[7] = 1.092548 * n * i,
                t[8] = .546274 * (n * n - r * r)
            }
        }
        class YE extends IE {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new qE;
                super(void 0, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1),
                this.isLightProbe = !0,
                this.sh = e
            }
            copy(e) {
                return super.copy(e),
                this.sh.copy(e.sh),
                this
            }
            fromJSON(e) {
                return this.intensity = e.intensity,
                this.sh.fromArray(e.sh),
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.sh = this.sh.toArray(),
                t
            }
        }
        class QE extends xE {
            constructor(e) {
                super(e),
                this.textures = {}
            }
            load(e, t, n, r) {
                const i = this
                  , o = new EE(i.manager);
                o.setPath(i.path),
                o.setRequestHeader(i.requestHeader),
                o.setWithCredentials(i.withCredentials),
                o.load(e, (function(n) {
                    try {
                        t(i.parse(JSON.parse(n)))
                    } catch (o) {
                        r ? r(o) : console.error(o),
                        i.manager.itemError(e)
                    }
                }
                ), n, r)
            }
            parse(e) {
                const t = this.textures;
                function n(e) {
                    return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e),
                    t[e]
                }
                const r = QE.createMaterialFromType(e.type);
                if (void 0 !== e.uuid && (r.uuid = e.uuid),
                void 0 !== e.name && (r.name = e.name),
                void 0 !== e.color && void 0 !== r.color && r.color.setHex(e.color),
                void 0 !== e.roughness && (r.roughness = e.roughness),
                void 0 !== e.metalness && (r.metalness = e.metalness),
                void 0 !== e.sheen && (r.sheen = e.sheen),
                void 0 !== e.sheenColor && (r.sheenColor = (new Uv).setHex(e.sheenColor)),
                void 0 !== e.sheenRoughness && (r.sheenRoughness = e.sheenRoughness),
                void 0 !== e.emissive && void 0 !== r.emissive && r.emissive.setHex(e.emissive),
                void 0 !== e.specular && void 0 !== r.specular && r.specular.setHex(e.specular),
                void 0 !== e.specularIntensity && (r.specularIntensity = e.specularIntensity),
                void 0 !== e.specularColor && void 0 !== r.specularColor && r.specularColor.setHex(e.specularColor),
                void 0 !== e.shininess && (r.shininess = e.shininess),
                void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat),
                void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness),
                void 0 !== e.iridescence && (r.iridescence = e.iridescence),
                void 0 !== e.iridescenceIOR && (r.iridescenceIOR = e.iridescenceIOR),
                void 0 !== e.iridescenceThicknessRange && (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
                void 0 !== e.transmission && (r.transmission = e.transmission),
                void 0 !== e.thickness && (r.thickness = e.thickness),
                void 0 !== e.attenuationDistance && (r.attenuationDistance = e.attenuationDistance),
                void 0 !== e.attenuationColor && void 0 !== r.attenuationColor && r.attenuationColor.setHex(e.attenuationColor),
                void 0 !== e.anisotropy && (r.anisotropy = e.anisotropy),
                void 0 !== e.anisotropyRotation && (r.anisotropyRotation = e.anisotropyRotation),
                void 0 !== e.fog && (r.fog = e.fog),
                void 0 !== e.flatShading && (r.flatShading = e.flatShading),
                void 0 !== e.blending && (r.blending = e.blending),
                void 0 !== e.combine && (r.combine = e.combine),
                void 0 !== e.side && (r.side = e.side),
                void 0 !== e.shadowSide && (r.shadowSide = e.shadowSide),
                void 0 !== e.opacity && (r.opacity = e.opacity),
                void 0 !== e.transparent && (r.transparent = e.transparent),
                void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest),
                void 0 !== e.alphaHash && (r.alphaHash = e.alphaHash),
                void 0 !== e.depthFunc && (r.depthFunc = e.depthFunc),
                void 0 !== e.depthTest && (r.depthTest = e.depthTest),
                void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite),
                void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite),
                void 0 !== e.blendSrc && (r.blendSrc = e.blendSrc),
                void 0 !== e.blendDst && (r.blendDst = e.blendDst),
                void 0 !== e.blendEquation && (r.blendEquation = e.blendEquation),
                void 0 !== e.blendSrcAlpha && (r.blendSrcAlpha = e.blendSrcAlpha),
                void 0 !== e.blendDstAlpha && (r.blendDstAlpha = e.blendDstAlpha),
                void 0 !== e.blendEquationAlpha && (r.blendEquationAlpha = e.blendEquationAlpha),
                void 0 !== e.blendColor && void 0 !== r.blendColor && r.blendColor.setHex(e.blendColor),
                void 0 !== e.blendAlpha && (r.blendAlpha = e.blendAlpha),
                void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask),
                void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc),
                void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef),
                void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask),
                void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail),
                void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail),
                void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass),
                void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite),
                void 0 !== e.wireframe && (r.wireframe = e.wireframe),
                void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth),
                void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap),
                void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin),
                void 0 !== e.rotation && (r.rotation = e.rotation),
                void 0 !== e.linewidth && (r.linewidth = e.linewidth),
                void 0 !== e.dashSize && (r.dashSize = e.dashSize),
                void 0 !== e.gapSize && (r.gapSize = e.gapSize),
                void 0 !== e.scale && (r.scale = e.scale),
                void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset),
                void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor),
                void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits),
                void 0 !== e.dithering && (r.dithering = e.dithering),
                void 0 !== e.alphaToCoverage && (r.alphaToCoverage = e.alphaToCoverage),
                void 0 !== e.premultipliedAlpha && (r.premultipliedAlpha = e.premultipliedAlpha),
                void 0 !== e.forceSinglePass && (r.forceSinglePass = e.forceSinglePass),
                void 0 !== e.visible && (r.visible = e.visible),
                void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped),
                void 0 !== e.userData && (r.userData = e.userData),
                void 0 !== e.vertexColors && ("number" === typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors),
                void 0 !== e.uniforms)
                    for (const i in e.uniforms) {
                        const t = e.uniforms[i];
                        switch (r.uniforms[i] = {},
                        t.type) {
                        case "t":
                            r.uniforms[i].value = n(t.value);
                            break;
                        case "c":
                            r.uniforms[i].value = (new Uv).setHex(t.value);
                            break;
                        case "v2":
                            r.uniforms[i].value = (new Hm).fromArray(t.value);
                            break;
                        case "v3":
                            r.uniforms[i].value = (new Ag).fromArray(t.value);
                            break;
                        case "v4":
                            r.uniforms[i].value = (new hg).fromArray(t.value);
                            break;
                        case "m3":
                            r.uniforms[i].value = (new jm).fromArray(t.value);
                            break;
                        case "m4":
                            r.uniforms[i].value = (new Qg).fromArray(t.value);
                            break;
                        default:
                            r.uniforms[i].value = t.value
                        }
                    }
                if (void 0 !== e.defines && (r.defines = e.defines),
                void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader),
                void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader),
                void 0 !== e.glslVersion && (r.glslVersion = e.glslVersion),
                void 0 !== e.extensions)
                    for (const i in e.extensions)
                        r.extensions[i] = e.extensions[i];
                if (void 0 !== e.lights && (r.lights = e.lights),
                void 0 !== e.clipping && (r.clipping = e.clipping),
                void 0 !== e.size && (r.size = e.size),
                void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation),
                void 0 !== e.map && (r.map = n(e.map)),
                void 0 !== e.matcap && (r.matcap = n(e.matcap)),
                void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)),
                void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)),
                void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale),
                void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)),
                void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType),
                void 0 !== e.normalScale) {
                    let t = e.normalScale;
                    !1 === Array.isArray(t) && (t = [t, t]),
                    r.normalScale = (new Hm).fromArray(t)
                }
                return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)),
                void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale),
                void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias),
                void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)),
                void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)),
                void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)),
                void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity),
                void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)),
                void 0 !== e.specularIntensityMap && (r.specularIntensityMap = n(e.specularIntensityMap)),
                void 0 !== e.specularColorMap && (r.specularColorMap = n(e.specularColorMap)),
                void 0 !== e.envMap && (r.envMap = n(e.envMap)),
                void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity),
                void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity),
                void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio),
                void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)),
                void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity),
                void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)),
                void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity),
                void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)),
                void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)),
                void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
                void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)),
                void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = (new Hm).fromArray(e.clearcoatNormalScale)),
                void 0 !== e.iridescenceMap && (r.iridescenceMap = n(e.iridescenceMap)),
                void 0 !== e.iridescenceThicknessMap && (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)),
                void 0 !== e.transmissionMap && (r.transmissionMap = n(e.transmissionMap)),
                void 0 !== e.thicknessMap && (r.thicknessMap = n(e.thicknessMap)),
                void 0 !== e.anisotropyMap && (r.anisotropyMap = n(e.anisotropyMap)),
                void 0 !== e.sheenColorMap && (r.sheenColorMap = n(e.sheenColorMap)),
                void 0 !== e.sheenRoughnessMap && (r.sheenRoughnessMap = n(e.sheenRoughnessMap)),
                r
            }
            setTextures(e) {
                return this.textures = e,
                this
            }
            static createMaterialFromType(e) {
                return new {
                    ShadowMaterial: jw,
                    SpriteMaterial: WA,
                    RawShaderMaterial: Ww,
                    ShaderMaterial: zy,
                    PointsMaterial: sS,
                    MeshPhysicalMaterial: Xw,
                    MeshStandardMaterial: Vw,
                    MeshPhongMaterial: Jw,
                    MeshToonMaterial: Kw,
                    MeshNormalMaterial: qw,
                    MeshLambertMaterial: Yw,
                    MeshDepthMaterial: SA,
                    MeshDistanceMaterial: wA,
                    MeshBasicMaterial: jv,
                    MeshMatcapMaterial: Qw,
                    LineDashedMaterial: Zw,
                    LineBasicMaterial: Yx,
                    Material: Hv
                }[e]
            }
        }
        class ZE {
            static decodeText(e) {
                if ("undefined" !== typeof TextDecoder)
                    return (new TextDecoder).decode(e);
                let t = "";
                for (let r = 0, i = e.length; r < i; r++)
                    t += String.fromCharCode(e[r]);
                try {
                    return decodeURIComponent(escape(t))
                } catch (n) {
                    return t
                }
            }
            static extractUrlBase(e) {
                const t = e.lastIndexOf("/");
                return -1 === t ? "./" : e.slice(0, t + 1)
            }
            static resolveURL(e, t) {
                return "string" !== typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
            }
        }
        class $E extends my {
            constructor() {
                super(),
                this.isInstancedBufferGeometry = !0,
                this.type = "InstancedBufferGeometry",
                this.instanceCount = 1 / 0
            }
            copy(e) {
                return super.copy(e),
                this.instanceCount = e.instanceCount,
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.instanceCount = this.instanceCount,
                e.isInstancedBufferGeometry = !0,
                e
            }
        }
        class eM extends xE {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = this
                  , o = new EE(i.manager);
                o.setPath(i.path),
                o.setRequestHeader(i.requestHeader),
                o.setWithCredentials(i.withCredentials),
                o.load(e, (function(n) {
                    try {
                        t(i.parse(JSON.parse(n)))
                    } catch (o) {
                        r ? r(o) : console.error(o),
                        i.manager.itemError(e)
                    }
                }
                ), n, r)
            }
            parse(e) {
                const t = {}
                  , n = {};
                function r(e, r) {
                    if (void 0 !== t[r])
                        return t[r];
                    const i = e.interleavedBuffers[r]
                      , o = function(e, t) {
                        if (void 0 !== n[t])
                            return n[t];
                        const r = e.arrayBuffers
                          , i = r[t]
                          , o = new Uint32Array(i).buffer;
                        return n[t] = o,
                        o
                    }(e, i.buffer)
                      , a = Jm(i.type, o)
                      , s = new GA(a,i.stride);
                    return s.uuid = i.uuid,
                    t[r] = s,
                    s
                }
                const i = e.isInstancedBufferGeometry ? new $E : new my
                  , o = e.data.index;
                if (void 0 !== o) {
                    const e = Jm(o.type, o.array);
                    i.setIndex(new Qv(e,1))
                }
                const a = e.data.attributes;
                for (const u in a) {
                    const t = a[u];
                    let n;
                    if (t.isInterleavedBufferAttribute) {
                        const i = r(e.data, t.data);
                        n = new jA(i,t.itemSize,t.offset,t.normalized)
                    } else {
                        const e = Jm(t.type, t.array);
                        n = new (t.isInstancedBufferAttribute ? wx : Qv)(e,t.itemSize,t.normalized)
                    }
                    void 0 !== t.name && (n.name = t.name),
                    void 0 !== t.usage && n.setUsage(t.usage),
                    i.setAttribute(u, n)
                }
                const s = e.data.morphAttributes;
                if (s)
                    for (const u in s) {
                        const t = s[u]
                          , n = [];
                        for (let i = 0, o = t.length; i < o; i++) {
                            const o = t[i];
                            let a;
                            if (o.isInterleavedBufferAttribute) {
                                const t = r(e.data, o.data);
                                a = new jA(t,o.itemSize,o.offset,o.normalized)
                            } else {
                                const e = Jm(o.type, o.array);
                                a = new Qv(e,o.itemSize,o.normalized)
                            }
                            void 0 !== o.name && (a.name = o.name),
                            n.push(a)
                        }
                        i.morphAttributes[u] = n
                    }
                e.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
                const l = e.data.groups || e.data.drawcalls || e.data.offsets;
                if (void 0 !== l)
                    for (let u = 0, d = l.length; u !== d; ++u) {
                        const e = l[u];
                        i.addGroup(e.start, e.count, e.materialIndex)
                    }
                const c = e.data.boundingSphere;
                if (void 0 !== c) {
                    const e = new Ag;
                    void 0 !== c.center && e.fromArray(c.center),
                    i.boundingSphere = new Hg(e,c.radius)
                }
                return e.name && (i.name = e.name),
                e.userData && (i.userData = e.userData),
                i
            }
        }
        class tM extends xE {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = this
                  , o = "" === this.path ? ZE.extractUrlBase(e) : this.path;
                this.resourcePath = this.resourcePath || o;
                const a = new EE(this.manager);
                a.setPath(this.path),
                a.setRequestHeader(this.requestHeader),
                a.setWithCredentials(this.withCredentials),
                a.load(e, (function(n) {
                    let o = null;
                    try {
                        o = JSON.parse(n)
                    } catch (s) {
                        return void 0 !== r && r(s),
                        void console.error("THREE:ObjectLoader: Can't parse " + e + ".", s.message)
                    }
                    const a = o.metadata;
                    if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase())
                        return void 0 !== r && r(new Error("THREE.ObjectLoader: Can't load " + e)),
                        void console.error("THREE.ObjectLoader: Can't load " + e);
                    i.parse(o, t)
                }
                ), n, r)
            }
            async loadAsync(e, t) {
                const n = "" === this.path ? ZE.extractUrlBase(e) : this.path;
                this.resourcePath = this.resourcePath || n;
                const r = new EE(this.manager);
                r.setPath(this.path),
                r.setRequestHeader(this.requestHeader),
                r.setWithCredentials(this.withCredentials);
                const i = await r.loadAsync(e, t)
                  , o = JSON.parse(i)
                  , a = o.metadata;
                if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase())
                    throw new Error("THREE.ObjectLoader: Can't load " + e);
                return await this.parseAsync(o)
            }
            parse(e, t) {
                const n = this.parseAnimations(e.animations)
                  , r = this.parseShapes(e.shapes)
                  , i = this.parseGeometries(e.geometries, r)
                  , o = this.parseImages(e.images, (function() {
                    void 0 !== t && t(l)
                }
                ))
                  , a = this.parseTextures(e.textures, o)
                  , s = this.parseMaterials(e.materials, a)
                  , l = this.parseObject(e.object, i, s, a, n)
                  , c = this.parseSkeletons(e.skeletons, l);
                if (this.bindSkeletons(l, c),
                void 0 !== t) {
                    let e = !1;
                    for (const t in o)
                        if (o[t].data instanceof HTMLImageElement) {
                            e = !0;
                            break
                        }
                    !1 === e && t(l)
                }
                return l
            }
            async parseAsync(e) {
                const t = this.parseAnimations(e.animations)
                  , n = this.parseShapes(e.shapes)
                  , r = this.parseGeometries(e.geometries, n)
                  , i = await this.parseImagesAsync(e.images)
                  , o = this.parseTextures(e.textures, i)
                  , a = this.parseMaterials(e.materials, o)
                  , s = this.parseObject(e.object, r, a, o, t)
                  , l = this.parseSkeletons(e.skeletons, s);
                return this.bindSkeletons(s, l),
                s
            }
            parseShapes(e) {
                const t = {};
                if (void 0 !== e)
                    for (let n = 0, r = e.length; n < r; n++) {
                        const r = (new ew).fromJSON(e[n]);
                        t[r.uuid] = r
                    }
                return t
            }
            parseSkeletons(e, t) {
                const n = {}
                  , r = {};
                if (t.traverse((function(e) {
                    e.isBone && (r[e.uuid] = e)
                }
                )),
                void 0 !== e)
                    for (let i = 0, o = e.length; i < o; i++) {
                        const t = (new Sx).fromJSON(e[i], r);
                        n[t.uuid] = t
                    }
                return n
            }
            parseGeometries(e, t) {
                const n = {};
                if (void 0 !== e) {
                    const r = new eM;
                    for (let i = 0, o = e.length; i < o; i++) {
                        let o;
                        const a = e[i];
                        switch (a.type) {
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            o = r.parse(a);
                            break;
                        default:
                            a.type in Hw ? o = Hw[a.type].fromJSON(a, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)
                        }
                        o.uuid = a.uuid,
                        void 0 !== a.name && (o.name = a.name),
                        void 0 !== a.userData && (o.userData = a.userData),
                        n[a.uuid] = o
                    }
                }
                return n
            }
            parseMaterials(e, t) {
                const n = {}
                  , r = {};
                if (void 0 !== e) {
                    const i = new QE;
                    i.setTextures(t);
                    for (let t = 0, o = e.length; t < o; t++) {
                        const o = e[t];
                        void 0 === n[o.uuid] && (n[o.uuid] = i.parse(o)),
                        r[o.uuid] = n[o.uuid]
                    }
                }
                return r
            }
            parseAnimations(e) {
                const t = {};
                if (void 0 !== e)
                    for (let n = 0; n < e.length; n++) {
                        const r = e[n]
                          , i = vE.parse(r);
                        t[i.uuid] = i
                    }
                return t
            }
            parseImages(e, t) {
                const n = this
                  , r = {};
                let i;
                function o(e) {
                    if ("string" === typeof e) {
                        const t = e;
                        return function(e) {
                            return n.manager.itemStart(e),
                            i.load(e, (function() {
                                n.manager.itemEnd(e)
                            }
                            ), void 0, (function() {
                                n.manager.itemError(e),
                                n.manager.itemEnd(e)
                            }
                            ))
                        }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : n.resourcePath + t)
                    }
                    return e.data ? {
                        data: Jm(e.type, e.data),
                        width: e.width,
                        height: e.height
                    } : null
                }
                if (void 0 !== e && e.length > 0) {
                    const n = new _E(t);
                    i = new TE(n),
                    i.setCrossOrigin(this.crossOrigin);
                    for (let t = 0, i = e.length; t < i; t++) {
                        const n = e[t]
                          , i = n.url;
                        if (Array.isArray(i)) {
                            const e = [];
                            for (let t = 0, n = i.length; t < n; t++) {
                                const n = o(i[t]);
                                null !== n && (n instanceof HTMLImageElement ? e.push(n) : e.push(new _x(n.data,n.width,n.height)))
                            }
                            r[n.uuid] = new lg(e)
                        } else {
                            const e = o(n.url);
                            r[n.uuid] = new lg(e)
                        }
                    }
                }
                return r
            }
            async parseImagesAsync(e) {
                const t = this
                  , n = {};
                let r;
                async function i(e) {
                    if ("string" === typeof e) {
                        const n = e
                          , i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : t.resourcePath + n;
                        return await r.loadAsync(i)
                    }
                    return e.data ? {
                        data: Jm(e.type, e.data),
                        width: e.width,
                        height: e.height
                    } : null
                }
                if (void 0 !== e && e.length > 0) {
                    r = new TE(this.manager),
                    r.setCrossOrigin(this.crossOrigin);
                    for (let t = 0, r = e.length; t < r; t++) {
                        const r = e[t]
                          , o = r.url;
                        if (Array.isArray(o)) {
                            const e = [];
                            for (let t = 0, n = o.length; t < n; t++) {
                                const n = o[t]
                                  , r = await i(n);
                                null !== r && (r instanceof HTMLImageElement ? e.push(r) : e.push(new _x(r.data,r.width,r.height)))
                            }
                            n[r.uuid] = new lg(e)
                        } else {
                            const e = await i(r.url);
                            n[r.uuid] = new lg(e)
                        }
                    }
                }
                return n
            }
            parseTextures(e, t) {
                function n(e, t) {
                    return "number" === typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e),
                    t[e])
                }
                const r = {};
                if (void 0 !== e)
                    for (let i = 0, o = e.length; i < o; i++) {
                        const o = e[i];
                        void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid),
                        void 0 === t[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image);
                        const a = t[o.image]
                          , s = a.data;
                        let l;
                        Array.isArray(s) ? (l = new Vy,
                        6 === s.length && (l.needsUpdate = !0)) : (l = s && s.data ? new _x : new dg,
                        s && (l.needsUpdate = !0)),
                        l.source = a,
                        l.uuid = o.uuid,
                        void 0 !== o.name && (l.name = o.name),
                        void 0 !== o.mapping && (l.mapping = n(o.mapping, nM)),
                        void 0 !== o.channel && (l.channel = o.channel),
                        void 0 !== o.offset && l.offset.fromArray(o.offset),
                        void 0 !== o.repeat && l.repeat.fromArray(o.repeat),
                        void 0 !== o.center && l.center.fromArray(o.center),
                        void 0 !== o.rotation && (l.rotation = o.rotation),
                        void 0 !== o.wrap && (l.wrapS = n(o.wrap[0], rM),
                        l.wrapT = n(o.wrap[1], rM)),
                        void 0 !== o.format && (l.format = o.format),
                        void 0 !== o.internalFormat && (l.internalFormat = o.internalFormat),
                        void 0 !== o.type && (l.type = o.type),
                        void 0 !== o.colorSpace && (l.colorSpace = o.colorSpace),
                        void 0 !== o.encoding && (l.encoding = o.encoding),
                        void 0 !== o.minFilter && (l.minFilter = n(o.minFilter, iM)),
                        void 0 !== o.magFilter && (l.magFilter = n(o.magFilter, iM)),
                        void 0 !== o.anisotropy && (l.anisotropy = o.anisotropy),
                        void 0 !== o.flipY && (l.flipY = o.flipY),
                        void 0 !== o.generateMipmaps && (l.generateMipmaps = o.generateMipmaps),
                        void 0 !== o.premultiplyAlpha && (l.premultiplyAlpha = o.premultiplyAlpha),
                        void 0 !== o.unpackAlignment && (l.unpackAlignment = o.unpackAlignment),
                        void 0 !== o.compareFunction && (l.compareFunction = o.compareFunction),
                        void 0 !== o.userData && (l.userData = o.userData),
                        r[o.uuid] = l
                    }
                return r
            }
            parseObject(e, t, n, r, i) {
                let o, a, s;
                function l(e) {
                    return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e),
                    t[e]
                }
                function c(e) {
                    if (void 0 !== e) {
                        if (Array.isArray(e)) {
                            const t = [];
                            for (let r = 0, i = e.length; r < i; r++) {
                                const i = e[r];
                                void 0 === n[i] && console.warn("THREE.ObjectLoader: Undefined material", i),
                                t.push(n[i])
                            }
                            return t
                        }
                        return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e),
                        n[e]
                    }
                }
                function u(e) {
                    return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined texture", e),
                    r[e]
                }
                switch (e.type) {
                case "Scene":
                    o = new zA,
                    void 0 !== e.background && (Number.isInteger(e.background) ? o.background = new Uv(e.background) : o.background = u(e.background)),
                    void 0 !== e.environment && (o.environment = u(e.environment)),
                    void 0 !== e.fog && ("Fog" === e.fog.type ? o.fog = new UA(e.fog.color,e.fog.near,e.fog.far) : "FogExp2" === e.fog.type && (o.fog = new FA(e.fog.color,e.fog.density)),
                    "" !== e.fog.name && (o.fog.name = e.fog.name)),
                    void 0 !== e.backgroundBlurriness && (o.backgroundBlurriness = e.backgroundBlurriness),
                    void 0 !== e.backgroundIntensity && (o.backgroundIntensity = e.backgroundIntensity);
                    break;
                case "PerspectiveCamera":
                    o = new Hy(e.fov,e.aspect,e.near,e.far),
                    void 0 !== e.focus && (o.focus = e.focus),
                    void 0 !== e.zoom && (o.zoom = e.zoom),
                    void 0 !== e.filmGauge && (o.filmGauge = e.filmGauge),
                    void 0 !== e.filmOffset && (o.filmOffset = e.filmOffset),
                    void 0 !== e.view && (o.view = Object.assign({}, e.view));
                    break;
                case "OrthographicCamera":
                    o = new pb(e.left,e.right,e.top,e.bottom,e.near,e.far),
                    void 0 !== e.zoom && (o.zoom = e.zoom),
                    void 0 !== e.view && (o.view = Object.assign({}, e.view));
                    break;
                case "AmbientLight":
                    o = new JE(e.color,e.intensity);
                    break;
                case "DirectionalLight":
                    o = new XE(e.color,e.intensity);
                    break;
                case "PointLight":
                    o = new WE(e.color,e.intensity,e.distance,e.decay);
                    break;
                case "RectAreaLight":
                    o = new KE(e.color,e.intensity,e.width,e.height);
                    break;
                case "SpotLight":
                    o = new UE(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
                    break;
                case "HemisphereLight":
                    o = new LE(e.color,e.groundColor,e.intensity);
                    break;
                case "LightProbe":
                    o = (new YE).fromJSON(e);
                    break;
                case "SkinnedMesh":
                    a = l(e.geometry),
                    s = c(e.material),
                    o = new yx(a,s),
                    void 0 !== e.bindMode && (o.bindMode = e.bindMode),
                    void 0 !== e.bindMatrix && o.bindMatrix.fromArray(e.bindMatrix),
                    void 0 !== e.skeleton && (o.skeleton = e.skeleton);
                    break;
                case "Mesh":
                    a = l(e.geometry),
                    s = c(e.material),
                    o = new Ly(a,s);
                    break;
                case "InstancedMesh":
                    a = l(e.geometry),
                    s = c(e.material);
                    const t = e.count
                      , n = e.instanceMatrix
                      , r = e.instanceColor;
                    o = new Ix(a,s,t),
                    o.instanceMatrix = new wx(new Float32Array(n.array),16),
                    void 0 !== r && (o.instanceColor = new wx(new Float32Array(r.array),r.itemSize));
                    break;
                case "BatchedMesh":
                    a = l(e.geometry),
                    s = c(e.material),
                    o = new qx(e.maxGeometryCount,e.maxVertexCount,e.maxIndexCount,s),
                    o.geometry = a,
                    o.perObjectFrustumCulled = e.perObjectFrustumCulled,
                    o.sortObjects = e.sortObjects,
                    o._drawRanges = e.drawRanges,
                    o._reservedRanges = e.reservedRanges,
                    o._visibility = e.visibility,
                    o._active = e.active,
                    o._bounds = e.bounds.map((e => {
                        const t = new wg;
                        t.min.fromArray(e.boxMin),
                        t.max.fromArray(e.boxMax);
                        const n = new Hg;
                        return n.radius = e.sphereRadius,
                        n.center.fromArray(e.sphereCenter),
                        {
                            boxInitialized: e.boxInitialized,
                            box: t,
                            sphereInitialized: e.sphereInitialized,
                            sphere: n
                        }
                    }
                    )),
                    o._maxGeometryCount = e.maxGeometryCount,
                    o._maxVertexCount = e.maxVertexCount,
                    o._maxIndexCount = e.maxIndexCount,
                    o._geometryInitialized = e.geometryInitialized,
                    o._geometryCount = e.geometryCount,
                    o._matricesTexture = u(e.matricesTexture.uuid);
                    break;
                case "LOD":
                    o = new lx;
                    break;
                case "Line":
                    o = new nS(l(e.geometry),c(e.material));
                    break;
                case "LineLoop":
                    o = new aS(l(e.geometry),c(e.material));
                    break;
                case "LineSegments":
                    o = new oS(l(e.geometry),c(e.material));
                    break;
                case "PointCloud":
                case "Points":
                    o = new hS(l(e.geometry),c(e.material));
                    break;
                case "Sprite":
                    o = new ix(c(e.material));
                    break;
                case "Group":
                    o = new PA;
                    break;
                case "Bone":
                    o = new bx;
                    break;
                default:
                    o = new xv
                }
                if (o.uuid = e.uuid,
                void 0 !== e.name && (o.name = e.name),
                void 0 !== e.matrix ? (o.matrix.fromArray(e.matrix),
                void 0 !== e.matrixAutoUpdate && (o.matrixAutoUpdate = e.matrixAutoUpdate),
                o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== e.position && o.position.fromArray(e.position),
                void 0 !== e.rotation && o.rotation.fromArray(e.rotation),
                void 0 !== e.quaternion && o.quaternion.fromArray(e.quaternion),
                void 0 !== e.scale && o.scale.fromArray(e.scale)),
                void 0 !== e.up && o.up.fromArray(e.up),
                void 0 !== e.castShadow && (o.castShadow = e.castShadow),
                void 0 !== e.receiveShadow && (o.receiveShadow = e.receiveShadow),
                e.shadow && (void 0 !== e.shadow.bias && (o.shadow.bias = e.shadow.bias),
                void 0 !== e.shadow.normalBias && (o.shadow.normalBias = e.shadow.normalBias),
                void 0 !== e.shadow.radius && (o.shadow.radius = e.shadow.radius),
                void 0 !== e.shadow.mapSize && o.shadow.mapSize.fromArray(e.shadow.mapSize),
                void 0 !== e.shadow.camera && (o.shadow.camera = this.parseObject(e.shadow.camera))),
                void 0 !== e.visible && (o.visible = e.visible),
                void 0 !== e.frustumCulled && (o.frustumCulled = e.frustumCulled),
                void 0 !== e.renderOrder && (o.renderOrder = e.renderOrder),
                void 0 !== e.userData && (o.userData = e.userData),
                void 0 !== e.layers && (o.layers.mask = e.layers),
                void 0 !== e.children) {
                    const a = e.children;
                    for (let e = 0; e < a.length; e++)
                        o.add(this.parseObject(a[e], t, n, r, i))
                }
                if (void 0 !== e.animations) {
                    const t = e.animations;
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e];
                        o.animations.push(i[n])
                    }
                }
                if ("LOD" === e.type) {
                    void 0 !== e.autoUpdate && (o.autoUpdate = e.autoUpdate);
                    const t = e.levels;
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e]
                          , r = o.getObjectByProperty("uuid", n.object);
                        void 0 !== r && o.addLevel(r, n.distance, n.hysteresis)
                    }
                }
                return o
            }
            bindSkeletons(e, t) {
                0 !== Object.keys(t).length && e.traverse((function(e) {
                    if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
                        const n = t[e.skeleton];
                        void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(n, e.bindMatrix)
                    }
                }
                ))
            }
        }
        const nM = {
            UVMapping: qh,
            CubeReflectionMapping: Yh,
            CubeRefractionMapping: Qh,
            EquirectangularReflectionMapping: Zh,
            EquirectangularRefractionMapping: $h,
            CubeUVReflectionMapping: ep
        }
          , rM = {
            RepeatWrapping: tp,
            ClampToEdgeWrapping: np,
            MirroredRepeatWrapping: rp
        }
          , iM = {
            NearestFilter: ip,
            NearestMipmapNearestFilter: op,
            NearestMipmapLinearFilter: sp,
            LinearFilter: cp,
            LinearMipmapNearestFilter: up,
            LinearMipmapLinearFilter: hp
        };
        class oM extends xE {
            constructor(e) {
                super(e),
                this.isImageBitmapLoader = !0,
                "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(e) {
                return this.options = e,
                this
            }
            load(e, t, n, r) {
                void 0 === e && (e = ""),
                void 0 !== this.path && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const i = this
                  , o = bE.get(e);
                if (void 0 !== o)
                    return i.manager.itemStart(e),
                    setTimeout((function() {
                        t && t(o),
                        i.manager.itemEnd(e)
                    }
                    ), 0),
                    o;
                const a = {};
                a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
                a.headers = this.requestHeader,
                fetch(e, a).then((function(e) {
                    return e.blob()
                }
                )).then((function(e) {
                    return createImageBitmap(e, Object.assign(i.options, {
                        colorSpaceConversion: "none"
                    }))
                }
                )).then((function(n) {
                    bE.add(e, n),
                    t && t(n),
                    i.manager.itemEnd(e)
                }
                )).catch((function(t) {
                    r && r(t),
                    i.manager.itemError(e),
                    i.manager.itemEnd(e)
                }
                )),
                i.manager.itemStart(e)
            }
        }
        let aM;
        class sM {
            static getContext() {
                return void 0 === aM && (aM = new (window.AudioContext || window.webkitAudioContext)),
                aM
            }
            static setContext(e) {
                aM = e
            }
        }
        class lM extends xE {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = this
                  , o = new EE(this.manager);
                function a(t) {
                    r ? r(t) : console.error(t),
                    i.manager.itemError(e)
                }
                o.setResponseType("arraybuffer"),
                o.setPath(this.path),
                o.setRequestHeader(this.requestHeader),
                o.setWithCredentials(this.withCredentials),
                o.load(e, (function(e) {
                    try {
                        const n = e.slice(0);
                        sM.getContext().decodeAudioData(n, (function(e) {
                            t(e)
                        }
                        )).catch(a)
                    } catch (n) {
                        a(n)
                    }
                }
                ), n, r)
            }
        }
        const cM = new Qg
          , uM = new Qg
          , dM = new Qg;
        class hM {
            constructor() {
                this.type = "StereoCamera",
                this.aspect = 1,
                this.eyeSep = .064,
                this.cameraL = new Hy,
                this.cameraL.layers.enable(1),
                this.cameraL.matrixAutoUpdate = !1,
                this.cameraR = new Hy,
                this.cameraR.layers.enable(2),
                this.cameraR.matrixAutoUpdate = !1,
                this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null
                }
            }
            update(e) {
                const t = this._cache;
                if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                    t.focus = e.focus,
                    t.fov = e.fov,
                    t.aspect = e.aspect * this.aspect,
                    t.near = e.near,
                    t.far = e.far,
                    t.zoom = e.zoom,
                    t.eyeSep = this.eyeSep,
                    dM.copy(e.projectionMatrix);
                    const n = t.eyeSep / 2
                      , r = n * t.near / t.focus
                      , i = t.near * Math.tan(Bm * t.fov * .5) / t.zoom;
                    let o, a;
                    uM.elements[12] = -n,
                    cM.elements[12] = n,
                    o = -i * t.aspect + r,
                    a = i * t.aspect + r,
                    dM.elements[0] = 2 * t.near / (a - o),
                    dM.elements[8] = (a + o) / (a - o),
                    this.cameraL.projectionMatrix.copy(dM),
                    o = -i * t.aspect - r,
                    a = i * t.aspect - r,
                    dM.elements[0] = 2 * t.near / (a - o),
                    dM.elements[8] = (a + o) / (a - o),
                    this.cameraR.projectionMatrix.copy(dM)
                }
                this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(uM),
                this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(cM)
            }
        }
        class pM {
            constructor() {
                let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.autoStart = e,
                this.startTime = 0,
                this.oldTime = 0,
                this.elapsedTime = 0,
                this.running = !1
            }
            start() {
                this.startTime = fM(),
                this.oldTime = this.startTime,
                this.elapsedTime = 0,
                this.running = !0
            }
            stop() {
                this.getElapsedTime(),
                this.running = !1,
                this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(),
                this.elapsedTime
            }
            getDelta() {
                let e = 0;
                if (this.autoStart && !this.running)
                    return this.start(),
                    0;
                if (this.running) {
                    const t = fM();
                    e = (t - this.oldTime) / 1e3,
                    this.oldTime = t,
                    this.elapsedTime += e
                }
                return e
            }
        }
        function fM() {
            return ("undefined" === typeof performance ? Date : performance).now()
        }
        const mM = new Ag
          , gM = new _g
          , vM = new Ag
          , yM = new Ag;
        class bM extends xv {
            constructor() {
                super(),
                this.type = "AudioListener",
                this.context = sM.getContext(),
                this.gain = this.context.createGain(),
                this.gain.connect(this.context.destination),
                this.filter = null,
                this.timeDelta = 0,
                this._clock = new pM
            }
            getInput() {
                return this.gain
            }
            removeFilter() {
                return null !== this.filter && (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination),
                this.gain.connect(this.context.destination),
                this.filter = null),
                this
            }
            getFilter() {
                return this.filter
            }
            setFilter(e) {
                return null !== this.filter ? (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
                this.filter = e,
                this.gain.connect(this.filter),
                this.filter.connect(this.context.destination),
                this
            }
            getMasterVolume() {
                return this.gain.gain.value
            }
            setMasterVolume(e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
                this
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e);
                const t = this.context.listener
                  , n = this.up;
                if (this.timeDelta = this._clock.getDelta(),
                this.matrixWorld.decompose(mM, gM, vM),
                yM.set(0, 0, -1).applyQuaternion(gM),
                t.positionX) {
                    const e = this.context.currentTime + this.timeDelta;
                    t.positionX.linearRampToValueAtTime(mM.x, e),
                    t.positionY.linearRampToValueAtTime(mM.y, e),
                    t.positionZ.linearRampToValueAtTime(mM.z, e),
                    t.forwardX.linearRampToValueAtTime(yM.x, e),
                    t.forwardY.linearRampToValueAtTime(yM.y, e),
                    t.forwardZ.linearRampToValueAtTime(yM.z, e),
                    t.upX.linearRampToValueAtTime(n.x, e),
                    t.upY.linearRampToValueAtTime(n.y, e),
                    t.upZ.linearRampToValueAtTime(n.z, e)
                } else
                    t.setPosition(mM.x, mM.y, mM.z),
                    t.setOrientation(yM.x, yM.y, yM.z, n.x, n.y, n.z)
            }
        }
        class _M extends xv {
            constructor(e) {
                super(),
                this.type = "Audio",
                this.listener = e,
                this.context = e.context,
                this.gain = this.context.createGain(),
                this.gain.connect(e.getInput()),
                this.autoplay = !1,
                this.buffer = null,
                this.detune = 0,
                this.loop = !1,
                this.loopStart = 0,
                this.loopEnd = 0,
                this.offset = 0,
                this.duration = void 0,
                this.playbackRate = 1,
                this.isPlaying = !1,
                this.hasPlaybackControl = !0,
                this.source = null,
                this.sourceType = "empty",
                this._startedAt = 0,
                this._progress = 0,
                this._connected = !1,
                this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(e) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "audioNode",
                this.source = e,
                this.connect(),
                this
            }
            setMediaElementSource(e) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaNode",
                this.source = this.context.createMediaElementSource(e),
                this.connect(),
                this
            }
            setMediaStreamSource(e) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaStreamNode",
                this.source = this.context.createMediaStreamSource(e),
                this.connect(),
                this
            }
            setBuffer(e) {
                return this.buffer = e,
                this.sourceType = "buffer",
                this.autoplay && this.play(),
                this
            }
            play() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                if (!0 === this.isPlaying)
                    return void console.warn("THREE.Audio: Audio is already playing.");
                if (!1 === this.hasPlaybackControl)
                    return void console.warn("THREE.Audio: this Audio has no playback control.");
                this._startedAt = this.context.currentTime + e;
                const t = this.context.createBufferSource();
                return t.buffer = this.buffer,
                t.loop = this.loop,
                t.loopStart = this.loopStart,
                t.loopEnd = this.loopEnd,
                t.onended = this.onEnded.bind(this),
                t.start(this._startedAt, this._progress + this.offset, this.duration),
                this.isPlaying = !0,
                this.source = t,
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
            }
            pause() {
                if (!1 !== this.hasPlaybackControl)
                    return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                    !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                    this.source.stop(),
                    this.source.onended = null,
                    this.isPlaying = !1),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            stop() {
                if (!1 !== this.hasPlaybackControl)
                    return this._progress = 0,
                    null !== this.source && (this.source.stop(),
                    this.source.onended = null),
                    this.isPlaying = !1,
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let e = 1, t = this.filters.length; e < t; e++)
                        this.filters[e - 1].connect(this.filters[e]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else
                    this.source.connect(this.getOutput());
                return this._connected = !0,
                this
            }
            disconnect() {
                if (!1 !== this._connected) {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let e = 1, t = this.filters.length; e < t; e++)
                            this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else
                        this.source.disconnect(this.getOutput());
                    return this._connected = !1,
                    this
                }
            }
            getFilters() {
                return this.filters
            }
            setFilters(e) {
                return e || (e = []),
                !0 === this._connected ? (this.disconnect(),
                this.filters = e.slice(),
                this.connect()) : this.filters = e.slice(),
                this
            }
            setDetune(e) {
                if (this.detune = e,
                void 0 !== this.source.detune)
                    return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                    this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(e) {
                return this.setFilters(e ? [e] : [])
            }
            setPlaybackRate(e) {
                if (!1 !== this.hasPlaybackControl)
                    return this.playbackRate = e,
                    !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
                !1) : this.loop
            }
            setLoop(e) {
                if (!1 !== this.hasPlaybackControl)
                    return this.loop = e,
                    !0 === this.isPlaying && (this.source.loop = this.loop),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            setLoopStart(e) {
                return this.loopStart = e,
                this
            }
            setLoopEnd(e) {
                return this.loopEnd = e,
                this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
                this
            }
        }
        const AM = new Ag
          , xM = new _g
          , SM = new Ag
          , wM = new Ag;
        class EM extends _M {
            constructor(e) {
                super(e),
                this.panner = this.context.createPanner(),
                this.panner.panningModel = "HRTF",
                this.panner.connect(this.gain)
            }
            connect() {
                super.connect(),
                this.panner.connect(this.gain)
            }
            disconnect() {
                super.disconnect(),
                this.panner.disconnect(this.gain)
            }
            getOutput() {
                return this.panner
            }
            getRefDistance() {
                return this.panner.refDistance
            }
            setRefDistance(e) {
                return this.panner.refDistance = e,
                this
            }
            getRolloffFactor() {
                return this.panner.rolloffFactor
            }
            setRolloffFactor(e) {
                return this.panner.rolloffFactor = e,
                this
            }
            getDistanceModel() {
                return this.panner.distanceModel
            }
            setDistanceModel(e) {
                return this.panner.distanceModel = e,
                this
            }
            getMaxDistance() {
                return this.panner.maxDistance
            }
            setMaxDistance(e) {
                return this.panner.maxDistance = e,
                this
            }
            setDirectionalCone(e, t, n) {
                return this.panner.coneInnerAngle = e,
                this.panner.coneOuterAngle = t,
                this.panner.coneOuterGain = n,
                this
            }
            updateMatrixWorld(e) {
                if (super.updateMatrixWorld(e),
                !0 === this.hasPlaybackControl && !1 === this.isPlaying)
                    return;
                this.matrixWorld.decompose(AM, xM, SM),
                wM.set(0, 0, 1).applyQuaternion(xM);
                const t = this.panner;
                if (t.positionX) {
                    const e = this.context.currentTime + this.listener.timeDelta;
                    t.positionX.linearRampToValueAtTime(AM.x, e),
                    t.positionY.linearRampToValueAtTime(AM.y, e),
                    t.positionZ.linearRampToValueAtTime(AM.z, e),
                    t.orientationX.linearRampToValueAtTime(wM.x, e),
                    t.orientationY.linearRampToValueAtTime(wM.y, e),
                    t.orientationZ.linearRampToValueAtTime(wM.z, e)
                } else
                    t.setPosition(AM.x, AM.y, AM.z),
                    t.setOrientation(wM.x, wM.y, wM.z)
            }
        }
        class MM {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2048;
                this.analyser = e.context.createAnalyser(),
                this.analyser.fftSize = t,
                this.data = new Uint8Array(this.analyser.frequencyBinCount),
                e.getOutput().connect(this.analyser)
            }
            getFrequencyData() {
                return this.analyser.getByteFrequencyData(this.data),
                this.data
            }
            getAverageFrequency() {
                let e = 0;
                const t = this.getFrequencyData();
                for (let n = 0; n < t.length; n++)
                    e += t[n];
                return e / t.length
            }
        }
        class CM {
            constructor(e, t, n) {
                let r, i, o;
                switch (this.binding = e,
                this.valueSize = n,
                t) {
                case "quaternion":
                    r = this._slerp,
                    i = this._slerpAdditive,
                    o = this._setAdditiveIdentityQuaternion,
                    this.buffer = new Float64Array(6 * n),
                    this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    r = this._select,
                    i = this._select,
                    o = this._setAdditiveIdentityOther,
                    this.buffer = new Array(5 * n);
                    break;
                default:
                    r = this._lerp,
                    i = this._lerpAdditive,
                    o = this._setAdditiveIdentityNumeric,
                    this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = r,
                this._mixBufferRegionAdditive = i,
                this._setIdentity = o,
                this._origIndex = 3,
                this._addIndex = 4,
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                this.useCount = 0,
                this.referenceCount = 0
            }
            accumulate(e, t) {
                const n = this.buffer
                  , r = this.valueSize
                  , i = e * r + r;
                let o = this.cumulativeWeight;
                if (0 === o) {
                    for (let e = 0; e !== r; ++e)
                        n[i + e] = n[e];
                    o = t
                } else {
                    o += t;
                    const e = t / o;
                    this._mixBufferRegion(n, i, 0, e, r)
                }
                this.cumulativeWeight = o
            }
            accumulateAdditive(e) {
                const t = this.buffer
                  , n = this.valueSize
                  , r = n * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(),
                this._mixBufferRegionAdditive(t, r, 0, e, n),
                this.cumulativeWeightAdditive += e
            }
            apply(e) {
                const t = this.valueSize
                  , n = this.buffer
                  , r = e * t + t
                  , i = this.cumulativeWeight
                  , o = this.cumulativeWeightAdditive
                  , a = this.binding;
                if (this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                i < 1) {
                    const e = t * this._origIndex;
                    this._mixBufferRegion(n, r, e, 1 - i, t)
                }
                o > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
                for (let s = t, l = t + t; s !== l; ++s)
                    if (n[s] !== n[s + t]) {
                        a.setValue(n, r);
                        break
                    }
            }
            saveOriginalState() {
                const e = this.binding
                  , t = this.buffer
                  , n = this.valueSize
                  , r = n * this._origIndex;
                e.getValue(t, r);
                for (let i = n, o = r; i !== o; ++i)
                    t[i] = t[r + i % n];
                this._setIdentity(),
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const e = 3 * this.valueSize;
                this.binding.setValue(this.buffer, e)
            }
            _setAdditiveIdentityNumeric() {
                const e = this._addIndex * this.valueSize
                  , t = e + this.valueSize;
                for (let n = e; n < t; n++)
                    this.buffer[n] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(),
                this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const e = this._origIndex * this.valueSize
                  , t = this._addIndex * this.valueSize;
                for (let n = 0; n < this.valueSize; n++)
                    this.buffer[t + n] = this.buffer[e + n]
            }
            _select(e, t, n, r, i) {
                if (r >= .5)
                    for (let o = 0; o !== i; ++o)
                        e[t + o] = e[n + o]
            }
            _slerp(e, t, n, r) {
                _g.slerpFlat(e, t, e, t, e, n, r)
            }
            _slerpAdditive(e, t, n, r, i) {
                const o = this._workIndex * i;
                _g.multiplyQuaternionsFlat(e, o, e, t, e, n),
                _g.slerpFlat(e, t, e, t, e, o, r)
            }
            _lerp(e, t, n, r, i) {
                const o = 1 - r;
                for (let a = 0; a !== i; ++a) {
                    const i = t + a;
                    e[i] = e[i] * o + e[n + a] * r
                }
            }
            _lerpAdditive(e, t, n, r, i) {
                for (let o = 0; o !== i; ++o) {
                    const i = t + o;
                    e[i] = e[i] + e[n + o] * r
                }
            }
        }
        const TM = "\\[\\]\\.:\\/"
          , RM = new RegExp("[" + TM + "]","g")
          , PM = "[^" + TM + "]"
          , BM = "[^" + TM.replace("\\.", "") + "]"
          , IM = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", PM) + /(WCOD+)?/.source.replace("WCOD", BM) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", PM) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", PM) + "$")
          , LM = ["material", "materials", "bones", "map"];
        class kM {
            constructor(e, t, n) {
                this.path = t,
                this.parsedPath = n || kM.parseTrackName(t),
                this.node = kM.findNode(e, this.parsedPath.nodeName),
                this.rootNode = e,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
            static create(e, t, n) {
                return e && e.isAnimationObjectGroup ? new kM.Composite(e,t,n) : new kM(e,t,n)
            }
            static sanitizeNodeName(e) {
                return e.replace(/\s/g, "_").replace(RM, "")
            }
            static parseTrackName(e) {
                const t = IM.exec(e);
                if (null === t)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                const n = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6]
                }
                  , r = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== r && -1 !== r) {
                    const e = n.nodeName.substring(r + 1);
                    -1 !== LM.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r),
                    n.objectName = e)
                }
                if (null === n.propertyName || 0 === n.propertyName.length)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return n
            }
            static findNode(e, t) {
                if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                    return e;
                if (e.skeleton) {
                    const n = e.skeleton.getBoneByName(t);
                    if (void 0 !== n)
                        return n
                }
                if (e.children) {
                    const n = function(e) {
                        for (let r = 0; r < e.length; r++) {
                            const i = e[r];
                            if (i.name === t || i.uuid === t)
                                return i;
                            const o = n(i.children);
                            if (o)
                                return o
                        }
                        return null
                    }
                      , r = n(e.children);
                    if (r)
                        return r
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(e, t) {
                e[t] = this.targetObject[this.propertyName]
            }
            _getValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r)
                    e[t++] = n[r]
            }
            _getValue_arrayElement(e, t) {
                e[t] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(e, t) {
                this.resolvedProperty.toArray(e, t)
            }
            _setValue_direct(e, t) {
                this.targetObject[this.propertyName] = e[t]
            }
            _setValue_direct_setNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t],
                this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r)
                    n[r] = e[t++]
            }
            _setValue_array_setNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r)
                    n[r] = e[t++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r)
                    n[r] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }
            _setValue_arrayElement_setNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t],
                this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(e, t) {
                this.resolvedProperty.fromArray(e, t)
            }
            _setValue_fromArray_setNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t),
                this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(e, t) {
                this.bind(),
                this.getValue(e, t)
            }
            _setValue_unbound(e, t) {
                this.bind(),
                this.setValue(e, t)
            }
            bind() {
                let e = this.node;
                const t = this.parsedPath
                  , n = t.objectName
                  , r = t.propertyName;
                let i = t.propertyIndex;
                if (e || (e = kM.findNode(this.rootNode, t.nodeName),
                this.node = e),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !e)
                    return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                if (n) {
                    let r = t.objectIndex;
                    switch (n) {
                    case "materials":
                        if (!e.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        e = e.skeleton.bones;
                        for (let t = 0; t < e.length; t++)
                            if (e[t].name === r) {
                                r = t;
                                break
                            }
                        break;
                    case "map":
                        if ("map"in e) {
                            e = e.map;
                            break
                        }
                        if (!e.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.map)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        e = e.material.map;
                        break;
                    default:
                        if (void 0 === e[n])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        e = e[n]
                    }
                    if (void 0 !== r) {
                        if (void 0 === e[r])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[r]
                    }
                }
                const o = e[r];
                if (void 0 === o) {
                    const n = t.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", e)
                }
                let a = this.Versioning.None;
                this.targetObject = e,
                void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                let s = this.BindingType.Direct;
                if (void 0 !== i) {
                    if ("morphTargetInfluences" === r) {
                        if (!e.geometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!e.geometry.morphAttributes)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i])
                    }
                    s = this.BindingType.ArrayElement,
                    this.resolvedProperty = o,
                    this.propertyIndex = i
                } else
                    void 0 !== o.fromArray && void 0 !== o.toArray ? (s = this.BindingType.HasFromToArray,
                    this.resolvedProperty = o) : Array.isArray(o) ? (s = this.BindingType.EntireArray,
                    this.resolvedProperty = o) : this.propertyName = r;
                this.getValue = this.GetterByBindingType[s],
                this.setValue = this.SetterByBindingTypeAndVersioning[s][a]
            }
            unbind() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }
        kM.Composite = class {
            constructor(e, t, n) {
                const r = n || kM.parseTrackName(t);
                this._targetGroup = e,
                this._bindings = e.subscribe_(t, r)
            }
            getValue(e, t) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_
                  , r = this._bindings[n];
                void 0 !== r && r.getValue(e, t)
            }
            setValue(e, t) {
                const n = this._bindings;
                for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r)
                    n[r].setValue(e, t)
            }
            bind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                    e[t].bind()
            }
            unbind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                    e[t].unbind()
            }
        }
        ,
        kM.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        kM.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        kM.prototype.GetterByBindingType = [kM.prototype._getValue_direct, kM.prototype._getValue_array, kM.prototype._getValue_arrayElement, kM.prototype._getValue_toArray],
        kM.prototype.SetterByBindingTypeAndVersioning = [[kM.prototype._setValue_direct, kM.prototype._setValue_direct_setNeedsUpdate, kM.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [kM.prototype._setValue_array, kM.prototype._setValue_array_setNeedsUpdate, kM.prototype._setValue_array_setMatrixWorldNeedsUpdate], [kM.prototype._setValue_arrayElement, kM.prototype._setValue_arrayElement_setNeedsUpdate, kM.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [kM.prototype._setValue_fromArray, kM.prototype._setValue_fromArray_setNeedsUpdate, kM.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        class DM {
            constructor() {
                this.isAnimationObjectGroup = !0,
                this.uuid = Lm(),
                this._objects = Array.prototype.slice.call(arguments),
                this.nCachedObjects_ = 0;
                const e = {};
                this._indicesByUUID = e;
                for (let n = 0, r = arguments.length; n !== r; ++n)
                    e[arguments[n].uuid] = n;
                this._paths = [],
                this._parsedPaths = [],
                this._bindings = [],
                this._bindingsIndicesByPath = {};
                const t = this;
                this.stats = {
                    objects: {
                        get total() {
                            return t._objects.length
                        },
                        get inUse() {
                            return this.total - t.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return t._bindings.length
                    }
                }
            }
            add() {
                const e = this._objects
                  , t = this._indicesByUUID
                  , n = this._paths
                  , r = this._parsedPaths
                  , i = this._bindings
                  , o = i.length;
                let a, s = e.length, l = this.nCachedObjects_;
                for (let c = 0, u = arguments.length; c !== u; ++c) {
                    const u = arguments[c]
                      , d = u.uuid;
                    let h = t[d];
                    if (void 0 === h) {
                        h = s++,
                        t[d] = h,
                        e.push(u);
                        for (let e = 0, t = o; e !== t; ++e)
                            i[e].push(new kM(u,n[e],r[e]))
                    } else if (h < l) {
                        a = e[h];
                        const s = --l
                          , c = e[s];
                        t[c.uuid] = h,
                        e[h] = c,
                        t[d] = s,
                        e[s] = u;
                        for (let e = 0, t = o; e !== t; ++e) {
                            const t = i[e]
                              , o = t[s];
                            let a = t[h];
                            t[h] = o,
                            void 0 === a && (a = new kM(u,n[e],r[e])),
                            t[s] = a
                        }
                    } else
                        e[h] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = l
            }
            remove() {
                const e = this._objects
                  , t = this._indicesByUUID
                  , n = this._bindings
                  , r = n.length;
                let i = this.nCachedObjects_;
                for (let o = 0, a = arguments.length; o !== a; ++o) {
                    const a = arguments[o]
                      , s = a.uuid
                      , l = t[s];
                    if (void 0 !== l && l >= i) {
                        const o = i++
                          , c = e[o];
                        t[c.uuid] = l,
                        e[l] = c,
                        t[s] = o,
                        e[o] = a;
                        for (let e = 0, t = r; e !== t; ++e) {
                            const t = n[e]
                              , r = t[o]
                              , i = t[l];
                            t[l] = r,
                            t[o] = i
                        }
                    }
                }
                this.nCachedObjects_ = i
            }
            uncache() {
                const e = this._objects
                  , t = this._indicesByUUID
                  , n = this._bindings
                  , r = n.length;
                let i = this.nCachedObjects_
                  , o = e.length;
                for (let a = 0, s = arguments.length; a !== s; ++a) {
                    const s = arguments[a].uuid
                      , l = t[s];
                    if (void 0 !== l)
                        if (delete t[s],
                        l < i) {
                            const a = --i
                              , s = e[a]
                              , c = --o
                              , u = e[c];
                            t[s.uuid] = l,
                            e[l] = s,
                            t[u.uuid] = a,
                            e[a] = u,
                            e.pop();
                            for (let e = 0, t = r; e !== t; ++e) {
                                const t = n[e]
                                  , r = t[a]
                                  , i = t[c];
                                t[l] = r,
                                t[a] = i,
                                t.pop()
                            }
                        } else {
                            const i = --o
                              , a = e[i];
                            i > 0 && (t[a.uuid] = l),
                            e[l] = a,
                            e.pop();
                            for (let e = 0, t = r; e !== t; ++e) {
                                const t = n[e];
                                t[l] = t[i],
                                t.pop()
                            }
                        }
                }
                this.nCachedObjects_ = i
            }
            subscribe_(e, t) {
                const n = this._bindingsIndicesByPath;
                let r = n[e];
                const i = this._bindings;
                if (void 0 !== r)
                    return i[r];
                const o = this._paths
                  , a = this._parsedPaths
                  , s = this._objects
                  , l = s.length
                  , c = this.nCachedObjects_
                  , u = new Array(l);
                r = i.length,
                n[e] = r,
                o.push(e),
                a.push(t),
                i.push(u);
                for (let d = c, h = s.length; d !== h; ++d) {
                    const n = s[d];
                    u[d] = new kM(n,e,t)
                }
                return u
            }
            unsubscribe_(e) {
                const t = this._bindingsIndicesByPath
                  , n = t[e];
                if (void 0 !== n) {
                    const r = this._paths
                      , i = this._parsedPaths
                      , o = this._bindings
                      , a = o.length - 1
                      , s = o[a];
                    t[e[a]] = n,
                    o[n] = s,
                    o.pop(),
                    i[n] = i[a],
                    i.pop(),
                    r[n] = r[a],
                    r.pop()
                }
            }
        }
        class OM {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.blendMode;
                this._mixer = e,
                this._clip = t,
                this._localRoot = n,
                this.blendMode = r;
                const i = t.tracks
                  , o = i.length
                  , a = new Array(o)
                  , s = {
                    endingStart: Af,
                    endingEnd: Af
                };
                for (let l = 0; l !== o; ++l) {
                    const e = i[l].createInterpolant(null);
                    a[l] = e,
                    e.settings = s
                }
                this._interpolantSettings = s,
                this._interpolants = a,
                this._propertyBindings = new Array(o),
                this._cacheIndex = null,
                this._byClipCacheIndex = null,
                this._timeScaleInterpolant = null,
                this._weightInterpolant = null,
                this.loop = gf,
                this._loopCount = -1,
                this._startTime = null,
                this.time = 0,
                this.timeScale = 1,
                this._effectiveTimeScale = 1,
                this.weight = 1,
                this._effectiveWeight = 1,
                this.repetitions = 1 / 0,
                this.paused = !1,
                this.enabled = !0,
                this.clampWhenFinished = !1,
                this.zeroSlopeAtStart = !0,
                this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this),
                this
            }
            stop() {
                return this._mixer._deactivateAction(this),
                this.reset()
            }
            reset() {
                return this.paused = !1,
                this.enabled = !0,
                this.time = 0,
                this._loopCount = -1,
                this._startTime = null,
                this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(e) {
                return this._startTime = e,
                this
            }
            setLoop(e, t) {
                return this.loop = e,
                this.repetitions = t,
                this
            }
            setEffectiveWeight(e) {
                return this.weight = e,
                this._effectiveWeight = this.enabled ? e : 0,
                this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(e) {
                return this._scheduleFading(e, 0, 1)
            }
            fadeOut(e) {
                return this._scheduleFading(e, 1, 0)
            }
            crossFadeFrom(e, t, n) {
                if (e.fadeOut(t),
                this.fadeIn(t),
                n) {
                    const n = this._clip.duration
                      , r = e._clip.duration
                      , i = r / n
                      , o = n / r;
                    e.warp(1, i, t),
                    this.warp(o, 1, t)
                }
                return this
            }
            crossFadeTo(e, t, n) {
                return e.crossFadeFrom(this, t, n)
            }
            stopFading() {
                const e = this._weightInterpolant;
                return null !== e && (this._weightInterpolant = null,
                this._mixer._takeBackControlInterpolant(e)),
                this
            }
            setEffectiveTimeScale(e) {
                return this.timeScale = e,
                this._effectiveTimeScale = this.paused ? 0 : e,
                this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(e) {
                return this.timeScale = this._clip.duration / e,
                this.stopWarping()
            }
            syncWith(e) {
                return this.time = e.time,
                this.timeScale = e.timeScale,
                this.stopWarping()
            }
            halt(e) {
                return this.warp(this._effectiveTimeScale, 0, e)
            }
            warp(e, t, n) {
                const r = this._mixer
                  , i = r.time
                  , o = this.timeScale;
                let a = this._timeScaleInterpolant;
                null === a && (a = r._lendControlInterpolant(),
                this._timeScaleInterpolant = a);
                const s = a.parameterPositions
                  , l = a.sampleValues;
                return s[0] = i,
                s[1] = i + n,
                l[0] = e / o,
                l[1] = t / o,
                this
            }
            stopWarping() {
                const e = this._timeScaleInterpolant;
                return null !== e && (this._timeScaleInterpolant = null,
                this._mixer._takeBackControlInterpolant(e)),
                this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(e, t, n, r) {
                if (!this.enabled)
                    return void this._updateWeight(e);
                const i = this._startTime;
                if (null !== i) {
                    const r = (e - i) * n;
                    r < 0 || 0 === n ? t = 0 : (this._startTime = null,
                    t = n * r)
                }
                t *= this._updateTimeScale(e);
                const o = this._updateTime(t)
                  , a = this._updateWeight(e);
                if (a > 0) {
                    const e = this._interpolants
                      , t = this._propertyBindings;
                    if (this.blendMode === Ef)
                        for (let n = 0, r = e.length; n !== r; ++n)
                            e[n].evaluate(o),
                            t[n].accumulateAdditive(a);
                    else
                        for (let n = 0, i = e.length; n !== i; ++n)
                            e[n].evaluate(o),
                            t[n].accumulate(r, a)
                }
            }
            _updateWeight(e) {
                let t = 0;
                if (this.enabled) {
                    t = this.weight;
                    const n = this._weightInterpolant;
                    if (null !== n) {
                        const r = n.evaluate(e)[0];
                        t *= r,
                        e > n.parameterPositions[1] && (this.stopFading(),
                        0 === r && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = t,
                t
            }
            _updateTimeScale(e) {
                let t = 0;
                if (!this.paused) {
                    t = this.timeScale;
                    const n = this._timeScaleInterpolant;
                    if (null !== n) {
                        t *= n.evaluate(e)[0],
                        e > n.parameterPositions[1] && (this.stopWarping(),
                        0 === t ? this.paused = !0 : this.timeScale = t)
                    }
                }
                return this._effectiveTimeScale = t,
                t
            }
            _updateTime(e) {
                const t = this._clip.duration
                  , n = this.loop;
                let r = this.time + e
                  , i = this._loopCount;
                const o = n === vf;
                if (0 === e)
                    return -1 === i ? r : o && 1 === (1 & i) ? t - r : r;
                if (n === mf) {
                    -1 === i && (this._loopCount = 0,
                    this._setEndings(!0, !0, !1));
                    e: {
                        if (r >= t)
                            r = t;
                        else {
                            if (!(r < 0)) {
                                this.time = r;
                                break e
                            }
                            r = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = r,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === i && (e >= 0 ? (i = 0,
                    this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)),
                    r >= t || r < 0) {
                        const n = Math.floor(r / t);
                        r -= t * n,
                        i += Math.abs(n);
                        const a = this.repetitions - i;
                        if (a <= 0)
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            r = e > 0 ? t : 0,
                            this.time = r,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e > 0 ? 1 : -1
                            });
                        else {
                            if (1 === a) {
                                const t = e < 0;
                                this._setEndings(t, !t, o)
                            } else
                                this._setEndings(!1, !1, o);
                            this._loopCount = i,
                            this.time = r,
                            this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: n
                            })
                        }
                    } else
                        this.time = r;
                    if (o && 1 === (1 & i))
                        return t - r
                }
                return r
            }
            _setEndings(e, t, n) {
                const r = this._interpolantSettings;
                n ? (r.endingStart = xf,
                r.endingEnd = xf) : (r.endingStart = e ? this.zeroSlopeAtStart ? xf : Af : Sf,
                r.endingEnd = t ? this.zeroSlopeAtEnd ? xf : Af : Sf)
            }
            _scheduleFading(e, t, n) {
                const r = this._mixer
                  , i = r.time;
                let o = this._weightInterpolant;
                null === o && (o = r._lendControlInterpolant(),
                this._weightInterpolant = o);
                const a = o.parameterPositions
                  , s = o.sampleValues;
                return a[0] = i,
                s[0] = t,
                a[1] = i + e,
                s[1] = n,
                this
            }
        }
        const NM = new Float32Array(1);
        class FM extends Tm {
            constructor(e) {
                super(),
                this._root = e,
                this._initMemoryManager(),
                this._accuIndex = 0,
                this.time = 0,
                this.timeScale = 1
            }
            _bindAction(e, t) {
                const n = e._localRoot || this._root
                  , r = e._clip.tracks
                  , i = r.length
                  , o = e._propertyBindings
                  , a = e._interpolants
                  , s = n.uuid
                  , l = this._bindingsByRootAndName;
                let c = l[s];
                void 0 === c && (c = {},
                l[s] = c);
                for (let u = 0; u !== i; ++u) {
                    const e = r[u]
                      , i = e.name;
                    let l = c[i];
                    if (void 0 !== l)
                        ++l.referenceCount,
                        o[u] = l;
                    else {
                        if (l = o[u],
                        void 0 !== l) {
                            null === l._cacheIndex && (++l.referenceCount,
                            this._addInactiveBinding(l, s, i));
                            continue
                        }
                        const r = t && t._propertyBindings[u].binding.parsedPath;
                        l = new CM(kM.create(n, i, r),e.ValueTypeName,e.getValueSize()),
                        ++l.referenceCount,
                        this._addInactiveBinding(l, s, i),
                        o[u] = l
                    }
                    a[u].resultBuffer = l.buffer
                }
            }
            _activateAction(e) {
                if (!this._isActiveAction(e)) {
                    if (null === e._cacheIndex) {
                        const t = (e._localRoot || this._root).uuid
                          , n = e._clip.uuid
                          , r = this._actionsByClip[n];
                        this._bindAction(e, r && r.knownActions[0]),
                        this._addInactiveAction(e, n, t)
                    }
                    const t = e._propertyBindings;
                    for (let e = 0, n = t.length; e !== n; ++e) {
                        const n = t[e];
                        0 === n.useCount++ && (this._lendBinding(n),
                        n.saveOriginalState())
                    }
                    this._lendAction(e)
                }
            }
            _deactivateAction(e) {
                if (this._isActiveAction(e)) {
                    const t = e._propertyBindings;
                    for (let e = 0, n = t.length; e !== n; ++e) {
                        const n = t[e];
                        0 === --n.useCount && (n.restoreOriginalState(),
                        this._takeBackBinding(n))
                    }
                    this._takeBackAction(e)
                }
            }
            _initMemoryManager() {
                this._actions = [],
                this._nActiveActions = 0,
                this._actionsByClip = {},
                this._bindings = [],
                this._nActiveBindings = 0,
                this._bindingsByRootAndName = {},
                this._controlInterpolants = [],
                this._nActiveControlInterpolants = 0;
                const e = this;
                this.stats = {
                    actions: {
                        get total() {
                            return e._actions.length
                        },
                        get inUse() {
                            return e._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return e._bindings.length
                        },
                        get inUse() {
                            return e._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return e._controlInterpolants.length
                        },
                        get inUse() {
                            return e._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(e) {
                const t = e._cacheIndex;
                return null !== t && t < this._nActiveActions
            }
            _addInactiveAction(e, t, n) {
                const r = this._actions
                  , i = this._actionsByClip;
                let o = i[t];
                if (void 0 === o)
                    o = {
                        knownActions: [e],
                        actionByRoot: {}
                    },
                    e._byClipCacheIndex = 0,
                    i[t] = o;
                else {
                    const t = o.knownActions;
                    e._byClipCacheIndex = t.length,
                    t.push(e)
                }
                e._cacheIndex = r.length,
                r.push(e),
                o.actionByRoot[n] = e
            }
            _removeInactiveAction(e) {
                const t = this._actions
                  , n = t[t.length - 1]
                  , r = e._cacheIndex;
                n._cacheIndex = r,
                t[r] = n,
                t.pop(),
                e._cacheIndex = null;
                const i = e._clip.uuid
                  , o = this._actionsByClip
                  , a = o[i]
                  , s = a.knownActions
                  , l = s[s.length - 1]
                  , c = e._byClipCacheIndex;
                l._byClipCacheIndex = c,
                s[c] = l,
                s.pop(),
                e._byClipCacheIndex = null;
                delete a.actionByRoot[(e._localRoot || this._root).uuid],
                0 === s.length && delete o[i],
                this._removeInactiveBindingsForAction(e)
            }
            _removeInactiveBindingsForAction(e) {
                const t = e._propertyBindings;
                for (let n = 0, r = t.length; n !== r; ++n) {
                    const e = t[n];
                    0 === --e.referenceCount && this._removeInactiveBinding(e)
                }
            }
            _lendAction(e) {
                const t = this._actions
                  , n = e._cacheIndex
                  , r = this._nActiveActions++
                  , i = t[r];
                e._cacheIndex = r,
                t[r] = e,
                i._cacheIndex = n,
                t[n] = i
            }
            _takeBackAction(e) {
                const t = this._actions
                  , n = e._cacheIndex
                  , r = --this._nActiveActions
                  , i = t[r];
                e._cacheIndex = r,
                t[r] = e,
                i._cacheIndex = n,
                t[n] = i
            }
            _addInactiveBinding(e, t, n) {
                const r = this._bindingsByRootAndName
                  , i = this._bindings;
                let o = r[t];
                void 0 === o && (o = {},
                r[t] = o),
                o[n] = e,
                e._cacheIndex = i.length,
                i.push(e)
            }
            _removeInactiveBinding(e) {
                const t = this._bindings
                  , n = e.binding
                  , r = n.rootNode.uuid
                  , i = n.path
                  , o = this._bindingsByRootAndName
                  , a = o[r]
                  , s = t[t.length - 1]
                  , l = e._cacheIndex;
                s._cacheIndex = l,
                t[l] = s,
                t.pop(),
                delete a[i],
                0 === Object.keys(a).length && delete o[r]
            }
            _lendBinding(e) {
                const t = this._bindings
                  , n = e._cacheIndex
                  , r = this._nActiveBindings++
                  , i = t[r];
                e._cacheIndex = r,
                t[r] = e,
                i._cacheIndex = n,
                t[n] = i
            }
            _takeBackBinding(e) {
                const t = this._bindings
                  , n = e._cacheIndex
                  , r = --this._nActiveBindings
                  , i = t[r];
                e._cacheIndex = r,
                t[r] = e,
                i._cacheIndex = n,
                t[n] = i
            }
            _lendControlInterpolant() {
                const e = this._controlInterpolants
                  , t = this._nActiveControlInterpolants++;
                let n = e[t];
                return void 0 === n && (n = new sE(new Float32Array(2),new Float32Array(2),1,NM),
                n.__cacheIndex = t,
                e[t] = n),
                n
            }
            _takeBackControlInterpolant(e) {
                const t = this._controlInterpolants
                  , n = e.__cacheIndex
                  , r = --this._nActiveControlInterpolants
                  , i = t[r];
                e.__cacheIndex = r,
                t[r] = e,
                i.__cacheIndex = n,
                t[n] = i
            }
            clipAction(e, t, n) {
                const r = t || this._root
                  , i = r.uuid;
                let o = "string" === typeof e ? vE.findByName(r, e) : e;
                const a = null !== o ? o.uuid : e
                  , s = this._actionsByClip[a];
                let l = null;
                if (void 0 === n && (n = null !== o ? o.blendMode : wf),
                void 0 !== s) {
                    const e = s.actionByRoot[i];
                    if (void 0 !== e && e.blendMode === n)
                        return e;
                    l = s.knownActions[0],
                    null === o && (o = l._clip)
                }
                if (null === o)
                    return null;
                const c = new OM(this,o,t,n);
                return this._bindAction(c, l),
                this._addInactiveAction(c, a, i),
                c
            }
            existingAction(e, t) {
                const n = t || this._root
                  , r = n.uuid
                  , i = "string" === typeof e ? vE.findByName(n, e) : e
                  , o = i ? i.uuid : e
                  , a = this._actionsByClip[o];
                return void 0 !== a && a.actionByRoot[r] || null
            }
            stopAllAction() {
                const e = this._actions;
                for (let t = this._nActiveActions - 1; t >= 0; --t)
                    e[t].stop();
                return this
            }
            update(e) {
                e *= this.timeScale;
                const t = this._actions
                  , n = this._nActiveActions
                  , r = this.time += e
                  , i = Math.sign(e)
                  , o = this._accuIndex ^= 1;
                for (let l = 0; l !== n; ++l) {
                    t[l]._update(r, e, i, o)
                }
                const a = this._bindings
                  , s = this._nActiveBindings;
                for (let l = 0; l !== s; ++l)
                    a[l].apply(o);
                return this
            }
            setTime(e) {
                this.time = 0;
                for (let t = 0; t < this._actions.length; t++)
                    this._actions[t].time = 0;
                return this.update(e)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(e) {
                const t = this._actions
                  , n = e.uuid
                  , r = this._actionsByClip
                  , i = r[n];
                if (void 0 !== i) {
                    const e = i.knownActions;
                    for (let n = 0, r = e.length; n !== r; ++n) {
                        const r = e[n];
                        this._deactivateAction(r);
                        const i = r._cacheIndex
                          , o = t[t.length - 1];
                        r._cacheIndex = null,
                        r._byClipCacheIndex = null,
                        o._cacheIndex = i,
                        t[i] = o,
                        t.pop(),
                        this._removeInactiveBindingsForAction(r)
                    }
                    delete r[n]
                }
            }
            uncacheRoot(e) {
                const t = e.uuid
                  , n = this._actionsByClip;
                for (const i in n) {
                    const e = n[i].actionByRoot[t];
                    void 0 !== e && (this._deactivateAction(e),
                    this._removeInactiveAction(e))
                }
                const r = this._bindingsByRootAndName[t];
                if (void 0 !== r)
                    for (const i in r) {
                        const e = r[i];
                        e.restoreOriginalState(),
                        this._removeInactiveBinding(e)
                    }
            }
            uncacheAction(e, t) {
                const n = this.existingAction(e, t);
                null !== n && (this._deactivateAction(n),
                this._removeInactiveAction(n))
            }
        }
        class UM {
            constructor(e) {
                this.value = e
            }
            clone() {
                return new UM(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }
        let zM = 0;
        class GM extends Tm {
            constructor() {
                super(),
                this.isUniformsGroup = !0,
                Object.defineProperty(this, "id", {
                    value: zM++
                }),
                this.name = "",
                this.usage = fm,
                this.uniforms = []
            }
            add(e) {
                return this.uniforms.push(e),
                this
            }
            remove(e) {
                const t = this.uniforms.indexOf(e);
                return -1 !== t && this.uniforms.splice(t, 1),
                this
            }
            setName(e) {
                return this.name = e,
                this
            }
            setUsage(e) {
                return this.usage = e,
                this
            }
            dispose() {
                return this.dispatchEvent({
                    type: "dispose"
                }),
                this
            }
            copy(e) {
                this.name = e.name,
                this.usage = e.usage;
                const t = e.uniforms;
                this.uniforms.length = 0;
                for (let n = 0, r = t.length; n < r; n++)
                    this.uniforms.push(t[n].clone());
                return this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class HM extends GA {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                super(e, t),
                this.isInstancedInterleavedBuffer = !0,
                this.meshPerAttribute = n
            }
            copy(e) {
                return super.copy(e),
                this.meshPerAttribute = e.meshPerAttribute,
                this
            }
            clone(e) {
                const t = super.clone(e);
                return t.meshPerAttribute = this.meshPerAttribute,
                t
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.isInstancedInterleavedBuffer = !0,
                t.meshPerAttribute = this.meshPerAttribute,
                t
            }
        }
        class jM {
            constructor(e, t, n, r, i) {
                this.isGLBufferAttribute = !0,
                this.name = "",
                this.buffer = e,
                this.type = t,
                this.itemSize = n,
                this.elementSize = r,
                this.count = i,
                this.version = 0
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            setBuffer(e) {
                return this.buffer = e,
                this
            }
            setType(e, t) {
                return this.type = e,
                this.elementSize = t,
                this
            }
            setItemSize(e) {
                return this.itemSize = e,
                this
            }
            setCount(e) {
                return this.count = e,
                this
            }
        }
        class WM {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0;
                this.ray = new Yg(e,t),
                this.near = n,
                this.far = r,
                this.camera = null,
                this.layers = new lv,
                this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }
            }
            set(e, t) {
                this.ray.set(e, t)
            }
            setFromCamera(e, t) {
                t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
                this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
                this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
                this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
            }
            intersectObject(e) {
                let t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                return XM(e, this, t, !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]),
                t.sort(VM),
                t
            }
            intersectObjects(e) {
                let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                for (let r = 0, i = e.length; r < i; r++)
                    XM(e[r], this, n, t);
                return n.sort(VM),
                n
            }
        }
        function VM(e, t) {
            return e.distance - t.distance
        }
        function XM(e, t, n, r) {
            if (e.layers.test(t.layers) && e.raycast(t, n),
            !0 === r) {
                const r = e.children;
                for (let e = 0, i = r.length; e < i; e++)
                    XM(r[e], t, n, !0)
            }
        }
        class JM {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return this.radius = e,
                this.phi = t,
                this.theta = n,
                this
            }
            set(e, t, n) {
                return this.radius = e,
                this.phi = t,
                this.theta = n,
                this
            }
            copy(e) {
                return this.radius = e.radius,
                this.phi = e.phi,
                this.theta = e.theta,
                this
            }
            makeSafe() {
                const e = 1e-6;
                return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)),
                this
            }
            setFromVector3(e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            }
            setFromCartesianCoords(e, t, n) {
                return this.radius = Math.sqrt(e * e + t * t + n * n),
                0 === this.radius ? (this.theta = 0,
                this.phi = 0) : (this.theta = Math.atan2(e, n),
                this.phi = Math.acos(km(t / this.radius, -1, 1))),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class KM {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return this.radius = e,
                this.theta = t,
                this.y = n,
                this
            }
            set(e, t, n) {
                return this.radius = e,
                this.theta = t,
                this.y = n,
                this
            }
            copy(e) {
                return this.radius = e.radius,
                this.theta = e.theta,
                this.y = e.y,
                this
            }
            setFromVector3(e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            }
            setFromCartesianCoords(e, t, n) {
                return this.radius = Math.sqrt(e * e + n * n),
                this.theta = Math.atan2(e, n),
                this.y = t,
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const qM = new Hm;
        class YM {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Hm(1 / 0,1 / 0)
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Hm(-1 / 0,-1 / 0);
                this.isBox2 = !0,
                this.min = e,
                this.max = t
            }
            set(e, t) {
                return this.min.copy(e),
                this.max.copy(t),
                this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t++)
                    this.expandByPoint(e[t]);
                return this
            }
            setFromCenterAndSize(e, t) {
                const n = qM.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n),
                this.max.copy(e).add(n),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.min.copy(e.min),
                this.max.copy(e.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0,
                this.max.x = this.max.y = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(e) {
                return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e),
                this.max.max(e),
                this
            }
            expandByVector(e) {
                return this.min.sub(e),
                this.max.add(e),
                this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e),
                this.max.addScalar(e),
                this
            }
            containsPoint(e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
            }
            getParameter(e, t) {
                return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
            }
            clampPoint(e, t) {
                return t.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return this.clampPoint(e, qM).distanceTo(e)
            }
            intersect(e) {
                return this.min.max(e.min),
                this.max.min(e.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(e) {
                return this.min.min(e.min),
                this.max.max(e.max),
                this
            }
            translate(e) {
                return this.min.add(e),
                this.max.add(e),
                this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        const QM = new Ag
          , ZM = new Ag;
        class $M {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Ag
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ag;
                this.start = e,
                this.end = t
            }
            set(e, t) {
                return this.start.copy(e),
                this.end.copy(t),
                this
            }
            copy(e) {
                return this.start.copy(e.start),
                this.end.copy(e.end),
                this
            }
            getCenter(e) {
                return e.addVectors(this.start, this.end).multiplyScalar(.5)
            }
            delta(e) {
                return e.subVectors(this.end, this.start)
            }
            distanceSq() {
                return this.start.distanceToSquared(this.end)
            }
            distance() {
                return this.start.distanceTo(this.end)
            }
            at(e, t) {
                return this.delta(t).multiplyScalar(e).add(this.start)
            }
            closestPointToPointParameter(e, t) {
                QM.subVectors(e, this.start),
                ZM.subVectors(this.end, this.start);
                const n = ZM.dot(ZM);
                let r = ZM.dot(QM) / n;
                return t && (r = km(r, 0, 1)),
                r
            }
            closestPointToPoint(e, t, n) {
                const r = this.closestPointToPointParameter(e, t);
                return this.delta(n).multiplyScalar(r).add(this.start)
            }
            applyMatrix4(e) {
                return this.start.applyMatrix4(e),
                this.end.applyMatrix4(e),
                this
            }
            equals(e) {
                return e.start.equals(this.start) && e.end.equals(this.end)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const eC = new Ag;
        class tC extends xv {
            constructor(e, t) {
                super(),
                this.light = e,
                this.matrix = e.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.color = t,
                this.type = "SpotLightHelper";
                const n = new my
                  , r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                for (let o = 0, a = 1, s = 32; o < s; o++,
                a++) {
                    const e = o / s * Math.PI * 2
                      , t = a / s * Math.PI * 2;
                    r.push(Math.cos(e), Math.sin(e), 1, Math.cos(t), Math.sin(t), 1)
                }
                n.setAttribute("position", new ay(r,3));
                const i = new Yx({
                    fog: !1,
                    toneMapped: !1
                });
                this.cone = new oS(n,i),
                this.add(this.cone),
                this.update()
            }
            dispose() {
                this.cone.geometry.dispose(),
                this.cone.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1),
                this.light.target.updateWorldMatrix(!0, !1);
                const e = this.light.distance ? this.light.distance : 1e3
                  , t = e * Math.tan(this.light.angle);
                this.cone.scale.set(t, t, e),
                eC.setFromMatrixPosition(this.light.target.matrixWorld),
                this.cone.lookAt(eC),
                void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }
        }
        const nC = new Ag
          , rC = new Qg
          , iC = new Qg;
        class oC extends oS {
            constructor(e) {
                const t = aC(e)
                  , n = new my
                  , r = []
                  , i = []
                  , o = new Uv(0,0,1)
                  , a = new Uv(0,1,0);
                for (let s = 0; s < t.length; s++) {
                    const e = t[s];
                    e.parent && e.parent.isBone && (r.push(0, 0, 0),
                    r.push(0, 0, 0),
                    i.push(o.r, o.g, o.b),
                    i.push(a.r, a.g, a.b))
                }
                n.setAttribute("position", new ay(r,3)),
                n.setAttribute("color", new ay(i,3));
                super(n, new Yx({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                })),
                this.isSkeletonHelper = !0,
                this.type = "SkeletonHelper",
                this.root = e,
                this.bones = t,
                this.matrix = e.matrixWorld,
                this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(e) {
                const t = this.bones
                  , n = this.geometry
                  , r = n.getAttribute("position");
                iC.copy(this.root.matrixWorld).invert();
                for (let i = 0, o = 0; i < t.length; i++) {
                    const e = t[i];
                    e.parent && e.parent.isBone && (rC.multiplyMatrices(iC, e.matrixWorld),
                    nC.setFromMatrixPosition(rC),
                    r.setXYZ(o, nC.x, nC.y, nC.z),
                    rC.multiplyMatrices(iC, e.parent.matrixWorld),
                    nC.setFromMatrixPosition(rC),
                    r.setXYZ(o + 1, nC.x, nC.y, nC.z),
                    o += 2)
                }
                n.getAttribute("position").needsUpdate = !0,
                super.updateMatrixWorld(e)
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        function aC(e) {
            const t = [];
            !0 === e.isBone && t.push(e);
            for (let n = 0; n < e.children.length; n++)
                t.push.apply(t, aC(e.children[n]));
            return t
        }
        class sC extends Ly {
            constructor(e, t, n) {
                super(new Dw(t,4,2), new jv({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                })),
                this.light = e,
                this.color = n,
                this.type = "PointLightHelper",
                this.matrix = this.light.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.update()
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1),
                void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            }
        }
        const lC = new Ag
          , cC = new Uv
          , uC = new Uv;
        class dC extends xv {
            constructor(e, t, n) {
                super(),
                this.light = e,
                this.matrix = e.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.color = n,
                this.type = "HemisphereLightHelper";
                const r = new Iw(t);
                r.rotateY(.5 * Math.PI),
                this.material = new jv({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                }),
                void 0 === this.color && (this.material.vertexColors = !0);
                const i = r.getAttribute("position")
                  , o = new Float32Array(3 * i.count);
                r.setAttribute("color", new Qv(o,3)),
                this.add(new Ly(r,this.material)),
                this.update()
            }
            dispose() {
                this.children[0].geometry.dispose(),
                this.children[0].material.dispose()
            }
            update() {
                const e = this.children[0];
                if (void 0 !== this.color)
                    this.material.color.set(this.color);
                else {
                    const t = e.geometry.getAttribute("color");
                    cC.copy(this.light.color),
                    uC.copy(this.light.groundColor);
                    for (let e = 0, n = t.count; e < n; e++) {
                        const r = e < n / 2 ? cC : uC;
                        t.setXYZ(e, r.r, r.g, r.b)
                    }
                    t.needsUpdate = !0
                }
                this.light.updateWorldMatrix(!0, !1),
                e.lookAt(lC.setFromMatrixPosition(this.light.matrixWorld).negate())
            }
        }
        class hC extends oS {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 4473924
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8947848;
                n = new Uv(n),
                r = new Uv(r);
                const i = t / 2
                  , o = e / t
                  , a = e / 2
                  , s = []
                  , l = [];
                for (let u = 0, d = 0, h = -a; u <= t; u++,
                h += o) {
                    s.push(-a, 0, h, a, 0, h),
                    s.push(h, 0, -a, h, 0, a);
                    const e = u === i ? n : r;
                    e.toArray(l, d),
                    d += 3,
                    e.toArray(l, d),
                    d += 3,
                    e.toArray(l, d),
                    d += 3,
                    e.toArray(l, d),
                    d += 3
                }
                const c = new my;
                c.setAttribute("position", new ay(s,3)),
                c.setAttribute("color", new ay(l,3));
                super(c, new Yx({
                    vertexColors: !0,
                    toneMapped: !1
                })),
                this.type = "GridHelper"
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class pC extends oS {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 64
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 4473924
                  , o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 8947848;
                i = new Uv(i),
                o = new Uv(o);
                const a = []
                  , s = [];
                if (t > 1)
                    for (let c = 0; c < t; c++) {
                        const n = c / t * (2 * Math.PI)
                          , r = Math.sin(n) * e
                          , l = Math.cos(n) * e;
                        a.push(0, 0, 0),
                        a.push(r, 0, l);
                        const u = 1 & c ? i : o;
                        s.push(u.r, u.g, u.b),
                        s.push(u.r, u.g, u.b)
                    }
                for (let c = 0; c < n; c++) {
                    const t = 1 & c ? i : o
                      , l = e - e / n * c;
                    for (let e = 0; e < r; e++) {
                        let n = e / r * (2 * Math.PI)
                          , i = Math.sin(n) * l
                          , o = Math.cos(n) * l;
                        a.push(i, 0, o),
                        s.push(t.r, t.g, t.b),
                        n = (e + 1) / r * (2 * Math.PI),
                        i = Math.sin(n) * l,
                        o = Math.cos(n) * l,
                        a.push(i, 0, o),
                        s.push(t.r, t.g, t.b)
                    }
                }
                const l = new my;
                l.setAttribute("position", new ay(a,3)),
                l.setAttribute("color", new ay(s,3));
                super(l, new Yx({
                    vertexColors: !0,
                    toneMapped: !1
                })),
                this.type = "PolarGridHelper"
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        const fC = new Ag
          , mC = new Ag
          , gC = new Ag;
        class vC extends xv {
            constructor(e, t, n) {
                super(),
                this.light = e,
                this.matrix = e.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.color = n,
                this.type = "DirectionalLightHelper",
                void 0 === t && (t = 1);
                let r = new my;
                r.setAttribute("position", new ay([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
                const i = new Yx({
                    fog: !1,
                    toneMapped: !1
                });
                this.lightPlane = new nS(r,i),
                this.add(this.lightPlane),
                r = new my,
                r.setAttribute("position", new ay([0, 0, 0, 0, 0, 1],3)),
                this.targetLine = new nS(r,i),
                this.add(this.targetLine),
                this.update()
            }
            dispose() {
                this.lightPlane.geometry.dispose(),
                this.lightPlane.material.dispose(),
                this.targetLine.geometry.dispose(),
                this.targetLine.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1),
                this.light.target.updateWorldMatrix(!0, !1),
                fC.setFromMatrixPosition(this.light.matrixWorld),
                mC.setFromMatrixPosition(this.light.target.matrixWorld),
                gC.subVectors(mC, fC),
                this.lightPlane.lookAt(mC),
                void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
                this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
                this.targetLine.material.color.copy(this.light.color)),
                this.targetLine.lookAt(mC),
                this.targetLine.scale.z = gC.length()
            }
        }
        const yC = new Ag
          , bC = new Gy;
        class _C extends oS {
            constructor(e) {
                const t = new my
                  , n = new Yx({
                    color: 16777215,
                    vertexColors: !0,
                    toneMapped: !1
                })
                  , r = []
                  , i = []
                  , o = {};
                function a(e, t) {
                    s(e),
                    s(t)
                }
                function s(e) {
                    r.push(0, 0, 0),
                    i.push(0, 0, 0),
                    void 0 === o[e] && (o[e] = []),
                    o[e].push(r.length / 3 - 1)
                }
                a("n1", "n2"),
                a("n2", "n4"),
                a("n4", "n3"),
                a("n3", "n1"),
                a("f1", "f2"),
                a("f2", "f4"),
                a("f4", "f3"),
                a("f3", "f1"),
                a("n1", "f1"),
                a("n2", "f2"),
                a("n3", "f3"),
                a("n4", "f4"),
                a("p", "n1"),
                a("p", "n2"),
                a("p", "n3"),
                a("p", "n4"),
                a("u1", "u2"),
                a("u2", "u3"),
                a("u3", "u1"),
                a("c", "t"),
                a("p", "c"),
                a("cn1", "cn2"),
                a("cn3", "cn4"),
                a("cf1", "cf2"),
                a("cf3", "cf4"),
                t.setAttribute("position", new ay(r,3)),
                t.setAttribute("color", new ay(i,3)),
                super(t, n),
                this.type = "CameraHelper",
                this.camera = e,
                this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                this.matrix = e.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.pointMap = o,
                this.update();
                const l = new Uv(16755200)
                  , c = new Uv(16711680)
                  , u = new Uv(43775)
                  , d = new Uv(16777215)
                  , h = new Uv(3355443);
                this.setColors(l, c, u, d, h)
            }
            setColors(e, t, n, r, i) {
                const o = this.geometry.getAttribute("color");
                o.setXYZ(0, e.r, e.g, e.b),
                o.setXYZ(1, e.r, e.g, e.b),
                o.setXYZ(2, e.r, e.g, e.b),
                o.setXYZ(3, e.r, e.g, e.b),
                o.setXYZ(4, e.r, e.g, e.b),
                o.setXYZ(5, e.r, e.g, e.b),
                o.setXYZ(6, e.r, e.g, e.b),
                o.setXYZ(7, e.r, e.g, e.b),
                o.setXYZ(8, e.r, e.g, e.b),
                o.setXYZ(9, e.r, e.g, e.b),
                o.setXYZ(10, e.r, e.g, e.b),
                o.setXYZ(11, e.r, e.g, e.b),
                o.setXYZ(12, e.r, e.g, e.b),
                o.setXYZ(13, e.r, e.g, e.b),
                o.setXYZ(14, e.r, e.g, e.b),
                o.setXYZ(15, e.r, e.g, e.b),
                o.setXYZ(16, e.r, e.g, e.b),
                o.setXYZ(17, e.r, e.g, e.b),
                o.setXYZ(18, e.r, e.g, e.b),
                o.setXYZ(19, e.r, e.g, e.b),
                o.setXYZ(20, e.r, e.g, e.b),
                o.setXYZ(21, e.r, e.g, e.b),
                o.setXYZ(22, e.r, e.g, e.b),
                o.setXYZ(23, e.r, e.g, e.b),
                o.setXYZ(24, t.r, t.g, t.b),
                o.setXYZ(25, t.r, t.g, t.b),
                o.setXYZ(26, t.r, t.g, t.b),
                o.setXYZ(27, t.r, t.g, t.b),
                o.setXYZ(28, t.r, t.g, t.b),
                o.setXYZ(29, t.r, t.g, t.b),
                o.setXYZ(30, t.r, t.g, t.b),
                o.setXYZ(31, t.r, t.g, t.b),
                o.setXYZ(32, n.r, n.g, n.b),
                o.setXYZ(33, n.r, n.g, n.b),
                o.setXYZ(34, n.r, n.g, n.b),
                o.setXYZ(35, n.r, n.g, n.b),
                o.setXYZ(36, n.r, n.g, n.b),
                o.setXYZ(37, n.r, n.g, n.b),
                o.setXYZ(38, r.r, r.g, r.b),
                o.setXYZ(39, r.r, r.g, r.b),
                o.setXYZ(40, i.r, i.g, i.b),
                o.setXYZ(41, i.r, i.g, i.b),
                o.setXYZ(42, i.r, i.g, i.b),
                o.setXYZ(43, i.r, i.g, i.b),
                o.setXYZ(44, i.r, i.g, i.b),
                o.setXYZ(45, i.r, i.g, i.b),
                o.setXYZ(46, i.r, i.g, i.b),
                o.setXYZ(47, i.r, i.g, i.b),
                o.setXYZ(48, i.r, i.g, i.b),
                o.setXYZ(49, i.r, i.g, i.b),
                o.needsUpdate = !0
            }
            update() {
                const e = this.geometry
                  , t = this.pointMap;
                bC.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
                AC("c", t, e, bC, 0, 0, -1),
                AC("t", t, e, bC, 0, 0, 1),
                AC("n1", t, e, bC, -1, -1, -1),
                AC("n2", t, e, bC, 1, -1, -1),
                AC("n3", t, e, bC, -1, 1, -1),
                AC("n4", t, e, bC, 1, 1, -1),
                AC("f1", t, e, bC, -1, -1, 1),
                AC("f2", t, e, bC, 1, -1, 1),
                AC("f3", t, e, bC, -1, 1, 1),
                AC("f4", t, e, bC, 1, 1, 1),
                AC("u1", t, e, bC, .7, 1.1, -1),
                AC("u2", t, e, bC, -.7, 1.1, -1),
                AC("u3", t, e, bC, 0, 2, -1),
                AC("cf1", t, e, bC, -1, 0, 1),
                AC("cf2", t, e, bC, 1, 0, 1),
                AC("cf3", t, e, bC, 0, -1, 1),
                AC("cf4", t, e, bC, 0, 1, 1),
                AC("cn1", t, e, bC, -1, 0, -1),
                AC("cn2", t, e, bC, 1, 0, -1),
                AC("cn3", t, e, bC, 0, -1, -1),
                AC("cn4", t, e, bC, 0, 1, -1),
                e.getAttribute("position").needsUpdate = !0
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        function AC(e, t, n, r, i, o, a) {
            yC.set(i, o, a).unproject(r);
            const s = t[e];
            if (void 0 !== s) {
                const e = n.getAttribute("position");
                for (let t = 0, n = s.length; t < n; t++)
                    e.setXYZ(s[t], yC.x, yC.y, yC.z)
            }
        }
        const xC = new wg;
        class SC extends oS {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16776960;
                const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                  , r = new Float32Array(24)
                  , i = new my;
                i.setIndex(new Qv(n,1)),
                i.setAttribute("position", new Qv(r,3)),
                super(i, new Yx({
                    color: t,
                    toneMapped: !1
                })),
                this.object = e,
                this.type = "BoxHelper",
                this.matrixAutoUpdate = !1,
                this.update()
            }
            update(e) {
                if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
                void 0 !== this.object && xC.setFromObject(this.object),
                xC.isEmpty())
                    return;
                const t = xC.min
                  , n = xC.max
                  , r = this.geometry.attributes.position
                  , i = r.array;
                i[0] = n.x,
                i[1] = n.y,
                i[2] = n.z,
                i[3] = t.x,
                i[4] = n.y,
                i[5] = n.z,
                i[6] = t.x,
                i[7] = t.y,
                i[8] = n.z,
                i[9] = n.x,
                i[10] = t.y,
                i[11] = n.z,
                i[12] = n.x,
                i[13] = n.y,
                i[14] = t.z,
                i[15] = t.x,
                i[16] = n.y,
                i[17] = t.z,
                i[18] = t.x,
                i[19] = t.y,
                i[20] = t.z,
                i[21] = n.x,
                i[22] = t.y,
                i[23] = t.z,
                r.needsUpdate = !0,
                this.geometry.computeBoundingSphere()
            }
            setFromObject(e) {
                return this.object = e,
                this.update(),
                this
            }
            copy(e, t) {
                return super.copy(e, t),
                this.object = e.object,
                this
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class wC extends oS {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16776960;
                const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                  , r = new my;
                r.setIndex(new Qv(n,1)),
                r.setAttribute("position", new ay([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
                super(r, new Yx({
                    color: t,
                    toneMapped: !1
                })),
                this.box = e,
                this.type = "Box3Helper",
                this.geometry.computeBoundingSphere()
            }
            updateMatrixWorld(e) {
                const t = this.box;
                t.isEmpty() || (t.getCenter(this.position),
                t.getSize(this.scale),
                this.scale.multiplyScalar(.5),
                super.updateMatrixWorld(e))
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class EC extends nS {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 16776960
                  , r = new my;
                r.setAttribute("position", new ay([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],3)),
                r.computeBoundingSphere(),
                super(r, new Yx({
                    color: n,
                    toneMapped: !1
                })),
                this.type = "PlaneHelper",
                this.plane = e,
                this.size = t;
                const i = new my;
                i.setAttribute("position", new ay([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],3)),
                i.computeBoundingSphere(),
                this.add(new Ly(i,new jv({
                    color: n,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1,
                    toneMapped: !1
                })))
            }
            updateMatrixWorld(e) {
                this.position.set(0, 0, 0),
                this.scale.set(.5 * this.size, .5 * this.size, 1),
                this.lookAt(this.plane.normal),
                this.translateZ(-this.plane.constant),
                super.updateMatrixWorld(e)
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose(),
                this.children[0].geometry.dispose(),
                this.children[0].material.dispose()
            }
        }
        const MC = new Ag;
        let CC, TC;
        class RC extends xv {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Ag(0,0,1)
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ag(0,0,0)
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 16776960
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .2 * n
                  , o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : .2 * i;
                super(),
                this.type = "ArrowHelper",
                void 0 === CC && (CC = new my,
                CC.setAttribute("position", new ay([0, 0, 0, 0, 1, 0],3)),
                TC = new VS(0,.5,1,5,1),
                TC.translate(0, -.5, 0)),
                this.position.copy(t),
                this.line = new nS(CC,new Yx({
                    color: r,
                    toneMapped: !1
                })),
                this.line.matrixAutoUpdate = !1,
                this.add(this.line),
                this.cone = new Ly(TC,new jv({
                    color: r,
                    toneMapped: !1
                })),
                this.cone.matrixAutoUpdate = !1,
                this.add(this.cone),
                this.setDirection(e),
                this.setLength(n, i, o)
            }
            setDirection(e) {
                if (e.y > .99999)
                    this.quaternion.set(0, 0, 0, 1);
                else if (e.y < -.99999)
                    this.quaternion.set(1, 0, 0, 0);
                else {
                    MC.set(e.z, 0, -e.x).normalize();
                    const t = Math.acos(e.y);
                    this.quaternion.setFromAxisAngle(MC, t)
                }
            }
            setLength(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .2 * e
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .2 * t;
                this.line.scale.set(1, Math.max(1e-4, e - t), 1),
                this.line.updateMatrix(),
                this.cone.scale.set(n, t, n),
                this.cone.position.y = e,
                this.cone.updateMatrix()
            }
            setColor(e) {
                this.line.material.color.set(e),
                this.cone.material.color.set(e)
            }
            copy(e) {
                return super.copy(e, !1),
                this.line.copy(e.line),
                this.cone.copy(e.cone),
                this
            }
            dispose() {
                this.line.geometry.dispose(),
                this.line.material.dispose(),
                this.cone.geometry.dispose(),
                this.cone.material.dispose()
            }
        }
        class PC extends oS {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
                  , n = new my;
                n.setAttribute("position", new ay(t,3)),
                n.setAttribute("color", new ay([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3));
                super(n, new Yx({
                    vertexColors: !0,
                    toneMapped: !1
                })),
                this.type = "AxesHelper"
            }
            setColors(e, t, n) {
                const r = new Uv
                  , i = this.geometry.attributes.color.array;
                return r.set(e),
                r.toArray(i, 0),
                r.toArray(i, 3),
                r.set(t),
                r.toArray(i, 6),
                r.toArray(i, 9),
                r.set(n),
                r.toArray(i, 12),
                r.toArray(i, 15),
                this.geometry.attributes.color.needsUpdate = !0,
                this
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class BC {
            constructor() {
                this.type = "ShapePath",
                this.color = new Uv,
                this.subPaths = [],
                this.currentPath = null
            }
            moveTo(e, t) {
                return this.currentPath = new GS,
                this.subPaths.push(this.currentPath),
                this.currentPath.moveTo(e, t),
                this
            }
            lineTo(e, t) {
                return this.currentPath.lineTo(e, t),
                this
            }
            quadraticCurveTo(e, t, n, r) {
                return this.currentPath.quadraticCurveTo(e, t, n, r),
                this
            }
            bezierCurveTo(e, t, n, r, i, o) {
                return this.currentPath.bezierCurveTo(e, t, n, r, i, o),
                this
            }
            splineThru(e) {
                return this.currentPath.splineThru(e),
                this
            }
            toShapes(e) {
                function t(e, t) {
                    const n = t.length;
                    let r = !1;
                    for (let i = n - 1, o = 0; o < n; i = o++) {
                        let n = t[i]
                          , a = t[o]
                          , s = a.x - n.x
                          , l = a.y - n.y;
                        if (Math.abs(l) > Number.EPSILON) {
                            if (l < 0 && (n = t[o],
                            s = -s,
                            a = t[i],
                            l = -l),
                            e.y < n.y || e.y > a.y)
                                continue;
                            if (e.y === n.y) {
                                if (e.x === n.x)
                                    return !0
                            } else {
                                const t = l * (e.x - n.x) - s * (e.y - n.y);
                                if (0 === t)
                                    return !0;
                                if (t < 0)
                                    continue;
                                r = !r
                            }
                        } else {
                            if (e.y !== n.y)
                                continue;
                            if (a.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= a.x)
                                return !0
                        }
                    }
                    return r
                }
                const n = Mw.isClockWise
                  , r = this.subPaths;
                if (0 === r.length)
                    return [];
                let i, o, a;
                const s = [];
                if (1 === r.length)
                    return o = r[0],
                    a = new ew,
                    a.curves = o.curves,
                    s.push(a),
                    s;
                let l = !n(r[0].getPoints());
                l = e ? !l : l;
                const c = []
                  , u = [];
                let d, h, p = [], f = 0;
                u[f] = void 0,
                p[f] = [];
                for (let m = 0, g = r.length; m < g; m++)
                    o = r[m],
                    d = o.getPoints(),
                    i = n(d),
                    i = e ? !i : i,
                    i ? (!l && u[f] && f++,
                    u[f] = {
                        s: new ew,
                        p: d
                    },
                    u[f].s.curves = o.curves,
                    l && f++,
                    p[f] = []) : p[f].push({
                        h: o,
                        p: d[0]
                    });
                if (!u[0])
                    return function(e) {
                        const t = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n]
                              , i = new ew;
                            i.curves = r.curves,
                            t.push(i)
                        }
                        return t
                    }(r);
                if (u.length > 1) {
                    let e = !1
                      , n = 0;
                    for (let t = 0, r = u.length; t < r; t++)
                        c[t] = [];
                    for (let r = 0, i = u.length; r < i; r++) {
                        const i = p[r];
                        for (let o = 0; o < i.length; o++) {
                            const a = i[o];
                            let s = !0;
                            for (let i = 0; i < u.length; i++)
                                t(a.p, u[i].p) && (r !== i && n++,
                                s ? (s = !1,
                                c[i].push(a)) : e = !0);
                            s && c[r].push(a)
                        }
                    }
                    n > 0 && !1 === e && (p = c)
                }
                for (let m = 0, g = u.length; m < g; m++) {
                    a = u[m].s,
                    s.push(a),
                    h = p[m];
                    for (let e = 0, t = h.length; e < t; e++)
                        a.holes.push(h[e].h)
                }
                return s
            }
        }
        "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
            detail: {
                revision: jd
            }
        })),
        "undefined" !== typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = jd);
        const IC = new WeakMap;
        class LC extends xE {
            constructor(e) {
                super(e),
                this.decoderPath = "",
                this.decoderConfig = {},
                this.decoderBinary = null,
                this.decoderPending = null,
                this.workerLimit = 4,
                this.workerPool = [],
                this.workerNextTaskID = 1,
                this.workerSourceURL = "",
                this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                },
                this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                }
            }
            setDecoderPath(e) {
                return this.decoderPath = e,
                this
            }
            setDecoderConfig(e) {
                return this.decoderConfig = e,
                this
            }
            setWorkerLimit(e) {
                return this.workerLimit = e,
                this
            }
            load(e, t, n, r) {
                const i = new EE(this.manager);
                i.setPath(this.path),
                i.setResponseType("arraybuffer"),
                i.setRequestHeader(this.requestHeader),
                i.setWithCredentials(this.withCredentials),
                i.load(e, (e => {
                    const n = {
                        attributeIDs: this.defaultAttributeIDs,
                        attributeTypes: this.defaultAttributeTypes,
                        useUniqueIDs: !1
                    };
                    this.decodeGeometry(e, n).then(t).catch(r)
                }
                ), n, r)
            }
            decodeDracoFile(e, t, n, r) {
                const i = {
                    attributeIDs: n || this.defaultAttributeIDs,
                    attributeTypes: r || this.defaultAttributeTypes,
                    useUniqueIDs: !!n
                };
                this.decodeGeometry(e, i).then(t)
            }
            decodeGeometry(e, t) {
                for (const s in t.attributeTypes) {
                    const e = t.attributeTypes[s];
                    void 0 !== e.BYTES_PER_ELEMENT && (t.attributeTypes[s] = e.name)
                }
                const n = JSON.stringify(t);
                if (IC.has(e)) {
                    const t = IC.get(e);
                    if (t.key === n)
                        return t.promise;
                    if (0 === e.byteLength)
                        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                }
                let r;
                const i = this.workerNextTaskID++
                  , o = e.byteLength
                  , a = this._getWorker(i, o).then((n => (r = n,
                new Promise(( (n, o) => {
                    r._callbacks[i] = {
                        resolve: n,
                        reject: o
                    },
                    r.postMessage({
                        type: "decode",
                        id: i,
                        taskConfig: t,
                        buffer: e
                    }, [e])
                }
                ))))).then((e => this._createGeometry(e.geometry)));
                return a.catch(( () => !0)).then(( () => {
                    r && i && this._releaseTask(r, i)
                }
                )),
                IC.set(e, {
                    key: n,
                    promise: a
                }),
                a
            }
            _createGeometry(e) {
                const t = new my;
                e.index && t.setIndex(new Qv(e.index.array,1));
                for (let n = 0; n < e.attributes.length; n++) {
                    const r = e.attributes[n]
                      , i = r.name
                      , o = r.array
                      , a = r.itemSize;
                    t.setAttribute(i, new Qv(o,a))
                }
                return t
            }
            _loadLibrary(e, t) {
                const n = new EE(this.manager);
                return n.setPath(this.decoderPath),
                n.setResponseType(t),
                n.setWithCredentials(this.withCredentials),
                new Promise(( (t, r) => {
                    n.load(e, t, void 0, r)
                }
                ))
            }
            preload() {
                return this._initDecoder(),
                this
            }
            _initDecoder() {
                if (this.decoderPending)
                    return this.decoderPending;
                const e = "object" !== typeof WebAssembly || "js" === this.decoderConfig.type
                  , t = [];
                return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
                this.decoderPending = Promise.all(t).then((t => {
                    const n = t[0];
                    e || (this.decoderConfig.wasmBinary = t[1]);
                    const r = kC.toString()
                      , i = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([i]))
                }
                )),
                this.decoderPending
            }
            _getWorker(e, t) {
                return this._initDecoder().then(( () => {
                    if (this.workerPool.length < this.workerLimit) {
                        const e = new Worker(this.workerSourceURL);
                        e._callbacks = {},
                        e._taskCosts = {},
                        e._taskLoad = 0,
                        e.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig
                        }),
                        e.onmessage = function(t) {
                            const n = t.data;
                            switch (n.type) {
                            case "decode":
                                e._callbacks[n.id].resolve(n);
                                break;
                            case "error":
                                e._callbacks[n.id].reject(n);
                                break;
                            default:
                                console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                            }
                        }
                        ,
                        this.workerPool.push(e)
                    } else
                        this.workerPool.sort((function(e, t) {
                            return e._taskLoad > t._taskLoad ? -1 : 1
                        }
                        ));
                    const n = this.workerPool[this.workerPool.length - 1];
                    return n._taskCosts[e] = t,
                    n._taskLoad += t,
                    n
                }
                ))
            }
            _releaseTask(e, t) {
                e._taskLoad -= e._taskCosts[t],
                delete e._callbacks[t],
                delete e._taskCosts[t]
            }
            debug() {
                console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
            }
            dispose() {
                for (let e = 0; e < this.workerPool.length; ++e)
                    this.workerPool[e].terminate();
                return this.workerPool.length = 0,
                this
            }
        }
        function kC() {
            let e, t;
            function n(e, t, n, r, i, o) {
                const a = o.num_components()
                  , s = n.num_points() * a
                  , l = s * i.BYTES_PER_ELEMENT
                  , c = function(e, t) {
                    switch (t) {
                    case Float32Array:
                        return e.DT_FLOAT32;
                    case Int8Array:
                        return e.DT_INT8;
                    case Int16Array:
                        return e.DT_INT16;
                    case Int32Array:
                        return e.DT_INT32;
                    case Uint8Array:
                        return e.DT_UINT8;
                    case Uint16Array:
                        return e.DT_UINT16;
                    case Uint32Array:
                        return e.DT_UINT32
                    }
                }(e, i)
                  , u = e._malloc(l);
                t.GetAttributeDataArrayForAllPoints(n, o, c, l, u);
                const d = new i(e.HEAPF32.buffer,u,s).slice();
                return e._free(u),
                {
                    name: r,
                    array: d,
                    itemSize: a
                }
            }
            onmessage = function(r) {
                const i = r.data;
                switch (i.type) {
                case "init":
                    e = i.decoderConfig,
                    t = new Promise((function(t) {
                        e.onModuleLoaded = function(e) {
                            t({
                                draco: e
                            })
                        }
                        ,
                        DracoDecoderModule(e)
                    }
                    ));
                    break;
                case "decode":
                    const r = i.buffer
                      , o = i.taskConfig;
                    t.then((e => {
                        const t = e.draco
                          , a = new t.Decoder
                          , s = new t.DecoderBuffer;
                        s.Init(new Int8Array(r), r.byteLength);
                        try {
                            const e = function(e, t, r, i) {
                                const o = i.attributeIDs
                                  , a = i.attributeTypes;
                                let s, l;
                                const c = t.GetEncodedGeometryType(r);
                                if (c === e.TRIANGULAR_MESH)
                                    s = new e.Mesh,
                                    l = t.DecodeBufferToMesh(r, s);
                                else {
                                    if (c !== e.POINT_CLOUD)
                                        throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                    s = new e.PointCloud,
                                    l = t.DecodeBufferToPointCloud(r, s)
                                }
                                if (!l.ok() || 0 === s.ptr)
                                    throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                const u = {
                                    index: null,
                                    attributes: []
                                };
                                for (const d in o) {
                                    const r = self[a[d]];
                                    let l, c;
                                    if (i.useUniqueIDs)
                                        c = o[d],
                                        l = t.GetAttributeByUniqueId(s, c);
                                    else {
                                        if (c = t.GetAttributeId(s, e[o[d]]),
                                        -1 === c)
                                            continue;
                                        l = t.GetAttribute(s, c)
                                    }
                                    u.attributes.push(n(e, t, s, d, r, l))
                                }
                                c === e.TRIANGULAR_MESH && (u.index = function(e, t, n) {
                                    const r = n.num_faces()
                                      , i = 3 * r
                                      , o = 4 * i
                                      , a = e._malloc(o);
                                    t.GetTrianglesUInt32Array(n, o, a);
                                    const s = new Uint32Array(e.HEAPF32.buffer,a,i).slice();
                                    return e._free(a),
                                    {
                                        array: s,
                                        itemSize: 1
                                    }
                                }(e, t, s));
                                return e.destroy(s),
                                u
                            }(t, a, s, o)
                              , r = e.attributes.map((e => e.array.buffer));
                            e.index && r.push(e.index.array.buffer),
                            self.postMessage({
                                type: "decode",
                                id: i.id,
                                geometry: e
                            }, r)
                        } catch (l) {
                            console.error(l),
                            self.postMessage({
                                type: "error",
                                id: i.id,
                                error: l.message
                            })
                        } finally {
                            t.destroy(s),
                            t.destroy(a)
                        }
                    }
                    ))
                }
            }
        }
        let DC;
        const OC = () => {
            if (DC)
                return DC;
            const e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11])
              , t = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
            if ("object" !== typeof WebAssembly)
                return {
                    supported: !1
                };
            let n, r = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
            WebAssembly.validate(e) && (r = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB");
            const i = WebAssembly.instantiate(function(e) {
                const n = new Uint8Array(e.length);
                for (let t = 0; t < e.length; ++t) {
                    const r = e.charCodeAt(t);
                    n[t] = r > 96 ? r - 71 : r > 64 ? r - 65 : r > 47 ? r + 4 : r > 46 ? 63 : 62
                }
                let r = 0;
                for (let i = 0; i < e.length; ++i)
                    n[r++] = n[i] < 60 ? t[n[i]] : 64 * (n[i] - 60) + n[++i];
                return n.buffer.slice(0, r)
            }(r), {}).then((e => {
                n = e.instance,
                n.exports.__wasm_call_ctors()
            }
            ));
            function o(e, t, r, i, o, a) {
                const s = n.exports.sbrk
                  , l = r + 3 & -4
                  , c = s(l * i)
                  , u = s(o.length)
                  , d = new Uint8Array(n.exports.memory.buffer);
                d.set(o, u);
                const h = e(c, r, i, u, o.length);
                if (0 === h && a && a(c, l, i),
                t.set(d.subarray(c, c + r * i)),
                s(c - s(0)),
                0 !== h)
                    throw new Error(`Malformed buffer data: ${h}`)
            }
            const a = {
                0: "",
                1: "meshopt_decodeFilterOct",
                2: "meshopt_decodeFilterQuat",
                3: "meshopt_decodeFilterExp",
                NONE: "",
                OCTAHEDRAL: "meshopt_decodeFilterOct",
                QUATERNION: "meshopt_decodeFilterQuat",
                EXPONENTIAL: "meshopt_decodeFilterExp"
            }
              , s = {
                0: "meshopt_decodeVertexBuffer",
                1: "meshopt_decodeIndexBuffer",
                2: "meshopt_decodeIndexSequence",
                ATTRIBUTES: "meshopt_decodeVertexBuffer",
                TRIANGLES: "meshopt_decodeIndexBuffer",
                INDICES: "meshopt_decodeIndexSequence"
            };
            return DC = {
                ready: i,
                supported: !0,
                decodeVertexBuffer(e, t, r, i, s) {
                    o(n.exports.meshopt_decodeVertexBuffer, e, t, r, i, n.exports[a[s]])
                },
                decodeIndexBuffer(e, t, r, i) {
                    o(n.exports.meshopt_decodeIndexBuffer, e, t, r, i)
                },
                decodeIndexSequence(e, t, r, i) {
                    o(n.exports.meshopt_decodeIndexSequence, e, t, r, i)
                },
                decodeGltfBuffer(e, t, r, i, l, c) {
                    o(n.exports[s[l]], e, t, r, i, n.exports[a[c]])
                }
            },
            DC
        }
        ;
        function NC(e, t) {
            if (t === Mf)
                return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
                e;
            if (t === Tf || t === Cf) {
                let n = e.getIndex();
                if (null === n) {
                    const t = []
                      , r = e.getAttribute("position");
                    if (void 0 === r)
                        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                        e;
                    for (let e = 0; e < r.count; e++)
                        t.push(e);
                    e.setIndex(t),
                    n = e.getIndex()
                }
                const r = n.count - 2
                  , i = [];
                if (n)
                    if (t === Tf)
                        for (let e = 1; e <= r; e++)
                            i.push(n.getX(0)),
                            i.push(n.getX(e)),
                            i.push(n.getX(e + 1));
                    else
                        for (let e = 0; e < r; e++)
                            e % 2 === 0 ? (i.push(n.getX(e)),
                            i.push(n.getX(e + 1)),
                            i.push(n.getX(e + 2))) : (i.push(n.getX(e + 2)),
                            i.push(n.getX(e + 1)),
                            i.push(n.getX(e)));
                i.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                const o = e.clone();
                return o.setIndex(i),
                o.clearGroups(),
                o
            }
            return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t),
            e
        }
        const FC = parseInt(jd.replace(/\D+/g, ""));
        function UC(e) {
            if ("undefined" !== typeof TextDecoder)
                return (new TextDecoder).decode(e);
            let t = "";
            for (let r = 0, i = e.length; r < i; r++)
                t += String.fromCharCode(e[r]);
            try {
                return decodeURIComponent(escape(t))
            } catch (n) {
                return t
            }
        }
        const zC = "srgb"
          , GC = "srgb-linear";
        class HC extends xE {
            constructor(e) {
                super(e),
                this.dracoLoader = null,
                this.ktx2Loader = null,
                this.meshoptDecoder = null,
                this.pluginCallbacks = [],
                this.register((function(e) {
                    return new KC(e)
                }
                )),
                this.register((function(e) {
                    return new qC(e)
                }
                )),
                this.register((function(e) {
                    return new iT(e)
                }
                )),
                this.register((function(e) {
                    return new oT(e)
                }
                )),
                this.register((function(e) {
                    return new aT(e)
                }
                )),
                this.register((function(e) {
                    return new QC(e)
                }
                )),
                this.register((function(e) {
                    return new ZC(e)
                }
                )),
                this.register((function(e) {
                    return new $C(e)
                }
                )),
                this.register((function(e) {
                    return new eT(e)
                }
                )),
                this.register((function(e) {
                    return new JC(e)
                }
                )),
                this.register((function(e) {
                    return new tT(e)
                }
                )),
                this.register((function(e) {
                    return new YC(e)
                }
                )),
                this.register((function(e) {
                    return new rT(e)
                }
                )),
                this.register((function(e) {
                    return new nT(e)
                }
                )),
                this.register((function(e) {
                    return new VC(e)
                }
                )),
                this.register((function(e) {
                    return new sT(e)
                }
                )),
                this.register((function(e) {
                    return new lT(e)
                }
                ))
            }
            load(e, t, n, r) {
                const i = this;
                let o;
                if ("" !== this.resourcePath)
                    o = this.resourcePath;
                else if ("" !== this.path) {
                    const t = ZE.extractUrlBase(e);
                    o = ZE.resolveURL(t, this.path)
                } else
                    o = ZE.extractUrlBase(e);
                this.manager.itemStart(e);
                const a = function(t) {
                    r ? r(t) : console.error(t),
                    i.manager.itemError(e),
                    i.manager.itemEnd(e)
                }
                  , s = new EE(this.manager);
                s.setPath(this.path),
                s.setResponseType("arraybuffer"),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(this.withCredentials),
                s.load(e, (function(n) {
                    try {
                        i.parse(n, o, (function(n) {
                            t(n),
                            i.manager.itemEnd(e)
                        }
                        ), a)
                    } catch (r) {
                        a(r)
                    }
                }
                ), n, a)
            }
            setDRACOLoader(e) {
                return this.dracoLoader = e,
                this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(e) {
                return this.ktx2Loader = e,
                this
            }
            setMeshoptDecoder(e) {
                return this.meshoptDecoder = e,
                this
            }
            register(e) {
                return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
                this
            }
            unregister(e) {
                return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
                this
            }
            parse(e, t, n, r) {
                let i;
                const o = {}
                  , a = {};
                if ("string" === typeof e)
                    i = JSON.parse(e);
                else if (e instanceof ArrayBuffer) {
                    if (UC(new Uint8Array(e.slice(0, 4))) === cT) {
                        try {
                            o[WC.KHR_BINARY_GLTF] = new hT(e)
                        } catch (l) {
                            return void (r && r(l))
                        }
                        i = JSON.parse(o[WC.KHR_BINARY_GLTF].content)
                    } else
                        i = JSON.parse(UC(new Uint8Array(e)))
                } else
                    i = e;
                if (void 0 === i.asset || i.asset.version[0] < 2)
                    return void (r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const s = new NT(i,{
                    path: t || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                s.fileLoader.setRequestHeader(this.requestHeader);
                for (let c = 0; c < this.pluginCallbacks.length; c++) {
                    const e = this.pluginCallbacks[c](s);
                    e.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
                    a[e.name] = e,
                    o[e.name] = !0
                }
                if (i.extensionsUsed)
                    for (let c = 0; c < i.extensionsUsed.length; ++c) {
                        const e = i.extensionsUsed[c]
                          , t = i.extensionsRequired || [];
                        switch (e) {
                        case WC.KHR_MATERIALS_UNLIT:
                            o[e] = new XC;
                            break;
                        case WC.KHR_DRACO_MESH_COMPRESSION:
                            o[e] = new pT(i,this.dracoLoader);
                            break;
                        case WC.KHR_TEXTURE_TRANSFORM:
                            o[e] = new fT;
                            break;
                        case WC.KHR_MESH_QUANTIZATION:
                            o[e] = new mT;
                            break;
                        default:
                            t.indexOf(e) >= 0 && void 0 === a[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                        }
                    }
                s.setExtensions(o),
                s.setPlugins(a),
                s.parse(n, r)
            }
            parseAsync(e, t) {
                const n = this;
                return new Promise((function(r, i) {
                    n.parse(e, t, r, i)
                }
                ))
            }
        }
        function jC() {
            let e = {};
            return {
                get: function(t) {
                    return e[t]
                },
                add: function(t, n) {
                    e[t] = n
                },
                remove: function(t) {
                    delete e[t]
                },
                removeAll: function() {
                    e = {}
                }
            }
        }
        const WC = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_MATERIALS_BUMP: "EXT_materials_bump",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_TEXTURE_AVIF: "EXT_texture_avif",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
        };
        class VC {
            constructor(e) {
                this.parser = e,
                this.name = WC.KHR_LIGHTS_PUNCTUAL,
                this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const e = this.parser
                  , t = this.parser.json.nodes || [];
                for (let n = 0, r = t.length; n < r; n++) {
                    const r = t[n];
                    r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && e._addNodeRef(this.cache, r.extensions[this.name].light)
                }
            }
            _loadLight(e) {
                const t = this.parser
                  , n = "light:" + e;
                let r = t.cache.get(n);
                if (r)
                    return r;
                const i = t.json
                  , o = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];
                let a;
                const s = new Uv(16777215);
                void 0 !== o.color && s.setRGB(o.color[0], o.color[1], o.color[2], GC);
                const l = void 0 !== o.range ? o.range : 0;
                switch (o.type) {
                case "directional":
                    a = new XE(s),
                    a.target.position.set(0, 0, -1),
                    a.add(a.target);
                    break;
                case "point":
                    a = new WE(s),
                    a.distance = l;
                    break;
                case "spot":
                    a = new UE(s),
                    a.distance = l,
                    o.spot = o.spot || {},
                    o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0,
                    o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4,
                    a.angle = o.spot.outerConeAngle,
                    a.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle,
                    a.target.position.set(0, 0, -1),
                    a.add(a.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type)
                }
                return a.position.set(0, 0, 0),
                a.decay = 2,
                BT(a, o),
                void 0 !== o.intensity && (a.intensity = o.intensity),
                a.name = t.createUniqueName(o.name || "light_" + e),
                r = Promise.resolve(a),
                t.cache.add(n, r),
                r
            }
            getDependency(e, t) {
                if ("light" === e)
                    return this._loadLight(t)
            }
            createNodeAttachment(e) {
                const t = this
                  , n = this.parser
                  , r = n.json.nodes[e]
                  , i = (r.extensions && r.extensions[this.name] || {}).light;
                return void 0 === i ? null : this._loadLight(i).then((function(e) {
                    return n._getNodeRef(t.cache, i, e)
                }
                ))
            }
        }
        class XC {
            constructor() {
                this.name = WC.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return jv
            }
            extendParams(e, t, n) {
                const r = [];
                e.color = new Uv(1,1,1),
                e.opacity = 1;
                const i = t.pbrMetallicRoughness;
                if (i) {
                    if (Array.isArray(i.baseColorFactor)) {
                        const t = i.baseColorFactor;
                        e.color.setRGB(t[0], t[1], t[2], GC),
                        e.opacity = t[3]
                    }
                    void 0 !== i.baseColorTexture && r.push(n.assignTexture(e, "map", i.baseColorTexture, zC))
                }
                return Promise.all(r)
            }
        }
        class JC {
            constructor(e) {
                this.parser = e,
                this.name = WC.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const r = n.extensions[this.name].emissiveStrength;
                return void 0 !== r && (t.emissiveIntensity = r),
                Promise.resolve()
            }
        }
        class KC {
            constructor(e) {
                this.parser = e,
                this.name = WC.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Xw : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const i = []
                  , o = r.extensions[this.name];
                if (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor),
                void 0 !== o.clearcoatTexture && i.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
                void 0 !== o.clearcoatRoughnessFactor && (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
                void 0 !== o.clearcoatRoughnessTexture && i.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)),
                void 0 !== o.clearcoatNormalTexture && (i.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)),
                void 0 !== o.clearcoatNormalTexture.scale)) {
                    const e = o.clearcoatNormalTexture.scale;
                    t.clearcoatNormalScale = new Hm(e,e)
                }
                return Promise.all(i)
            }
        }
        class qC {
            constructor(e) {
                this.parser = e,
                this.name = WC.KHR_MATERIALS_DISPERSION
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Xw : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const r = n.extensions[this.name];
                return t.dispersion = void 0 !== r.dispersion ? r.dispersion : 0,
                Promise.resolve()
            }
        }
        class YC {
            constructor(e) {
                this.parser = e,
                this.name = WC.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Xw : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const i = []
                  , o = r.extensions[this.name];
                return void 0 !== o.iridescenceFactor && (t.iridescence = o.iridescenceFactor),
                void 0 !== o.iridescenceTexture && i.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
                void 0 !== o.iridescenceIor && (t.iridescenceIOR = o.iridescenceIor),
                void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]),
                void 0 !== o.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
                void 0 !== o.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
                void 0 !== o.iridescenceThicknessTexture && i.push(n.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)),
                Promise.all(i)
            }
        }
        class QC {
            constructor(e) {
                this.parser = e,
                this.name = WC.KHR_MATERIALS_SHEEN
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Xw : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const i = [];
                t.sheenColor = new Uv(0,0,0),
                t.sheenRoughness = 0,
                t.sheen = 1;
                const o = r.extensions[this.name];
                if (void 0 !== o.sheenColorFactor) {
                    const e = o.sheenColorFactor;
                    t.sheenColor.setRGB(e[0], e[1], e[2], GC)
                }
                return void 0 !== o.sheenRoughnessFactor && (t.sheenRoughness = o.sheenRoughnessFactor),
                void 0 !== o.sheenColorTexture && i.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, zC)),
                void 0 !== o.sheenRoughnessTexture && i.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)),
                Promise.all(i)
            }
        }
        class ZC {
            constructor(e) {
                this.parser = e,
                this.name = WC.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Xw : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const i = []
                  , o = r.extensions[this.name];
                return void 0 !== o.transmissionFactor && (t.transmission = o.transmissionFactor),
                void 0 !== o.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)),
                Promise.all(i)
            }
        }
        class $C {
            constructor(e) {
                this.parser = e,
                this.name = WC.KHR_MATERIALS_VOLUME
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Xw : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const i = []
                  , o = r.extensions[this.name];
                t.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0,
                void 0 !== o.thicknessTexture && i.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)),
                t.attenuationDistance = o.attenuationDistance || 1 / 0;
                const a = o.attenuationColor || [1, 1, 1];
                return t.attenuationColor = (new Uv).setRGB(a[0], a[1], a[2], GC),
                Promise.all(i)
            }
        }
        class eT {
            constructor(e) {
                this.parser = e,
                this.name = WC.KHR_MATERIALS_IOR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Xw : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const r = n.extensions[this.name];
                return t.ior = void 0 !== r.ior ? r.ior : 1.5,
                Promise.resolve()
            }
        }
        class tT {
            constructor(e) {
                this.parser = e,
                this.name = WC.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Xw : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const i = []
                  , o = r.extensions[this.name];
                t.specularIntensity = void 0 !== o.specularFactor ? o.specularFactor : 1,
                void 0 !== o.specularTexture && i.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
                const a = o.specularColorFactor || [1, 1, 1];
                return t.specularColor = (new Uv).setRGB(a[0], a[1], a[2], GC),
                void 0 !== o.specularColorTexture && i.push(n.assignTexture(t, "specularColorMap", o.specularColorTexture, zC)),
                Promise.all(i)
            }
        }
        class nT {
            constructor(e) {
                this.parser = e,
                this.name = WC.EXT_MATERIALS_BUMP
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Xw : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const i = []
                  , o = r.extensions[this.name];
                return t.bumpScale = void 0 !== o.bumpFactor ? o.bumpFactor : 1,
                void 0 !== o.bumpTexture && i.push(n.assignTexture(t, "bumpMap", o.bumpTexture)),
                Promise.all(i)
            }
        }
        class rT {
            constructor(e) {
                this.parser = e,
                this.name = WC.KHR_MATERIALS_ANISOTROPY
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Xw : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const i = []
                  , o = r.extensions[this.name];
                return void 0 !== o.anisotropyStrength && (t.anisotropy = o.anisotropyStrength),
                void 0 !== o.anisotropyRotation && (t.anisotropyRotation = o.anisotropyRotation),
                void 0 !== o.anisotropyTexture && i.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
                Promise.all(i)
            }
        }
        class iT {
            constructor(e) {
                this.parser = e,
                this.name = WC.KHR_TEXTURE_BASISU
            }
            loadTexture(e) {
                const t = this.parser
                  , n = t.json
                  , r = n.textures[e];
                if (!r.extensions || !r.extensions[this.name])
                    return null;
                const i = r.extensions[this.name]
                  , o = t.options.ktx2Loader;
                if (!o) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return t.loadTextureImage(e, i.source, o)
            }
        }
        class oT {
            constructor(e) {
                this.parser = e,
                this.name = WC.EXT_TEXTURE_WEBP,
                this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name
                  , n = this.parser
                  , r = n.json
                  , i = r.textures[e];
                if (!i.extensions || !i.extensions[t])
                    return null;
                const o = i.extensions[t]
                  , a = r.images[o.source];
                let s = n.textureLoader;
                if (a.uri) {
                    const e = n.options.manager.getHandler(a.uri);
                    null !== e && (s = e)
                }
                return this.detectSupport().then((function(i) {
                    if (i)
                        return n.loadTextureImage(e, o.source, s);
                    if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
                        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(e)
                }
                ))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                    t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }
                ))),
                this.isSupported
            }
        }
        class aT {
            constructor(e) {
                this.parser = e,
                this.name = WC.EXT_TEXTURE_AVIF,
                this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name
                  , n = this.parser
                  , r = n.json
                  , i = r.textures[e];
                if (!i.extensions || !i.extensions[t])
                    return null;
                const o = i.extensions[t]
                  , a = r.images[o.source];
                let s = n.textureLoader;
                if (a.uri) {
                    const e = n.options.manager.getHandler(a.uri);
                    null !== e && (s = e)
                }
                return this.detectSupport().then((function(i) {
                    if (i)
                        return n.loadTextureImage(e, o.source, s);
                    if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
                        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                    return n.loadTexture(e)
                }
                ))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
                    t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }
                ))),
                this.isSupported
            }
        }
        class sT {
            constructor(e) {
                this.name = WC.EXT_MESHOPT_COMPRESSION,
                this.parser = e
            }
            loadBufferView(e) {
                const t = this.parser.json
                  , n = t.bufferViews[e];
                if (n.extensions && n.extensions[this.name]) {
                    const e = n.extensions[this.name]
                      , r = this.parser.getDependency("buffer", e.buffer)
                      , i = this.parser.options.meshoptDecoder;
                    if (!i || !i.supported) {
                        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return r.then((function(t) {
                        const n = e.byteOffset || 0
                          , r = e.byteLength || 0
                          , o = e.count
                          , a = e.byteStride
                          , s = new Uint8Array(t,n,r);
                        return i.decodeGltfBufferAsync ? i.decodeGltfBufferAsync(o, a, s, e.mode, e.filter).then((function(e) {
                            return e.buffer
                        }
                        )) : i.ready.then((function() {
                            const t = new ArrayBuffer(o * a);
                            return i.decodeGltfBuffer(new Uint8Array(t), o, a, s, e.mode, e.filter),
                            t
                        }
                        ))
                    }
                    ))
                }
                return null
            }
        }
        class lT {
            constructor(e) {
                this.name = WC.EXT_MESH_GPU_INSTANCING,
                this.parser = e
            }
            createNodeMesh(e) {
                const t = this.parser.json
                  , n = t.nodes[e];
                if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
                    return null;
                const r = t.meshes[n.mesh];
                for (const s of r.primitives)
                    if (s.mode !== bT.TRIANGLES && s.mode !== bT.TRIANGLE_STRIP && s.mode !== bT.TRIANGLE_FAN && void 0 !== s.mode)
                        return null;
                const i = n.extensions[this.name].attributes
                  , o = []
                  , a = {};
                for (const s in i)
                    o.push(this.parser.getDependency("accessor", i[s]).then((e => (a[s] = e,
                    a[s]))));
                return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)),
                Promise.all(o).then((e => {
                    const t = e.pop()
                      , n = t.isGroup ? t.children : [t]
                      , r = e[0].count
                      , i = [];
                    for (const o of n) {
                        const e = new Qg
                          , t = new Ag
                          , n = new _g
                          , s = new Ag(1,1,1)
                          , l = new Ix(o.geometry,o.material,r);
                        for (let i = 0; i < r; i++)
                            a.TRANSLATION && t.fromBufferAttribute(a.TRANSLATION, i),
                            a.ROTATION && n.fromBufferAttribute(a.ROTATION, i),
                            a.SCALE && s.fromBufferAttribute(a.SCALE, i),
                            l.setMatrixAt(i, e.compose(t, n, s));
                        for (const r in a)
                            if ("_COLOR_0" === r) {
                                const e = a[r];
                                l.instanceColor = new wx(e.array,e.itemSize,e.normalized)
                            } else
                                "TRANSLATION" !== r && "ROTATION" !== r && "SCALE" !== r && o.geometry.setAttribute(r, a[r]);
                        xv.prototype.copy.call(l, o),
                        this.parser.assignFinalMaterial(l),
                        i.push(l)
                    }
                    return t.isGroup ? (t.clear(),
                    t.add(...i),
                    t) : i[0]
                }
                )))
            }
        }
        const cT = "glTF"
          , uT = 1313821514
          , dT = 5130562;
        class hT {
            constructor(e) {
                this.name = WC.KHR_BINARY_GLTF,
                this.content = null,
                this.body = null;
                const t = new DataView(e,0,12);
                if (this.header = {
                    magic: UC(new Uint8Array(e.slice(0, 4))),
                    version: t.getUint32(4, !0),
                    length: t.getUint32(8, !0)
                },
                this.header.magic !== cT)
                    throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2)
                    throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const n = this.header.length - 12
                  , r = new DataView(e,12);
                let i = 0;
                for (; i < n; ) {
                    const t = r.getUint32(i, !0);
                    i += 4;
                    const n = r.getUint32(i, !0);
                    if (i += 4,
                    n === uT) {
                        const n = new Uint8Array(e,12 + i,t);
                        this.content = UC(n)
                    } else if (n === dT) {
                        const n = 12 + i;
                        this.body = e.slice(n, n + t)
                    }
                    i += t
                }
                if (null === this.content)
                    throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class pT {
            constructor(e, t) {
                if (!t)
                    throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = WC.KHR_DRACO_MESH_COMPRESSION,
                this.json = e,
                this.dracoLoader = t,
                this.dracoLoader.preload()
            }
            decodePrimitive(e, t) {
                const n = this.json
                  , r = this.dracoLoader
                  , i = e.extensions[this.name].bufferView
                  , o = e.extensions[this.name].attributes
                  , a = {}
                  , s = {}
                  , l = {};
                for (const c in o) {
                    const e = wT[c] || c.toLowerCase();
                    a[e] = o[c]
                }
                for (const c in e.attributes) {
                    const t = wT[c] || c.toLowerCase();
                    if (void 0 !== o[c]) {
                        const r = n.accessors[e.attributes[c]]
                          , i = _T[r.componentType];
                        l[t] = i.name,
                        s[t] = !0 === r.normalized
                    }
                }
                return t.getDependency("bufferView", i).then((function(e) {
                    return new Promise((function(t, n) {
                        r.decodeDracoFile(e, (function(e) {
                            for (const t in e.attributes) {
                                const n = e.attributes[t]
                                  , r = s[t];
                                void 0 !== r && (n.normalized = r)
                            }
                            t(e)
                        }
                        ), a, l, GC, n)
                    }
                    ))
                }
                ))
            }
        }
        class fT {
            constructor() {
                this.name = WC.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(e, t) {
                return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(),
                void 0 !== t.texCoord && (e.channel = t.texCoord),
                void 0 !== t.offset && e.offset.fromArray(t.offset),
                void 0 !== t.rotation && (e.rotation = t.rotation),
                void 0 !== t.scale && e.repeat.fromArray(t.scale),
                e.needsUpdate = !0,
                e) : e
            }
        }
        class mT {
            constructor() {
                this.name = WC.KHR_MESH_QUANTIZATION
            }
        }
        class gT extends oE {
            constructor(e, t, n, r) {
                super(e, t, n, r)
            }
            copySampleValue_(e) {
                const t = this.resultBuffer
                  , n = this.sampleValues
                  , r = this.valueSize
                  , i = e * r * 3 + r;
                for (let o = 0; o !== r; o++)
                    t[o] = n[i + o];
                return t
            }
            interpolate_(e, t, n, r) {
                const i = this.resultBuffer
                  , o = this.sampleValues
                  , a = this.valueSize
                  , s = 2 * a
                  , l = 3 * a
                  , c = r - t
                  , u = (n - t) / c
                  , d = u * u
                  , h = d * u
                  , p = e * l
                  , f = p - l
                  , m = -2 * h + 3 * d
                  , g = h - d
                  , v = 1 - m
                  , y = g - d + u;
                for (let b = 0; b !== a; b++) {
                    const e = o[f + b + a]
                      , t = o[f + b + s] * c
                      , n = o[p + b + a]
                      , r = o[p + b] * c;
                    i[b] = v * e + y * t + m * n + g * r
                }
                return i
            }
        }
        const vT = new _g;
        class yT extends gT {
            interpolate_(e, t, n, r) {
                const i = super.interpolate_(e, t, n, r);
                return vT.fromArray(i).normalize().toArray(i),
                i
            }
        }
        const bT = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123
        }
          , _T = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }
          , AT = {
            9728: ip,
            9729: cp,
            9984: op,
            9985: up,
            9986: sp,
            9987: hp
        }
          , xT = {
            33071: np,
            33648: rp,
            10497: tp
        }
          , ST = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        }
          , wT = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            ...FC >= 152 ? {
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv1",
                TEXCOORD_2: "uv2",
                TEXCOORD_3: "uv3"
            } : {
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv2"
            },
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        }
          , ET = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        }
          , MT = {
            CUBICSPLINE: void 0,
            LINEAR: bf,
            STEP: yf
        }
          , CT = "OPAQUE"
          , TT = "MASK"
          , RT = "BLEND";
        function PT(e, t, n) {
            for (const r in n.extensions)
                void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {},
                t.userData.gltfExtensions[r] = n.extensions[r])
        }
        function BT(e, t) {
            void 0 !== t.extras && ("object" === typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
        }
        function IT(e, t) {
            if (e.updateMorphTargets(),
            void 0 !== t.weights)
                for (let n = 0, r = t.weights.length; n < r; n++)
                    e.morphTargetInfluences[n] = t.weights[n];
            if (t.extras && Array.isArray(t.extras.targetNames)) {
                const n = t.extras.targetNames;
                if (e.morphTargetInfluences.length === n.length) {
                    e.morphTargetDictionary = {};
                    for (let t = 0, r = n.length; t < r; t++)
                        e.morphTargetDictionary[n[t]] = t
                } else
                    console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }
        function LT(e) {
            let t;
            const n = e.extensions && e.extensions[WC.KHR_DRACO_MESH_COMPRESSION];
            if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + kT(n.attributes) : e.indices + ":" + kT(e.attributes) + ":" + e.mode,
            void 0 !== e.targets)
                for (let r = 0, i = e.targets.length; r < i; r++)
                    t += ":" + kT(e.targets[r]);
            return t
        }
        function kT(e) {
            let t = "";
            const n = Object.keys(e).sort();
            for (let r = 0, i = n.length; r < i; r++)
                t += n[r] + ":" + e[n[r]] + ";";
            return t
        }
        function DT(e) {
            switch (e) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        const OT = new Qg;
        class NT {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                this.json = e,
                this.extensions = {},
                this.plugins = {},
                this.options = t,
                this.cache = new jC,
                this.associations = new Map,
                this.primitiveCache = {},
                this.nodeCache = {},
                this.meshCache = {
                    refs: {},
                    uses: {}
                },
                this.cameraCache = {
                    refs: {},
                    uses: {}
                },
                this.lightCache = {
                    refs: {},
                    uses: {}
                },
                this.sourceCache = {},
                this.textureCache = {},
                this.nodeNamesUsed = {};
                let n = !1
                  , r = !1
                  , i = -1;
                "undefined" !== typeof navigator && "undefined" !== typeof navigator.userAgent && (n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                r = navigator.userAgent.indexOf("Firefox") > -1,
                i = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1),
                "undefined" === typeof createImageBitmap || n || r && i < 98 ? this.textureLoader = new BE(this.options.manager) : this.textureLoader = new oM(this.options.manager),
                this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                this.textureLoader.setRequestHeader(this.options.requestHeader),
                this.fileLoader = new EE(this.options.manager),
                this.fileLoader.setResponseType("arraybuffer"),
                "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(e) {
                this.extensions = e
            }
            setPlugins(e) {
                this.plugins = e
            }
            parse(e, t) {
                const n = this
                  , r = this.json
                  , i = this.extensions;
                this.cache.removeAll(),
                this.nodeCache = {},
                this._invokeAll((function(e) {
                    return e._markDefs && e._markDefs()
                }
                )),
                Promise.all(this._invokeAll((function(e) {
                    return e.beforeRoot && e.beforeRoot()
                }
                ))).then((function() {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                }
                )).then((function(t) {
                    const o = {
                        scene: t[0][r.scene || 0],
                        scenes: t[0],
                        animations: t[1],
                        cameras: t[2],
                        asset: r.asset,
                        parser: n,
                        userData: {}
                    };
                    return PT(i, o, r),
                    BT(o, r),
                    Promise.all(n._invokeAll((function(e) {
                        return e.afterRoot && e.afterRoot(o)
                    }
                    ))).then((function() {
                        for (const e of o.scenes)
                            e.updateMatrixWorld();
                        e(o)
                    }
                    ))
                }
                )).catch(t)
            }
            _markDefs() {
                const e = this.json.nodes || []
                  , t = this.json.skins || []
                  , n = this.json.meshes || [];
                for (let r = 0, i = t.length; r < i; r++) {
                    const n = t[r].joints;
                    for (let t = 0, r = n.length; t < r; t++)
                        e[n[t]].isBone = !0
                }
                for (let r = 0, i = e.length; r < i; r++) {
                    const t = e[r];
                    void 0 !== t.mesh && (this._addNodeRef(this.meshCache, t.mesh),
                    void 0 !== t.skin && (n[t.mesh].isSkinnedMesh = !0)),
                    void 0 !== t.camera && this._addNodeRef(this.cameraCache, t.camera)
                }
            }
            _addNodeRef(e, t) {
                void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0),
                e.refs[t]++)
            }
            _getNodeRef(e, t, n) {
                if (e.refs[t] <= 1)
                    return n;
                const r = n.clone()
                  , i = (e, t) => {
                    const n = this.associations.get(e);
                    null != n && this.associations.set(t, n);
                    for (const [r,o] of e.children.entries())
                        i(o, t.children[r])
                }
                ;
                return i(n, r),
                r.name += "_instance_" + e.uses[t]++,
                r
            }
            _invokeOne(e) {
                const t = Object.values(this.plugins);
                t.push(this);
                for (let n = 0; n < t.length; n++) {
                    const r = e(t[n]);
                    if (r)
                        return r
                }
                return null
            }
            _invokeAll(e) {
                const t = Object.values(this.plugins);
                t.unshift(this);
                const n = [];
                for (let r = 0; r < t.length; r++) {
                    const i = e(t[r]);
                    i && n.push(i)
                }
                return n
            }
            getDependency(e, t) {
                const n = e + ":" + t;
                let r = this.cache.get(n);
                if (!r) {
                    switch (e) {
                    case "scene":
                        r = this.loadScene(t);
                        break;
                    case "node":
                        r = this._invokeOne((function(e) {
                            return e.loadNode && e.loadNode(t)
                        }
                        ));
                        break;
                    case "mesh":
                        r = this._invokeOne((function(e) {
                            return e.loadMesh && e.loadMesh(t)
                        }
                        ));
                        break;
                    case "accessor":
                        r = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        r = this._invokeOne((function(e) {
                            return e.loadBufferView && e.loadBufferView(t)
                        }
                        ));
                        break;
                    case "buffer":
                        r = this.loadBuffer(t);
                        break;
                    case "material":
                        r = this._invokeOne((function(e) {
                            return e.loadMaterial && e.loadMaterial(t)
                        }
                        ));
                        break;
                    case "texture":
                        r = this._invokeOne((function(e) {
                            return e.loadTexture && e.loadTexture(t)
                        }
                        ));
                        break;
                    case "skin":
                        r = this.loadSkin(t);
                        break;
                    case "animation":
                        r = this._invokeOne((function(e) {
                            return e.loadAnimation && e.loadAnimation(t)
                        }
                        ));
                        break;
                    case "camera":
                        r = this.loadCamera(t);
                        break;
                    default:
                        if (r = this._invokeOne((function(n) {
                            return n != this && n.getDependency && n.getDependency(e, t)
                        }
                        )),
                        !r)
                            throw new Error("Unknown type: " + e)
                    }
                    this.cache.add(n, r)
                }
                return r
            }
            getDependencies(e) {
                let t = this.cache.get(e);
                if (!t) {
                    const n = this
                      , r = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                    t = Promise.all(r.map((function(t, r) {
                        return n.getDependency(e, r)
                    }
                    ))),
                    this.cache.add(e, t)
                }
                return t
            }
            loadBuffer(e) {
                const t = this.json.buffers[e]
                  , n = this.fileLoader;
                if (t.type && "arraybuffer" !== t.type)
                    throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                if (void 0 === t.uri && 0 === e)
                    return Promise.resolve(this.extensions[WC.KHR_BINARY_GLTF].body);
                const r = this.options;
                return new Promise((function(e, i) {
                    n.load(ZE.resolveURL(t.uri, r.path), e, void 0, (function() {
                        i(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                    }
                    ))
                }
                ))
            }
            loadBufferView(e) {
                const t = this.json.bufferViews[e];
                return this.getDependency("buffer", t.buffer).then((function(e) {
                    const n = t.byteLength || 0
                      , r = t.byteOffset || 0;
                    return e.slice(r, r + n)
                }
                ))
            }
            loadAccessor(e) {
                const t = this
                  , n = this.json
                  , r = this.json.accessors[e];
                if (void 0 === r.bufferView && void 0 === r.sparse) {
                    const e = ST[r.type]
                      , t = _T[r.componentType]
                      , n = !0 === r.normalized
                      , i = new t(r.count * e);
                    return Promise.resolve(new Qv(i,e,n))
                }
                const i = [];
                return void 0 !== r.bufferView ? i.push(this.getDependency("bufferView", r.bufferView)) : i.push(null),
                void 0 !== r.sparse && (i.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
                i.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
                Promise.all(i).then((function(e) {
                    const i = e[0]
                      , o = ST[r.type]
                      , a = _T[r.componentType]
                      , s = a.BYTES_PER_ELEMENT
                      , l = s * o
                      , c = r.byteOffset || 0
                      , u = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0
                      , d = !0 === r.normalized;
                    let h, p;
                    if (u && u !== l) {
                        const e = Math.floor(c / u)
                          , n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + e + ":" + r.count;
                        let l = t.cache.get(n);
                        l || (h = new a(i,e * u,r.count * u / s),
                        l = new GA(h,u / s),
                        t.cache.add(n, l)),
                        p = new jA(l,o,c % u / s,d)
                    } else
                        h = null === i ? new a(r.count * o) : new a(i,c,r.count * o),
                        p = new Qv(h,o,d);
                    if (void 0 !== r.sparse) {
                        const t = ST.SCALAR
                          , n = _T[r.sparse.indices.componentType]
                          , s = r.sparse.indices.byteOffset || 0
                          , l = r.sparse.values.byteOffset || 0
                          , c = new n(e[1],s,r.sparse.count * t)
                          , u = new a(e[2],l,r.sparse.count * o);
                        null !== i && (p = new Qv(p.array.slice(),p.itemSize,p.normalized));
                        for (let e = 0, r = c.length; e < r; e++) {
                            const t = c[e];
                            if (p.setX(t, u[e * o]),
                            o >= 2 && p.setY(t, u[e * o + 1]),
                            o >= 3 && p.setZ(t, u[e * o + 2]),
                            o >= 4 && p.setW(t, u[e * o + 3]),
                            o >= 5)
                                throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return p
                }
                ))
            }
            loadTexture(e) {
                const t = this.json
                  , n = this.options
                  , r = t.textures[e].source
                  , i = t.images[r];
                let o = this.textureLoader;
                if (i.uri) {
                    const e = n.manager.getHandler(i.uri);
                    null !== e && (o = e)
                }
                return this.loadTextureImage(e, r, o)
            }
            loadTextureImage(e, t, n) {
                const r = this
                  , i = this.json
                  , o = i.textures[e]
                  , a = i.images[t]
                  , s = (a.uri || a.bufferView) + ":" + o.sampler;
                if (this.textureCache[s])
                    return this.textureCache[s];
                const l = this.loadImageSource(t, n).then((function(t) {
                    t.flipY = !1,
                    t.name = o.name || a.name || "",
                    "" === t.name && "string" === typeof a.uri && !1 === a.uri.startsWith("data:image/") && (t.name = a.uri);
                    const n = (i.samplers || {})[o.sampler] || {};
                    return t.magFilter = AT[n.magFilter] || cp,
                    t.minFilter = AT[n.minFilter] || hp,
                    t.wrapS = xT[n.wrapS] || tp,
                    t.wrapT = xT[n.wrapT] || tp,
                    r.associations.set(t, {
                        textures: e
                    }),
                    t
                }
                )).catch((function() {
                    return null
                }
                ));
                return this.textureCache[s] = l,
                l
            }
            loadImageSource(e, t) {
                const n = this
                  , r = this.json
                  , i = this.options;
                if (void 0 !== this.sourceCache[e])
                    return this.sourceCache[e].then((e => e.clone()));
                const o = r.images[e]
                  , a = self.URL || self.webkitURL;
                let s = o.uri || ""
                  , l = !1;
                if (void 0 !== o.bufferView)
                    s = n.getDependency("bufferView", o.bufferView).then((function(e) {
                        l = !0;
                        const t = new Blob([e],{
                            type: o.mimeType
                        });
                        return s = a.createObjectURL(t),
                        s
                    }
                    ));
                else if (void 0 === o.uri)
                    throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                const c = Promise.resolve(s).then((function(e) {
                    return new Promise((function(n, r) {
                        let o = n;
                        !0 === t.isImageBitmapLoader && (o = function(e) {
                            const t = new dg(e);
                            t.needsUpdate = !0,
                            n(t)
                        }
                        ),
                        t.load(ZE.resolveURL(e, i.path), o, void 0, r)
                    }
                    ))
                }
                )).then((function(e) {
                    var t;
                    return !0 === l && a.revokeObjectURL(s),
                    BT(e, o),
                    e.userData.mimeType = o.mimeType || ((t = o.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"),
                    e
                }
                )).catch((function(e) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", s),
                    e
                }
                ));
                return this.sourceCache[e] = c,
                c
            }
            assignTexture(e, t, n, r) {
                const i = this;
                return this.getDependency("texture", n.index).then((function(o) {
                    if (!o)
                        return null;
                    if (void 0 !== n.texCoord && n.texCoord > 0 && ((o = o.clone()).channel = n.texCoord),
                    i.extensions[WC.KHR_TEXTURE_TRANSFORM]) {
                        const e = void 0 !== n.extensions ? n.extensions[WC.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (e) {
                            const t = i.associations.get(o);
                            o = i.extensions[WC.KHR_TEXTURE_TRANSFORM].extendTexture(o, e),
                            i.associations.set(o, t)
                        }
                    }
                    return void 0 !== r && ("number" === typeof r && (r = 3001 === r ? zC : GC),
                    "colorSpace"in o ? o.colorSpace = r : o.encoding = r === zC ? 3001 : 3e3),
                    e[t] = o,
                    o
                }
                ))
            }
            assignFinalMaterial(e) {
                const t = e.geometry;
                let n = e.material;
                const r = void 0 === t.attributes.tangent
                  , i = void 0 !== t.attributes.color
                  , o = void 0 === t.attributes.normal;
                if (e.isPoints) {
                    const e = "PointsMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new sS,
                    Hv.prototype.copy.call(t, n),
                    t.color.copy(n.color),
                    t.map = n.map,
                    t.sizeAttenuation = !1,
                    this.cache.add(e, t)),
                    n = t
                } else if (e.isLine) {
                    const e = "LineBasicMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new Yx,
                    Hv.prototype.copy.call(t, n),
                    t.color.copy(n.color),
                    t.map = n.map,
                    this.cache.add(e, t)),
                    n = t
                }
                if (r || i || o) {
                    let e = "ClonedMaterial:" + n.uuid + ":";
                    r && (e += "derivative-tangents:"),
                    i && (e += "vertex-colors:"),
                    o && (e += "flat-shading:");
                    let t = this.cache.get(e);
                    t || (t = n.clone(),
                    i && (t.vertexColors = !0),
                    o && (t.flatShading = !0),
                    r && (t.normalScale && (t.normalScale.y *= -1),
                    t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
                    this.cache.add(e, t),
                    this.associations.set(t, this.associations.get(n))),
                    n = t
                }
                e.material = n
            }
            getMaterialType() {
                return Vw
            }
            loadMaterial(e) {
                const t = this
                  , n = this.json
                  , r = this.extensions
                  , i = n.materials[e];
                let o;
                const a = {}
                  , s = [];
                if ((i.extensions || {})[WC.KHR_MATERIALS_UNLIT]) {
                    const e = r[WC.KHR_MATERIALS_UNLIT];
                    o = e.getMaterialType(),
                    s.push(e.extendParams(a, i, t))
                } else {
                    const n = i.pbrMetallicRoughness || {};
                    if (a.color = new Uv(1,1,1),
                    a.opacity = 1,
                    Array.isArray(n.baseColorFactor)) {
                        const e = n.baseColorFactor;
                        a.color.setRGB(e[0], e[1], e[2], GC),
                        a.opacity = e[3]
                    }
                    void 0 !== n.baseColorTexture && s.push(t.assignTexture(a, "map", n.baseColorTexture, zC)),
                    a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1,
                    a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1,
                    void 0 !== n.metallicRoughnessTexture && (s.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)),
                    s.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))),
                    o = this._invokeOne((function(t) {
                        return t.getMaterialType && t.getMaterialType(e)
                    }
                    )),
                    s.push(Promise.all(this._invokeAll((function(t) {
                        return t.extendMaterialParams && t.extendMaterialParams(e, a)
                    }
                    ))))
                }
                !0 === i.doubleSided && (a.side = nh);
                const l = i.alphaMode || CT;
                if (l === RT ? (a.transparent = !0,
                a.depthWrite = !1) : (a.transparent = !1,
                l === TT && (a.alphaTest = void 0 !== i.alphaCutoff ? i.alphaCutoff : .5)),
                void 0 !== i.normalTexture && o !== jv && (s.push(t.assignTexture(a, "normalMap", i.normalTexture)),
                a.normalScale = new Hm(1,1),
                void 0 !== i.normalTexture.scale)) {
                    const e = i.normalTexture.scale;
                    a.normalScale.set(e, e)
                }
                if (void 0 !== i.occlusionTexture && o !== jv && (s.push(t.assignTexture(a, "aoMap", i.occlusionTexture)),
                void 0 !== i.occlusionTexture.strength && (a.aoMapIntensity = i.occlusionTexture.strength)),
                void 0 !== i.emissiveFactor && o !== jv) {
                    const e = i.emissiveFactor;
                    a.emissive = (new Uv).setRGB(e[0], e[1], e[2], GC)
                }
                return void 0 !== i.emissiveTexture && o !== jv && s.push(t.assignTexture(a, "emissiveMap", i.emissiveTexture, zC)),
                Promise.all(s).then((function() {
                    const n = new o(a);
                    return i.name && (n.name = i.name),
                    BT(n, i),
                    t.associations.set(n, {
                        materials: e
                    }),
                    i.extensions && PT(r, n, i),
                    n
                }
                ))
            }
            createUniqueName(e) {
                const t = kM.sanitizeNodeName(e || "");
                return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0,
                t)
            }
            loadGeometries(e) {
                const t = this
                  , n = this.extensions
                  , r = this.primitiveCache;
                function i(e) {
                    return n[WC.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                        return FT(n, e, t)
                    }
                    ))
                }
                const o = [];
                for (let a = 0, s = e.length; a < s; a++) {
                    const n = e[a]
                      , s = LT(n)
                      , l = r[s];
                    if (l)
                        o.push(l.promise);
                    else {
                        let e;
                        e = n.extensions && n.extensions[WC.KHR_DRACO_MESH_COMPRESSION] ? i(n) : FT(new my, n, t),
                        r[s] = {
                            primitive: n,
                            promise: e
                        },
                        o.push(e)
                    }
                }
                return Promise.all(o)
            }
            loadMesh(e) {
                const t = this
                  , n = this.json
                  , r = this.extensions
                  , i = n.meshes[e]
                  , o = i.primitives
                  , a = [];
                for (let l = 0, c = o.length; l < c; l++) {
                    const e = void 0 === o[l].material ? (void 0 === (s = this.cache).DefaultMaterial && (s.DefaultMaterial = new Vw({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: eh
                    })),
                    s.DefaultMaterial) : this.getDependency("material", o[l].material);
                    a.push(e)
                }
                var s;
                return a.push(t.loadGeometries(o)),
                Promise.all(a).then((function(n) {
                    const a = n.slice(0, n.length - 1)
                      , s = n[n.length - 1]
                      , l = [];
                    for (let u = 0, d = s.length; u < d; u++) {
                        const n = s[u]
                          , c = o[u];
                        let d;
                        const h = a[u];
                        if (c.mode === bT.TRIANGLES || c.mode === bT.TRIANGLE_STRIP || c.mode === bT.TRIANGLE_FAN || void 0 === c.mode)
                            d = !0 === i.isSkinnedMesh ? new yx(n,h) : new Ly(n,h),
                            !0 === d.isSkinnedMesh && d.normalizeSkinWeights(),
                            c.mode === bT.TRIANGLE_STRIP ? d.geometry = NC(d.geometry, Cf) : c.mode === bT.TRIANGLE_FAN && (d.geometry = NC(d.geometry, Tf));
                        else if (c.mode === bT.LINES)
                            d = new oS(n,h);
                        else if (c.mode === bT.LINE_STRIP)
                            d = new nS(n,h);
                        else if (c.mode === bT.LINE_LOOP)
                            d = new aS(n,h);
                        else {
                            if (c.mode !== bT.POINTS)
                                throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + c.mode);
                            d = new hS(n,h)
                        }
                        Object.keys(d.geometry.morphAttributes).length > 0 && IT(d, i),
                        d.name = t.createUniqueName(i.name || "mesh_" + e),
                        BT(d, i),
                        c.extensions && PT(r, d, c),
                        t.assignFinalMaterial(d),
                        l.push(d)
                    }
                    for (let r = 0, i = l.length; r < i; r++)
                        t.associations.set(l[r], {
                            meshes: e,
                            primitives: r
                        });
                    if (1 === l.length)
                        return i.extensions && PT(r, l[0], i),
                        l[0];
                    const c = new PA;
                    i.extensions && PT(r, c, i),
                    t.associations.set(c, {
                        meshes: e
                    });
                    for (let e = 0, t = l.length; e < t; e++)
                        c.add(l[e]);
                    return c
                }
                ))
            }
            loadCamera(e) {
                let t;
                const n = this.json.cameras[e]
                  , r = n[n.type];
                if (r)
                    return "perspective" === n.type ? t = new Hy(Gm.radToDeg(r.yfov),r.aspectRatio || 1,r.znear || 1,r.zfar || 2e6) : "orthographic" === n.type && (t = new pb(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),
                    n.name && (t.name = this.createUniqueName(n.name)),
                    BT(t, n),
                    Promise.resolve(t);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(e) {
                const t = this.json.skins[e]
                  , n = [];
                for (let r = 0, i = t.joints.length; r < i; r++)
                    n.push(this._loadNodeShallow(t.joints[r]));
                return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null),
                Promise.all(n).then((function(e) {
                    const n = e.pop()
                      , r = e
                      , i = []
                      , o = [];
                    for (let a = 0, s = r.length; a < s; a++) {
                        const e = r[a];
                        if (e) {
                            i.push(e);
                            const t = new Qg;
                            null !== n && t.fromArray(n.array, 16 * a),
                            o.push(t)
                        } else
                            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[a])
                    }
                    return new Sx(i,o)
                }
                ))
            }
            loadAnimation(e) {
                const t = this.json
                  , n = this
                  , r = t.animations[e]
                  , i = r.name ? r.name : "animation_" + e
                  , o = []
                  , a = []
                  , s = []
                  , l = []
                  , c = [];
                for (let u = 0, d = r.channels.length; u < d; u++) {
                    const e = r.channels[u]
                      , t = r.samplers[e.sampler]
                      , n = e.target
                      , i = n.node
                      , d = void 0 !== r.parameters ? r.parameters[t.input] : t.input
                      , h = void 0 !== r.parameters ? r.parameters[t.output] : t.output;
                    void 0 !== n.node && (o.push(this.getDependency("node", i)),
                    a.push(this.getDependency("accessor", d)),
                    s.push(this.getDependency("accessor", h)),
                    l.push(t),
                    c.push(n))
                }
                return Promise.all([Promise.all(o), Promise.all(a), Promise.all(s), Promise.all(l), Promise.all(c)]).then((function(e) {
                    const t = e[0]
                      , r = e[1]
                      , o = e[2]
                      , a = e[3]
                      , s = e[4]
                      , l = [];
                    for (let i = 0, c = t.length; i < c; i++) {
                        const e = t[i]
                          , c = r[i]
                          , u = o[i]
                          , d = a[i]
                          , h = s[i];
                        if (void 0 === e)
                            continue;
                        e.updateMatrix && e.updateMatrix();
                        const p = n._createAnimationTracks(e, c, u, d, h);
                        if (p)
                            for (let t = 0; t < p.length; t++)
                                l.push(p[t])
                    }
                    return new vE(i,void 0,l)
                }
                ))
            }
            createNodeMesh(e) {
                const t = this.json
                  , n = this
                  , r = t.nodes[e];
                return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then((function(e) {
                    const t = n._getNodeRef(n.meshCache, r.mesh, e);
                    return void 0 !== r.weights && t.traverse((function(e) {
                        if (e.isMesh)
                            for (let t = 0, n = r.weights.length; t < n; t++)
                                e.morphTargetInfluences[t] = r.weights[t]
                    }
                    )),
                    t
                }
                ))
            }
            loadNode(e) {
                const t = this
                  , n = this.json.nodes[e]
                  , r = t._loadNodeShallow(e)
                  , i = []
                  , o = n.children || [];
                for (let s = 0, l = o.length; s < l; s++)
                    i.push(t.getDependency("node", o[s]));
                const a = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin);
                return Promise.all([r, Promise.all(i), a]).then((function(e) {
                    const t = e[0]
                      , n = e[1]
                      , r = e[2];
                    null !== r && t.traverse((function(e) {
                        e.isSkinnedMesh && e.bind(r, OT)
                    }
                    ));
                    for (let i = 0, o = n.length; i < o; i++)
                        t.add(n[i]);
                    return t
                }
                ))
            }
            _loadNodeShallow(e) {
                const t = this.json
                  , n = this.extensions
                  , r = this;
                if (void 0 !== this.nodeCache[e])
                    return this.nodeCache[e];
                const i = t.nodes[e]
                  , o = i.name ? r.createUniqueName(i.name) : ""
                  , a = []
                  , s = r._invokeOne((function(t) {
                    return t.createNodeMesh && t.createNodeMesh(e)
                }
                ));
                return s && a.push(s),
                void 0 !== i.camera && a.push(r.getDependency("camera", i.camera).then((function(e) {
                    return r._getNodeRef(r.cameraCache, i.camera, e)
                }
                ))),
                r._invokeAll((function(t) {
                    return t.createNodeAttachment && t.createNodeAttachment(e)
                }
                )).forEach((function(e) {
                    a.push(e)
                }
                )),
                this.nodeCache[e] = Promise.all(a).then((function(t) {
                    let a;
                    if (a = !0 === i.isBone ? new bx : t.length > 1 ? new PA : 1 === t.length ? t[0] : new xv,
                    a !== t[0])
                        for (let e = 0, n = t.length; e < n; e++)
                            a.add(t[e]);
                    if (i.name && (a.userData.name = i.name,
                    a.name = o),
                    BT(a, i),
                    i.extensions && PT(n, a, i),
                    void 0 !== i.matrix) {
                        const e = new Qg;
                        e.fromArray(i.matrix),
                        a.applyMatrix4(e)
                    } else
                        void 0 !== i.translation && a.position.fromArray(i.translation),
                        void 0 !== i.rotation && a.quaternion.fromArray(i.rotation),
                        void 0 !== i.scale && a.scale.fromArray(i.scale);
                    return r.associations.has(a) || r.associations.set(a, {}),
                    r.associations.get(a).nodes = e,
                    a
                }
                )),
                this.nodeCache[e]
            }
            loadScene(e) {
                const t = this.extensions
                  , n = this.json.scenes[e]
                  , r = this
                  , i = new PA;
                n.name && (i.name = r.createUniqueName(n.name)),
                BT(i, n),
                n.extensions && PT(t, i, n);
                const o = n.nodes || []
                  , a = [];
                for (let s = 0, l = o.length; s < l; s++)
                    a.push(r.getDependency("node", o[s]));
                return Promise.all(a).then((function(e) {
                    for (let t = 0, n = e.length; t < n; t++)
                        i.add(e[t]);
                    return r.associations = (e => {
                        const t = new Map;
                        for (const [n,i] of r.associations)
                            (n instanceof Hv || n instanceof dg) && t.set(n, i);
                        return e.traverse((e => {
                            const n = r.associations.get(e);
                            null != n && t.set(e, n)
                        }
                        )),
                        t
                    }
                    )(i),
                    i
                }
                ))
            }
            _createAnimationTracks(e, t, n, r, i) {
                const o = []
                  , a = e.name ? e.name : e.uuid
                  , s = [];
                let l;
                switch (ET[i.path] === ET.weights ? e.traverse((function(e) {
                    e.morphTargetInfluences && s.push(e.name ? e.name : e.uuid)
                }
                )) : s.push(a),
                ET[i.path]) {
                case ET.weights:
                    l = hE;
                    break;
                case ET.rotation:
                    l = fE;
                    break;
                case ET.position:
                case ET.scale:
                    l = gE;
                    break;
                default:
                    if (1 === n.itemSize)
                        l = hE;
                    else
                        l = gE
                }
                const c = void 0 !== r.interpolation ? MT[r.interpolation] : bf
                  , u = this._getArrayFromAccessor(n);
                for (let d = 0, h = s.length; d < h; d++) {
                    const e = new l(s[d] + "." + ET[i.path],t.array,u,c);
                    "CUBICSPLINE" === r.interpolation && this._createCubicSplineTrackInterpolant(e),
                    o.push(e)
                }
                return o
            }
            _getArrayFromAccessor(e) {
                let t = e.array;
                if (e.normalized) {
                    const e = DT(t.constructor)
                      , n = new Float32Array(t.length);
                    for (let r = 0, i = t.length; r < i; r++)
                        n[r] = t[r] * e;
                    t = n
                }
                return t
            }
            _createCubicSplineTrackInterpolant(e) {
                e.createInterpolant = function(e) {
                    return new (this instanceof fE ? yT : gT)(this.times,this.values,this.getValueSize() / 3,e)
                }
                ,
                e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
            }
        }
        function FT(e, t, n) {
            const r = t.attributes
              , i = [];
            function o(t, r) {
                return n.getDependency("accessor", t).then((function(t) {
                    e.setAttribute(r, t)
                }
                ))
            }
            for (const a in r) {
                const t = wT[a] || a.toLowerCase();
                t in e.attributes || i.push(o(r[a], t))
            }
            if (void 0 !== t.indices && !e.index) {
                const r = n.getDependency("accessor", t.indices).then((function(t) {
                    e.setIndex(t)
                }
                ));
                i.push(r)
            }
            return BT(e, t),
            function(e, t, n) {
                const r = t.attributes
                  , i = new wg;
                if (void 0 === r.POSITION)
                    return;
                {
                    const e = n.json.accessors[r.POSITION]
                      , t = e.min
                      , o = e.max;
                    if (void 0 === t || void 0 === o)
                        return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    if (i.set(new Ag(t[0],t[1],t[2]), new Ag(o[0],o[1],o[2])),
                    e.normalized) {
                        const t = DT(_T[e.componentType]);
                        i.min.multiplyScalar(t),
                        i.max.multiplyScalar(t)
                    }
                }
                const o = t.targets;
                if (void 0 !== o) {
                    const e = new Ag
                      , t = new Ag;
                    for (let r = 0, i = o.length; r < i; r++) {
                        const i = o[r];
                        if (void 0 !== i.POSITION) {
                            const r = n.json.accessors[i.POSITION]
                              , o = r.min
                              , a = r.max;
                            if (void 0 !== o && void 0 !== a) {
                                if (t.setX(Math.max(Math.abs(o[0]), Math.abs(a[0]))),
                                t.setY(Math.max(Math.abs(o[1]), Math.abs(a[1]))),
                                t.setZ(Math.max(Math.abs(o[2]), Math.abs(a[2]))),
                                r.normalized) {
                                    const e = DT(_T[r.componentType]);
                                    t.multiplyScalar(e)
                                }
                                e.max(t)
                            } else
                                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }
                    i.expandByVector(e)
                }
                e.boundingBox = i;
                const a = new Hg;
                i.getCenter(a.center),
                a.radius = i.min.distanceTo(i.max) / 2,
                e.boundingSphere = a
            }(e, t, n),
            Promise.all(i).then((function() {
                return void 0 !== t.targets ? function(e, t, n) {
                    let r = !1
                      , i = !1
                      , o = !1;
                    for (let c = 0, u = t.length; c < u; c++) {
                        const e = t[c];
                        if (void 0 !== e.POSITION && (r = !0),
                        void 0 !== e.NORMAL && (i = !0),
                        void 0 !== e.COLOR_0 && (o = !0),
                        r && i && o)
                            break
                    }
                    if (!r && !i && !o)
                        return Promise.resolve(e);
                    const a = []
                      , s = []
                      , l = [];
                    for (let c = 0, u = t.length; c < u; c++) {
                        const u = t[c];
                        if (r) {
                            const t = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : e.attributes.position;
                            a.push(t)
                        }
                        if (i) {
                            const t = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : e.attributes.normal;
                            s.push(t)
                        }
                        if (o) {
                            const t = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : e.attributes.color;
                            l.push(t)
                        }
                    }
                    return Promise.all([Promise.all(a), Promise.all(s), Promise.all(l)]).then((function(t) {
                        const n = t[0]
                          , a = t[1]
                          , s = t[2];
                        return r && (e.morphAttributes.position = n),
                        i && (e.morphAttributes.normal = a),
                        o && (e.morphAttributes.color = s),
                        e.morphTargetsRelative = !0,
                        e
                    }
                    ))
                }(e, t.targets, n) : e
            }
            ))
        }
        var UT = __webpack_require__(3878);
        function zT(e) {
            let t;
            const n = new Set
              , r = (e, r) => {
                const i = "function" === typeof e ? e(t) : e;
                if (i !== t) {
                    const e = t;
                    t = r ? i : Object.assign({}, t, i),
                    n.forEach((n => n(t, e)))
                }
            }
              , i = () => t
              , o = {
                setState: r,
                getState: i,
                subscribe: (e, r, o) => r || o ? function(e) {
                    let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i
                      , o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Object.is;
                    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
                    let a = r(t);
                    function s() {
                        const n = r(t);
                        if (!o(a, n)) {
                            const t = a;
                            e(a = n, t)
                        }
                    }
                    return n.add(s),
                    () => n.delete(s)
                }(e, r, o) : (n.add(e),
                () => n.delete(e)),
                destroy: () => n.clear()
            };
            return t = e(r, i, o),
            o
        }
        const GT = "undefined" === typeof window || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent) ? t.useEffect : t.useLayoutEffect;
        const HT = [];
        function jT(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : (e, t) => e === t;
            if (e === t)
                return !0;
            if (!e || !t)
                return !1;
            const r = e.length;
            if (t.length !== r)
                return !1;
            for (let i = 0; i < r; i++)
                if (!n(e[i], t[i]))
                    return !1;
            return !0
        }
        function WT(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
              , n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
              , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
            null === t && (t = [e]);
            for (const a of HT)
                if (jT(t, a.keys, a.equal)) {
                    if (n)
                        return;
                    if (Object.prototype.hasOwnProperty.call(a, "error"))
                        throw a.error;
                    if (Object.prototype.hasOwnProperty.call(a, "response"))
                        return r.lifespan && r.lifespan > 0 && (a.timeout && clearTimeout(a.timeout),
                        a.timeout = setTimeout(a.remove, r.lifespan)),
                        a.response;
                    if (!n)
                        throw a.promise
                }
            const i = {
                keys: t,
                equal: r.equal,
                remove: () => {
                    const e = HT.indexOf(i);
                    -1 !== e && HT.splice(e, 1)
                }
                ,
                promise: (o = e,
                "object" === typeof o && "function" === typeof o.then ? e : e(...t)).then((e => {
                    i.response = e,
                    r.lifespan && r.lifespan > 0 && (i.timeout = setTimeout(i.remove, r.lifespan))
                }
                )).catch((e => i.error = e))
            };
            var o;
            if (HT.push(i),
            !n)
                throw i.promise
        }
        var VT = __webpack_require__(9235)
          , XT = __webpack_require__.n(VT)
          , JT = __webpack_require__(5340);
        const KT = {};
        var qT, YT;
        const QT = e => "colorSpace"in e || "outputColorSpace"in e
          , ZT = () => {
            var e;
            return null != (e = KT.ColorManagement) ? e : null
        }
          , $T = e => e && e.isOrthographicCamera
          , eR = "undefined" !== typeof window && (null != (qT = window.document) && qT.createElement || "ReactNative" === (null == (YT = window.navigator) ? void 0 : YT.product)) ? t.useLayoutEffect : t.useEffect;
        function tR(e) {
            const n = t.useRef(e);
            return eR(( () => {
                n.current = e
            }
            ), [e]),
            n
        }
        function nR(e) {
            let {set: t} = e;
            return eR(( () => (t(new Promise(( () => null))),
            () => t(!1))), [t]),
            null
        }
        class rR extends t.Component {
            constructor() {
                super(...arguments),
                this.state = {
                    error: !1
                }
            }
            componentDidCatch(e) {
                this.props.set(e)
            }
            render() {
                return this.state.error ? null : this.props.children
            }
        }
        rR.getDerivedStateFromError = () => ({
            error: !0
        });
        const iR = "__default"
          , oR = new Map
          , aR = e => e && !!e.memoized && !!e.changes;
        function sR(e) {
            var t;
            const n = "undefined" !== typeof window ? null != (t = window.devicePixelRatio) ? t : 2 : 1;
            return Array.isArray(e) ? Math.min(Math.max(e[0], n), e[1]) : e
        }
        const lR = e => {
            var t;
            return null == (t = e.__r3f) ? void 0 : t.root.getState()
        }
        ;
        function cR(e) {
            let t = e.__r3f.root;
            for (; t.getState().previousRoot; )
                t = t.getState().previousRoot;
            return t
        }
        const uR = {
            obj: e => e === Object(e) && !uR.arr(e) && "function" !== typeof e,
            fun: e => "function" === typeof e,
            str: e => "string" === typeof e,
            num: e => "number" === typeof e,
            boo: e => "boolean" === typeof e,
            und: e => void 0 === e,
            arr: e => Array.isArray(e),
            equ(e, t) {
                let {arrays: n="shallow", objects: r="reference", strict: i=!0} = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                if (typeof e !== typeof t || !!e !== !!t)
                    return !1;
                if (uR.str(e) || uR.num(e) || uR.boo(e))
                    return e === t;
                const o = uR.obj(e);
                if (o && "reference" === r)
                    return e === t;
                const a = uR.arr(e);
                if (a && "reference" === n)
                    return e === t;
                if ((a || o) && e === t)
                    return !0;
                let s;
                for (s in e)
                    if (!(s in t))
                        return !1;
                if (o && "shallow" === n && "shallow" === r) {
                    for (s in i ? t : e)
                        if (!uR.equ(e[s], t[s], {
                            strict: i,
                            objects: "reference"
                        }))
                            return !1
                } else
                    for (s in i ? t : e)
                        if (e[s] !== t[s])
                            return !1;
                if (uR.und(s)) {
                    if (a && 0 === e.length && 0 === t.length)
                        return !0;
                    if (o && 0 === Object.keys(e).length && 0 === Object.keys(t).length)
                        return !0;
                    if (e !== t)
                        return !1
                }
                return !0
            }
        };
        function dR(e) {
            const t = {
                nodes: {},
                materials: {}
            };
            return e && e.traverse((e => {
                e.name && (t.nodes[e.name] = e),
                e.material && !t.materials[e.material.name] && (t.materials[e.material.name] = e.material)
            }
            )),
            t
        }
        function hR(e, t) {
            return e.__r3f = {
                type: "",
                root: null,
                previousAttach: null,
                memoizedProps: {},
                eventCount: 0,
                handlers: {},
                objects: [],
                parent: null,
                ...t
            },
            e
        }
        function pR(e, t) {
            let n = e;
            if (t.includes("-")) {
                const r = t.split("-")
                  , i = r.pop();
                return n = r.reduce(( (e, t) => e[t]), e),
                {
                    target: n,
                    key: i
                }
            }
            return {
                target: n,
                key: t
            }
        }
        const fR = /-\d+$/;
        function mR(e, t, n) {
            if (uR.str(n)) {
                if (fR.test(n)) {
                    const t = n.replace(fR, "")
                      , {target: r, key: i} = pR(e, t);
                    Array.isArray(r[i]) || (r[i] = [])
                }
                const {target: r, key: i} = pR(e, n);
                t.__r3f.previousAttach = r[i],
                r[i] = t
            } else
                t.__r3f.previousAttach = n(e, t)
        }
        function gR(e, t, n) {
            var r, i;
            if (uR.str(n)) {
                const {target: r, key: i} = pR(e, n)
                  , o = t.__r3f.previousAttach;
                void 0 === o ? delete r[i] : r[i] = o
            } else
                null == (r = t.__r3f) || null == r.previousAttach || r.previousAttach(e, t);
            null == (i = t.__r3f) || delete i.previousAttach
        }
        function vR(e, t) {
            let {children: n, key: r, ref: i, ...o} = t
              , {children: a, key: s, ref: l, ...c} = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
              , u = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            const d = e.__r3f
              , h = Object.entries(o)
              , p = [];
            if (u) {
                const e = Object.keys(c);
                for (let t = 0; t < e.length; t++)
                    o.hasOwnProperty(e[t]) || h.unshift([e[t], iR + "remove"])
            }
            h.forEach((t => {
                let[n,r] = t;
                var i;
                if (null != (i = e.__r3f) && i.primitive && "object" === n)
                    return;
                if (uR.equ(r, c[n]))
                    return;
                if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(n))
                    return p.push([n, r, !0, []]);
                let a = [];
                n.includes("-") && (a = n.split("-")),
                p.push([n, r, !1, a]);
                for (const e in o) {
                    const t = o[e];
                    e.startsWith(`${n}-`) && p.push([e, t, !1, e.split("-")])
                }
            }
            ));
            const f = {
                ...o
            };
            return null != d && d.memoizedProps && null != d && d.memoizedProps.args && (f.args = d.memoizedProps.args),
            null != d && d.memoizedProps && null != d && d.memoizedProps.attach && (f.attach = d.memoizedProps.attach),
            {
                memoized: f,
                changes: p
            }
        }
        const yR = "undefined" !== typeof process && !1;
        function bR(e, t) {
            var n;
            const r = e.__r3f
              , i = null == r ? void 0 : r.root
              , o = null == i || null == i.getState ? void 0 : i.getState()
              , {memoized: a, changes: s} = aR(t) ? t : vR(e, t)
              , l = null == r ? void 0 : r.eventCount;
            e.__r3f && (e.__r3f.memoizedProps = a);
            for (let c = 0; c < s.length; c++) {
                let[t,n,i,a] = s[c];
                if (QT(e)) {
                    const e = 3001
                      , r = "srgb"
                      , i = "srgb-linear";
                    "encoding" === t ? (t = "colorSpace",
                    n = n === e ? r : i) : "outputEncoding" === t && (t = "outputColorSpace",
                    n = n === e ? r : i)
                }
                let l = e
                  , u = l[t];
                if (a.length && (u = a.reduce(( (e, t) => e[t]), e),
                !u || !u.set)) {
                    const [n,...r] = a.reverse();
                    l = r.reverse().reduce(( (e, t) => e[t]), e),
                    t = n
                }
                if (n === iR + "remove")
                    if (l.constructor) {
                        let e = oR.get(l.constructor);
                        e || (e = new l.constructor,
                        oR.set(l.constructor, e)),
                        n = e[t]
                    } else
                        n = 0;
                if (i && r)
                    n ? r.handlers[t] = n : delete r.handlers[t],
                    r.eventCount = Object.keys(r.handlers).length;
                else if (u && u.set && (u.copy || u instanceof lv)) {
                    if (Array.isArray(n))
                        u.fromArray ? u.fromArray(n) : u.set(...n);
                    else if (u.copy && n && n.constructor && (yR ? u.constructor.name === n.constructor.name : u.constructor === n.constructor))
                        u.copy(n);
                    else if (void 0 !== n) {
                        const e = u instanceof Uv;
                        !e && u.setScalar ? u.setScalar(n) : u instanceof lv && n instanceof lv ? u.mask = n.mask : u.set(n),
                        !ZT() && o && !o.linear && e && u.convertSRGBToLinear()
                    }
                } else if (l[t] = n,
                l[t]instanceof dg && l[t].format === Mp && l[t].type === fp && o) {
                    const e = l[t];
                    QT(e) && QT(o.gl) ? e.colorSpace = o.gl.outputColorSpace : e.encoding = o.gl.outputEncoding
                }
                _R(e)
            }
            if (r && r.parent && e.raycast && l !== r.eventCount) {
                const t = cR(e).getState().internal
                  , n = t.interaction.indexOf(e);
                n > -1 && t.interaction.splice(n, 1),
                r.eventCount && t.interaction.push(e)
            }
            return !(1 === s.length && "onUpdate" === s[0][0]) && s.length && null != (n = e.__r3f) && n.parent && AR(e),
            e
        }
        function _R(e) {
            var t, n;
            const r = null == (t = e.__r3f) || null == (n = t.root) || null == n.getState ? void 0 : n.getState();
            r && 0 === r.internal.frames && r.invalidate()
        }
        function AR(e) {
            null == e.onUpdate || e.onUpdate(e)
        }
        function xR(e, t) {
            e.manual || ($T(e) ? (e.left = t.width / -2,
            e.right = t.width / 2,
            e.top = t.height / 2,
            e.bottom = t.height / -2) : e.aspect = t.width / t.height,
            e.updateProjectionMatrix(),
            e.updateMatrixWorld())
        }
        function SR(e) {
            return (e.eventObject || e.object).uuid + "/" + e.index + e.instanceId
        }
        function wR(e, t, n, r) {
            const i = n.get(t);
            i && (n.delete(t),
            0 === n.size && (e.delete(r),
            i.target.releasePointerCapture(r)))
        }
        function ER(e) {
            function t(e) {
                return e.filter((e => ["Move", "Over", "Enter", "Out", "Leave"].some((t => {
                    var n;
                    return null == (n = e.__r3f) ? void 0 : n.handlers["onPointer" + t]
                }
                ))))
            }
            function n(t) {
                const {internal: n} = e.getState();
                for (const e of n.hovered.values())
                    if (!t.length || !t.find((t => t.object === e.object && t.index === e.index && t.instanceId === e.instanceId))) {
                        const r = e.eventObject.__r3f
                          , i = null == r ? void 0 : r.handlers;
                        if (n.hovered.delete(SR(e)),
                        null != r && r.eventCount) {
                            const n = {
                                ...e,
                                intersections: t
                            };
                            null == i.onPointerOut || i.onPointerOut(n),
                            null == i.onPointerLeave || i.onPointerLeave(n)
                        }
                    }
            }
            function r(e, t) {
                for (let n = 0; n < t.length; n++) {
                    const r = t[n].__r3f;
                    null == r || null == r.handlers.onPointerMissed || r.handlers.onPointerMissed(e)
                }
            }
            return {
                handlePointer: function(i) {
                    switch (i) {
                    case "onPointerLeave":
                    case "onPointerCancel":
                        return () => n([]);
                    case "onLostPointerCapture":
                        return t => {
                            const {internal: r} = e.getState();
                            "pointerId"in t && r.capturedMap.has(t.pointerId) && requestAnimationFrame(( () => {
                                r.capturedMap.has(t.pointerId) && (r.capturedMap.delete(t.pointerId),
                                n([]))
                            }
                            ))
                        }
                    }
                    return function(o) {
                        const {onPointerMissed: a, internal: s} = e.getState();
                        s.lastEvent.current = o;
                        const l = "onPointerMove" === i
                          , c = "onClick" === i || "onContextMenu" === i || "onDoubleClick" === i
                          , u = function(t, n) {
                            const r = e.getState()
                              , i = new Set
                              , o = []
                              , a = n ? n(r.internal.interaction) : r.internal.interaction;
                            for (let e = 0; e < a.length; e++) {
                                const t = lR(a[e]);
                                t && (t.raycaster.camera = void 0)
                            }
                            r.previousRoot || null == r.events.compute || r.events.compute(t, r);
                            let s = a.flatMap((function(e) {
                                const n = lR(e);
                                return n && n.events.enabled && null !== n.raycaster.camera ? (void 0 === n.raycaster.camera && (null == n.events.compute || n.events.compute(t, n, null == (r = n.previousRoot) ? void 0 : r.getState()),
                                void 0 === n.raycaster.camera && (n.raycaster.camera = null)),
                                n.raycaster.camera ? n.raycaster.intersectObject(e, !0) : []) : [];
                                var r
                            }
                            )).sort(( (e, t) => {
                                const n = lR(e.object)
                                  , r = lR(t.object);
                                return n && r && r.events.priority - n.events.priority || e.distance - t.distance
                            }
                            )).filter((e => {
                                const t = SR(e);
                                return !i.has(t) && (i.add(t),
                                !0)
                            }
                            ));
                            r.events.filter && (s = r.events.filter(s, r));
                            for (const e of s) {
                                let t = e.object;
                                for (; t; ) {
                                    var l;
                                    null != (l = t.__r3f) && l.eventCount && o.push({
                                        ...e,
                                        eventObject: t
                                    }),
                                    t = t.parent
                                }
                            }
                            if ("pointerId"in t && r.internal.capturedMap.has(t.pointerId))
                                for (let e of r.internal.capturedMap.get(t.pointerId).values())
                                    i.has(SR(e.intersection)) || o.push(e.intersection);
                            return o
                        }(o, l ? t : void 0)
                          , d = c ? function(t) {
                            const {internal: n} = e.getState()
                              , r = t.offsetX - n.initialClick[0]
                              , i = t.offsetY - n.initialClick[1];
                            return Math.round(Math.sqrt(r * r + i * i))
                        }(o) : 0;
                        "onPointerDown" === i && (s.initialClick = [o.offsetX, o.offsetY],
                        s.initialHits = u.map((e => e.eventObject))),
                        c && !u.length && d <= 2 && (r(o, s.interaction),
                        a && a(o)),
                        l && n(u),
                        function(t, r, i, o) {
                            const a = e.getState();
                            if (t.length) {
                                const e = {
                                    stopped: !1
                                };
                                for (const s of t) {
                                    const l = lR(s.object) || a
                                      , {raycaster: c, pointer: u, camera: d, internal: h} = l
                                      , p = new Ag(u.x,u.y,0).unproject(d)
                                      , f = e => {
                                        var t, n;
                                        return null != (t = null == (n = h.capturedMap.get(e)) ? void 0 : n.has(s.eventObject)) && t
                                    }
                                      , m = e => {
                                        const t = {
                                            intersection: s,
                                            target: r.target
                                        };
                                        h.capturedMap.has(e) ? h.capturedMap.get(e).set(s.eventObject, t) : h.capturedMap.set(e, new Map([[s.eventObject, t]])),
                                        r.target.setPointerCapture(e)
                                    }
                                      , g = e => {
                                        const t = h.capturedMap.get(e);
                                        t && wR(h.capturedMap, s.eventObject, t, e)
                                    }
                                    ;
                                    let v = {};
                                    for (let e in r) {
                                        let t = r[e];
                                        "function" !== typeof t && (v[e] = t)
                                    }
                                    let y = {
                                        ...s,
                                        ...v,
                                        pointer: u,
                                        intersections: t,
                                        stopped: e.stopped,
                                        delta: i,
                                        unprojectedPoint: p,
                                        ray: c.ray,
                                        camera: d,
                                        stopPropagation() {
                                            const i = "pointerId"in r && h.capturedMap.get(r.pointerId);
                                            (!i || i.has(s.eventObject)) && (y.stopped = e.stopped = !0,
                                            h.hovered.size && Array.from(h.hovered.values()).find((e => e.eventObject === s.eventObject))) && n([...t.slice(0, t.indexOf(s)), s])
                                        },
                                        target: {
                                            hasPointerCapture: f,
                                            setPointerCapture: m,
                                            releasePointerCapture: g
                                        },
                                        currentTarget: {
                                            hasPointerCapture: f,
                                            setPointerCapture: m,
                                            releasePointerCapture: g
                                        },
                                        nativeEvent: r
                                    };
                                    if (o(y),
                                    !0 === e.stopped)
                                        break
                                }
                            }
                        }(u, o, d, (function(e) {
                            const t = e.eventObject
                              , n = t.__r3f
                              , a = null == n ? void 0 : n.handlers;
                            if (null != n && n.eventCount)
                                if (l) {
                                    if (a.onPointerOver || a.onPointerEnter || a.onPointerOut || a.onPointerLeave) {
                                        const t = SR(e)
                                          , n = s.hovered.get(t);
                                        n ? n.stopped && e.stopPropagation() : (s.hovered.set(t, e),
                                        null == a.onPointerOver || a.onPointerOver(e),
                                        null == a.onPointerEnter || a.onPointerEnter(e))
                                    }
                                    null == a.onPointerMove || a.onPointerMove(e)
                                } else {
                                    const n = a[i];
                                    n ? c && !s.initialHits.includes(t) || (r(o, s.interaction.filter((e => !s.initialHits.includes(e)))),
                                    n(e)) : c && s.initialHits.includes(t) && r(o, s.interaction.filter((e => !s.initialHits.includes(e))))
                                }
                        }
                        ))
                    }
                }
            }
        }
        const MR = e => !(null == e || !e.render)
          , CR = t.createContext(null)
          , TR = (e, n) => {
            const r = function(e) {
                const n = "function" === typeof e ? zT(e) : e
                  , r = function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : n.getState
                      , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Object.is;
                    const [,i] = (0,
                    t.useReducer)((e => e + 1), 0)
                      , o = n.getState()
                      , a = (0,
                    t.useRef)(o)
                      , s = (0,
                    t.useRef)(e)
                      , l = (0,
                    t.useRef)(r)
                      , c = (0,
                    t.useRef)(!1)
                      , u = (0,
                    t.useRef)();
                    let d;
                    void 0 === u.current && (u.current = e(o));
                    let h = !1;
                    (a.current !== o || s.current !== e || l.current !== r || c.current) && (d = e(o),
                    h = !r(u.current, d)),
                    GT(( () => {
                        h && (u.current = d),
                        a.current = o,
                        s.current = e,
                        l.current = r,
                        c.current = !1
                    }
                    ));
                    const p = (0,
                    t.useRef)(o);
                    GT(( () => {
                        const e = () => {
                            try {
                                const e = n.getState()
                                  , t = s.current(e);
                                l.current(u.current, t) || (a.current = e,
                                u.current = t,
                                i())
                            } catch (e) {
                                c.current = !0,
                                i()
                            }
                        }
                          , t = n.subscribe(e);
                        return n.getState() !== p.current && e(),
                        t
                    }
                    ), []);
                    const f = h ? d : u.current;
                    return (0,
                    t.useDebugValue)(f),
                    f
                };
                return Object.assign(r, n),
                r[Symbol.iterator] = function() {
                    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
                    const e = [r, n];
                    return {
                        next() {
                            const t = e.length <= 0;
                            return {
                                value: e.shift(),
                                done: t
                            }
                        }
                    }
                }
                ,
                r
            }(( (r, i) => {
                const o = new Ag
                  , a = new Ag
                  , s = new Ag;
                function l() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i().camera
                      , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : a
                      , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i().size;
                    const {width: r, height: l, top: c, left: u} = n
                      , d = r / l;
                    t instanceof Ag ? s.copy(t) : s.set(...t);
                    const h = e.getWorldPosition(o).distanceTo(s);
                    if ($T(e))
                        return {
                            width: r / e.zoom,
                            height: l / e.zoom,
                            top: c,
                            left: u,
                            factor: 1,
                            distance: h,
                            aspect: d
                        };
                    {
                        const t = e.fov * Math.PI / 180
                          , n = 2 * Math.tan(t / 2) * h
                          , i = n * (r / l);
                        return {
                            width: i,
                            height: n,
                            top: c,
                            left: u,
                            factor: r / i,
                            distance: h,
                            aspect: d
                        }
                    }
                }
                let c;
                const u = e => r((t => ({
                    performance: {
                        ...t.performance,
                        current: e
                    }
                })))
                  , d = new Hm
                  , h = {
                    set: r,
                    get: i,
                    gl: null,
                    camera: null,
                    raycaster: null,
                    events: {
                        priority: 1,
                        enabled: !0,
                        connected: !1
                    },
                    xr: null,
                    scene: null,
                    invalidate: function() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                        return e(i(), t)
                    },
                    advance: (e, t) => n(e, t, i()),
                    legacy: !1,
                    linear: !1,
                    flat: !1,
                    controls: null,
                    clock: new pM,
                    pointer: d,
                    mouse: d,
                    frameloop: "always",
                    onPointerMissed: void 0,
                    performance: {
                        current: 1,
                        min: .5,
                        max: 1,
                        debounce: 200,
                        regress: () => {
                            const e = i();
                            c && clearTimeout(c),
                            e.performance.current !== e.performance.min && u(e.performance.min),
                            c = setTimeout(( () => u(i().performance.max)), e.performance.debounce)
                        }
                    },
                    size: {
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        updateStyle: !1
                    },
                    viewport: {
                        initialDpr: 0,
                        dpr: 0,
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        aspect: 0,
                        distance: 0,
                        factor: 0,
                        getCurrentViewport: l
                    },
                    setEvents: e => r((t => ({
                        ...t,
                        events: {
                            ...t.events,
                            ...e
                        }
                    }))),
                    setSize: (e, t, n, o, s) => {
                        const c = i().camera
                          , u = {
                            width: e,
                            height: t,
                            top: o || 0,
                            left: s || 0,
                            updateStyle: n
                        };
                        r((e => ({
                            size: u,
                            viewport: {
                                ...e.viewport,
                                ...l(c, a, u)
                            }
                        })))
                    }
                    ,
                    setDpr: e => r((t => {
                        const n = sR(e);
                        return {
                            viewport: {
                                ...t.viewport,
                                dpr: n,
                                initialDpr: t.viewport.initialDpr || n
                            }
                        }
                    }
                    )),
                    setFrameloop: function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "always";
                        const t = i().clock;
                        t.stop(),
                        t.elapsedTime = 0,
                        "never" !== e && (t.start(),
                        t.elapsedTime = 0),
                        r(( () => ({
                            frameloop: e
                        })))
                    },
                    previousRoot: void 0,
                    internal: {
                        active: !1,
                        priority: 0,
                        frames: 0,
                        lastEvent: t.createRef(),
                        interaction: [],
                        hovered: new Map,
                        subscribers: [],
                        initialClick: [0, 0],
                        initialHits: [],
                        capturedMap: new Map,
                        subscribe: (e, t, n) => {
                            const r = i().internal;
                            return r.priority = r.priority + (t > 0 ? 1 : 0),
                            r.subscribers.push({
                                ref: e,
                                priority: t,
                                store: n
                            }),
                            r.subscribers = r.subscribers.sort(( (e, t) => e.priority - t.priority)),
                            () => {
                                const n = i().internal;
                                null != n && n.subscribers && (n.priority = n.priority - (t > 0 ? 1 : 0),
                                n.subscribers = n.subscribers.filter((t => t.ref !== e)))
                            }
                        }
                    }
                };
                return h
            }
            ))
              , i = r.getState();
            let o = i.size
              , a = i.viewport.dpr
              , s = i.camera;
            return r.subscribe(( () => {
                const {camera: e, size: t, viewport: n, gl: i, set: l} = r.getState();
                if (t.width !== o.width || t.height !== o.height || n.dpr !== a) {
                    var c;
                    o = t,
                    a = n.dpr,
                    xR(e, t),
                    i.setPixelRatio(n.dpr);
                    const r = null != (c = t.updateStyle) ? c : "undefined" !== typeof HTMLCanvasElement && i.domElement instanceof HTMLCanvasElement;
                    i.setSize(t.width, t.height, r)
                }
                e !== s && (s = e,
                l((t => ({
                    viewport: {
                        ...t.viewport,
                        ...t.viewport.getCurrentViewport(e)
                    }
                }))))
            }
            )),
            r.subscribe((t => e(t))),
            r
        }
        ;
        let RR, PR = new Set, BR = new Set, IR = new Set;
        function LR(e, t) {
            if (e.size)
                for (const {callback: n} of e.values())
                    n(t)
        }
        function kR(e, t) {
            switch (e) {
            case "before":
                return LR(PR, t);
            case "after":
                return LR(BR, t);
            case "tail":
                return LR(IR, t)
            }
        }
        let DR, OR;
        function NR(e, t, n) {
            let r = t.clock.getDelta();
            for ("never" === t.frameloop && "number" === typeof e && (r = e - t.clock.elapsedTime,
            t.clock.oldTime = t.clock.elapsedTime,
            t.clock.elapsedTime = e),
            DR = t.internal.subscribers,
            RR = 0; RR < DR.length; RR++)
                OR = DR[RR],
                OR.ref.current(OR.store.getState(), r, n);
            return !t.internal.priority && t.gl.render && t.gl.render(t.scene, t.camera),
            t.internal.frames = Math.max(0, t.internal.frames - 1),
            "always" === t.frameloop ? 1 : t.internal.frames
        }
        function FR() {
            const e = t.useContext(CR);
            if (!e)
                throw new Error("R3F: Hooks can only be used within the Canvas component!");
            return e
        }
        function UR() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : e => e
              , t = arguments.length > 1 ? arguments[1] : void 0;
            return FR()(e, t)
        }
        function zR(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            const n = FR()
              , r = n.getState().internal.subscribe
              , i = tR(e);
            return eR(( () => r(i, t, n)), [t, r, n]),
            null
        }
        const GR = new WeakMap;
        function HR(e, t) {
            return function(n) {
                let r = GR.get(n);
                r || (r = new n,
                GR.set(n, r)),
                e && e(r);
                for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
                    o[a - 1] = arguments[a];
                return Promise.all(o.map((e => new Promise(( (n, i) => r.load(e, (e => {
                    e.scene && Object.assign(e, dR(e.scene)),
                    n(e)
                }
                ), t, (t => i(new Error(`Could not load ${e}: ${null == t ? void 0 : t.message}`)))))))))
            }
        }
        function jR(e, t, n, r) {
            const i = Array.isArray(t) ? t : [t]
              , o = ( (e, t, n) => WT(e, t, !1, n))(HR(n, r), [e, ...i], {
                equal: uR.equ
            });
            return Array.isArray(t) ? o : o[0]
        }
        jR.preload = function(e, t, n) {
            const r = Array.isArray(t) ? t : [t];
            return ( (e, t, n) => {
                WT(e, t, !0, n)
            }
            )(HR(n), [e, ...r])
        }
        ,
        jR.clear = function(e, t) {
            return (e => {
                if (void 0 === e || 0 === e.length)
                    HT.splice(0, HT.length);
                else {
                    const t = HT.find((t => jT(e, t.keys, t.equal)));
                    t && t.remove()
                }
            }
            )([e, ...Array.isArray(t) ? t : [t]])
        }
        ;
        const WR = new Map
          , {invalidate: VR, advance: XR} = function(e) {
            let t, n, r, i = !1, o = !1;
            function a(s) {
                n = requestAnimationFrame(a),
                i = !0,
                t = 0,
                kR("before", s),
                o = !0;
                for (const n of e.values()) {
                    var l;
                    r = n.store.getState(),
                    !r.internal.active || !("always" === r.frameloop || r.internal.frames > 0) || null != (l = r.gl.xr) && l.isPresenting || (t += NR(s, r))
                }
                if (o = !1,
                kR("after", s),
                0 === t)
                    return kR("tail", s),
                    i = !1,
                    cancelAnimationFrame(n)
            }
            return {
                loop: a,
                invalidate: function t(n) {
                    let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                    var s;
                    if (!n)
                        return e.forEach((e => t(e.store.getState(), r)));
                    null != (s = n.gl.xr) && s.isPresenting || !n.internal.active || "never" === n.frameloop || (n.internal.frames = r > 1 ? Math.min(60, n.internal.frames + r) : o ? 2 : 1,
                    i || (i = !0,
                    requestAnimationFrame(a)))
                },
                advance: function(t) {
                    let n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                      , r = arguments.length > 2 ? arguments[2] : void 0
                      , i = arguments.length > 3 ? arguments[3] : void 0;
                    if (n && kR("before", t),
                    r)
                        NR(t, r, i);
                    else
                        for (const o of e.values())
                            NR(t, o.store.getState());
                    n && kR("after", t)
                }
            }
        }(WR)
          , {reconciler: JR, applyProps: KR} = function(e, t) {
            function n(e, t, n) {
                let r, {args: i=[], attach: o, ...a} = t, s = `${e[0].toUpperCase()}${e.slice(1)}`;
                if ("primitive" === e) {
                    if (void 0 === a.object)
                        throw new Error("R3F: Primitives without 'object' are invalid!");
                    r = hR(a.object, {
                        type: e,
                        root: n,
                        attach: o,
                        primitive: !0
                    })
                } else {
                    const t = KT[s];
                    if (!t)
                        throw new Error(`R3F: ${s} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
                    if (!Array.isArray(i))
                        throw new Error("R3F: The args prop must be an array!");
                    r = hR(new t(...i), {
                        type: e,
                        root: n,
                        attach: o,
                        memoizedProps: {
                            args: i
                        }
                    })
                }
                return void 0 === r.__r3f.attach && (r instanceof my ? r.__r3f.attach = "geometry" : r instanceof Hv && (r.__r3f.attach = "material")),
                "inject" !== s && bR(r, a),
                r
            }
            function r(e, t) {
                let n = !1;
                var r, i;
                t && (null != (r = t.__r3f) && r.attach ? mR(e, t, t.__r3f.attach) : t.isObject3D && e.isObject3D && (e.add(t),
                n = !0),
                n || null == (i = e.__r3f) || i.objects.push(t),
                t.__r3f || hR(t, {}),
                t.__r3f.parent = e,
                AR(t),
                _R(t))
            }
            function i(e, t, n) {
                let r = !1;
                if (t) {
                    var i, o;
                    if (null != (i = t.__r3f) && i.attach)
                        mR(e, t, t.__r3f.attach);
                    else if (t.isObject3D && e.isObject3D) {
                        t.parent = e,
                        t.dispatchEvent({
                            type: "added"
                        }),
                        e.dispatchEvent({
                            type: "childadded",
                            child: t
                        });
                        const i = e.children.filter((e => e !== t))
                          , o = i.indexOf(n);
                        e.children = [...i.slice(0, o), t, ...i.slice(o)],
                        r = !0
                    }
                    r || null == (o = e.__r3f) || o.objects.push(t),
                    t.__r3f || hR(t, {}),
                    t.__r3f.parent = e,
                    AR(t),
                    _R(t)
                }
            }
            function o(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                e && [...e].forEach((e => a(t, e, n)))
            }
            function a(e, t, n) {
                if (t) {
                    var r, i, a;
                    if (t.__r3f && (t.__r3f.parent = null),
                    null != (r = e.__r3f) && r.objects && (e.__r3f.objects = e.__r3f.objects.filter((e => e !== t))),
                    null != (i = t.__r3f) && i.attach)
                        gR(e, t, t.__r3f.attach);
                    else if (t.isObject3D && e.isObject3D) {
                        var s;
                        e.remove(t),
                        null != (s = t.__r3f) && s.root && function(e, t) {
                            const {internal: n} = e.getState();
                            n.interaction = n.interaction.filter((e => e !== t)),
                            n.initialHits = n.initialHits.filter((e => e !== t)),
                            n.hovered.forEach(( (e, r) => {
                                e.eventObject !== t && e.object !== t || n.hovered.delete(r)
                            }
                            )),
                            n.capturedMap.forEach(( (e, r) => {
                                wR(n.capturedMap, t, e, r)
                            }
                            ))
                        }(cR(t), t)
                    }
                    const c = null == (a = t.__r3f) ? void 0 : a.primitive
                      , u = !c && (void 0 === n ? null !== t.dispose : n);
                    var l;
                    if (!c)
                        o(null == (l = t.__r3f) ? void 0 : l.objects, t, u),
                        o(t.children, t, u);
                    if (delete t.__r3f,
                    u && t.dispose && "Scene" !== t.type) {
                        const e = () => {
                            try {
                                t.dispose()
                            } catch (e) {}
                        }
                        ;
                        "undefined" === typeof IS_REACT_ACT_ENVIRONMENT ? (0,
                        JT.unstable_scheduleCallback)(JT.unstable_IdlePriority, e) : e()
                    }
                    _R(e)
                }
            }
            const s = () => {}
            ;
            return {
                reconciler: XT()({
                    createInstance: n,
                    removeChild: a,
                    appendChild: r,
                    appendInitialChild: r,
                    insertBefore: i,
                    supportsMutation: !0,
                    isPrimaryRenderer: !1,
                    supportsPersistence: !1,
                    supportsHydration: !1,
                    noTimeout: -1,
                    appendChildToContainer: (e, t) => {
                        if (!t)
                            return;
                        const n = e.getState().scene;
                        n.__r3f && (n.__r3f.root = e,
                        r(n, t))
                    }
                    ,
                    removeChildFromContainer: (e, t) => {
                        t && a(e.getState().scene, t)
                    }
                    ,
                    insertInContainerBefore: (e, t, n) => {
                        if (!t || !n)
                            return;
                        const r = e.getState().scene;
                        r.__r3f && i(r, t, n)
                    }
                    ,
                    getRootHostContext: () => null,
                    getChildHostContext: e => e,
                    finalizeInitialChildren(e) {
                        var t;
                        const n = null != (t = null == e ? void 0 : e.__r3f) ? t : {};
                        return Boolean(n.handlers)
                    },
                    prepareUpdate(e, t, n, r) {
                        var i;
                        if ((null != (i = null == e ? void 0 : e.__r3f) ? i : {}).primitive && r.object && r.object !== e)
                            return [!0];
                        {
                            const {args: t=[], children: i, ...o} = r
                              , {args: a=[], children: s, ...l} = n;
                            if (!Array.isArray(t))
                                throw new Error("R3F: the args prop must be an array!");
                            if (t.some(( (e, t) => e !== a[t])))
                                return [!0];
                            const c = vR(e, o, l, !0);
                            return c.changes.length ? [!1, c] : null
                        }
                    },
                    commitUpdate(e, t, i, o, s, l) {
                        let[c,u] = t;
                        c ? function(e, t, i, o) {
                            var s;
                            const l = null == (s = e.__r3f) ? void 0 : s.parent;
                            if (!l)
                                return;
                            const c = n(t, i, e.__r3f.root);
                            if (e.children) {
                                for (const t of e.children)
                                    t.__r3f && r(c, t);
                                e.children = e.children.filter((e => !e.__r3f))
                            }
                            e.__r3f.objects.forEach((e => r(c, e))),
                            e.__r3f.objects = [],
                            e.__r3f.autoRemovedBeforeAppend || a(l, e),
                            c.parent && (c.__r3f.autoRemovedBeforeAppend = !0),
                            r(l, c),
                            c.raycast && c.__r3f.eventCount && cR(c).getState().internal.interaction.push(c);
                            [o, o.alternate].forEach((e => {
                                null !== e && (e.stateNode = c,
                                e.ref && ("function" === typeof e.ref ? e.ref(c) : e.ref.current = c))
                            }
                            ))
                        }(e, i, s, l) : bR(e, u)
                    },
                    commitMount(e, t, n, r) {
                        var i;
                        const o = null != (i = e.__r3f) ? i : {};
                        e.raycast && o.handlers && o.eventCount && cR(e).getState().internal.interaction.push(e)
                    },
                    getPublicInstance: e => e,
                    prepareForCommit: () => null,
                    preparePortalMount: e => hR(e.getState().scene),
                    resetAfterCommit: () => {}
                    ,
                    shouldSetTextContent: () => !1,
                    clearContainer: () => !1,
                    hideInstance(e) {
                        var t;
                        const {attach: n, parent: r} = null != (t = e.__r3f) ? t : {};
                        n && r && gR(r, e, n),
                        e.isObject3D && (e.visible = !1),
                        _R(e)
                    },
                    unhideInstance(e, t) {
                        var n;
                        const {attach: r, parent: i} = null != (n = e.__r3f) ? n : {};
                        r && i && mR(i, e, r),
                        (e.isObject3D && null == t.visible || t.visible) && (e.visible = !0),
                        _R(e)
                    },
                    createTextInstance: s,
                    hideTextInstance: s,
                    unhideTextInstance: s,
                    getCurrentEventPriority: () => t ? t() : UT.DefaultEventPriority,
                    beforeActiveInstanceBlur: () => {}
                    ,
                    afterActiveInstanceBlur: () => {}
                    ,
                    detachDeletedInstance: () => {}
                    ,
                    now: "undefined" !== typeof performance && uR.fun(performance.now) ? performance.now : uR.fun(Date.now) ? Date.now : () => 0,
                    scheduleTimeout: uR.fun(setTimeout) ? setTimeout : void 0,
                    cancelTimeout: uR.fun(clearTimeout) ? clearTimeout : void 0
                }),
                applyProps: bR
            }
        }(0, (function() {
            var e;
            const t = "undefined" !== typeof self && self || "undefined" !== typeof window && window;
            if (!t)
                return UT.DefaultEventPriority;
            switch (null == (e = t.event) ? void 0 : e.type) {
            case "click":
            case "contextmenu":
            case "dblclick":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
                return UT.DiscreteEventPriority;
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerenter":
            case "pointerleave":
            case "wheel":
                return UT.ContinuousEventPriority;
            default:
                return UT.DefaultEventPriority
            }
        }
        ))
          , qR = {
            objects: "shallow",
            strict: !1
        }
          , YR = (e, t) => {
            const n = "function" === typeof e ? e(t) : e;
            return MR(n) ? n : new OA({
                powerPreference: "high-performance",
                canvas: t,
                antialias: !0,
                alpha: !0,
                ...e
            })
        }
        ;
        function QR(e) {
            const t = WR.get(e)
              , n = null == t ? void 0 : t.fiber
              , r = null == t ? void 0 : t.store;
            t && console.warn("R3F.createRoot should only be called once!");
            const i = "function" === typeof reportError ? reportError : console.error
              , o = r || TR(VR, XR)
              , a = n || JR.createContainer(o, UT.ConcurrentRoot, null, !1, null, "", i, null);
            let s;
            t || WR.set(e, {
                fiber: a,
                store: o
            });
            let l, c = !1;
            return {
                configure() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                      , {gl: n, size: r, scene: i, events: a, onCreated: u, shadows: d=!1, linear: h=!1, flat: p=!1, legacy: f=!1, orthographic: m=!1, frameloop: g="always", dpr: v=[1, 2], performance: y, raycaster: b, camera: _, onPointerMissed: A} = t
                      , x = o.getState()
                      , S = x.gl;
                    x.gl || x.set({
                        gl: S = YR(n, e)
                    });
                    let w = x.raycaster;
                    w || x.set({
                        raycaster: w = new WM
                    });
                    const {params: E, ...M} = b || {};
                    if (uR.equ(M, w, qR) || KR(w, {
                        ...M
                    }),
                    uR.equ(E, w.params, qR) || KR(w, {
                        params: {
                            ...w.params,
                            ...E
                        }
                    }),
                    !x.camera || x.camera === l && !uR.equ(l, _, qR)) {
                        l = _;
                        const e = _ instanceof Gy
                          , t = e ? _ : m ? new pb(0,0,0,0,.1,1e3) : new Hy(75,0,.1,1e3);
                        e || (t.position.z = 5,
                        _ && (KR(t, _),
                        ("aspect"in _ || "left"in _ || "right"in _ || "bottom"in _ || "top"in _) && (t.manual = !0,
                        t.updateProjectionMatrix())),
                        x.camera || null != _ && _.rotation || t.lookAt(0, 0, 0)),
                        x.set({
                            camera: t
                        }),
                        w.camera = t
                    }
                    if (!x.scene) {
                        let e;
                        i instanceof zA ? e = i : (e = new zA,
                        i && KR(e, i)),
                        x.set({
                            scene: hR(e)
                        })
                    }
                    if (!x.xr) {
                        var C;
                        const e = (e, t) => {
                            const n = o.getState();
                            "never" !== n.frameloop && XR(e, !0, n, t)
                        }
                          , t = () => {
                            const t = o.getState();
                            t.gl.xr.enabled = t.gl.xr.isPresenting,
                            t.gl.xr.setAnimationLoop(t.gl.xr.isPresenting ? e : null),
                            t.gl.xr.isPresenting || VR(t)
                        }
                          , n = {
                            connect() {
                                const e = o.getState().gl;
                                e.xr.addEventListener("sessionstart", t),
                                e.xr.addEventListener("sessionend", t)
                            },
                            disconnect() {
                                const e = o.getState().gl;
                                e.xr.removeEventListener("sessionstart", t),
                                e.xr.removeEventListener("sessionend", t)
                            }
                        };
                        "function" === typeof (null == (C = S.xr) ? void 0 : C.addEventListener) && n.connect(),
                        x.set({
                            xr: n
                        })
                    }
                    if (S.shadowMap) {
                        const e = S.shadowMap.enabled
                          , t = S.shadowMap.type;
                        if (S.shadowMap.enabled = !!d,
                        uR.boo(d))
                            S.shadowMap.type = Zd;
                        else if (uR.str(d)) {
                            var T;
                            const e = {
                                basic: Yd,
                                percentage: Qd,
                                soft: Zd,
                                variance: $d
                            };
                            S.shadowMap.type = null != (T = e[d]) ? T : Zd
                        } else
                            uR.obj(d) && Object.assign(S.shadowMap, d);
                        e === S.shadowMap.enabled && t === S.shadowMap.type || (S.shadowMap.needsUpdate = !0)
                    }
                    const R = ZT();
                    if (R && ("enabled"in R ? R.enabled = !f : "legacyMode"in R && (R.legacyMode = f)),
                    !c) {
                        KR(S, {
                            outputEncoding: h ? 3e3 : 3001,
                            toneMapping: p ? Gh : Vh
                        })
                    }
                    x.legacy !== f && x.set(( () => ({
                        legacy: f
                    }))),
                    x.linear !== h && x.set(( () => ({
                        linear: h
                    }))),
                    x.flat !== p && x.set(( () => ({
                        flat: p
                    }))),
                    !n || uR.fun(n) || MR(n) || uR.equ(n, S, qR) || KR(S, n),
                    a && !x.events.handlers && x.set({
                        events: a(o)
                    });
                    const P = function(e, t) {
                        const n = "undefined" !== typeof HTMLCanvasElement && e instanceof HTMLCanvasElement;
                        if (t) {
                            const {width: e, height: r, top: i, left: o, updateStyle: a=n} = t;
                            return {
                                width: e,
                                height: r,
                                top: i,
                                left: o,
                                updateStyle: a
                            }
                        }
                        if ("undefined" !== typeof HTMLCanvasElement && e instanceof HTMLCanvasElement && e.parentElement) {
                            const {width: t, height: r, top: i, left: o} = e.parentElement.getBoundingClientRect();
                            return {
                                width: t,
                                height: r,
                                top: i,
                                left: o,
                                updateStyle: n
                            }
                        }
                        return "undefined" !== typeof OffscreenCanvas && e instanceof OffscreenCanvas ? {
                            width: e.width,
                            height: e.height,
                            top: 0,
                            left: 0,
                            updateStyle: n
                        } : {
                            width: 0,
                            height: 0,
                            top: 0,
                            left: 0
                        }
                    }(e, r);
                    return uR.equ(P, x.size, qR) || x.setSize(P.width, P.height, P.updateStyle, P.top, P.left),
                    v && x.viewport.dpr !== sR(v) && x.setDpr(v),
                    x.frameloop !== g && x.setFrameloop(g),
                    x.onPointerMissed || x.set({
                        onPointerMissed: A
                    }),
                    y && !uR.equ(y, x.performance, qR) && x.set((e => ({
                        performance: {
                            ...e.performance,
                            ...y
                        }
                    }))),
                    s = u,
                    c = !0,
                    this
                },
                render(t) {
                    return c || this.configure(),
                    JR.updateContainer((0,
                    mt.jsx)(ZR, {
                        store: o,
                        children: t,
                        onCreated: s,
                        rootElement: e
                    }), a, null, ( () => {}
                    )),
                    o
                },
                unmount() {
                    $R(e)
                }
            }
        }
        function ZR(e) {
            let {store: t, children: n, onCreated: r, rootElement: i} = e;
            return eR(( () => {
                const e = t.getState();
                e.set((e => ({
                    internal: {
                        ...e.internal,
                        active: !0
                    }
                }))),
                r && r(e),
                t.getState().events.connected || null == e.events.connect || e.events.connect(i)
            }
            ), []),
            (0,
            mt.jsx)(CR.Provider, {
                value: t,
                children: n
            })
        }
        function $R(e, t) {
            const n = WR.get(e)
              , r = null == n ? void 0 : n.fiber;
            if (r) {
                const i = null == n ? void 0 : n.store.getState();
                i && (i.internal.active = !1),
                JR.updateContainer(null, r, null, ( () => {
                    i && setTimeout(( () => {
                        try {
                            var n, r, o, a;
                            null == i.events.disconnect || i.events.disconnect(),
                            null == (n = i.gl) || null == (r = n.renderLists) || null == r.dispose || r.dispose(),
                            null == (o = i.gl) || null == o.forceContextLoss || o.forceContextLoss(),
                            null != (a = i.gl) && a.xr && i.xr.disconnect(),
                            function(e) {
                                e.dispose && "Scene" !== e.type && e.dispose();
                                for (const t in e)
                                    null == t.dispose || t.dispose(),
                                    delete e[t]
                            }(i),
                            WR.delete(e),
                            t && t(e)
                        } catch (s) {}
                    }
                    ), 500)
                }
                ))
            }
        }
        JR.injectIntoDevTools({
            bundleType: 0,
            rendererPackageName: "@react-three/fiber",
            version: t.version
        });
        t.unstable_act;
        const eP = {
            onClick: ["click", !1],
            onContextMenu: ["contextmenu", !1],
            onDoubleClick: ["dblclick", !1],
            onWheel: ["wheel", !0],
            onPointerDown: ["pointerdown", !0],
            onPointerUp: ["pointerup", !0],
            onPointerLeave: ["pointerleave", !0],
            onPointerMove: ["pointermove", !0],
            onPointerCancel: ["pointercancel", !0],
            onLostPointerCapture: ["lostpointercapture", !0]
        };
        function tP(e) {
            const {handlePointer: t} = ER(e);
            return {
                priority: 1,
                enabled: !0,
                compute(e, t, n) {
                    t.pointer.set(e.offsetX / t.size.width * 2 - 1, -e.offsetY / t.size.height * 2 + 1),
                    t.raycaster.setFromCamera(t.pointer, t.camera)
                },
                connected: void 0,
                handlers: Object.keys(eP).reduce(( (e, n) => ({
                    ...e,
                    [n]: t(n)
                })), {}),
                update: () => {
                    var t;
                    const {events: n, internal: r} = e.getState();
                    null != (t = r.lastEvent) && t.current && n.handlers && n.handlers.onPointerMove(r.lastEvent.current)
                }
                ,
                connect: t => {
                    var n;
                    const {set: r, events: i} = e.getState();
                    null == i.disconnect || i.disconnect(),
                    r((e => ({
                        events: {
                            ...e.events,
                            connected: t
                        }
                    }))),
                    Object.entries(null != (n = i.handlers) ? n : []).forEach((e => {
                        let[n,r] = e;
                        const [i,o] = eP[n];
                        t.addEventListener(i, r, {
                            passive: o
                        })
                    }
                    ))
                }
                ,
                disconnect: () => {
                    const {set: t, events: n} = e.getState();
                    var r;
                    n.connected && (Object.entries(null != (r = n.handlers) ? r : []).forEach((e => {
                        let[t,r] = e;
                        if (n && n.connected instanceof HTMLElement) {
                            const [e] = eP[t];
                            n.connected.removeEventListener(e, r)
                        }
                    }
                    )),
                    t((e => ({
                        events: {
                            ...e.events,
                            connected: void 0
                        }
                    }))))
                }
            }
        }
        let nP = null
          , rP = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/";
        function iP() {
            let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]
              , t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
              , n = arguments.length > 2 ? arguments[2] : void 0;
            return r => {
                n && n(r),
                e && (nP || (nP = new LC),
                nP.setDecoderPath("string" === typeof e ? e : rP),
                r.setDRACOLoader(nP)),
                t && r.setMeshoptDecoder(OC())
            }
        }
        const oP = (e, t, n, r) => jR(HC, e, iP(t, n, r));
        oP.preload = (e, t, n, r) => jR.preload(HC, e, iP(t, n, r)),
        oP.clear = e => jR.clear(HC, e),
        oP.setDecoderPath = e => {
            rP = e
        }
        ;
        function aP(e, n, r) {
            const i = UR((e => e.size))
              , o = UR((e => e.viewport))
              , a = "number" === typeof e ? e : i.width * o.dpr
              , s = "number" === typeof n ? n : i.height * o.dpr
              , l = ("number" === typeof e ? r : e) || {}
              , {samples: c=0, depth: u, ...d} = l
              , h = t.useMemo(( () => {
                const e = new fg(a,s,{
                    minFilter: cp,
                    magFilter: cp,
                    type: Ap,
                    ...d
                });
                return u && (e.depthTexture = new Ub(a,s,_p)),
                e.samples = c,
                e
            }
            ), []);
            return t.useLayoutEffect(( () => {
                h.setSize(a, s),
                c && (h.samples = c)
            }
            ), [c, h, a, s]),
            t.useEffect(( () => () => h.dispose()), []),
            h
        }
        const sP = t.forwardRef(( (e, n) => {
            let {envMap: r, resolution: i=256, frames: o=1 / 0, makeDefault: a, children: s, ...l} = e;
            const c = UR((e => {
                let {set: t} = e;
                return t
            }
            ))
              , u = UR((e => {
                let {camera: t} = e;
                return t
            }
            ))
              , d = UR((e => {
                let {size: t} = e;
                return t
            }
            ))
              , h = t.useRef(null);
            t.useImperativeHandle(n, ( () => h.current), []);
            const p = t.useRef(null)
              , f = aP(i);
            t.useLayoutEffect(( () => {
                l.manual || (h.current.aspect = d.width / d.height)
            }
            ), [d, l]),
            t.useLayoutEffect(( () => {
                h.current.updateProjectionMatrix()
            }
            ));
            let m = 0
              , g = null;
            const v = "function" === typeof s;
            return zR((e => {
                v && (o === 1 / 0 || m < o) && (p.current.visible = !1,
                e.gl.setRenderTarget(f),
                g = e.scene.background,
                r && (e.scene.background = r),
                e.gl.render(e.scene, h.current),
                e.scene.background = g,
                e.gl.setRenderTarget(null),
                p.current.visible = !0,
                m++)
            }
            )),
            t.useLayoutEffect(( () => {
                if (a) {
                    const e = u;
                    return c(( () => ({
                        camera: h.current
                    }))),
                    () => c(( () => ({
                        camera: e
                    })))
                }
            }
            ), [h, a, c]),
            t.createElement(t.Fragment, null, t.createElement("perspectiveCamera", (0,
            rt.A)({
                ref: h
            }, l), !v && s), t.createElement("group", {
                ref: p
            }, v && s(f.texture)))
        }
        ));
        var lP, cP, uP = __webpack_require__(9356), dP = __webpack_require__.n(uP), hP = Object.defineProperty, pP = Object.defineProperties, fP = Object.getOwnPropertyDescriptors, mP = Object.getOwnPropertySymbols, gP = Object.prototype.hasOwnProperty, vP = Object.prototype.propertyIsEnumerable, yP = (e, t, n) => t in e ? hP(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n
        }) : e[t] = n, bP = (e, t) => {
            for (var n in t || (t = {}))
                gP.call(t, n) && yP(e, n, t[n]);
            if (mP)
                for (var n of mP(t))
                    vP.call(t, n) && yP(e, n, t[n]);
            return e
        }
        ;
        "undefined" === typeof window || !(null == (lP = window.document) ? void 0 : lP.createElement) && "ReactNative" !== (null == (cP = window.navigator) ? void 0 : cP.product) ? t.useEffect : t.useLayoutEffect;
        function _P(e, t, n) {
            if (!e)
                return;
            if (!0 === n(e))
                return e;
            let r = t ? e.return : e.child;
            for (; r; ) {
                const e = _P(r, t, n);
                if (e)
                    return e;
                r = t ? null : r.sibling
            }
        }
        function AP(e) {
            try {
                return Object.defineProperties(e, {
                    _currentRenderer: {
                        get: () => null,
                        set() {}
                    },
                    _currentRenderer2: {
                        get: () => null,
                        set() {}
                    }
                })
            } catch (t) {
                return e
            }
        }
        const xP = console.error;
        console.error = function() {
            const e = [...arguments].join("");
            if (!(null == e ? void 0 : e.startsWith("Warning:")) || !e.includes("useContext"))
                return xP.apply(this, arguments);
            console.error = xP
        }
        ;
        const SP = AP(t.createContext(null));
        class wP extends t.Component {
            render() {
                return t.createElement(SP.Provider, {
                    value: this._reactInternals
                }, this.props.children)
            }
        }
        function EP() {
            const e = t.useContext(SP);
            if (null === e)
                throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
            const n = t.useId();
            return t.useMemo(( () => {
                for (const t of [e, null == e ? void 0 : e.alternate]) {
                    if (!t)
                        continue;
                    const e = _P(t, !1, (e => {
                        let t = e.memoizedState;
                        for (; t; ) {
                            if (t.memoizedState === n)
                                return !0;
                            t = t.next
                        }
                    }
                    ));
                    if (e)
                        return e
                }
            }
            ), [e, n])
        }
        function MP() {
            const e = function() {
                const e = EP()
                  , [n] = t.useState(( () => new Map));
                n.clear();
                let r = e;
                for (; r; ) {
                    if (r.type && "object" === typeof r.type) {
                        const e = void 0 === r.type._context && r.type.Provider === r.type ? r.type : r.type._context;
                        e && e !== SP && !n.has(e) && n.set(e, t.useContext(AP(e)))
                    }
                    r = r.return
                }
                return n
            }();
            return t.useMemo(( () => Array.from(e.keys()).reduce(( (n, r) => i => {
                return t.createElement(n, null, t.createElement(r.Provider, (o = bP({}, i),
                a = {
                    value: e.get(r)
                },
                pP(o, fP(a)))));
                var o, a
            }
            ), (e => t.createElement(wP, bP({}, e))))), [e])
        }
        function CP() {
            let {debounce: e, scroll: n, polyfill: r, offsetSize: i} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                debounce: 0,
                scroll: !1,
                offsetSize: !1
            };
            const o = r || "undefined" !== typeof window && window.ResizeObserver
              , [a,s] = (0,
            t.useState)({
                left: 0,
                top: 0,
                width: 0,
                height: 0,
                bottom: 0,
                right: 0,
                x: 0,
                y: 0
            });
            if (!o)
                return a.width = 1280,
                a.height = 800,
                [ () => {}
                , a, () => {}
                ];
            const l = (0,
            t.useRef)({
                element: null,
                scrollContainers: null,
                resizeObserver: null,
                lastBounds: a,
                orientationHandler: null
            })
              , c = e ? "number" === typeof e ? e : e.scroll : null
              , u = e ? "number" === typeof e ? e : e.resize : null
              , d = (0,
            t.useRef)(!1);
            (0,
            t.useEffect)(( () => (d.current = !0,
            () => {
                d.current = !1
            }
            )));
            const [h,p,f] = (0,
            t.useMemo)(( () => {
                const e = () => {
                    if (!l.current.element)
                        return;
                    const {left: e, top: t, width: n, height: r, bottom: o, right: a, x: c, y: u} = l.current.element.getBoundingClientRect()
                      , h = {
                        left: e,
                        top: t,
                        width: n,
                        height: r,
                        bottom: o,
                        right: a,
                        x: c,
                        y: u
                    };
                    l.current.element instanceof HTMLElement && i && (h.height = l.current.element.offsetHeight,
                    h.width = l.current.element.offsetWidth),
                    Object.freeze(h),
                    d.current && !PP(l.current.lastBounds, h) && s(l.current.lastBounds = h)
                }
                ;
                return [e, u ? dP()(e, u) : e, c ? dP()(e, c) : e]
            }
            ), [s, i, c, u]);
            function m() {
                l.current.scrollContainers && (l.current.scrollContainers.forEach((e => e.removeEventListener("scroll", f, !0))),
                l.current.scrollContainers = null),
                l.current.resizeObserver && (l.current.resizeObserver.disconnect(),
                l.current.resizeObserver = null),
                l.current.orientationHandler && ("orientation"in screen && "removeEventListener"in screen.orientation ? screen.orientation.removeEventListener("change", l.current.orientationHandler) : "onorientationchange"in window && window.removeEventListener("orientationchange", l.current.orientationHandler))
            }
            function g() {
                var e;
                l.current.element && (l.current.resizeObserver = new o(p),
                null == (e = l.current.resizeObserver) || e.observe(l.current.element),
                n && l.current.scrollContainers && l.current.scrollContainers.forEach((e => e.addEventListener("scroll", f, {
                    capture: !0,
                    passive: !0
                }))),
                l.current.orientationHandler = () => {
                    f()
                }
                ,
                "orientation"in screen && "addEventListener"in screen.orientation ? screen.orientation.addEventListener("change", l.current.orientationHandler) : "onorientationchange"in window && window.addEventListener("orientationchange", l.current.orientationHandler))
            }
            var v, y, b;
            return v = f,
            y = Boolean(n),
            (0,
            t.useEffect)(( () => {
                if (y) {
                    const e = v;
                    return window.addEventListener("scroll", e, {
                        capture: !0,
                        passive: !0
                    }),
                    () => {
                        window.removeEventListener("scroll", e, !0)
                    }
                }
            }
            ), [v, y]),
            b = p,
            (0,
            t.useEffect)(( () => {
                const e = b;
                return window.addEventListener("resize", e),
                () => {
                    window.removeEventListener("resize", e)
                }
            }
            ), [b]),
            (0,
            t.useEffect)(( () => {
                m(),
                g()
            }
            ), [n, f, p]),
            (0,
            t.useEffect)(( () => m), []),
            [e => {
                e && e !== l.current.element && (m(),
                l.current.element = e,
                l.current.scrollContainers = TP(e),
                g())
            }
            , a, h]
        }
        function TP(e) {
            const t = [];
            if (!e || e === document.body)
                return t;
            const {overflow: n, overflowX: r, overflowY: i} = window.getComputedStyle(e);
            return [n, r, i].some((e => "auto" === e || "scroll" === e)) && t.push(e),
            [...t, ...TP(e.parentElement)]
        }
        const RP = ["x", "y", "top", "bottom", "left", "right", "width", "height"]
          , PP = (e, t) => RP.every((n => e[n] === t[n]))
          , BP = t.forwardRef((function(n, r) {
            let {children: i, fallback: o, resize: a, style: s, gl: l, events: c=tP, eventSource: u, eventPrefix: d, shadows: h, linear: p, flat: f, legacy: m, orthographic: g, frameloop: v, dpr: y, performance: b, raycaster: _, camera: A, scene: x, onPointerMissed: S, onCreated: w, ...E} = n;
            t.useMemo(( () => {
                return t = e,
                void Object.assign(KT, t);
                var t
            }
            ), []);
            const M = MP()
              , [C,T] = CP({
                scroll: !0,
                debounce: {
                    scroll: 50,
                    resize: 0
                },
                ...a
            })
              , R = t.useRef(null)
              , P = t.useRef(null);
            t.useImperativeHandle(r, ( () => R.current));
            const B = tR(S)
              , [I,L] = t.useState(!1)
              , [k,D] = t.useState(!1);
            if (I)
                throw I;
            if (k)
                throw k;
            const O = t.useRef(null);
            eR(( () => {
                const e = R.current;
                T.width > 0 && T.height > 0 && e && (O.current || (O.current = QR(e)),
                O.current.configure({
                    gl: l,
                    events: c,
                    shadows: h,
                    linear: p,
                    flat: f,
                    legacy: m,
                    orthographic: g,
                    frameloop: v,
                    dpr: y,
                    performance: b,
                    raycaster: _,
                    camera: A,
                    scene: x,
                    size: T,
                    onPointerMissed: function() {
                        return null == B.current ? void 0 : B.current(...arguments)
                    },
                    onCreated: e => {
                        var t;
                        null == e.events.connect || e.events.connect(u ? (t = u) && t.hasOwnProperty("current") ? u.current : u : P.current),
                        d && e.setEvents({
                            compute: (e, t) => {
                                const n = e[d + "X"]
                                  , r = e[d + "Y"];
                                t.pointer.set(n / t.size.width * 2 - 1, -r / t.size.height * 2 + 1),
                                t.raycaster.setFromCamera(t.pointer, t.camera)
                            }
                        }),
                        null == w || w(e)
                    }
                }),
                O.current.render((0,
                mt.jsx)(M, {
                    children: (0,
                    mt.jsx)(rR, {
                        set: D,
                        children: (0,
                        mt.jsx)(t.Suspense, {
                            fallback: (0,
                            mt.jsx)(nR, {
                                set: L
                            }),
                            children: i
                        })
                    })
                })))
            }
            )),
            t.useEffect(( () => {
                const e = R.current;
                if (e)
                    return () => $R(e)
            }
            ), []);
            const N = u ? "none" : "auto";
            return (0,
            mt.jsx)("div", {
                ref: P,
                style: {
                    position: "relative",
                    width: "100%",
                    height: "100%",
                    overflow: "hidden",
                    pointerEvents: N,
                    ...s
                },
                ...E,
                children: (0,
                mt.jsx)("div", {
                    ref: C,
                    style: {
                        width: "100%",
                        height: "100%"
                    },
                    children: (0,
                    mt.jsx)("canvas", {
                        ref: R,
                        style: {
                            display: "block"
                        },
                        children: o
                    })
                })
            })
        }
        ))
          , IP = t.forwardRef((function(e, t) {
            return (0,
            mt.jsx)(wP, {
                children: (0,
                mt.jsx)(BP, {
                    ...e,
                    ref: t
                })
            })
        }
        ))
          , LP = () => {
            const e = C();
            return (0,
            t.useCallback)((t => e(Je(t))), [e])
        }
          , kP = () => {
            const e = C();
            return (0,
            t.useCallback)((t => e(Ke(t))), [e])
        }
          , DP = () => {
            const e = C();
            return (0,
            t.useCallback)((t => e(Ye(t))), [e])
        }
          , OP = () => {
            const e = C();
            return (0,
            t.useCallback)((t => e(Qe(t))), [e])
        }
          , NP = () => {
            const e = C();
            return (0,
            t.useCallback)((t => e($e(t))), [e])
        }
          , FP = () => {
            const e = C();
            return (0,
            t.useCallback)((t => e(et(t))), [e])
        }
          , UP = () => {
            const e = C();
            return (0,
            t.useCallback)((t => e(tt(t))), [e])
        }
        ;
        const zP = function(e, t, n) {
            if (0 !== e.length) {
                let r = [];
                for (let e = 0; e < Object.keys(t).length; e++)
                    r.push([]);
                let i = []
                  , o = 0;
                e.forEach(( (e, n) => {
                    Object.entries(e.blendshapes).forEach((e => {
                        let[n,i] = e;
                        n in t && r[t[n]].push(i)
                    }
                    )),
                    i.push(o / 60),
                    o++
                }
                ));
                let a = [];
                Object.entries(e[0].blendshapes).forEach((e => {
                    let[o] = e;
                    if (o in t) {
                        var s = t[o]
                          , l = new hE(`${n}.morphTargetInfluences[${s}]`,i,r[s]);
                        a.push(l)
                    }
                }
                ));
                return new vE("animation",-1,a)
            }
            return null
        };
        function GP(e) {
            return (0,
            Bt.Ay)("MuiTypography", e)
        }
        (0,
        _t.A)("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
        const HP = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"]
          , jP = (0,
        Mt.Ay)("span", {
            name: "MuiTypography",
            slot: "Root",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.root, n.variant && t[n.variant], "inherit" !== n.align && t[`align${(0,
                Tt.A)(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph]
            }
        })((e => {
            let {theme: t, ownerState: n} = e;
            return (0,
            rt.A)({
                margin: 0
            }, "inherit" === n.variant && {
                font: "inherit"
            }, "inherit" !== n.variant && t.typography[n.variant], "inherit" !== n.align && {
                textAlign: n.align
            }, n.noWrap && {
                overflow: "hidden",
                textOverflow: "ellipsis",
                whiteSpace: "nowrap"
            }, n.gutterBottom && {
                marginBottom: "0.35em"
            }, n.paragraph && {
                marginBottom: 16
            })
        }
        ))
          , WP = {
            h1: "h1",
            h2: "h2",
            h3: "h3",
            h4: "h4",
            h5: "h5",
            h6: "h6",
            subtitle1: "h6",
            subtitle2: "h6",
            body1: "p",
            body2: "p",
            inherit: "p"
        }
          , VP = {
            primary: "primary.main",
            textPrimary: "text.primary",
            secondary: "secondary.main",
            textSecondary: "text.secondary",
            error: "error.main"
        }
          , XP = t.forwardRef((function(e, t) {
            const n = (0,
            Ct.b)({
                props: e,
                name: "MuiTypography"
            })
              , r = (e => VP[e] || e)(n.color)
              , i = (0,
            ct.A)((0,
            rt.A)({}, n, {
                color: r
            }))
              , {align: o="inherit", className: a, component: s, gutterBottom: l=!1, noWrap: c=!1, paragraph: u=!1, variant: d="body1", variantMapping: h=WP} = i
              , p = (0,
            it.A)(i, HP)
              , f = (0,
            rt.A)({}, i, {
                align: o,
                color: r,
                className: a,
                component: s,
                gutterBottom: l,
                noWrap: c,
                paragraph: u,
                variant: d,
                variantMapping: h
            })
              , m = s || (u ? "p" : h[d] || WP[d]) || "span"
              , g = (e => {
                const {align: t, gutterBottom: n, noWrap: r, paragraph: i, variant: o, classes: a} = e
                  , s = {
                    root: ["root", o, "inherit" !== e.align && `align${(0,
                    Tt.A)(t)}`, n && "gutterBottom", r && "noWrap", i && "paragraph"]
                };
                return (0,
                Et.A)(s, GP, a)
            }
            )(f);
            return (0,
            mt.jsx)(jP, (0,
            rt.A)({
                as: m,
                ref: t,
                ownerState: f,
                className: (0,
                wt.A)(g.root, a)
            }, p))
        }
        ));
        var JP = __webpack_require__(3539)
          , KP = __webpack_require__(5393);
        const qP = function(e) {
            return "string" === typeof e
        };
        const YP = function(e, t, n) {
            return void 0 === e || qP(e) ? t : (0,
            rt.A)({}, t, {
                ownerState: (0,
                rt.A)({}, t.ownerState, n)
            })
        };
        function QP(e) {
            var t, n, r = "";
            if ("string" == typeof e || "number" == typeof e)
                r += e;
            else if ("object" == typeof e)
                if (Array.isArray(e)) {
                    var i = e.length;
                    for (t = 0; t < i; t++)
                        e[t] && (n = QP(e[t])) && (r && (r += " "),
                        r += n)
                } else
                    for (n in e)
                        e[n] && (r && (r += " "),
                        r += n);
            return r
        }
        const ZP = function() {
            for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)
                (e = arguments[n]) && (t = QP(e)) && (r && (r += " "),
                r += t);
            return r
        };
        const $P = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            if (void 0 === e)
                return {};
            const n = {};
            return Object.keys(e).filter((n => n.match(/^on[A-Z]/) && "function" === typeof e[n] && !t.includes(n))).forEach((t => {
                n[t] = e[t]
            }
            )),
            n
        };
        const eB = function(e) {
            if (void 0 === e)
                return {};
            const t = {};
            return Object.keys(e).filter((t => !(t.match(/^on[A-Z]/) && "function" === typeof e[t]))).forEach((n => {
                t[n] = e[n]
            }
            )),
            t
        };
        const tB = function(e) {
            const {getSlotProps: t, additionalProps: n, externalSlotProps: r, externalForwardedProps: i, className: o} = e;
            if (!t) {
                const e = ZP(null == n ? void 0 : n.className, o, null == i ? void 0 : i.className, null == r ? void 0 : r.className)
                  , t = (0,
                rt.A)({}, null == n ? void 0 : n.style, null == i ? void 0 : i.style, null == r ? void 0 : r.style)
                  , a = (0,
                rt.A)({}, n, i, r);
                return e.length > 0 && (a.className = e),
                Object.keys(t).length > 0 && (a.style = t),
                {
                    props: a,
                    internalRef: void 0
                }
            }
            const a = $P((0,
            rt.A)({}, i, r))
              , s = eB(r)
              , l = eB(i)
              , c = t(a)
              , u = ZP(null == c ? void 0 : c.className, null == n ? void 0 : n.className, o, null == i ? void 0 : i.className, null == r ? void 0 : r.className)
              , d = (0,
            rt.A)({}, null == c ? void 0 : c.style, null == n ? void 0 : n.style, null == i ? void 0 : i.style, null == r ? void 0 : r.style)
              , h = (0,
            rt.A)({}, c, n, l, s);
            return u.length > 0 && (h.className = u),
            Object.keys(d).length > 0 && (h.style = d),
            {
                props: h,
                internalRef: c.ref
            }
        };
        const nB = function(e, t, n) {
            return "function" === typeof e ? e(t, n) : e
        }
          , rB = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
        const iB = function(e) {
            var t;
            const {elementType: n, externalSlotProps: r, ownerState: i, skipResolvingSlotProps: o=!1} = e
              , a = (0,
            it.A)(e, rB)
              , s = o ? {} : nB(r, i)
              , {props: l, internalRef: c} = tB((0,
            rt.A)({}, a, {
                externalSlotProps: s
            }))
              , u = (0,
            KP.A)(c, null == s ? void 0 : s.ref, null == (t = e.additionalProps) ? void 0 : t.ref);
            return YP(n, (0,
            rt.A)({}, l, {
                ref: u
            }), i)
        };
        var oB = __webpack_require__(6907);
        const aB = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
        function sB(e) {
            const t = []
              , n = [];
            return Array.from(e.querySelectorAll(aB)).forEach(( (e, r) => {
                const i = function(e) {
                    const t = parseInt(e.getAttribute("tabindex") || "", 10);
                    return Number.isNaN(t) ? "true" === e.contentEditable || ("AUDIO" === e.nodeName || "VIDEO" === e.nodeName || "DETAILS" === e.nodeName) && null === e.getAttribute("tabindex") ? 0 : e.tabIndex : t
                }(e);
                -1 !== i && function(e) {
                    return !(e.disabled || "INPUT" === e.tagName && "hidden" === e.type || function(e) {
                        if ("INPUT" !== e.tagName || "radio" !== e.type)
                            return !1;
                        if (!e.name)
                            return !1;
                        const t = t => e.ownerDocument.querySelector(`input[type="radio"]${t}`);
                        let n = t(`[name="${e.name}"]:checked`);
                        return n || (n = t(`[name="${e.name}"]`)),
                        n !== e
                    }(e))
                }(e) && (0 === i ? t.push(e) : n.push({
                    documentOrder: r,
                    tabIndex: i,
                    node: e
                }))
            }
            )),
            n.sort(( (e, t) => e.tabIndex === t.tabIndex ? e.documentOrder - t.documentOrder : e.tabIndex - t.tabIndex)).map((e => e.node)).concat(t)
        }
        function lB() {
            return !0
        }
        const cB = function(e) {
            const {children: n, disableAutoFocus: r=!1, disableEnforceFocus: i=!1, disableRestoreFocus: o=!1, getTabbable: a=sB, isEnabled: s=lB, open: l} = e
              , c = t.useRef(!1)
              , u = t.useRef(null)
              , d = t.useRef(null)
              , h = t.useRef(null)
              , p = t.useRef(null)
              , f = t.useRef(!1)
              , m = t.useRef(null)
              , g = (0,
            KP.A)(n.ref, m)
              , v = t.useRef(null);
            t.useEffect(( () => {
                l && m.current && (f.current = !r)
            }
            ), [r, l]),
            t.useEffect(( () => {
                if (!l || !m.current)
                    return;
                const e = (0,
                oB.A)(m.current);
                return m.current.contains(e.activeElement) || (m.current.hasAttribute("tabIndex") || m.current.setAttribute("tabIndex", "-1"),
                f.current && m.current.focus()),
                () => {
                    o || (h.current && h.current.focus && (c.current = !0,
                    h.current.focus()),
                    h.current = null)
                }
            }
            ), [l]),
            t.useEffect(( () => {
                if (!l || !m.current)
                    return;
                const e = (0,
                oB.A)(m.current)
                  , t = t => {
                    v.current = t,
                    !i && s() && "Tab" === t.key && e.activeElement === m.current && t.shiftKey && (c.current = !0,
                    d.current && d.current.focus())
                }
                  , n = () => {
                    const t = m.current;
                    if (null === t)
                        return;
                    if (!e.hasFocus() || !s() || c.current)
                        return void (c.current = !1);
                    if (t.contains(e.activeElement))
                        return;
                    if (i && e.activeElement !== u.current && e.activeElement !== d.current)
                        return;
                    if (e.activeElement !== p.current)
                        p.current = null;
                    else if (null !== p.current)
                        return;
                    if (!f.current)
                        return;
                    let n = [];
                    if (e.activeElement !== u.current && e.activeElement !== d.current || (n = a(m.current)),
                    n.length > 0) {
                        var r, o;
                        const e = Boolean((null == (r = v.current) ? void 0 : r.shiftKey) && "Tab" === (null == (o = v.current) ? void 0 : o.key))
                          , t = n[0]
                          , i = n[n.length - 1];
                        "string" !== typeof t && "string" !== typeof i && (e ? i.focus() : t.focus())
                    } else
                        t.focus()
                }
                ;
                e.addEventListener("focusin", n),
                e.addEventListener("keydown", t, !0);
                const r = setInterval(( () => {
                    e.activeElement && "BODY" === e.activeElement.tagName && n()
                }
                ), 50);
                return () => {
                    clearInterval(r),
                    e.removeEventListener("focusin", n),
                    e.removeEventListener("keydown", t, !0)
                }
            }
            ), [r, i, o, s, l, a]);
            const y = e => {
                null === h.current && (h.current = e.relatedTarget),
                f.current = !0
            }
            ;
            return (0,
            mt.jsxs)(t.Fragment, {
                children: [(0,
                mt.jsx)("div", {
                    tabIndex: l ? 0 : -1,
                    onFocus: y,
                    ref: u,
                    "data-testid": "sentinelStart"
                }), t.cloneElement(n, {
                    ref: g,
                    onFocus: e => {
                        null === h.current && (h.current = e.relatedTarget),
                        f.current = !0,
                        p.current = e.target;
                        const t = n.props.onFocus;
                        t && t(e)
                    }
                }), (0,
                mt.jsx)("div", {
                    tabIndex: l ? 0 : -1,
                    onFocus: y,
                    ref: d,
                    "data-testid": "sentinelEnd"
                })]
            })
        };
        var uB = __webpack_require__(7119)
          , dB = __webpack_require__(1399)
          , hB = __webpack_require__(5587);
        const pB = t.forwardRef((function(e, n) {
            const {children: r, container: i, disablePortal: o=!1} = e
              , [a,s] = t.useState(null)
              , l = (0,
            KP.A)(t.isValidElement(r) ? r.ref : null, n);
            if ((0,
            dB.A)(( () => {
                o || s(function(e) {
                    return "function" === typeof e ? e() : e
                }(i) || document.body)
            }
            ), [i, o]),
            (0,
            dB.A)(( () => {
                if (a && !o)
                    return (0,
                    hB.A)(n, a),
                    () => {
                        (0,
                        hB.A)(n, null)
                    }
            }
            ), [n, a, o]),
            o) {
                if (t.isValidElement(r)) {
                    const e = {
                        ref: l
                    };
                    return t.cloneElement(r, e)
                }
                return (0,
                mt.jsx)(t.Fragment, {
                    children: r
                })
            }
            return (0,
            mt.jsx)(t.Fragment, {
                children: a ? uB.createPortal(r, a) : a
            })
        }
        ));
        function fB(e, t) {
            return fB = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                return e.__proto__ = t,
                e
            }
            ,
            fB(e, t)
        }
        function mB(e, t) {
            e.prototype = Object.create(t.prototype),
            e.prototype.constructor = e,
            fB(e, t)
        }
        const gB = !1
          , vB = t.createContext(null);
        var yB = "unmounted"
          , bB = "exited"
          , _B = "entering"
          , AB = "entered"
          , xB = "exiting"
          , SB = function(e) {
            function n(t, n) {
                var r;
                r = e.call(this, t, n) || this;
                var i, o = n && !n.isMounting ? t.enter : t.appear;
                return r.appearStatus = null,
                t.in ? o ? (i = bB,
                r.appearStatus = _B) : i = AB : i = t.unmountOnExit || t.mountOnEnter ? yB : bB,
                r.state = {
                    status: i
                },
                r.nextCallback = null,
                r
            }
            mB(n, e),
            n.getDerivedStateFromProps = function(e, t) {
                return e.in && t.status === yB ? {
                    status: bB
                } : null
            }
            ;
            var r = n.prototype;
            return r.componentDidMount = function() {
                this.updateStatus(!0, this.appearStatus)
            }
            ,
            r.componentDidUpdate = function(e) {
                var t = null;
                if (e !== this.props) {
                    var n = this.state.status;
                    this.props.in ? n !== _B && n !== AB && (t = _B) : n !== _B && n !== AB || (t = xB)
                }
                this.updateStatus(!1, t)
            }
            ,
            r.componentWillUnmount = function() {
                this.cancelNextCallback()
            }
            ,
            r.getTimeouts = function() {
                var e, t, n, r = this.props.timeout;
                return e = t = n = r,
                null != r && "number" !== typeof r && (e = r.exit,
                t = r.enter,
                n = void 0 !== r.appear ? r.appear : t),
                {
                    exit: e,
                    enter: t,
                    appear: n
                }
            }
            ,
            r.updateStatus = function(e, t) {
                if (void 0 === e && (e = !1),
                null !== t)
                    if (this.cancelNextCallback(),
                    t === _B) {
                        if (this.props.unmountOnExit || this.props.mountOnEnter) {
                            var n = this.props.nodeRef ? this.props.nodeRef.current : uB.findDOMNode(this);
                            n && function(e) {
                                e.scrollTop
                            }(n)
                        }
                        this.performEnter(e)
                    } else
                        this.performExit();
                else
                    this.props.unmountOnExit && this.state.status === bB && this.setState({
                        status: yB
                    })
            }
            ,
            r.performEnter = function(e) {
                var t = this
                  , n = this.props.enter
                  , r = this.context ? this.context.isMounting : e
                  , i = this.props.nodeRef ? [r] : [uB.findDOMNode(this), r]
                  , o = i[0]
                  , a = i[1]
                  , s = this.getTimeouts()
                  , l = r ? s.appear : s.enter;
                !e && !n || gB ? this.safeSetState({
                    status: AB
                }, (function() {
                    t.props.onEntered(o)
                }
                )) : (this.props.onEnter(o, a),
                this.safeSetState({
                    status: _B
                }, (function() {
                    t.props.onEntering(o, a),
                    t.onTransitionEnd(l, (function() {
                        t.safeSetState({
                            status: AB
                        }, (function() {
                            t.props.onEntered(o, a)
                        }
                        ))
                    }
                    ))
                }
                )))
            }
            ,
            r.performExit = function() {
                var e = this
                  , t = this.props.exit
                  , n = this.getTimeouts()
                  , r = this.props.nodeRef ? void 0 : uB.findDOMNode(this);
                t && !gB ? (this.props.onExit(r),
                this.safeSetState({
                    status: xB
                }, (function() {
                    e.props.onExiting(r),
                    e.onTransitionEnd(n.exit, (function() {
                        e.safeSetState({
                            status: bB
                        }, (function() {
                            e.props.onExited(r)
                        }
                        ))
                    }
                    ))
                }
                ))) : this.safeSetState({
                    status: bB
                }, (function() {
                    e.props.onExited(r)
                }
                ))
            }
            ,
            r.cancelNextCallback = function() {
                null !== this.nextCallback && (this.nextCallback.cancel(),
                this.nextCallback = null)
            }
            ,
            r.safeSetState = function(e, t) {
                t = this.setNextCallback(t),
                this.setState(e, t)
            }
            ,
            r.setNextCallback = function(e) {
                var t = this
                  , n = !0;
                return this.nextCallback = function(r) {
                    n && (n = !1,
                    t.nextCallback = null,
                    e(r))
                }
                ,
                this.nextCallback.cancel = function() {
                    n = !1
                }
                ,
                this.nextCallback
            }
            ,
            r.onTransitionEnd = function(e, t) {
                this.setNextCallback(t);
                var n = this.props.nodeRef ? this.props.nodeRef.current : uB.findDOMNode(this)
                  , r = null == e && !this.props.addEndListener;
                if (n && !r) {
                    if (this.props.addEndListener) {
                        var i = this.props.nodeRef ? [this.nextCallback] : [n, this.nextCallback]
                          , o = i[0]
                          , a = i[1];
                        this.props.addEndListener(o, a)
                    }
                    null != e && setTimeout(this.nextCallback, e)
                } else
                    setTimeout(this.nextCallback, 0)
            }
            ,
            r.render = function() {
                var e = this.state.status;
                if (e === yB)
                    return null;
                var n = this.props
                  , r = n.children
                  , i = (n.in,
                n.mountOnEnter,
                n.unmountOnExit,
                n.appear,
                n.enter,
                n.exit,
                n.timeout,
                n.addEndListener,
                n.onEnter,
                n.onEntering,
                n.onEntered,
                n.onExit,
                n.onExiting,
                n.onExited,
                n.nodeRef,
                (0,
                it.A)(n, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]));
                return t.createElement(vB.Provider, {
                    value: null
                }, "function" === typeof r ? r(e, i) : t.cloneElement(t.Children.only(r), i))
            }
            ,
            n
        }(t.Component);
        function wB() {}
        SB.contextType = vB,
        SB.propTypes = {},
        SB.defaultProps = {
            in: !1,
            mountOnEnter: !1,
            unmountOnExit: !1,
            appear: !1,
            enter: !0,
            exit: !0,
            onEnter: wB,
            onEntering: wB,
            onEntered: wB,
            onExit: wB,
            onExiting: wB,
            onExited: wB
        },
        SB.UNMOUNTED = yB,
        SB.EXITED = bB,
        SB.ENTERING = _B,
        SB.ENTERED = AB,
        SB.EXITING = xB;
        const EB = SB;
        var MB = __webpack_require__(195);
        function CB() {
            const e = ft(MB.A);
            return e[bt.A] || e
        }
        const TB = e => e.scrollTop;
        function RB(e, t) {
            var n, r;
            const {timeout: i, easing: o, style: a={}} = e;
            return {
                duration: null != (n = a.transitionDuration) ? n : "number" === typeof i ? i : i[t.mode] || 0,
                easing: null != (r = a.transitionTimingFunction) ? r : "object" === typeof o ? o[t.mode] : o,
                delay: a.transitionDelay
            }
        }
        var PB = __webpack_require__(1506);
        const BB = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"]
          , IB = {
            entering: {
                opacity: 1
            },
            entered: {
                opacity: 1
            }
        }
          , LB = t.forwardRef((function(e, n) {
            const r = CB()
              , i = {
                enter: r.transitions.duration.enteringScreen,
                exit: r.transitions.duration.leavingScreen
            }
              , {addEndListener: o, appear: a=!0, children: s, easing: l, in: c, onEnter: u, onEntered: d, onEntering: h, onExit: p, onExited: f, onExiting: m, style: g, timeout: v=i, TransitionComponent: y=EB} = e
              , b = (0,
            it.A)(e, BB)
              , _ = t.useRef(null)
              , A = (0,
            PB.A)(_, s.ref, n)
              , x = e => t => {
                if (e) {
                    const n = _.current;
                    void 0 === t ? e(n) : e(n, t)
                }
            }
              , S = x(h)
              , w = x(( (e, t) => {
                TB(e);
                const n = RB({
                    style: g,
                    timeout: v,
                    easing: l
                }, {
                    mode: "enter"
                });
                e.style.webkitTransition = r.transitions.create("opacity", n),
                e.style.transition = r.transitions.create("opacity", n),
                u && u(e, t)
            }
            ))
              , E = x(d)
              , M = x(m)
              , C = x((e => {
                const t = RB({
                    style: g,
                    timeout: v,
                    easing: l
                }, {
                    mode: "exit"
                });
                e.style.webkitTransition = r.transitions.create("opacity", t),
                e.style.transition = r.transitions.create("opacity", t),
                p && p(e)
            }
            ))
              , T = x(f);
            return (0,
            mt.jsx)(y, (0,
            rt.A)({
                appear: a,
                in: c,
                nodeRef: _,
                onEnter: w,
                onEntered: E,
                onEntering: S,
                onExit: C,
                onExited: T,
                onExiting: M,
                addEndListener: e => {
                    o && o(_.current, e)
                }
                ,
                timeout: v
            }, b, {
                children: (e, n) => t.cloneElement(s, (0,
                rt.A)({
                    style: (0,
                    rt.A)({
                        opacity: 0,
                        visibility: "exited" !== e || c ? void 0 : "hidden"
                    }, IB[e], g, s.props.style),
                    ref: A
                }, n))
            }))
        }
        ));
        function kB(e) {
            return (0,
            Bt.Ay)("MuiBackdrop", e)
        }
        (0,
        _t.A)("MuiBackdrop", ["root", "invisible"]);
        const DB = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"]
          , OB = (0,
        Mt.Ay)("div", {
            name: "MuiBackdrop",
            slot: "Root",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.root, n.invisible && t.invisible]
            }
        })((e => {
            let {ownerState: t} = e;
            return (0,
            rt.A)({
                position: "fixed",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                right: 0,
                bottom: 0,
                top: 0,
                left: 0,
                backgroundColor: "rgba(0, 0, 0, 0.5)",
                WebkitTapHighlightColor: "transparent"
            }, t.invisible && {
                backgroundColor: "transparent"
            })
        }
        ))
          , NB = t.forwardRef((function(e, t) {
            var n, r, i;
            const o = (0,
            Ct.b)({
                props: e,
                name: "MuiBackdrop"
            })
              , {children: a, className: s, component: l="div", components: c={}, componentsProps: u={}, invisible: d=!1, open: h, slotProps: p={}, slots: f={}, TransitionComponent: m=LB, transitionDuration: g} = o
              , v = (0,
            it.A)(o, DB)
              , y = (0,
            rt.A)({}, o, {
                component: l,
                invisible: d
            })
              , b = (e => {
                const {classes: t, invisible: n} = e
                  , r = {
                    root: ["root", n && "invisible"]
                };
                return (0,
                Et.A)(r, kB, t)
            }
            )(y)
              , _ = null != (n = p.root) ? n : u.root;
            return (0,
            mt.jsx)(m, (0,
            rt.A)({
                in: h,
                timeout: g
            }, v, {
                children: (0,
                mt.jsx)(OB, (0,
                rt.A)({
                    "aria-hidden": !0
                }, _, {
                    as: null != (r = null != (i = f.root) ? i : c.Root) ? r : l,
                    className: (0,
                    wt.A)(b.root, s, null == _ ? void 0 : _.className),
                    ownerState: (0,
                    rt.A)({}, y, null == _ ? void 0 : _.ownerState),
                    classes: b,
                    ref: t,
                    children: a
                }))
            }))
        }
        ));
        var FB = __webpack_require__(2529)
          , UB = __webpack_require__(5511)
          , zB = __webpack_require__(8635);
        function GB(e, t) {
            t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden")
        }
        function HB(e) {
            return parseInt((0,
            zB.A)(e).getComputedStyle(e).paddingRight, 10) || 0
        }
        function jB(e, t, n, r, i) {
            const o = [t, n, ...r];
            [].forEach.call(e.children, (e => {
                const t = -1 === o.indexOf(e)
                  , n = !function(e) {
                    const t = -1 !== ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].indexOf(e.tagName)
                      , n = "INPUT" === e.tagName && "hidden" === e.getAttribute("type");
                    return t || n
                }(e);
                t && n && GB(e, i)
            }
            ))
        }
        function WB(e, t) {
            let n = -1;
            return e.some(( (e, r) => !!t(e) && (n = r,
            !0))),
            n
        }
        function VB(e, t) {
            const n = []
              , r = e.container;
            if (!t.disableScrollLock) {
                if (function(e) {
                    const t = (0,
                    oB.A)(e);
                    return t.body === e ? (0,
                    zB.A)(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight
                }(r)) {
                    const e = function(e) {
                        const t = e.documentElement.clientWidth;
                        return Math.abs(window.innerWidth - t)
                    }((0,
                    oB.A)(r));
                    n.push({
                        value: r.style.paddingRight,
                        property: "padding-right",
                        el: r
                    }),
                    r.style.paddingRight = `${HB(r) + e}px`;
                    const t = (0,
                    oB.A)(r).querySelectorAll(".mui-fixed");
                    [].forEach.call(t, (t => {
                        n.push({
                            value: t.style.paddingRight,
                            property: "padding-right",
                            el: t
                        }),
                        t.style.paddingRight = `${HB(t) + e}px`
                    }
                    ))
                }
                let e;
                if (r.parentNode instanceof DocumentFragment)
                    e = (0,
                    oB.A)(r).body;
                else {
                    const t = r.parentElement
                      , n = (0,
                    zB.A)(r);
                    e = "HTML" === (null == t ? void 0 : t.nodeName) && "scroll" === n.getComputedStyle(t).overflowY ? t : r
                }
                n.push({
                    value: e.style.overflow,
                    property: "overflow",
                    el: e
                }, {
                    value: e.style.overflowX,
                    property: "overflow-x",
                    el: e
                }, {
                    value: e.style.overflowY,
                    property: "overflow-y",
                    el: e
                }),
                e.style.overflow = "hidden"
            }
            return () => {
                n.forEach((e => {
                    let {value: t, el: n, property: r} = e;
                    t ? n.style.setProperty(r, t) : n.style.removeProperty(r)
                }
                ))
            }
        }
        const XB = new class {
            constructor() {
                this.containers = void 0,
                this.modals = void 0,
                this.modals = [],
                this.containers = []
            }
            add(e, t) {
                let n = this.modals.indexOf(e);
                if (-1 !== n)
                    return n;
                n = this.modals.length,
                this.modals.push(e),
                e.modalRef && GB(e.modalRef, !1);
                const r = function(e) {
                    const t = [];
                    return [].forEach.call(e.children, (e => {
                        "true" === e.getAttribute("aria-hidden") && t.push(e)
                    }
                    )),
                    t
                }(t);
                jB(t, e.mount, e.modalRef, r, !0);
                const i = WB(this.containers, (e => e.container === t));
                return -1 !== i ? (this.containers[i].modals.push(e),
                n) : (this.containers.push({
                    modals: [e],
                    container: t,
                    restore: null,
                    hiddenSiblings: r
                }),
                n)
            }
            mount(e, t) {
                const n = WB(this.containers, (t => -1 !== t.modals.indexOf(e)))
                  , r = this.containers[n];
                r.restore || (r.restore = VB(r, t))
            }
            remove(e) {
                let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                const n = this.modals.indexOf(e);
                if (-1 === n)
                    return n;
                const r = WB(this.containers, (t => -1 !== t.modals.indexOf(e)))
                  , i = this.containers[r];
                if (i.modals.splice(i.modals.indexOf(e), 1),
                this.modals.splice(n, 1),
                0 === i.modals.length)
                    i.restore && i.restore(),
                    e.modalRef && GB(e.modalRef, t),
                    jB(i.container, e.mount, e.modalRef, i.hiddenSiblings, !1),
                    this.containers.splice(r, 1);
                else {
                    const e = i.modals[i.modals.length - 1];
                    e.modalRef && GB(e.modalRef, !1)
                }
                return n
            }
            isTopModal(e) {
                return this.modals.length > 0 && this.modals[this.modals.length - 1] === e
            }
        }
        ;
        const JB = function(e) {
            const {container: n, disableEscapeKeyDown: r=!1, disableScrollLock: i=!1, manager: o=XB, closeAfterTransition: a=!1, onTransitionEnter: s, onTransitionExited: l, children: c, onClose: u, open: d, rootRef: h} = e
              , p = t.useRef({})
              , f = t.useRef(null)
              , m = t.useRef(null)
              , g = (0,
            KP.A)(m, h)
              , [v,y] = t.useState(!d)
              , b = function(e) {
                return !!e && e.props.hasOwnProperty("in")
            }(c);
            let _ = !0;
            "false" !== e["aria-hidden"] && !1 !== e["aria-hidden"] || (_ = !1);
            const A = () => (p.current.modalRef = m.current,
            p.current.mount = f.current,
            p.current)
              , x = () => {
                o.mount(A(), {
                    disableScrollLock: i
                }),
                m.current && (m.current.scrollTop = 0)
            }
              , S = (0,
            FB.A)(( () => {
                const e = function(e) {
                    return "function" === typeof e ? e() : e
                }(n) || (0,
                oB.A)(f.current).body;
                o.add(A(), e),
                m.current && x()
            }
            ))
              , w = t.useCallback(( () => o.isTopModal(A())), [o])
              , E = (0,
            FB.A)((e => {
                f.current = e,
                e && (d && w() ? x() : m.current && GB(m.current, _))
            }
            ))
              , M = t.useCallback(( () => {
                o.remove(A(), _)
            }
            ), [_, o]);
            t.useEffect(( () => () => {
                M()
            }
            ), [M]),
            t.useEffect(( () => {
                d ? S() : b && a || M()
            }
            ), [d, M, b, a, S]);
            const C = e => t => {
                var n;
                null == (n = e.onKeyDown) || n.call(e, t),
                "Escape" === t.key && 229 !== t.which && w() && (r || (t.stopPropagation(),
                u && u(t, "escapeKeyDown")))
            }
              , T = e => t => {
                var n;
                null == (n = e.onClick) || n.call(e, t),
                t.target === t.currentTarget && u && u(t, "backdropClick")
            }
            ;
            return {
                getRootProps: function() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    const n = $P(e);
                    delete n.onTransitionEnter,
                    delete n.onTransitionExited;
                    const r = (0,
                    rt.A)({}, n, t);
                    return (0,
                    rt.A)({
                        role: "presentation"
                    }, r, {
                        onKeyDown: C(r),
                        ref: g
                    })
                },
                getBackdropProps: function() {
                    const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return (0,
                    rt.A)({
                        "aria-hidden": !0
                    }, e, {
                        onClick: T(e),
                        open: d
                    })
                },
                getTransitionProps: () => ({
                    onEnter: (0,
                    UB.A)(( () => {
                        y(!1),
                        s && s()
                    }
                    ), null == c ? void 0 : c.props.onEnter),
                    onExited: (0,
                    UB.A)(( () => {
                        y(!0),
                        l && l(),
                        a && M()
                    }
                    ), null == c ? void 0 : c.props.onExited)
                }),
                rootRef: g,
                portalRef: E,
                isTopModal: w,
                exited: v,
                hasTransition: b
            }
        };
        function KB(e) {
            return (0,
            Bt.Ay)("MuiModal", e)
        }
        (0,
        _t.A)("MuiModal", ["root", "hidden", "backdrop"]);
        const qB = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"]
          , YB = (0,
        Mt.Ay)("div", {
            name: "MuiModal",
            slot: "Root",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.root, !n.open && n.exited && t.hidden]
            }
        })((e => {
            let {theme: t, ownerState: n} = e;
            return (0,
            rt.A)({
                position: "fixed",
                zIndex: (t.vars || t).zIndex.modal,
                right: 0,
                bottom: 0,
                top: 0,
                left: 0
            }, !n.open && n.exited && {
                visibility: "hidden"
            })
        }
        ))
          , QB = (0,
        Mt.Ay)(NB, {
            name: "MuiModal",
            slot: "Backdrop",
            overridesResolver: (e, t) => t.backdrop
        })({
            zIndex: -1
        })
          , ZB = t.forwardRef((function(e, n) {
            var r, i, o, a, s, l;
            const c = (0,
            Ct.b)({
                name: "MuiModal",
                props: e
            })
              , {BackdropComponent: u=QB, BackdropProps: d, className: h, closeAfterTransition: p=!1, children: f, container: m, component: g, components: v={}, componentsProps: y={}, disableAutoFocus: b=!1, disableEnforceFocus: _=!1, disableEscapeKeyDown: A=!1, disablePortal: x=!1, disableRestoreFocus: S=!1, disableScrollLock: w=!1, hideBackdrop: E=!1, keepMounted: M=!1, onBackdropClick: C, open: T, slotProps: R, slots: P} = c
              , B = (0,
            it.A)(c, qB)
              , I = (0,
            rt.A)({}, c, {
                closeAfterTransition: p,
                disableAutoFocus: b,
                disableEnforceFocus: _,
                disableEscapeKeyDown: A,
                disablePortal: x,
                disableRestoreFocus: S,
                disableScrollLock: w,
                hideBackdrop: E,
                keepMounted: M
            })
              , {getRootProps: L, getBackdropProps: k, getTransitionProps: D, portalRef: O, isTopModal: N, exited: F, hasTransition: U} = JB((0,
            rt.A)({}, I, {
                rootRef: n
            }))
              , z = (0,
            rt.A)({}, I, {
                exited: F
            })
              , G = (e => {
                const {open: t, exited: n, classes: r} = e
                  , i = {
                    root: ["root", !t && n && "hidden"],
                    backdrop: ["backdrop"]
                };
                return (0,
                Et.A)(i, KB, r)
            }
            )(z)
              , H = {};
            if (void 0 === f.props.tabIndex && (H.tabIndex = "-1"),
            U) {
                const {onEnter: e, onExited: t} = D();
                H.onEnter = e,
                H.onExited = t
            }
            const j = null != (r = null != (i = null == P ? void 0 : P.root) ? i : v.Root) ? r : YB
              , W = null != (o = null != (a = null == P ? void 0 : P.backdrop) ? a : v.Backdrop) ? o : u
              , V = null != (s = null == R ? void 0 : R.root) ? s : y.root
              , X = null != (l = null == R ? void 0 : R.backdrop) ? l : y.backdrop
              , J = iB({
                elementType: j,
                externalSlotProps: V,
                externalForwardedProps: B,
                getSlotProps: L,
                additionalProps: {
                    ref: n,
                    as: g
                },
                ownerState: z,
                className: (0,
                wt.A)(h, null == V ? void 0 : V.className, null == G ? void 0 : G.root, !z.open && z.exited && (null == G ? void 0 : G.hidden))
            })
              , K = iB({
                elementType: W,
                externalSlotProps: X,
                additionalProps: d,
                getSlotProps: e => k((0,
                rt.A)({}, e, {
                    onClick: t => {
                        C && C(t),
                        null != e && e.onClick && e.onClick(t)
                    }
                })),
                className: (0,
                wt.A)(null == X ? void 0 : X.className, null == d ? void 0 : d.className, null == G ? void 0 : G.backdrop),
                ownerState: z
            });
            return M || T || U && !F ? (0,
            mt.jsx)(pB, {
                ref: O,
                container: m,
                disablePortal: x,
                children: (0,
                mt.jsxs)(j, (0,
                rt.A)({}, J, {
                    children: [!E && u ? (0,
                    mt.jsx)(W, (0,
                    rt.A)({}, K)) : null, (0,
                    mt.jsx)(cB, {
                        disableEnforceFocus: _,
                        disableAutoFocus: b,
                        disableRestoreFocus: S,
                        isEnabled: N,
                        open: T,
                        children: t.cloneElement(f, H)
                    })]
                }))
            }) : null
        }
        ));
        function $B(e) {
            return (0,
            Bt.Ay)("MuiDialog", e)
        }
        const eI = (0,
        _t.A)("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
        const tI = t.createContext({})
          , nI = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"]
          , rI = (0,
        Mt.Ay)(NB, {
            name: "MuiDialog",
            slot: "Backdrop",
            overrides: (e, t) => t.backdrop
        })({
            zIndex: -1
        })
          , iI = (0,
        Mt.Ay)(ZB, {
            name: "MuiDialog",
            slot: "Root",
            overridesResolver: (e, t) => t.root
        })({
            "@media print": {
                position: "absolute !important"
            }
        })
          , oI = (0,
        Mt.Ay)("div", {
            name: "MuiDialog",
            slot: "Container",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.container, t[`scroll${(0,
                Tt.A)(n.scroll)}`]]
            }
        })((e => {
            let {ownerState: t} = e;
            return (0,
            rt.A)({
                height: "100%",
                "@media print": {
                    height: "auto"
                },
                outline: 0
            }, "paper" === t.scroll && {
                display: "flex",
                justifyContent: "center",
                alignItems: "center"
            }, "body" === t.scroll && {
                overflowY: "auto",
                overflowX: "hidden",
                textAlign: "center",
                "&::after": {
                    content: '""',
                    display: "inline-block",
                    verticalAlign: "middle",
                    height: "100%",
                    width: "0"
                }
            })
        }
        ))
          , aI = (0,
        Mt.Ay)(Dt, {
            name: "MuiDialog",
            slot: "Paper",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.paper, t[`scrollPaper${(0,
                Tt.A)(n.scroll)}`], t[`paperWidth${(0,
                Tt.A)(String(n.maxWidth))}`], n.fullWidth && t.paperFullWidth, n.fullScreen && t.paperFullScreen]
            }
        })((e => {
            let {theme: t, ownerState: n} = e;
            return (0,
            rt.A)({
                margin: 32,
                position: "relative",
                overflowY: "auto",
                "@media print": {
                    overflowY: "visible",
                    boxShadow: "none"
                }
            }, "paper" === n.scroll && {
                display: "flex",
                flexDirection: "column",
                maxHeight: "calc(100% - 64px)"
            }, "body" === n.scroll && {
                display: "inline-block",
                verticalAlign: "middle",
                textAlign: "left"
            }, !n.maxWidth && {
                maxWidth: "calc(100% - 64px)"
            }, "xs" === n.maxWidth && {
                maxWidth: "px" === t.breakpoints.unit ? Math.max(t.breakpoints.values.xs, 444) : `max(${t.breakpoints.values.xs}${t.breakpoints.unit}, 444px)`,
                [`&.${eI.paperScrollBody}`]: {
                    [t.breakpoints.down(Math.max(t.breakpoints.values.xs, 444) + 64)]: {
                        maxWidth: "calc(100% - 64px)"
                    }
                }
            }, n.maxWidth && "xs" !== n.maxWidth && {
                maxWidth: `${t.breakpoints.values[n.maxWidth]}${t.breakpoints.unit}`,
                [`&.${eI.paperScrollBody}`]: {
                    [t.breakpoints.down(t.breakpoints.values[n.maxWidth] + 64)]: {
                        maxWidth: "calc(100% - 64px)"
                    }
                }
            }, n.fullWidth && {
                width: "calc(100% - 64px)"
            }, n.fullScreen && {
                margin: 0,
                width: "100%",
                maxWidth: "100%",
                height: "100%",
                maxHeight: "none",
                borderRadius: 0,
                [`&.${eI.paperScrollBody}`]: {
                    margin: 0,
                    maxWidth: "100%"
                }
            })
        }
        ))
          , sI = t.forwardRef((function(e, n) {
            const r = (0,
            Ct.b)({
                props: e,
                name: "MuiDialog"
            })
              , i = CB()
              , o = {
                enter: i.transitions.duration.enteringScreen,
                exit: i.transitions.duration.leavingScreen
            }
              , {"aria-describedby": a, "aria-labelledby": s, BackdropComponent: l, BackdropProps: c, children: u, className: d, disableEscapeKeyDown: h=!1, fullScreen: p=!1, fullWidth: f=!1, maxWidth: m="sm", onBackdropClick: g, onClick: v, onClose: y, open: b, PaperComponent: _=Dt, PaperProps: A={}, scroll: x="paper", TransitionComponent: S=LB, transitionDuration: w=o, TransitionProps: E} = r
              , M = (0,
            it.A)(r, nI)
              , C = (0,
            rt.A)({}, r, {
                disableEscapeKeyDown: h,
                fullScreen: p,
                fullWidth: f,
                maxWidth: m,
                scroll: x
            })
              , T = (e => {
                const {classes: t, scroll: n, maxWidth: r, fullWidth: i, fullScreen: o} = e
                  , a = {
                    root: ["root"],
                    container: ["container", `scroll${(0,
                    Tt.A)(n)}`],
                    paper: ["paper", `paperScroll${(0,
                    Tt.A)(n)}`, `paperWidth${(0,
                    Tt.A)(String(r))}`, i && "paperFullWidth", o && "paperFullScreen"]
                };
                return (0,
                Et.A)(a, $B, t)
            }
            )(C)
              , R = t.useRef()
              , P = (0,
            JP.A)(s)
              , B = t.useMemo(( () => ({
                titleId: P
            })), [P]);
            return (0,
            mt.jsx)(iI, (0,
            rt.A)({
                className: (0,
                wt.A)(T.root, d),
                closeAfterTransition: !0,
                components: {
                    Backdrop: rI
                },
                componentsProps: {
                    backdrop: (0,
                    rt.A)({
                        transitionDuration: w,
                        as: l
                    }, c)
                },
                disableEscapeKeyDown: h,
                onClose: y,
                open: b,
                ref: n,
                onClick: e => {
                    v && v(e),
                    R.current && (R.current = null,
                    g && g(e),
                    y && y(e, "backdropClick"))
                }
                ,
                ownerState: C
            }, M, {
                children: (0,
                mt.jsx)(S, (0,
                rt.A)({
                    appear: !0,
                    in: b,
                    timeout: w,
                    role: "presentation"
                }, E, {
                    children: (0,
                    mt.jsx)(oI, {
                        className: (0,
                        wt.A)(T.container),
                        onMouseDown: e => {
                            R.current = e.target === e.currentTarget
                        }
                        ,
                        ownerState: C,
                        children: (0,
                        mt.jsx)(aI, (0,
                        rt.A)({
                            as: _,
                            elevation: 24,
                            role: "dialog",
                            "aria-describedby": a,
                            "aria-labelledby": P
                        }, A, {
                            className: (0,
                            wt.A)(T.paper, A.className),
                            ownerState: C,
                            children: (0,
                            mt.jsx)(tI.Provider, {
                                value: B,
                                children: u
                            })
                        }))
                    })
                }))
            }))
        }
        ));
        var lI = __webpack_require__(5537)
          , cI = __webpack_require__(741)
          , uI = __webpack_require__(1976)
          , dI = __webpack_require__(2937);
        function hI(e, n) {
            var r = Object.create(null);
            return e && t.Children.map(e, (function(e) {
                return e
            }
            )).forEach((function(e) {
                r[e.key] = function(e) {
                    return n && (0,
                    t.isValidElement)(e) ? n(e) : e
                }(e)
            }
            )),
            r
        }
        function pI(e, t, n) {
            return null != n[t] ? n[t] : e.props[t]
        }
        function fI(e, n, r) {
            var i = hI(e.children)
              , o = function(e, t) {
                function n(n) {
                    return n in t ? t[n] : e[n]
                }
                e = e || {},
                t = t || {};
                var r, i = Object.create(null), o = [];
                for (var a in e)
                    a in t ? o.length && (i[a] = o,
                    o = []) : o.push(a);
                var s = {};
                for (var l in t) {
                    if (i[l])
                        for (r = 0; r < i[l].length; r++) {
                            var c = i[l][r];
                            s[i[l][r]] = n(c)
                        }
                    s[l] = n(l)
                }
                for (r = 0; r < o.length; r++)
                    s[o[r]] = n(o[r]);
                return s
            }(n, i);
            return Object.keys(o).forEach((function(a) {
                var s = o[a];
                if ((0,
                t.isValidElement)(s)) {
                    var l = a in n
                      , c = a in i
                      , u = n[a]
                      , d = (0,
                    t.isValidElement)(u) && !u.props.in;
                    !c || l && !d ? c || !l || d ? c && l && (0,
                    t.isValidElement)(u) && (o[a] = (0,
                    t.cloneElement)(s, {
                        onExited: r.bind(null, s),
                        in: u.props.in,
                        exit: pI(s, "exit", e),
                        enter: pI(s, "enter", e)
                    })) : o[a] = (0,
                    t.cloneElement)(s, {
                        in: !1
                    }) : o[a] = (0,
                    t.cloneElement)(s, {
                        onExited: r.bind(null, s),
                        in: !0,
                        exit: pI(s, "exit", e),
                        enter: pI(s, "enter", e)
                    })
                }
            }
            )),
            o
        }
        var mI = Object.values || function(e) {
            return Object.keys(e).map((function(t) {
                return e[t]
            }
            ))
        }
          , gI = function(e) {
            function n(t, n) {
                var r, i = (r = e.call(this, t, n) || this).handleExited.bind(function(e) {
                    if (void 0 === e)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(r));
                return r.state = {
                    contextValue: {
                        isMounting: !0
                    },
                    handleExited: i,
                    firstRender: !0
                },
                r
            }
            mB(n, e);
            var r = n.prototype;
            return r.componentDidMount = function() {
                this.mounted = !0,
                this.setState({
                    contextValue: {
                        isMounting: !1
                    }
                })
            }
            ,
            r.componentWillUnmount = function() {
                this.mounted = !1
            }
            ,
            n.getDerivedStateFromProps = function(e, n) {
                var r, i, o = n.children, a = n.handleExited;
                return {
                    children: n.firstRender ? (r = e,
                    i = a,
                    hI(r.children, (function(e) {
                        return (0,
                        t.cloneElement)(e, {
                            onExited: i.bind(null, e),
                            in: !0,
                            appear: pI(e, "appear", r),
                            enter: pI(e, "enter", r),
                            exit: pI(e, "exit", r)
                        })
                    }
                    ))) : fI(e, o, a),
                    firstRender: !1
                }
            }
            ,
            r.handleExited = function(e, t) {
                var n = hI(this.props.children);
                e.key in n || (e.props.onExited && e.props.onExited(t),
                this.mounted && this.setState((function(t) {
                    var n = (0,
                    rt.A)({}, t.children);
                    return delete n[e.key],
                    {
                        children: n
                    }
                }
                )))
            }
            ,
            r.render = function() {
                var e = this.props
                  , n = e.component
                  , r = e.childFactory
                  , i = (0,
                it.A)(e, ["component", "childFactory"])
                  , o = this.state.contextValue
                  , a = mI(this.state.children).map(r);
                return delete i.appear,
                delete i.enter,
                delete i.exit,
                null === n ? t.createElement(vB.Provider, {
                    value: o
                }, a) : t.createElement(vB.Provider, {
                    value: o
                }, t.createElement(n, i, a))
            }
            ,
            n
        }(t.Component);
        gI.propTypes = {},
        gI.defaultProps = {
            component: "div",
            childFactory: function(e) {
                return e
            }
        };
        const vI = gI;
        var yI = __webpack_require__(8283)
          , bI = __webpack_require__(1824);
        const _I = function(e) {
            const {className: n, classes: r, pulsate: i=!1, rippleX: o, rippleY: a, rippleSize: s, in: l, onExited: c, timeout: u} = e
              , [d,h] = t.useState(!1)
              , p = (0,
            wt.A)(n, r.ripple, r.rippleVisible, i && r.ripplePulsate)
              , f = {
                width: s,
                height: s,
                top: -s / 2 + a,
                left: -s / 2 + o
            }
              , m = (0,
            wt.A)(r.child, d && r.childLeaving, i && r.childPulsate);
            return l || d || h(!0),
            t.useEffect(( () => {
                if (!l && null != c) {
                    const e = setTimeout(c, u);
                    return () => {
                        clearTimeout(e)
                    }
                }
            }
            ), [c, l, u]),
            (0,
            mt.jsx)("span", {
                className: p,
                style: f,
                children: (0,
                mt.jsx)("span", {
                    className: m
                })
            })
        };
        const AI = (0,
        _t.A)("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"])
          , xI = ["center", "classes", "className"];
        let SI, wI, EI, MI, CI = e => e;
        const TI = (0,
        yI.i7)(SI || (SI = CI`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`))
          , RI = (0,
        yI.i7)(wI || (wI = CI`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`))
          , PI = (0,
        yI.i7)(EI || (EI = CI`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`))
          , BI = (0,
        Mt.Ay)("span", {
            name: "MuiTouchRipple",
            slot: "Root"
        })({
            overflow: "hidden",
            pointerEvents: "none",
            position: "absolute",
            zIndex: 0,
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            borderRadius: "inherit"
        })
          , II = (0,
        Mt.Ay)(_I, {
            name: "MuiTouchRipple",
            slot: "Ripple"
        })(MI || (MI = CI`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), AI.rippleVisible, TI, 550, (e => {
            let {theme: t} = e;
            return t.transitions.easing.easeInOut
        }
        ), AI.ripplePulsate, (e => {
            let {theme: t} = e;
            return t.transitions.duration.shorter
        }
        ), AI.child, AI.childLeaving, RI, 550, (e => {
            let {theme: t} = e;
            return t.transitions.easing.easeInOut
        }
        ), AI.childPulsate, PI, (e => {
            let {theme: t} = e;
            return t.transitions.easing.easeInOut
        }
        ))
          , LI = t.forwardRef((function(e, n) {
            const r = (0,
            Ct.b)({
                props: e,
                name: "MuiTouchRipple"
            })
              , {center: i=!1, classes: o={}, className: a} = r
              , s = (0,
            it.A)(r, xI)
              , [l,c] = t.useState([])
              , u = t.useRef(0)
              , d = t.useRef(null);
            t.useEffect(( () => {
                d.current && (d.current(),
                d.current = null)
            }
            ), [l]);
            const h = t.useRef(!1)
              , p = (0,
            bI.A)()
              , f = t.useRef(null)
              , m = t.useRef(null)
              , g = t.useCallback((e => {
                const {pulsate: t, rippleX: n, rippleY: r, rippleSize: i, cb: a} = e;
                c((e => [...e, (0,
                mt.jsx)(II, {
                    classes: {
                        ripple: (0,
                        wt.A)(o.ripple, AI.ripple),
                        rippleVisible: (0,
                        wt.A)(o.rippleVisible, AI.rippleVisible),
                        ripplePulsate: (0,
                        wt.A)(o.ripplePulsate, AI.ripplePulsate),
                        child: (0,
                        wt.A)(o.child, AI.child),
                        childLeaving: (0,
                        wt.A)(o.childLeaving, AI.childLeaving),
                        childPulsate: (0,
                        wt.A)(o.childPulsate, AI.childPulsate)
                    },
                    timeout: 550,
                    pulsate: t,
                    rippleX: n,
                    rippleY: r,
                    rippleSize: i
                }, u.current)])),
                u.current += 1,
                d.current = a
            }
            ), [o])
              , v = t.useCallback((function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : () => {}
                ;
                const {pulsate: r=!1, center: o=i || t.pulsate, fakeElement: a=!1} = t;
                if ("mousedown" === (null == e ? void 0 : e.type) && h.current)
                    return void (h.current = !1);
                "touchstart" === (null == e ? void 0 : e.type) && (h.current = !0);
                const s = a ? null : m.current
                  , l = s ? s.getBoundingClientRect() : {
                    width: 0,
                    height: 0,
                    left: 0,
                    top: 0
                };
                let c, u, d;
                if (o || void 0 === e || 0 === e.clientX && 0 === e.clientY || !e.clientX && !e.touches)
                    c = Math.round(l.width / 2),
                    u = Math.round(l.height / 2);
                else {
                    const {clientX: t, clientY: n} = e.touches && e.touches.length > 0 ? e.touches[0] : e;
                    c = Math.round(t - l.left),
                    u = Math.round(n - l.top)
                }
                if (o)
                    d = Math.sqrt((2 * l.width ** 2 + l.height ** 2) / 3),
                    d % 2 === 0 && (d += 1);
                else {
                    const e = 2 * Math.max(Math.abs((s ? s.clientWidth : 0) - c), c) + 2
                      , t = 2 * Math.max(Math.abs((s ? s.clientHeight : 0) - u), u) + 2;
                    d = Math.sqrt(e ** 2 + t ** 2)
                }
                null != e && e.touches ? null === f.current && (f.current = () => {
                    g({
                        pulsate: r,
                        rippleX: c,
                        rippleY: u,
                        rippleSize: d,
                        cb: n
                    })
                }
                ,
                p.start(80, ( () => {
                    f.current && (f.current(),
                    f.current = null)
                }
                ))) : g({
                    pulsate: r,
                    rippleX: c,
                    rippleY: u,
                    rippleSize: d,
                    cb: n
                })
            }
            ), [i, g, p])
              , y = t.useCallback(( () => {
                v({}, {
                    pulsate: !0
                })
            }
            ), [v])
              , b = t.useCallback(( (e, t) => {
                if (p.clear(),
                "touchend" === (null == e ? void 0 : e.type) && f.current)
                    return f.current(),
                    f.current = null,
                    void p.start(0, ( () => {
                        b(e, t)
                    }
                    ));
                f.current = null,
                c((e => e.length > 0 ? e.slice(1) : e)),
                d.current = t
            }
            ), [p]);
            return t.useImperativeHandle(n, ( () => ({
                pulsate: y,
                start: v,
                stop: b
            })), [y, v, b]),
            (0,
            mt.jsx)(BI, (0,
            rt.A)({
                className: (0,
                wt.A)(AI.root, o.root, a),
                ref: m
            }, s, {
                children: (0,
                mt.jsx)(vI, {
                    component: null,
                    exit: !0,
                    children: l
                })
            }))
        }
        ));
        function kI(e) {
            return (0,
            Bt.Ay)("MuiButtonBase", e)
        }
        const DI = (0,
        _t.A)("MuiButtonBase", ["root", "disabled", "focusVisible"])
          , OI = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"]
          , NI = (0,
        Mt.Ay)("button", {
            name: "MuiButtonBase",
            slot: "Root",
            overridesResolver: (e, t) => t.root
        })({
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center",
            position: "relative",
            boxSizing: "border-box",
            WebkitTapHighlightColor: "transparent",
            backgroundColor: "transparent",
            outline: 0,
            border: 0,
            margin: 0,
            borderRadius: 0,
            padding: 0,
            cursor: "pointer",
            userSelect: "none",
            verticalAlign: "middle",
            MozAppearance: "none",
            WebkitAppearance: "none",
            textDecoration: "none",
            color: "inherit",
            "&::-moz-focus-inner": {
                borderStyle: "none"
            },
            [`&.${DI.disabled}`]: {
                pointerEvents: "none",
                cursor: "default"
            },
            "@media print": {
                colorAdjust: "exact"
            }
        })
          , FI = t.forwardRef((function(e, n) {
            const r = (0,
            Ct.b)({
                props: e,
                name: "MuiButtonBase"
            })
              , {action: i, centerRipple: o=!1, children: a, className: s, component: l="button", disabled: c=!1, disableRipple: u=!1, disableTouchRipple: d=!1, focusRipple: h=!1, LinkComponent: p="a", onBlur: f, onClick: m, onContextMenu: g, onDragLeave: v, onFocus: y, onFocusVisible: b, onKeyDown: _, onKeyUp: A, onMouseDown: x, onMouseLeave: S, onMouseUp: w, onTouchEnd: E, onTouchMove: M, onTouchStart: C, tabIndex: T=0, TouchRippleProps: R, touchRippleRef: P, type: B} = r
              , I = (0,
            it.A)(r, OI)
              , L = t.useRef(null)
              , k = t.useRef(null)
              , D = (0,
            PB.A)(k, P)
              , {isFocusVisibleRef: O, onFocus: N, onBlur: F, ref: U} = (0,
            dI.A)()
              , [z,G] = t.useState(!1);
            c && z && G(!1),
            t.useImperativeHandle(i, ( () => ({
                focusVisible: () => {
                    G(!0),
                    L.current.focus()
                }
            })), []);
            const [H,j] = t.useState(!1);
            t.useEffect(( () => {
                j(!0)
            }
            ), []);
            const W = H && !u && !c;
            function V(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : d;
                return (0,
                uI.A)((r => {
                    t && t(r);
                    return !n && k.current && k.current[e](r),
                    !0
                }
                ))
            }
            t.useEffect(( () => {
                z && h && !u && H && k.current.pulsate()
            }
            ), [u, h, z, H]);
            const X = V("start", x)
              , J = V("stop", g)
              , K = V("stop", v)
              , q = V("stop", w)
              , Y = V("stop", (e => {
                z && e.preventDefault(),
                S && S(e)
            }
            ))
              , Q = V("start", C)
              , Z = V("stop", E)
              , $ = V("stop", M)
              , ee = V("stop", (e => {
                F(e),
                !1 === O.current && G(!1),
                f && f(e)
            }
            ), !1)
              , te = (0,
            uI.A)((e => {
                L.current || (L.current = e.currentTarget),
                N(e),
                !0 === O.current && (G(!0),
                b && b(e)),
                y && y(e)
            }
            ))
              , ne = () => {
                const e = L.current;
                return l && "button" !== l && !("A" === e.tagName && e.href)
            }
              , re = t.useRef(!1)
              , ie = (0,
            uI.A)((e => {
                h && !re.current && z && k.current && " " === e.key && (re.current = !0,
                k.current.stop(e, ( () => {
                    k.current.start(e)
                }
                ))),
                e.target === e.currentTarget && ne() && " " === e.key && e.preventDefault(),
                _ && _(e),
                e.target === e.currentTarget && ne() && "Enter" === e.key && !c && (e.preventDefault(),
                m && m(e))
            }
            ))
              , oe = (0,
            uI.A)((e => {
                h && " " === e.key && k.current && z && !e.defaultPrevented && (re.current = !1,
                k.current.stop(e, ( () => {
                    k.current.pulsate(e)
                }
                ))),
                A && A(e),
                m && e.target === e.currentTarget && ne() && " " === e.key && !e.defaultPrevented && m(e)
            }
            ));
            let ae = l;
            "button" === ae && (I.href || I.to) && (ae = p);
            const se = {};
            "button" === ae ? (se.type = void 0 === B ? "button" : B,
            se.disabled = c) : (I.href || I.to || (se.role = "button"),
            c && (se["aria-disabled"] = c));
            const le = (0,
            PB.A)(n, U, L);
            const ce = (0,
            rt.A)({}, r, {
                centerRipple: o,
                component: l,
                disabled: c,
                disableRipple: u,
                disableTouchRipple: d,
                focusRipple: h,
                tabIndex: T,
                focusVisible: z
            })
              , ue = (e => {
                const {disabled: t, focusVisible: n, focusVisibleClassName: r, classes: i} = e
                  , o = {
                    root: ["root", t && "disabled", n && "focusVisible"]
                }
                  , a = (0,
                Et.A)(o, kI, i);
                return n && r && (a.root += ` ${r}`),
                a
            }
            )(ce);
            return (0,
            mt.jsxs)(NI, (0,
            rt.A)({
                as: ae,
                className: (0,
                wt.A)(ue.root, s),
                ownerState: ce,
                onBlur: ee,
                onClick: m,
                onContextMenu: J,
                onFocus: te,
                onKeyDown: ie,
                onKeyUp: oe,
                onMouseDown: X,
                onMouseLeave: Y,
                onMouseUp: q,
                onDragLeave: K,
                onTouchEnd: Z,
                onTouchMove: $,
                onTouchStart: Q,
                ref: le,
                tabIndex: c ? -1 : T,
                type: B
            }, se, I, {
                children: [a, W ? (0,
                mt.jsx)(LI, (0,
                rt.A)({
                    ref: D,
                    center: o
                }, R)) : null]
            }))
        }
        ));
        function UI(e) {
            return (0,
            Bt.Ay)("MuiButton", e)
        }
        const zI = (0,
        _t.A)("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
        const GI = t.createContext({});
        const HI = t.createContext(void 0)
          , jI = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"]
          , WI = e => (0,
        rt.A)({}, "small" === e.size && {
            "& > *:nth-of-type(1)": {
                fontSize: 18
            }
        }, "medium" === e.size && {
            "& > *:nth-of-type(1)": {
                fontSize: 20
            }
        }, "large" === e.size && {
            "& > *:nth-of-type(1)": {
                fontSize: 22
            }
        })
          , VI = (0,
        Mt.Ay)(FI, {
            shouldForwardProp: e => (0,
            cI.A)(e) || "classes" === e,
            name: "MuiButton",
            slot: "Root",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.root, t[n.variant], t[`${n.variant}${(0,
                Tt.A)(n.color)}`], t[`size${(0,
                Tt.A)(n.size)}`], t[`${n.variant}Size${(0,
                Tt.A)(n.size)}`], "inherit" === n.color && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth]
            }
        })((e => {
            let {theme: t, ownerState: n} = e;
            var r, i;
            const o = "light" === t.palette.mode ? t.palette.grey[300] : t.palette.grey[800]
              , a = "light" === t.palette.mode ? t.palette.grey.A100 : t.palette.grey[700];
            return (0,
            rt.A)({}, t.typography.button, {
                minWidth: 64,
                padding: "6px 16px",
                borderRadius: (t.vars || t).shape.borderRadius,
                transition: t.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
                    duration: t.transitions.duration.short
                }),
                "&:hover": (0,
                rt.A)({
                    textDecoration: "none",
                    backgroundColor: t.vars ? `rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.hoverOpacity})` : (0,
                    Rt.X4)(t.palette.text.primary, t.palette.action.hoverOpacity),
                    "@media (hover: none)": {
                        backgroundColor: "transparent"
                    }
                }, "text" === n.variant && "inherit" !== n.color && {
                    backgroundColor: t.vars ? `rgba(${t.vars.palette[n.color].mainChannel} / ${t.vars.palette.action.hoverOpacity})` : (0,
                    Rt.X4)(t.palette[n.color].main, t.palette.action.hoverOpacity),
                    "@media (hover: none)": {
                        backgroundColor: "transparent"
                    }
                }, "outlined" === n.variant && "inherit" !== n.color && {
                    border: `1px solid ${(t.vars || t).palette[n.color].main}`,
                    backgroundColor: t.vars ? `rgba(${t.vars.palette[n.color].mainChannel} / ${t.vars.palette.action.hoverOpacity})` : (0,
                    Rt.X4)(t.palette[n.color].main, t.palette.action.hoverOpacity),
                    "@media (hover: none)": {
                        backgroundColor: "transparent"
                    }
                }, "contained" === n.variant && {
                    backgroundColor: t.vars ? t.vars.palette.Button.inheritContainedHoverBg : a,
                    boxShadow: (t.vars || t).shadows[4],
                    "@media (hover: none)": {
                        boxShadow: (t.vars || t).shadows[2],
                        backgroundColor: (t.vars || t).palette.grey[300]
                    }
                }, "contained" === n.variant && "inherit" !== n.color && {
                    backgroundColor: (t.vars || t).palette[n.color].dark,
                    "@media (hover: none)": {
                        backgroundColor: (t.vars || t).palette[n.color].main
                    }
                }),
                "&:active": (0,
                rt.A)({}, "contained" === n.variant && {
                    boxShadow: (t.vars || t).shadows[8]
                }),
                [`&.${zI.focusVisible}`]: (0,
                rt.A)({}, "contained" === n.variant && {
                    boxShadow: (t.vars || t).shadows[6]
                }),
                [`&.${zI.disabled}`]: (0,
                rt.A)({
                    color: (t.vars || t).palette.action.disabled
                }, "outlined" === n.variant && {
                    border: `1px solid ${(t.vars || t).palette.action.disabledBackground}`
                }, "contained" === n.variant && {
                    color: (t.vars || t).palette.action.disabled,
                    boxShadow: (t.vars || t).shadows[0],
                    backgroundColor: (t.vars || t).palette.action.disabledBackground
                })
            }, "text" === n.variant && {
                padding: "6px 8px"
            }, "text" === n.variant && "inherit" !== n.color && {
                color: (t.vars || t).palette[n.color].main
            }, "outlined" === n.variant && {
                padding: "5px 15px",
                border: "1px solid currentColor"
            }, "outlined" === n.variant && "inherit" !== n.color && {
                color: (t.vars || t).palette[n.color].main,
                border: t.vars ? `1px solid rgba(${t.vars.palette[n.color].mainChannel} / 0.5)` : `1px solid ${(0,
                Rt.X4)(t.palette[n.color].main, .5)}`
            }, "contained" === n.variant && {
                color: t.vars ? t.vars.palette.text.primary : null == (r = (i = t.palette).getContrastText) ? void 0 : r.call(i, t.palette.grey[300]),
                backgroundColor: t.vars ? t.vars.palette.Button.inheritContainedBg : o,
                boxShadow: (t.vars || t).shadows[2]
            }, "contained" === n.variant && "inherit" !== n.color && {
                color: (t.vars || t).palette[n.color].contrastText,
                backgroundColor: (t.vars || t).palette[n.color].main
            }, "inherit" === n.color && {
                color: "inherit",
                borderColor: "currentColor"
            }, "small" === n.size && "text" === n.variant && {
                padding: "4px 5px",
                fontSize: t.typography.pxToRem(13)
            }, "large" === n.size && "text" === n.variant && {
                padding: "8px 11px",
                fontSize: t.typography.pxToRem(15)
            }, "small" === n.size && "outlined" === n.variant && {
                padding: "3px 9px",
                fontSize: t.typography.pxToRem(13)
            }, "large" === n.size && "outlined" === n.variant && {
                padding: "7px 21px",
                fontSize: t.typography.pxToRem(15)
            }, "small" === n.size && "contained" === n.variant && {
                padding: "4px 10px",
                fontSize: t.typography.pxToRem(13)
            }, "large" === n.size && "contained" === n.variant && {
                padding: "8px 22px",
                fontSize: t.typography.pxToRem(15)
            }, n.fullWidth && {
                width: "100%"
            })
        }
        ), (e => {
            let {ownerState: t} = e;
            return t.disableElevation && {
                boxShadow: "none",
                "&:hover": {
                    boxShadow: "none"
                },
                [`&.${zI.focusVisible}`]: {
                    boxShadow: "none"
                },
                "&:active": {
                    boxShadow: "none"
                },
                [`&.${zI.disabled}`]: {
                    boxShadow: "none"
                }
            }
        }
        ))
          , XI = (0,
        Mt.Ay)("span", {
            name: "MuiButton",
            slot: "StartIcon",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.startIcon, t[`iconSize${(0,
                Tt.A)(n.size)}`]]
            }
        })((e => {
            let {ownerState: t} = e;
            return (0,
            rt.A)({
                display: "inherit",
                marginRight: 8,
                marginLeft: -4
            }, "small" === t.size && {
                marginLeft: -2
            }, WI(t))
        }
        ))
          , JI = (0,
        Mt.Ay)("span", {
            name: "MuiButton",
            slot: "EndIcon",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.endIcon, t[`iconSize${(0,
                Tt.A)(n.size)}`]]
            }
        })((e => {
            let {ownerState: t} = e;
            return (0,
            rt.A)({
                display: "inherit",
                marginRight: -4,
                marginLeft: 8
            }, "small" === t.size && {
                marginRight: -2
            }, WI(t))
        }
        ))
          , KI = t.forwardRef((function(e, n) {
            const r = t.useContext(GI)
              , i = t.useContext(HI)
              , o = (0,
            lI.A)(r, e)
              , a = (0,
            Ct.b)({
                props: o,
                name: "MuiButton"
            })
              , {children: s, color: l="primary", component: c="button", className: u, disabled: d=!1, disableElevation: h=!1, disableFocusRipple: p=!1, endIcon: f, focusVisibleClassName: m, fullWidth: g=!1, size: v="medium", startIcon: y, type: b, variant: _="text"} = a
              , A = (0,
            it.A)(a, jI)
              , x = (0,
            rt.A)({}, a, {
                color: l,
                component: c,
                disabled: d,
                disableElevation: h,
                disableFocusRipple: p,
                fullWidth: g,
                size: v,
                type: b,
                variant: _
            })
              , S = (e => {
                const {color: t, disableElevation: n, fullWidth: r, size: i, variant: o, classes: a} = e
                  , s = {
                    root: ["root", o, `${o}${(0,
                    Tt.A)(t)}`, `size${(0,
                    Tt.A)(i)}`, `${o}Size${(0,
                    Tt.A)(i)}`, `color${(0,
                    Tt.A)(t)}`, n && "disableElevation", r && "fullWidth"],
                    label: ["label"],
                    startIcon: ["icon", "startIcon", `iconSize${(0,
                    Tt.A)(i)}`],
                    endIcon: ["icon", "endIcon", `iconSize${(0,
                    Tt.A)(i)}`]
                }
                  , l = (0,
                Et.A)(s, UI, a);
                return (0,
                rt.A)({}, a, l)
            }
            )(x)
              , w = y && (0,
            mt.jsx)(XI, {
                className: S.startIcon,
                ownerState: x,
                children: y
            })
              , E = f && (0,
            mt.jsx)(JI, {
                className: S.endIcon,
                ownerState: x,
                children: f
            })
              , M = i || "";
            return (0,
            mt.jsxs)(VI, (0,
            rt.A)({
                ownerState: x,
                className: (0,
                wt.A)(r.className, S.root, u, M),
                component: c,
                disabled: d,
                focusRipple: !p,
                focusVisibleClassName: (0,
                wt.A)(S.focusVisible, m),
                ref: n,
                type: b
            }, A, {
                classes: S,
                children: [w, s, E]
            }))
        }
        ));
        function qI(e) {
            return (0,
            Bt.Ay)("MuiDialogContent", e)
        }
        (0,
        _t.A)("MuiDialogContent", ["root", "dividers"]);
        const YI = (0,
        _t.A)("MuiDialogTitle", ["root"])
          , QI = ["className", "dividers"]
          , ZI = (0,
        Mt.Ay)("div", {
            name: "MuiDialogContent",
            slot: "Root",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.root, n.dividers && t.dividers]
            }
        })((e => {
            let {theme: t, ownerState: n} = e;
            return (0,
            rt.A)({
                flex: "1 1 auto",
                WebkitOverflowScrolling: "touch",
                overflowY: "auto",
                padding: "20px 24px"
            }, n.dividers ? {
                padding: "16px 24px",
                borderTop: `1px solid ${(t.vars || t).palette.divider}`,
                borderBottom: `1px solid ${(t.vars || t).palette.divider}`
            } : {
                [`.${YI.root} + &`]: {
                    paddingTop: 0
                }
            })
        }
        ))
          , $I = t.forwardRef((function(e, t) {
            const n = (0,
            Ct.b)({
                props: e,
                name: "MuiDialogContent"
            })
              , {className: r, dividers: i=!1} = n
              , o = (0,
            it.A)(n, QI)
              , a = (0,
            rt.A)({}, n, {
                dividers: i
            })
              , s = (e => {
                const {classes: t, dividers: n} = e
                  , r = {
                    root: ["root", n && "dividers"]
                };
                return (0,
                Et.A)(r, qI, t)
            }
            )(a);
            return (0,
            mt.jsx)(ZI, (0,
            rt.A)({
                className: (0,
                wt.A)(s.root, r),
                ownerState: a,
                ref: t
            }, o))
        }
        ));
        var eL = __webpack_require__(5501);
        function tL(e) {
            let {props: t, name: n, defaultTheme: r, themeId: i} = e
              , o = ft(r);
            i && (o = o[i] || o);
            const a = function(e) {
                const {theme: t, name: n, props: r} = e;
                return t && t.components && t.components[n] && t.components[n].defaultProps ? (0,
                lI.A)(t.components[n].defaultProps, r) : r
            }({
                theme: o,
                name: n,
                props: t
            });
            return a
        }
        var nL = __webpack_require__(7483);
        const rL = ["ownerState"]
          , iL = ["variants"]
          , oL = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
        function aL(e) {
            return "ownerState" !== e && "theme" !== e && "sx" !== e && "as" !== e
        }
        const sL = (0,
        ut.A)()
          , lL = e => e ? e.charAt(0).toLowerCase() + e.slice(1) : e;
        function cL(e) {
            let {defaultTheme: t, theme: n, themeId: r} = e;
            return i = n,
            0 === Object.keys(i).length ? t : n[r] || n;
            var i
        }
        function uL(e) {
            return e ? (t, n) => n[e] : null
        }
        function dL(e, t) {
            let {ownerState: n} = t
              , r = (0,
            it.A)(t, rL);
            const i = "function" === typeof e ? e((0,
            rt.A)({
                ownerState: n
            }, r)) : e;
            if (Array.isArray(i))
                return i.flatMap((e => dL(e, (0,
                rt.A)({
                    ownerState: n
                }, r))));
            if (i && "object" === typeof i && Array.isArray(i.variants)) {
                const {variants: e=[]} = i;
                let t = (0,
                it.A)(i, iL);
                return e.forEach((e => {
                    let i = !0;
                    "function" === typeof e.props ? i = e.props((0,
                    rt.A)({
                        ownerState: n
                    }, r, n)) : Object.keys(e.props).forEach((t => {
                        (null == n ? void 0 : n[t]) !== e.props[t] && r[t] !== e.props[t] && (i = !1)
                    }
                    )),
                    i && (Array.isArray(t) || (t = [t]),
                    t.push("function" === typeof e.style ? e.style((0,
                    rt.A)({
                        ownerState: n
                    }, r, n)) : e.style))
                }
                )),
                t
            }
            return i
        }
        const hL = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const {themeId: t, defaultTheme: n=sL, rootShouldForwardProp: r=aL, slotShouldForwardProp: i=aL} = e
              , o = e => (0,
            lt.A)((0,
            rt.A)({}, e, {
                theme: cL((0,
                rt.A)({}, e, {
                    defaultTheme: n,
                    themeId: t
                }))
            }));
            return o.__mui_systemSx = !0,
            function(e) {
                let a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                (0,
                st.internal_processStyles)(e, (e => e.filter((e => !(null != e && e.__mui_systemSx)))));
                const {name: s, slot: l, skipVariantsResolver: c, skipSx: u, overridesResolver: d=uL(lL(l))} = a
                  , h = (0,
                it.A)(a, oL)
                  , p = void 0 !== c ? c : l && "Root" !== l && "root" !== l || !1
                  , f = u || !1;
                let m = aL;
                "Root" === l || "root" === l ? m = r : l ? m = i : function(e) {
                    return "string" === typeof e && e.charCodeAt(0) > 96
                }(e) && (m = void 0);
                const g = (0,
                st.default)(e, (0,
                rt.A)({
                    shouldForwardProp: m,
                    label: undefined
                }, h))
                  , v = e => "function" === typeof e && e.__emotion_real !== e || (0,
                nL.Q)(e) ? r => dL(e, (0,
                rt.A)({}, r, {
                    theme: cL({
                        theme: r.theme,
                        defaultTheme: n,
                        themeId: t
                    })
                })) : e
                  , y = function(r) {
                    let i = v(r);
                    for (var a = arguments.length, l = new Array(a > 1 ? a - 1 : 0), c = 1; c < a; c++)
                        l[c - 1] = arguments[c];
                    const u = l ? l.map(v) : [];
                    s && d && u.push((e => {
                        const r = cL((0,
                        rt.A)({}, e, {
                            defaultTheme: n,
                            themeId: t
                        }));
                        if (!r.components || !r.components[s] || !r.components[s].styleOverrides)
                            return null;
                        const i = r.components[s].styleOverrides
                          , o = {};
                        return Object.entries(i).forEach((t => {
                            let[n,i] = t;
                            o[n] = dL(i, (0,
                            rt.A)({}, e, {
                                theme: r
                            }))
                        }
                        )),
                        d(e, o)
                    }
                    )),
                    s && !p && u.push((e => {
                        var r;
                        const i = cL((0,
                        rt.A)({}, e, {
                            defaultTheme: n,
                            themeId: t
                        }));
                        return dL({
                            variants: null == i || null == (r = i.components) || null == (r = r[s]) ? void 0 : r.variants
                        }, (0,
                        rt.A)({}, e, {
                            theme: i
                        }))
                    }
                    )),
                    f || u.push(o);
                    const h = u.length - l.length;
                    if (Array.isArray(r) && h > 0) {
                        const e = new Array(h).fill("");
                        i = [...r, ...e],
                        i.raw = [...r.raw, ...e]
                    }
                    const m = g(i, ...u);
                    return e.muiName && (m.muiName = e.muiName),
                    m
                };
                return g.withConfig && (y.withConfig = g.withConfig),
                y
            }
        }()
          , pL = ["className", "component", "disableGutters", "fixed", "maxWidth", "classes"]
          , fL = (0,
        ut.A)()
          , mL = hL("div", {
            name: "MuiContainer",
            slot: "Root",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.root, t[`maxWidth${(0,
                eL.A)(String(n.maxWidth))}`], n.fixed && t.fixed, n.disableGutters && t.disableGutters]
            }
        })
          , gL = e => tL({
            props: e,
            name: "MuiContainer",
            defaultTheme: fL
        });
        const vL = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const {createStyledComponent: n=mL, useThemeProps: r=gL, componentName: i="MuiContainer"} = e
              , o = n((e => {
                let {theme: t, ownerState: n} = e;
                return (0,
                rt.A)({
                    width: "100%",
                    marginLeft: "auto",
                    boxSizing: "border-box",
                    marginRight: "auto",
                    display: "block"
                }, !n.disableGutters && {
                    paddingLeft: t.spacing(2),
                    paddingRight: t.spacing(2),
                    [t.breakpoints.up("sm")]: {
                        paddingLeft: t.spacing(3),
                        paddingRight: t.spacing(3)
                    }
                })
            }
            ), (e => {
                let {theme: t, ownerState: n} = e;
                return n.fixed && Object.keys(t.breakpoints.values).reduce(( (e, n) => {
                    const r = n
                      , i = t.breakpoints.values[r];
                    return 0 !== i && (e[t.breakpoints.up(r)] = {
                        maxWidth: `${i}${t.breakpoints.unit}`
                    }),
                    e
                }
                ), {})
            }
            ), (e => {
                let {theme: t, ownerState: n} = e;
                return (0,
                rt.A)({}, "xs" === n.maxWidth && {
                    [t.breakpoints.up("xs")]: {
                        maxWidth: Math.max(t.breakpoints.values.xs, 444)
                    }
                }, n.maxWidth && "xs" !== n.maxWidth && {
                    [t.breakpoints.up(n.maxWidth)]: {
                        maxWidth: `${t.breakpoints.values[n.maxWidth]}${t.breakpoints.unit}`
                    }
                })
            }
            ));
            return t.forwardRef((function(e, t) {
                const n = r(e)
                  , {className: a, component: s="div", disableGutters: l=!1, fixed: c=!1, maxWidth: u="lg"} = n
                  , d = (0,
                it.A)(n, pL)
                  , h = (0,
                rt.A)({}, n, {
                    component: s,
                    disableGutters: l,
                    fixed: c,
                    maxWidth: u
                })
                  , p = ( (e, t) => {
                    const {classes: n, fixed: r, disableGutters: i, maxWidth: o} = e
                      , a = {
                        root: ["root", o && `maxWidth${(0,
                        eL.A)(String(o))}`, r && "fixed", i && "disableGutters"]
                    };
                    return (0,
                    Et.A)(a, (e => (0,
                    Bt.Ay)(t, e)), n)
                }
                )(h, i);
                return (0,
                mt.jsx)(o, (0,
                rt.A)({
                    as: s,
                    ownerState: h,
                    className: at(p.root, a),
                    ref: t
                }, d))
            }
            ))
        }({
            createStyledComponent: (0,
            Mt.Ay)("div", {
                name: "MuiContainer",
                slot: "Root",
                overridesResolver: (e, t) => {
                    const {ownerState: n} = e;
                    return [t.root, t[`maxWidth${(0,
                    Tt.A)(String(n.maxWidth))}`], n.fixed && t.fixed, n.disableGutters && t.disableGutters]
                }
            }),
            useThemeProps: e => (0,
            Ct.b)({
                props: e,
                name: "MuiContainer"
            })
        });
        var yL = __webpack_require__(8286);
        const bL = t.createContext();
        function _L(e) {
            return (0,
            Bt.Ay)("MuiGrid", e)
        }
        const AL = ["auto", !0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
          , xL = (0,
        _t.A)("MuiGrid", ["root", "container", "item", "zeroMinWidth", ...[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((e => `spacing-xs-${e}`)), ...["column-reverse", "column", "row-reverse", "row"].map((e => `direction-xs-${e}`)), ...["nowrap", "wrap-reverse", "wrap"].map((e => `wrap-xs-${e}`)), ...AL.map((e => `grid-xs-${e}`)), ...AL.map((e => `grid-sm-${e}`)), ...AL.map((e => `grid-md-${e}`)), ...AL.map((e => `grid-lg-${e}`)), ...AL.map((e => `grid-xl-${e}`))])
          , SL = ["className", "columns", "columnSpacing", "component", "container", "direction", "item", "rowSpacing", "spacing", "wrap", "zeroMinWidth"];
        function wL(e) {
            const t = parseFloat(e);
            return `${t}${String(e).replace(String(t), "") || "px"}`
        }
        function EL(e) {
            let {breakpoints: t, values: n} = e
              , r = "";
            Object.keys(n).forEach((e => {
                "" === r && 0 !== n[e] && (r = e)
            }
            ));
            const i = Object.keys(t).sort(( (e, n) => t[e] - t[n]));
            return i.slice(0, i.indexOf(r))
        }
        const ML = (0,
        Mt.Ay)("div", {
            name: "MuiGrid",
            slot: "Root",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e
                  , {container: r, direction: i, item: o, spacing: a, wrap: s, zeroMinWidth: l, breakpoints: c} = n;
                let u = [];
                r && (u = function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    if (!e || e <= 0)
                        return [];
                    if ("string" === typeof e && !Number.isNaN(Number(e)) || "number" === typeof e)
                        return [n[`spacing-xs-${String(e)}`]];
                    const r = [];
                    return t.forEach((t => {
                        const i = e[t];
                        Number(i) > 0 && r.push(n[`spacing-${t}-${String(i)}`])
                    }
                    )),
                    r
                }(a, c, t));
                const d = [];
                return c.forEach((e => {
                    const r = n[e];
                    r && d.push(t[`grid-${e}-${String(r)}`])
                }
                )),
                [t.root, r && t.container, o && t.item, l && t.zeroMinWidth, ...u, "row" !== i && t[`direction-xs-${String(i)}`], "wrap" !== s && t[`wrap-xs-${String(s)}`], ...d]
            }
        })((e => {
            let {ownerState: t} = e;
            return (0,
            rt.A)({
                boxSizing: "border-box"
            }, t.container && {
                display: "flex",
                flexWrap: "wrap",
                width: "100%"
            }, t.item && {
                margin: 0
            }, t.zeroMinWidth && {
                minWidth: 0
            }, "wrap" !== t.wrap && {
                flexWrap: t.wrap
            })
        }
        ), (function(e) {
            let {theme: t, ownerState: n} = e;
            const r = (0,
            yL.kW)({
                values: n.direction,
                breakpoints: t.breakpoints.values
            });
            return (0,
            yL.NI)({
                theme: t
            }, r, (e => {
                const t = {
                    flexDirection: e
                };
                return 0 === e.indexOf("column") && (t[`& > .${xL.item}`] = {
                    maxWidth: "none"
                }),
                t
            }
            ))
        }
        ), (function(e) {
            let {theme: t, ownerState: n} = e;
            const {container: r, rowSpacing: i} = n;
            let o = {};
            if (r && 0 !== i) {
                const e = (0,
                yL.kW)({
                    values: i,
                    breakpoints: t.breakpoints.values
                });
                let n;
                "object" === typeof e && (n = EL({
                    breakpoints: t.breakpoints.values,
                    values: e
                })),
                o = (0,
                yL.NI)({
                    theme: t
                }, e, ( (e, r) => {
                    var i;
                    const o = t.spacing(e);
                    return "0px" !== o ? {
                        marginTop: `-${wL(o)}`,
                        [`& > .${xL.item}`]: {
                            paddingTop: wL(o)
                        }
                    } : null != (i = n) && i.includes(r) ? {} : {
                        marginTop: 0,
                        [`& > .${xL.item}`]: {
                            paddingTop: 0
                        }
                    }
                }
                ))
            }
            return o
        }
        ), (function(e) {
            let {theme: t, ownerState: n} = e;
            const {container: r, columnSpacing: i} = n;
            let o = {};
            if (r && 0 !== i) {
                const e = (0,
                yL.kW)({
                    values: i,
                    breakpoints: t.breakpoints.values
                });
                let n;
                "object" === typeof e && (n = EL({
                    breakpoints: t.breakpoints.values,
                    values: e
                })),
                o = (0,
                yL.NI)({
                    theme: t
                }, e, ( (e, r) => {
                    var i;
                    const o = t.spacing(e);
                    return "0px" !== o ? {
                        width: `calc(100% + ${wL(o)})`,
                        marginLeft: `-${wL(o)}`,
                        [`& > .${xL.item}`]: {
                            paddingLeft: wL(o)
                        }
                    } : null != (i = n) && i.includes(r) ? {} : {
                        width: "100%",
                        marginLeft: 0,
                        [`& > .${xL.item}`]: {
                            paddingLeft: 0
                        }
                    }
                }
                ))
            }
            return o
        }
        ), (function(e) {
            let t, {theme: n, ownerState: r} = e;
            return n.breakpoints.keys.reduce(( (e, i) => {
                let o = {};
                if (r[i] && (t = r[i]),
                !t)
                    return e;
                if (!0 === t)
                    o = {
                        flexBasis: 0,
                        flexGrow: 1,
                        maxWidth: "100%"
                    };
                else if ("auto" === t)
                    o = {
                        flexBasis: "auto",
                        flexGrow: 0,
                        flexShrink: 0,
                        maxWidth: "none",
                        width: "auto"
                    };
                else {
                    const a = (0,
                    yL.kW)({
                        values: r.columns,
                        breakpoints: n.breakpoints.values
                    })
                      , s = "object" === typeof a ? a[i] : a;
                    if (void 0 === s || null === s)
                        return e;
                    const l = Math.round(t / s * 1e8) / 1e6 + "%";
                    let c = {};
                    if (r.container && r.item && 0 !== r.columnSpacing) {
                        const e = n.spacing(r.columnSpacing);
                        if ("0px" !== e) {
                            const t = `calc(${l} + ${wL(e)})`;
                            c = {
                                flexBasis: t,
                                maxWidth: t
                            }
                        }
                    }
                    o = (0,
                    rt.A)({
                        flexBasis: l,
                        flexGrow: 0,
                        maxWidth: l
                    }, c)
                }
                return 0 === n.breakpoints.values[i] ? Object.assign(e, o) : e[n.breakpoints.up(i)] = o,
                e
            }
            ), {})
        }
        ));
        const CL = e => {
            const {classes: t, container: n, direction: r, item: i, spacing: o, wrap: a, zeroMinWidth: s, breakpoints: l} = e;
            let c = [];
            n && (c = function(e, t) {
                if (!e || e <= 0)
                    return [];
                if ("string" === typeof e && !Number.isNaN(Number(e)) || "number" === typeof e)
                    return [`spacing-xs-${String(e)}`];
                const n = [];
                return t.forEach((t => {
                    const r = e[t];
                    if (Number(r) > 0) {
                        const e = `spacing-${t}-${String(r)}`;
                        n.push(e)
                    }
                }
                )),
                n
            }(o, l));
            const u = [];
            l.forEach((t => {
                const n = e[t];
                n && u.push(`grid-${t}-${String(n)}`)
            }
            ));
            const d = {
                root: ["root", n && "container", i && "item", s && "zeroMinWidth", ...c, "row" !== r && `direction-xs-${String(r)}`, "wrap" !== a && `wrap-xs-${String(a)}`, ...u]
            };
            return (0,
            Et.A)(d, _L, t)
        }
        ;
        const TL = t.forwardRef((function(e, n) {
            const r = (0,
            Ct.b)({
                props: e,
                name: "MuiGrid"
            })
              , {breakpoints: i} = CB()
              , o = (0,
            ct.A)(r)
              , {className: a, columns: s, columnSpacing: l, component: c="div", container: u=!1, direction: d="row", item: h=!1, rowSpacing: p, spacing: f=0, wrap: m="wrap", zeroMinWidth: g=!1} = o
              , v = (0,
            it.A)(o, SL)
              , y = p || f
              , b = l || f
              , _ = t.useContext(bL)
              , A = u ? s || 12 : _
              , x = {}
              , S = (0,
            rt.A)({}, v);
            i.keys.forEach((e => {
                null != v[e] && (x[e] = v[e],
                delete S[e])
            }
            ));
            const w = (0,
            rt.A)({}, o, {
                columns: A,
                container: u,
                direction: d,
                item: h,
                rowSpacing: y,
                columnSpacing: b,
                wrap: m,
                zeroMinWidth: g,
                spacing: f
            }, x, {
                breakpoints: i.keys
            })
              , E = CL(w);
            return (0,
            mt.jsx)(bL.Provider, {
                value: A,
                children: (0,
                mt.jsx)(ML, (0,
                rt.A)({
                    ownerState: w,
                    className: (0,
                    wt.A)(E.root, a),
                    as: c,
                    ref: n
                }, S))
            })
        }
        ));
        __webpack_require__(6429);
        const RL = ["value"]
          , PL = t.createContext();
        const BL = () => {
            const e = t.useContext(PL);
            return null != e && e
        }
          , IL = function(e) {
            let {value: t} = e
              , n = (0,
            it.A)(e, RL);
            return (0,
            mt.jsx)(PL.Provider, (0,
            rt.A)({
                value: null == t || t
            }, n))
        };
        var LL = __webpack_require__(1380);
        let kL;
        function DL() {
            if (kL)
                return kL;
            const e = document.createElement("div")
              , t = document.createElement("div");
            return t.style.width = "10px",
            t.style.height = "1px",
            e.appendChild(t),
            e.dir = "rtl",
            e.style.fontSize = "14px",
            e.style.width = "4px",
            e.style.height = "1px",
            e.style.position = "absolute",
            e.style.top = "-1000px",
            e.style.overflow = "scroll",
            document.body.appendChild(e),
            kL = "reverse",
            e.scrollLeft > 0 ? kL = "default" : (e.scrollLeft = 1,
            0 === e.scrollLeft && (kL = "negative")),
            document.body.removeChild(e),
            kL
        }
        function OL(e, t) {
            const n = e.scrollLeft;
            if ("rtl" !== t)
                return n;
            switch (DL()) {
            case "negative":
                return e.scrollWidth - e.clientWidth + n;
            case "reverse":
                return e.scrollWidth - e.clientWidth - n;
            default:
                return n
            }
        }
        function NL(e) {
            return (1 + Math.sin(Math.PI * e - Math.PI / 2)) / 2
        }
        var FL = __webpack_require__(9044)
          , UL = __webpack_require__(827);
        const zL = ["onChange"]
          , GL = {
            width: 99,
            height: 99,
            position: "absolute",
            top: -9999,
            overflow: "scroll"
        };
        var HL = __webpack_require__(3235);
        const jL = (0,
        HL.A)((0,
        mt.jsx)("path", {
            d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
        }), "KeyboardArrowLeft")
          , WL = (0,
        HL.A)((0,
        mt.jsx)("path", {
            d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
        }), "KeyboardArrowRight");
        function VL(e) {
            return (0,
            Bt.Ay)("MuiTabScrollButton", e)
        }
        const XL = (0,
        _t.A)("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"])
          , JL = ["className", "slots", "slotProps", "direction", "orientation", "disabled"]
          , KL = (0,
        Mt.Ay)(FI, {
            name: "MuiTabScrollButton",
            slot: "Root",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.root, n.orientation && t[n.orientation]]
            }
        })((e => {
            let {ownerState: t} = e;
            return (0,
            rt.A)({
                width: 40,
                flexShrink: 0,
                opacity: .8,
                [`&.${XL.disabled}`]: {
                    opacity: 0
                }
            }, "vertical" === t.orientation && {
                width: "100%",
                height: 40,
                "& svg": {
                    transform: `rotate(${t.isRtl ? -90 : 90}deg)`
                }
            })
        }
        ))
          , qL = t.forwardRef((function(e, t) {
            var n, r;
            const i = (0,
            Ct.b)({
                props: e,
                name: "MuiTabScrollButton"
            })
              , {className: o, slots: a={}, slotProps: s={}, direction: l} = i
              , c = (0,
            it.A)(i, JL)
              , u = BL()
              , d = (0,
            rt.A)({
                isRtl: u
            }, i)
              , h = (e => {
                const {classes: t, orientation: n, disabled: r} = e
                  , i = {
                    root: ["root", n, r && "disabled"]
                };
                return (0,
                Et.A)(i, VL, t)
            }
            )(d)
              , p = null != (n = a.StartScrollButtonIcon) ? n : jL
              , f = null != (r = a.EndScrollButtonIcon) ? r : WL
              , m = iB({
                elementType: p,
                externalSlotProps: s.startScrollButtonIcon,
                additionalProps: {
                    fontSize: "small"
                },
                ownerState: d
            })
              , g = iB({
                elementType: f,
                externalSlotProps: s.endScrollButtonIcon,
                additionalProps: {
                    fontSize: "small"
                },
                ownerState: d
            });
            return (0,
            mt.jsx)(KL, (0,
            rt.A)({
                component: "div",
                className: (0,
                wt.A)(h.root, o),
                ref: t,
                role: null,
                ownerState: d,
                tabIndex: null
            }, c, {
                children: "left" === l ? (0,
                mt.jsx)(p, (0,
                rt.A)({}, m)) : (0,
                mt.jsx)(f, (0,
                rt.A)({}, g))
            }))
        }
        ));
        function YL(e) {
            return (0,
            Bt.Ay)("MuiTabs", e)
        }
        const QL = (0,
        _t.A)("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]);
        var ZL = __webpack_require__(7402);
        const $L = ["aria-label", "aria-labelledby", "action", "centered", "children", "className", "component", "allowScrollButtonsMobile", "indicatorColor", "onChange", "orientation", "ScrollButtonComponent", "scrollButtons", "selectionFollowsFocus", "slots", "slotProps", "TabIndicatorProps", "TabScrollButtonProps", "textColor", "value", "variant", "visibleScrollbar"]
          , ek = (e, t) => e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : e.firstChild
          , tk = (e, t) => e === t ? e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : e.lastChild
          , nk = (e, t, n) => {
            let r = !1
              , i = n(e, t);
            for (; i; ) {
                if (i === e.firstChild) {
                    if (r)
                        return;
                    r = !0
                }
                const t = i.disabled || "true" === i.getAttribute("aria-disabled");
                if (i.hasAttribute("tabindex") && !t)
                    return void i.focus();
                i = n(e, i)
            }
        }
          , rk = (0,
        Mt.Ay)("div", {
            name: "MuiTabs",
            slot: "Root",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [{
                    [`& .${QL.scrollButtons}`]: t.scrollButtons
                }, {
                    [`& .${QL.scrollButtons}`]: n.scrollButtonsHideMobile && t.scrollButtonsHideMobile
                }, t.root, n.vertical && t.vertical]
            }
        })((e => {
            let {ownerState: t, theme: n} = e;
            return (0,
            rt.A)({
                overflow: "hidden",
                minHeight: 48,
                WebkitOverflowScrolling: "touch",
                display: "flex"
            }, t.vertical && {
                flexDirection: "column"
            }, t.scrollButtonsHideMobile && {
                [`& .${QL.scrollButtons}`]: {
                    [n.breakpoints.down("sm")]: {
                        display: "none"
                    }
                }
            })
        }
        ))
          , ik = (0,
        Mt.Ay)("div", {
            name: "MuiTabs",
            slot: "Scroller",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.scroller, n.fixed && t.fixed, n.hideScrollbar && t.hideScrollbar, n.scrollableX && t.scrollableX, n.scrollableY && t.scrollableY]
            }
        })((e => {
            let {ownerState: t} = e;
            return (0,
            rt.A)({
                position: "relative",
                display: "inline-block",
                flex: "1 1 auto",
                whiteSpace: "nowrap"
            }, t.fixed && {
                overflowX: "hidden",
                width: "100%"
            }, t.hideScrollbar && {
                scrollbarWidth: "none",
                "&::-webkit-scrollbar": {
                    display: "none"
                }
            }, t.scrollableX && {
                overflowX: "auto",
                overflowY: "hidden"
            }, t.scrollableY && {
                overflowY: "auto",
                overflowX: "hidden"
            })
        }
        ))
          , ok = (0,
        Mt.Ay)("div", {
            name: "MuiTabs",
            slot: "FlexContainer",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.flexContainer, n.vertical && t.flexContainerVertical, n.centered && t.centered]
            }
        })((e => {
            let {ownerState: t} = e;
            return (0,
            rt.A)({
                display: "flex"
            }, t.vertical && {
                flexDirection: "column"
            }, t.centered && {
                justifyContent: "center"
            })
        }
        ))
          , ak = (0,
        Mt.Ay)("span", {
            name: "MuiTabs",
            slot: "Indicator",
            overridesResolver: (e, t) => t.indicator
        })((e => {
            let {ownerState: t, theme: n} = e;
            return (0,
            rt.A)({
                position: "absolute",
                height: 2,
                bottom: 0,
                width: "100%",
                transition: n.transitions.create()
            }, "primary" === t.indicatorColor && {
                backgroundColor: (n.vars || n).palette.primary.main
            }, "secondary" === t.indicatorColor && {
                backgroundColor: (n.vars || n).palette.secondary.main
            }, t.vertical && {
                height: "100%",
                width: 2,
                right: 0
            })
        }
        ))
          , sk = (0,
        Mt.Ay)((function(e) {
            const {onChange: n} = e
              , r = (0,
            it.A)(e, zL)
              , i = t.useRef()
              , o = t.useRef(null)
              , a = () => {
                i.current = o.current.offsetHeight - o.current.clientHeight
            }
            ;
            return (0,
            FL.A)(( () => {
                const e = (0,
                LL.A)(( () => {
                    const e = i.current;
                    a(),
                    e !== i.current && n(i.current)
                }
                ))
                  , t = (0,
                UL.A)(o.current);
                return t.addEventListener("resize", e),
                () => {
                    e.clear(),
                    t.removeEventListener("resize", e)
                }
            }
            ), [n]),
            t.useEffect(( () => {
                a(),
                n(i.current)
            }
            ), [n]),
            (0,
            mt.jsx)("div", (0,
            rt.A)({
                style: GL,
                ref: o
            }, r))
        }
        ))({
            overflowX: "auto",
            overflowY: "hidden",
            scrollbarWidth: "none",
            "&::-webkit-scrollbar": {
                display: "none"
            }
        })
          , lk = {};
        const ck = t.forwardRef((function(e, n) {
            const r = (0,
            Ct.b)({
                props: e,
                name: "MuiTabs"
            })
              , i = CB()
              , o = BL()
              , {"aria-label": a, "aria-labelledby": s, action: l, centered: c=!1, children: u, className: d, component: h="div", allowScrollButtonsMobile: p=!1, indicatorColor: f="primary", onChange: m, orientation: g="horizontal", ScrollButtonComponent: v=qL, scrollButtons: y="auto", selectionFollowsFocus: b, slots: _={}, slotProps: A={}, TabIndicatorProps: x={}, TabScrollButtonProps: S={}, textColor: w="primary", value: E, variant: M="standard", visibleScrollbar: C=!1} = r
              , T = (0,
            it.A)(r, $L)
              , R = "scrollable" === M
              , P = "vertical" === g
              , B = P ? "scrollTop" : "scrollLeft"
              , I = P ? "top" : "left"
              , L = P ? "bottom" : "right"
              , k = P ? "clientHeight" : "clientWidth"
              , D = P ? "height" : "width"
              , O = (0,
            rt.A)({}, r, {
                component: h,
                allowScrollButtonsMobile: p,
                indicatorColor: f,
                orientation: g,
                vertical: P,
                scrollButtons: y,
                textColor: w,
                variant: M,
                visibleScrollbar: C,
                fixed: !R,
                hideScrollbar: R && !C,
                scrollableX: R && !P,
                scrollableY: R && P,
                centered: c && !R,
                scrollButtonsHideMobile: !p
            })
              , N = (e => {
                const {vertical: t, fixed: n, hideScrollbar: r, scrollableX: i, scrollableY: o, centered: a, scrollButtonsHideMobile: s, classes: l} = e
                  , c = {
                    root: ["root", t && "vertical"],
                    scroller: ["scroller", n && "fixed", r && "hideScrollbar", i && "scrollableX", o && "scrollableY"],
                    flexContainer: ["flexContainer", t && "flexContainerVertical", a && "centered"],
                    indicator: ["indicator"],
                    scrollButtons: ["scrollButtons", s && "scrollButtonsHideMobile"],
                    scrollableX: [i && "scrollableX"],
                    hideScrollbar: [r && "hideScrollbar"]
                };
                return (0,
                Et.A)(c, YL, l)
            }
            )(O)
              , F = iB({
                elementType: _.StartScrollButtonIcon,
                externalSlotProps: A.startScrollButtonIcon,
                ownerState: O
            })
              , U = iB({
                elementType: _.EndScrollButtonIcon,
                externalSlotProps: A.endScrollButtonIcon,
                ownerState: O
            });
            const [z,G] = t.useState(!1)
              , [H,j] = t.useState(lk)
              , [W,V] = t.useState(!1)
              , [X,J] = t.useState(!1)
              , [K,q] = t.useState(!1)
              , [Y,Q] = t.useState({
                overflow: "hidden",
                scrollbarWidth: 0
            })
              , Z = new Map
              , $ = t.useRef(null)
              , ee = t.useRef(null)
              , te = () => {
                const e = $.current;
                let t, n;
                if (e) {
                    const n = e.getBoundingClientRect();
                    t = {
                        clientWidth: e.clientWidth,
                        scrollLeft: e.scrollLeft,
                        scrollTop: e.scrollTop,
                        scrollLeftNormalized: OL(e, o ? "rtl" : "ltr"),
                        scrollWidth: e.scrollWidth,
                        top: n.top,
                        bottom: n.bottom,
                        left: n.left,
                        right: n.right
                    }
                }
                if (e && !1 !== E) {
                    const e = ee.current.children;
                    if (e.length > 0) {
                        const t = e[Z.get(E)];
                        0,
                        n = t ? t.getBoundingClientRect() : null
                    }
                }
                return {
                    tabsMeta: t,
                    tabMeta: n
                }
            }
              , ne = (0,
            uI.A)(( () => {
                const {tabsMeta: e, tabMeta: t} = te();
                let n, r = 0;
                if (P)
                    n = "top",
                    t && e && (r = t.top - e.top + e.scrollTop);
                else if (n = o ? "right" : "left",
                t && e) {
                    const i = o ? e.scrollLeftNormalized + e.clientWidth - e.scrollWidth : e.scrollLeft;
                    r = (o ? -1 : 1) * (t[n] - e[n] + i)
                }
                const i = {
                    [n]: r,
                    [D]: t ? t[D] : 0
                };
                if (isNaN(H[n]) || isNaN(H[D]))
                    j(i);
                else {
                    const e = Math.abs(H[n] - i[n])
                      , t = Math.abs(H[D] - i[D]);
                    (e >= 1 || t >= 1) && j(i)
                }
            }
            ))
              , re = function(e) {
                let {animation: t=!0} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                t ? function(e, t, n) {
                    let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}
                      , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : () => {}
                    ;
                    const {ease: o=NL, duration: a=300} = r;
                    let s = null;
                    const l = t[e];
                    let c = !1;
                    const u = () => {
                        c = !0
                    }
                      , d = r => {
                        if (c)
                            return void i(new Error("Animation cancelled"));
                        null === s && (s = r);
                        const u = Math.min(1, (r - s) / a);
                        t[e] = o(u) * (n - l) + l,
                        u >= 1 ? requestAnimationFrame(( () => {
                            i(null)
                        }
                        )) : requestAnimationFrame(d)
                    }
                    ;
                    l === n ? i(new Error("Element already at target position")) : requestAnimationFrame(d)
                }(B, $.current, e, {
                    duration: i.transitions.duration.standard
                }) : $.current[B] = e
            }
              , ie = e => {
                let t = $.current[B];
                P ? t += e : (t += e * (o ? -1 : 1),
                t *= o && "reverse" === DL() ? -1 : 1),
                re(t)
            }
              , oe = () => {
                const e = $.current[k];
                let t = 0;
                const n = Array.from(ee.current.children);
                for (let r = 0; r < n.length; r += 1) {
                    const i = n[r];
                    if (t + i[k] > e) {
                        0 === r && (t = e);
                        break
                    }
                    t += i[k]
                }
                return t
            }
              , ae = () => {
                ie(-1 * oe())
            }
              , se = () => {
                ie(oe())
            }
              , le = t.useCallback((e => {
                Q({
                    overflow: null,
                    scrollbarWidth: e
                })
            }
            ), [])
              , ce = (0,
            uI.A)((e => {
                const {tabsMeta: t, tabMeta: n} = te();
                if (n && t)
                    if (n[I] < t[I]) {
                        const r = t[B] + (n[I] - t[I]);
                        re(r, {
                            animation: e
                        })
                    } else if (n[L] > t[L]) {
                        const r = t[B] + (n[L] - t[L]);
                        re(r, {
                            animation: e
                        })
                    }
            }
            ))
              , ue = (0,
            uI.A)(( () => {
                R && !1 !== y && q(!K)
            }
            ));
            t.useEffect(( () => {
                const e = (0,
                LL.A)(( () => {
                    $.current && ne()
                }
                ));
                let t;
                const n = n => {
                    n.forEach((e => {
                        e.removedNodes.forEach((e => {
                            var n;
                            null == (n = t) || n.unobserve(e)
                        }
                        )),
                        e.addedNodes.forEach((e => {
                            var n;
                            null == (n = t) || n.observe(e)
                        }
                        ))
                    }
                    )),
                    e(),
                    ue()
                }
                  , r = (0,
                UL.A)($.current);
                let i;
                return r.addEventListener("resize", e),
                "undefined" !== typeof ResizeObserver && (t = new ResizeObserver(e),
                Array.from(ee.current.children).forEach((e => {
                    t.observe(e)
                }
                ))),
                "undefined" !== typeof MutationObserver && (i = new MutationObserver(n),
                i.observe(ee.current, {
                    childList: !0
                })),
                () => {
                    var n, o;
                    e.clear(),
                    r.removeEventListener("resize", e),
                    null == (n = i) || n.disconnect(),
                    null == (o = t) || o.disconnect()
                }
            }
            ), [ne, ue]),
            t.useEffect(( () => {
                const e = Array.from(ee.current.children)
                  , t = e.length;
                if ("undefined" !== typeof IntersectionObserver && t > 0 && R && !1 !== y) {
                    const n = e[0]
                      , r = e[t - 1]
                      , i = {
                        root: $.current,
                        threshold: .99
                    }
                      , o = new IntersectionObserver((e => {
                        V(!e[0].isIntersecting)
                    }
                    ),i);
                    o.observe(n);
                    const a = new IntersectionObserver((e => {
                        J(!e[0].isIntersecting)
                    }
                    ),i);
                    return a.observe(r),
                    () => {
                        o.disconnect(),
                        a.disconnect()
                    }
                }
            }
            ), [R, y, K, null == u ? void 0 : u.length]),
            t.useEffect(( () => {
                G(!0)
            }
            ), []),
            t.useEffect(( () => {
                ne()
            }
            )),
            t.useEffect(( () => {
                ce(lk !== H)
            }
            ), [ce, H]),
            t.useImperativeHandle(l, ( () => ({
                updateIndicator: ne,
                updateScrollButtons: ue
            })), [ne, ue]);
            const de = (0,
            mt.jsx)(ak, (0,
            rt.A)({}, x, {
                className: (0,
                wt.A)(N.indicator, x.className),
                ownerState: O,
                style: (0,
                rt.A)({}, H, x.style)
            }));
            let he = 0;
            const pe = t.Children.map(u, (e => {
                if (!t.isValidElement(e))
                    return null;
                const n = void 0 === e.props.value ? he : e.props.value;
                Z.set(n, he);
                const r = n === E;
                return he += 1,
                t.cloneElement(e, (0,
                rt.A)({
                    fullWidth: "fullWidth" === M,
                    indicator: r && !z && de,
                    selected: r,
                    selectionFollowsFocus: b,
                    onChange: m,
                    textColor: w,
                    value: n
                }, 1 !== he || !1 !== E || e.props.tabIndex ? {} : {
                    tabIndex: 0
                }))
            }
            ))
              , fe = ( () => {
                const e = {};
                e.scrollbarSizeListener = R ? (0,
                mt.jsx)(sk, {
                    onChange: le,
                    className: (0,
                    wt.A)(N.scrollableX, N.hideScrollbar)
                }) : null;
                const t = R && ("auto" === y && (W || X) || !0 === y);
                return e.scrollButtonStart = t ? (0,
                mt.jsx)(v, (0,
                rt.A)({
                    slots: {
                        StartScrollButtonIcon: _.StartScrollButtonIcon
                    },
                    slotProps: {
                        startScrollButtonIcon: F
                    },
                    orientation: g,
                    direction: o ? "right" : "left",
                    onClick: ae,
                    disabled: !W
                }, S, {
                    className: (0,
                    wt.A)(N.scrollButtons, S.className)
                })) : null,
                e.scrollButtonEnd = t ? (0,
                mt.jsx)(v, (0,
                rt.A)({
                    slots: {
                        EndScrollButtonIcon: _.EndScrollButtonIcon
                    },
                    slotProps: {
                        endScrollButtonIcon: U
                    },
                    orientation: g,
                    direction: o ? "left" : "right",
                    onClick: se,
                    disabled: !X
                }, S, {
                    className: (0,
                    wt.A)(N.scrollButtons, S.className)
                })) : null,
                e
            }
            )();
            return (0,
            mt.jsxs)(rk, (0,
            rt.A)({
                className: (0,
                wt.A)(N.root, d),
                ownerState: O,
                ref: n,
                as: h
            }, T, {
                children: [fe.scrollButtonStart, fe.scrollbarSizeListener, (0,
                mt.jsxs)(ik, {
                    className: N.scroller,
                    ownerState: O,
                    style: {
                        overflow: Y.overflow,
                        [P ? "margin" + (o ? "Left" : "Right") : "marginBottom"]: C ? void 0 : -Y.scrollbarWidth
                    },
                    ref: $,
                    children: [(0,
                    mt.jsx)(ok, {
                        "aria-label": a,
                        "aria-labelledby": s,
                        "aria-orientation": "vertical" === g ? "vertical" : null,
                        className: N.flexContainer,
                        ownerState: O,
                        onKeyDown: e => {
                            const t = ee.current
                              , n = (0,
                            ZL.A)(t).activeElement;
                            if ("tab" !== n.getAttribute("role"))
                                return;
                            let r = "horizontal" === g ? "ArrowLeft" : "ArrowUp"
                              , i = "horizontal" === g ? "ArrowRight" : "ArrowDown";
                            switch ("horizontal" === g && o && (r = "ArrowRight",
                            i = "ArrowLeft"),
                            e.key) {
                            case r:
                                e.preventDefault(),
                                nk(t, n, tk);
                                break;
                            case i:
                                e.preventDefault(),
                                nk(t, n, ek);
                                break;
                            case "Home":
                                e.preventDefault(),
                                nk(t, null, ek);
                                break;
                            case "End":
                                e.preventDefault(),
                                nk(t, null, tk)
                            }
                        }
                        ,
                        ref: ee,
                        role: "tablist",
                        children: pe
                    }), z && de]
                }), fe.scrollButtonEnd]
            }))
        }
        ));
        function uk(e) {
            return (0,
            Bt.Ay)("MuiTab", e)
        }
        const dk = (0,
        _t.A)("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper"])
          , hk = ["className", "disabled", "disableFocusRipple", "fullWidth", "icon", "iconPosition", "indicator", "label", "onChange", "onClick", "onFocus", "selected", "selectionFollowsFocus", "textColor", "value", "wrapped"]
          , pk = (0,
        Mt.Ay)(FI, {
            name: "MuiTab",
            slot: "Root",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.root, n.label && n.icon && t.labelIcon, t[`textColor${(0,
                Tt.A)(n.textColor)}`], n.fullWidth && t.fullWidth, n.wrapped && t.wrapped, {
                    [`& .${dk.iconWrapper}`]: t.iconWrapper
                }]
            }
        })((e => {
            let {theme: t, ownerState: n} = e;
            return (0,
            rt.A)({}, t.typography.button, {
                maxWidth: 360,
                minWidth: 90,
                position: "relative",
                minHeight: 48,
                flexShrink: 0,
                padding: "12px 16px",
                overflow: "hidden",
                whiteSpace: "normal",
                textAlign: "center"
            }, n.label && {
                flexDirection: "top" === n.iconPosition || "bottom" === n.iconPosition ? "column" : "row"
            }, {
                lineHeight: 1.25
            }, n.icon && n.label && {
                minHeight: 72,
                paddingTop: 9,
                paddingBottom: 9,
                [`& > .${dk.iconWrapper}`]: (0,
                rt.A)({}, "top" === n.iconPosition && {
                    marginBottom: 6
                }, "bottom" === n.iconPosition && {
                    marginTop: 6
                }, "start" === n.iconPosition && {
                    marginRight: t.spacing(1)
                }, "end" === n.iconPosition && {
                    marginLeft: t.spacing(1)
                })
            }, "inherit" === n.textColor && {
                color: "inherit",
                opacity: .6,
                [`&.${dk.selected}`]: {
                    opacity: 1
                },
                [`&.${dk.disabled}`]: {
                    opacity: (t.vars || t).palette.action.disabledOpacity
                }
            }, "primary" === n.textColor && {
                color: (t.vars || t).palette.text.secondary,
                [`&.${dk.selected}`]: {
                    color: (t.vars || t).palette.primary.main
                },
                [`&.${dk.disabled}`]: {
                    color: (t.vars || t).palette.text.disabled
                }
            }, "secondary" === n.textColor && {
                color: (t.vars || t).palette.text.secondary,
                [`&.${dk.selected}`]: {
                    color: (t.vars || t).palette.secondary.main
                },
                [`&.${dk.disabled}`]: {
                    color: (t.vars || t).palette.text.disabled
                }
            }, n.fullWidth && {
                flexShrink: 1,
                flexGrow: 1,
                flexBasis: 0,
                maxWidth: "none"
            }, n.wrapped && {
                fontSize: t.typography.pxToRem(12)
            })
        }
        ))
          , fk = t.forwardRef((function(e, n) {
            const r = (0,
            Ct.b)({
                props: e,
                name: "MuiTab"
            })
              , {className: i, disabled: o=!1, disableFocusRipple: a=!1, fullWidth: s, icon: l, iconPosition: c="top", indicator: u, label: d, onChange: h, onClick: p, onFocus: f, selected: m, selectionFollowsFocus: g, textColor: v="inherit", value: y, wrapped: b=!1} = r
              , _ = (0,
            it.A)(r, hk)
              , A = (0,
            rt.A)({}, r, {
                disabled: o,
                disableFocusRipple: a,
                selected: m,
                icon: !!l,
                iconPosition: c,
                label: !!d,
                fullWidth: s,
                textColor: v,
                wrapped: b
            })
              , x = (e => {
                const {classes: t, textColor: n, fullWidth: r, wrapped: i, icon: o, label: a, selected: s, disabled: l} = e
                  , c = {
                    root: ["root", o && a && "labelIcon", `textColor${(0,
                    Tt.A)(n)}`, r && "fullWidth", i && "wrapped", s && "selected", l && "disabled"],
                    iconWrapper: ["iconWrapper"]
                };
                return (0,
                Et.A)(c, uk, t)
            }
            )(A)
              , S = l && d && t.isValidElement(l) ? t.cloneElement(l, {
                className: (0,
                wt.A)(x.iconWrapper, l.props.className)
            }) : l;
            return (0,
            mt.jsxs)(pk, (0,
            rt.A)({
                focusRipple: !a,
                className: (0,
                wt.A)(x.root, i),
                ref: n,
                role: "tab",
                "aria-selected": m,
                disabled: o,
                onClick: e => {
                    !m && h && h(e, y),
                    p && p(e)
                }
                ,
                onFocus: e => {
                    g && !m && h && h(e, y),
                    f && f(e)
                }
                ,
                ownerState: A,
                tabIndex: m ? 0 : -1
            }, _, {
                children: ["top" === c || "start" === c ? (0,
                mt.jsxs)(t.Fragment, {
                    children: [S, d]
                }) : (0,
                mt.jsxs)(t.Fragment, {
                    children: [d, S]
                }), u]
            }))
        }
        ));
        __webpack_require__(7413);
        Object.create(null);
        const mk = {};
        function gk() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                t[n] = arguments[n];
            _k(t[0]) && mk[t[0]] || (_k(t[0]) && (mk[t[0]] = new Date),
            function() {
                if (console && console.warn) {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                        t[n] = arguments[n];
                    _k(t[0]) && (t[0] = `react-i18next:: ${t[0]}`),
                    console.warn(...t)
                }
            }(...t))
        }
        const vk = (e, t) => () => {
            if (e.isInitialized)
                t();
            else {
                const n = () => {
                    setTimeout(( () => {
                        e.off("initialized", n)
                    }
                    ), 0),
                    t()
                }
                ;
                e.on("initialized", n)
            }
        }
          , yk = (e, t, n) => {
            e.loadNamespaces(t, vk(e, n))
        }
          , bk = (e, t, n, r) => {
            _k(n) && (n = [n]),
            n.forEach((t => {
                e.options.ns.indexOf(t) < 0 && e.options.ns.push(t)
            }
            )),
            e.loadLanguages(t, vk(e, r))
        }
          , _k = e => "string" === typeof e
          , Ak = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g
          , xk = {
            "&amp;": "&",
            "&#38;": "&",
            "&lt;": "<",
            "&#60;": "<",
            "&gt;": ">",
            "&#62;": ">",
            "&apos;": "'",
            "&#39;": "'",
            "&quot;": '"',
            "&#34;": '"',
            "&nbsp;": " ",
            "&#160;": " ",
            "&copy;": "\xa9",
            "&#169;": "\xa9",
            "&reg;": "\xae",
            "&#174;": "\xae",
            "&hellip;": "\u2026",
            "&#8230;": "\u2026",
            "&#x2F;": "/",
            "&#47;": "/"
        }
          , Sk = e => xk[e];
        let wk = {
            bindI18n: "languageChanged",
            bindI18nStore: "",
            transEmptyNodeValue: "",
            transSupportBasicHtmlNodes: !0,
            transWrapTextNodes: "",
            transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
            useSuspense: !0,
            unescape: e => e.replace(Ak, Sk)
        };
        let Ek;
        const Mk = {
            type: "3rdParty",
            init(e) {
                !function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    wk = {
                        ...wk,
                        ...e
                    }
                }(e.options.react),
                (e => {
                    Ek = e
                }
                )(e)
            }
        }
          , Ck = (0,
        t.createContext)();
        class Tk {
            constructor() {
                this.usedNamespaces = {}
            }
            addUsedNamespaces(e) {
                e.forEach((e => {
                    this.usedNamespaces[e] || (this.usedNamespaces[e] = !0)
                }
                ))
            }
            getUsedNamespaces = () => Object.keys(this.usedNamespaces)
        }
        const Rk = (e, t, n, r) => e.getFixedT(t, n, r)
          , Pk = function(e) {
            let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const {i18n: r} = n
              , {i18n: i, defaultNS: o} = (0,
            t.useContext)(Ck) || {}
              , a = r || i || Ek;
            if (a && !a.reportNamespaces && (a.reportNamespaces = new Tk),
            !a) {
                gk("You will need to pass in an i18next instance by using initReactI18next");
                const e = (e, t) => {
                    return _k(t) ? t : "object" === typeof (n = t) && null !== n && _k(t.defaultValue) ? t.defaultValue : Array.isArray(e) ? e[e.length - 1] : e;
                    var n
                }
                  , t = [e, {}, !1];
                return t.t = e,
                t.i18n = {},
                t.ready = !1,
                t
            }
            a.options.react && void 0 !== a.options.react.wait && gk("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
            const s = {
                ...wk,
                ...a.options.react,
                ...n
            }
              , {useSuspense: l, keyPrefix: c} = s;
            let u = e || o || a.options && a.options.defaultNS;
            u = _k(u) ? [u] : u || ["translation"],
            a.reportNamespaces.addUsedNamespaces && a.reportNamespaces.addUsedNamespaces(u);
            const d = (a.isInitialized || a.initializedStoreOnce) && u.every((e => function(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                return t.languages && t.languages.length ? void 0 !== t.options.ignoreJSONStructure ? t.hasLoadedNamespace(e, {
                    lng: n.lng,
                    precheck: (t, r) => {
                        if (n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && t.services.backendConnector.backend && t.isLanguageChangingTo && !r(t.isLanguageChangingTo, e))
                            return !1
                    }
                }) : function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    const r = t.languages[0]
                      , i = !!t.options && t.options.fallbackLng
                      , o = t.languages[t.languages.length - 1];
                    if ("cimode" === r.toLowerCase())
                        return !0;
                    const a = (e, n) => {
                        const r = t.services.backendConnector.state[`${e}|${n}`];
                        return -1 === r || 2 === r
                    }
                    ;
                    return !(n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && t.services.backendConnector.backend && t.isLanguageChangingTo && !a(t.isLanguageChangingTo, e)) && (!!t.hasResourceBundle(r, e) || !(t.services.backendConnector.backend && (!t.options.resources || t.options.partialBundledLanguages)) || !(!a(r, e) || i && !a(o, e)))
                }(e, t, n) : (gk("i18n.languages were undefined or empty", t.languages),
                !0)
            }(e, a, s)))
              , h = ( (e, n, r, i) => (0,
            t.useCallback)(Rk(e, n, r, i), [e, n, r, i]))(a, n.lng || null, "fallback" === s.nsMode ? u : u[0], c)
              , p = () => h
              , f = () => Rk(a, n.lng || null, "fallback" === s.nsMode ? u : u[0], c)
              , [m,g] = (0,
            t.useState)(p);
            let v = u.join();
            n.lng && (v = `${n.lng}${v}`);
            const y = ( (e, n) => {
                const r = (0,
                t.useRef)();
                return (0,
                t.useEffect)(( () => {
                    r.current = n ? r.current : e
                }
                ), [e, n]),
                r.current
            }
            )(v)
              , b = (0,
            t.useRef)(!0);
            (0,
            t.useEffect)(( () => {
                const {bindI18n: e, bindI18nStore: t} = s;
                b.current = !0,
                d || l || (n.lng ? bk(a, n.lng, u, ( () => {
                    b.current && g(f)
                }
                )) : yk(a, u, ( () => {
                    b.current && g(f)
                }
                ))),
                d && y && y !== v && b.current && g(f);
                const r = () => {
                    b.current && g(f)
                }
                ;
                return e && a && a.on(e, r),
                t && a && a.store.on(t, r),
                () => {
                    b.current = !1,
                    e && a && e.split(" ").forEach((e => a.off(e, r))),
                    t && a && t.split(" ").forEach((e => a.store.off(e, r)))
                }
            }
            ), [a, v]),
            (0,
            t.useEffect)(( () => {
                b.current && d && g(p)
            }
            ), [a, c, d]);
            const _ = [m, a, d];
            if (_.t = m,
            _.i18n = a,
            _.ready = d,
            d)
                return _;
            if (!d && !l)
                return _;
            throw new Promise((e => {
                n.lng ? bk(a, n.lng, u, ( () => e())) : yk(a, u, ( () => e()))
            }
            ))
        };
        const Bk = __webpack_require__.p + "static/media/title_logo.7ad5dfa62ffc67b77b3b.png"
          , Ik = (__webpack_require__.p,
        __webpack_require__.p,
        __webpack_require__.p,
        __webpack_require__.p,
        __webpack_require__.p,
        __webpack_require__.p,
        __webpack_require__.p + "static/media/info01_cn.de4514ec2845f1b7a4f3.png")
          , Lk = __webpack_require__.p + "static/media/info02_cn.52ef48bd976fb6424142.png"
          , kk = __webpack_require__.p + "static/media/bear_01.b717200aba9f2edb42e9.png"
          , Dk = __webpack_require__.p + "static/media/bear_02.eab6523a8ac948a7b81b.png"
          , Ok = __webpack_require__.p + "static/media/bear_03.068039d465d39e9514b1.png"
          , Nk = __webpack_require__.p + "static/media/bear_04.ce11ecff226c3b1cbddf.png"
          , Fk = __webpack_require__.p + "static/media/bear_05.b596650b007ddb9cb7d5.png"
          , Uk = __webpack_require__.p + "static/media/bear_06.762db9611d2b93905e13.png"
          , zk = __webpack_require__.p + "static/media/bear_07.a34bed519c742b20d04b.png"
          , Gk = __webpack_require__.p + "static/media/bear_08.97443297207e457ce407.png"
          , Hk = __webpack_require__.p + "static/media/bear_09.060f4cad5e5654ebdc39.png"
          , jk = __webpack_require__.p + "static/media/bear_10.a6054edde3aa97432fe2.png"
          , Wk = __webpack_require__.p + "static/media/bear_11.3ad70cfeba1628d7f22b.png"
          , Vk = __webpack_require__.p + "static/media/bear_12.551cdf3cd4f2a6c915f8.png"
          , Xk = e => [{
            label: e("first"),
            src: kk,
            alt: "Bear1",
            isDisabled: !0
        }, {
            label: e("second"),
            src: Dk,
            alt: "Bear2",
            isDisabled: !0
        }, {
            label: e("third"),
            src: Ok,
            alt: "Bear3",
            isDisabled: !0
        }, {
            label: e("fourth"),
            src: Nk,
            alt: "Bear4",
            isDisabled: !0
        }]
          , Jk = e => [{
            label: e("first"),
            src: Fk,
            alt: "Bear5",
            isDisabled: !0
        }, {
            label: e("second"),
            src: Uk,
            alt: "Bear6",
            isDisabled: !1
        }, {
            label: e("third"),
            src: zk,
            alt: "Bear7",
            isDisabled: !0
        }, {
            label: e("fourth"),
            src: Gk,
            alt: "Bear8",
            isDisabled: !0
        }]
          , Kk = e => [{
            label: e("first"),
            src: Hk,
            alt: "Bear9",
            isDisabled: !0
        }, {
            label: e("second"),
            src: jk,
            alt: "Bear10",
            isDisabled: !0
        }, {
            label: e("third"),
            src: Wk,
            alt: "Bear11",
            isDisabled: !0
        }, {
            label: e("fourth"),
            src: Vk,
            alt: "Bear12",
            isDisabled: !0
        }]
          , qk = __webpack_require__.p + "static/media/brownbear_01.347ba7fb43df38152a26.png"
          , Yk = __webpack_require__.p + "static/media/brownbear_02.b5dc203415bb7a7d84a0.png"
          , Qk = __webpack_require__.p + "static/media/brownbear_03.8285aa5fa46ab70b2b93.png"
          , Zk = __webpack_require__.p + "static/media/brownbear_04.4a353475a107ded1c759.png"
          , $k = __webpack_require__.p + "static/media/brownbear_05.829375d96c9d8bb313be.png"
          , eD = __webpack_require__.p + "static/media/brownbear_06.ef945db0b906d379a6fa.png"
          , tD = __webpack_require__.p + "static/media/brownbear_07.792b7d02920252ca2919.png"
          , nD = __webpack_require__.p + "static/media/brownbear_08.24b9b2d822d4225bad1f.png"
          , rD = __webpack_require__.p + "static/media/brownbear_09.763f7989e9d261ae9d7a.png"
          , iD = __webpack_require__.p + "static/media/brownbear_10.cfbe5167c9f15d333230.png"
          , oD = __webpack_require__.p + "static/media/brownbear_11.e2f3ab0f06ead6fef1f5.png"
          , aD = __webpack_require__.p + "static/media/brownbear_12.ecb7eee0cefa3a040020.png"
          , sD = __webpack_require__.p + "static/media/brownbear_13.cd88e51272c6f313b4f7.png"
          , lD = __webpack_require__.p + "static/media/brownbear_14.5abee22335f1c05c21e6.png"
          , cD = __webpack_require__.p + "static/media/brownbear_15.565a16a3a72d9e440a91.png"
          , uD = __webpack_require__.p + "static/media/brownbear_16.697d12f47b745c32d8bd.png"
          , dD = __webpack_require__.p + "static/media/brownbear_17.bd7b2106b25315d11322.png"
          , hD = __webpack_require__.p + "static/media/brownbear_18.26e0dcd5d8da18f3b690.png"
          , pD = __webpack_require__.p + "static/media/brownbear_19.1782bc0d42727c9abbf7.png"
          , fD = __webpack_require__.p + "static/media/brownbear_20.2b0642b5595362b812bd.png"
          , mD = __webpack_require__.p + "static/media/brownbear_21.18a970d034ff4069eaff.png"
          , gD = __webpack_require__.p + "static/media/brownbear_22.34d2adfb124edbfd6450.png"
          , vD = __webpack_require__.p + "static/media/brownbear_23.96dd12465ae42e2ee032.png"
          , yD = __webpack_require__.p + "static/media/brownbear_24.5f9107ab355aead5447f.png"
          , bD = __webpack_require__.p + "static/media/brownbear_25.445c93b887aa82a9d2b5.png"
          , _D = __webpack_require__.p + "static/media/brownbear_26.53fbb08b3dfb3afe62df.png"
          , AD = __webpack_require__.p + "static/media/brownbear_27.90f847647c5f5fc8461a.png"
          , xD = __webpack_require__.p + "static/media/brownbear_28.d2f37e16df21524437dc.png"
          , SD = __webpack_require__.p + "static/media/brownbear_29.3696ac0d9103dc6cb2aa.png"
          , wD = __webpack_require__.p + "static/media/whitebear_01.90bd96f9a95b564f288b.png"
          , ED = __webpack_require__.p + "static/media/whitebear_02.f42281469f1a9da167a5.png"
          , MD = __webpack_require__.p + "static/media/whitebear_03.6d84a883fbe9e0842833.png"
          , CD = __webpack_require__.p + "static/media/whitebear_04.3c280a8de88a0affc7f5.png"
          , TD = __webpack_require__.p + "static/media/whitebear_05.909fb7f24d13eb4fd2bf.png"
          , RD = __webpack_require__.p + "static/media/whitebear_06.907de43339f186a54b65.png"
          , PD = __webpack_require__.p + "static/media/whitebear_07.dfdc2217f0868c0e6b1e.png"
          , BD = __webpack_require__.p + "static/media/whitebear_08.6076a479298fbc83286d.png"
          , ID = __webpack_require__.p + "static/media/whitebear_09.c9cd2c672f287a1dc6da.png"
          , LD = __webpack_require__.p + "static/media/whitebear_10.7790d9d14ee46c8222c4.png"
          , kD = __webpack_require__.p + "static/media/whitebear_11.eff6193cd488e10b6b0c.png"
          , DD = __webpack_require__.p + "static/media/whitebear_12.86bde0bc43c7f516e751.png"
          , OD = __webpack_require__.p + "static/media/whitebear_13.987df2eee19573edffbc.png"
          , ND = __webpack_require__.p + "static/media/whitebear_14.3774abf239900aa5a5ec.png"
          , FD = __webpack_require__.p + "static/media/whitebear_15.4d47d2951a3d18749dcc.png"
          , UD = __webpack_require__.p + "static/media/whitebear_16.18a215242edc496896e4.png"
          , zD = __webpack_require__.p + "static/media/whitebear_17.b15f3f7677ecbf34926d.png"
          , GD = __webpack_require__.p + "static/media/whitebear_18.bf6ffb484c528cdc2509.png"
          , HD = __webpack_require__.p + "static/media/whitebear_19.18211246a84a9b5b2dea.png"
          , jD = __webpack_require__.p + "static/media/whitebear_20.2cab3a3c67277baa3f17.png"
          , WD = __webpack_require__.p + "static/media/whitebear_21.59054cc7a95c100b8996.png"
          , VD = __webpack_require__.p + "static/media/whitebear_22.7ff8f148dd9c773f5d53.png"
          , XD = __webpack_require__.p + "static/media/whitebear_23.4d97c86fbd079233c227.png"
          , JD = __webpack_require__.p + "static/media/whitebear_24.d999d894cd84ed6b3850.png"
          , KD = __webpack_require__.p + "static/media/whitebear_25.2705c56edc927d1f1525.png"
          , qD = __webpack_require__.p + "static/media/whitebear_26.8a5304fef9d80c041948.png"
          , YD = __webpack_require__.p + "static/media/whitebear_27.1f9e5f72ee8332933469.png"
          , QD = __webpack_require__.p + "static/media/whitebear_28.c91b437a7b806d3cff9a.png"
          , ZD = __webpack_require__.p + "static/media/whitebear_29.63be52f284e9fa58ddbb.png"
          , $D = {
            0: [{
                label: "1-1",
                src: qk,
                isDisabled: !0
            }, {
                label: "1-2",
                src: LD,
                isDisabled: !0
            }, {
                label: "1-3",
                src: oD,
                isDisabled: !0
            }, {
                label: "1-4",
                src: FD,
                isDisabled: !0
            }, {
                label: "1-5",
                src: _D,
                isDisabled: !0
            }, {
                label: "1-6",
                src: OD,
                isDisabled: !1
            }],
            1: [{
                label: "2-1",
                src: iD
            }, {
                label: "2-2",
                src: FD
            }, {
                label: "2-3",
                src: ED
            }, {
                label: "2-4",
                src: oD
            }, {
                label: "2-5",
                src: UD
            }, {
                label: "2-6",
                src: RD
            }],
            2: [{
                label: "3-1",
                src: hD
            }, {
                label: "3-2",
                src: qD
            }, {
                label: "3-3",
                src: iD
            }, {
                label: "3-4",
                src: cD
            }, {
                label: "3-5",
                src: cD
            }, {
                label: "3-6",
                src: jD
            }],
            3: [{
                label: "4-1",
                src: Yk
            }, {
                label: "4-2",
                src: cD
            }, {
                label: "4-3",
                src: jD
            }, {
                label: "4-4",
                src: vD
            }, {
                label: "4-5",
                src: LD
            }, {
                label: "4-6",
                src: Qk
            }]
        }
          , eO = {
            0: [{
                label: "1-7",
                src: DD,
                isDisabled: !0
            }, {
                label: "1-8",
                src: sD,
                isDisabled: !0
            }, {
                label: "1-9",
                src: ED,
                isDisabled: !0
            }, {
                label: "1-10",
                src: uD,
                isDisabled: !0
            }, {
                label: "1-11",
                src: RD,
                isDisabled: !0
            }, {
                label: "1-12",
                src: HD,
                isDisabled: !0
            }],
            1: [{
                label: "2-7",
                src: pD
            }, {
                label: "2-8",
                src: DD
            }, {
                label: "2-9",
                src: lD
            }, {
                label: "2-10",
                src: $k
            }, {
                label: "2-11",
                src: BD
            }, {
                label: "2-12",
                src: HD
            }],
            2: [{
                label: "3-7",
                src: XD
            }, {
                label: "3-8",
                src: sD
            }, {
                label: "3-9",
                src: UD
            }, {
                label: "3-10",
                src: kD
            }, {
                label: "3-11",
                src: eD
            }, {
                label: "3-12",
                src: HD
            }],
            3: [{
                label: "4-7",
                src: XD
            }, {
                label: "4-8",
                src: fD
            }, {
                label: "4-9",
                src: ID
            }, {
                label: "4-10",
                src: aD
            }, {
                label: "4-11",
                src: GD
            }, {
                label: "4-12",
                src: HD
            }]
        }
          , tO = {
            0: [{
                label: "1-1",
                src: TD,
                isDisabled: !1
            }, {
                label: "1-2",
                src: oD,
                isDisabled: !0
            }, {
                label: "1-3",
                src: ID,
                isDisabled: !0
            }, {
                label: "1-4",
                src: Qk,
                isDisabled: !0
            }, {
                label: "1-5",
                src: AD,
                isDisabled: !0
            }, {
                label: "1-6",
                src: zD,
                isDisabled: !0
            }],
            1: [{
                label: "2-1",
                src: MD,
                isDisabled: !0
            }, {
                label: "2-2",
                src: cD,
                isDisabled: !0
            }, {
                label: "2-3",
                src: SD,
                isDisabled: !0
            }, {
                label: "2-4",
                src: BD,
                isDisabled: !1
            }, {
                label: "2-5",
                src: nD,
                isDisabled: !0
            }, {
                label: "2-6",
                src: UD,
                isDisabled: !0
            }],
            2: [{
                label: "3-1",
                src: aD,
                isDisabled: !0
            }, {
                label: "3-2",
                src: UD,
                isDisabled: !0
            }, {
                label: "3-3",
                src: nD,
                isDisabled: !0
            }, {
                label: "3-4",
                src: RD,
                isDisabled: !0
            }, {
                label: "3-5",
                src: Qk,
                isDisabled: !0
            }, {
                label: "3-6",
                src: ED,
                isDisabled: !0
            }],
            3: [{
                label: "4-1",
                src: TD
            }, {
                label: "4-2",
                src: mD
            }, {
                label: "4-3",
                src: KD
            }, {
                label: "4-4",
                src: XD
            }, {
                label: "4-5",
                src: qk
            }, {
                label: "4-6",
                src: zD
            }]
        }
          , nO = {
            0: [{
                label: "1-7",
                src: UD,
                isDisabled: !0
            }, {
                label: "1-8",
                src: fD,
                isDisabled: !0
            }, {
                label: "1-9",
                src: RD,
                isDisabled: !0
            }, {
                label: "1-10",
                src: mD,
                isDisabled: !0
            }, {
                label: "1-11",
                src: kD,
                isDisabled: !0
            }, {
                label: "1-12",
                src: HD,
                isDisabled: !0
            }],
            1: [{
                label: "2-7",
                src: cD,
                isDisabled: !0
            }, {
                label: "2-8",
                src: XD,
                isDisabled: !0
            }, {
                label: "2-9",
                src: lD,
                isDisabled: !0
            }, {
                label: "2-10",
                src: VD,
                isDisabled: !0
            }, {
                label: "2-11",
                src: mD,
                isDisabled: !0
            }, {
                label: "2-12",
                src: HD,
                isDisabled: !0
            }],
            2: [{
                label: "3-7",
                src: sD
            }, {
                label: "3-8",
                src: qD
            }, {
                label: "3-9",
                src: qk
            }, {
                label: "3-10",
                src: zD
            }, {
                label: "3-11",
                src: _D
            }, {
                label: "3-12",
                src: HD
            }],
            3: [{
                label: "4-7",
                src: tD
            }, {
                label: "4-8",
                src: ND
            }, {
                label: "4-9",
                src: yD
            }, {
                label: "4-10",
                src: wD
            }, {
                label: "4-11",
                src: pD
            }, {
                label: "4-12",
                src: HD
            }]
        }
          , rO = {
            0: [{
                label: "1-1",
                src: hD,
                isDisabled: !0
            }, {
                label: "1-2",
                src: WD,
                isDisabled: !0
            }, {
                label: "1-3",
                src: $k,
                isDisabled: !0
            }, {
                label: "1-4",
                src: CD,
                isDisabled: !1
            }, {
                label: "1-5",
                src: bD,
                isDisabled: !0
            }, {
                label: "1-6",
                src: XD,
                isDisabled: !0
            }],
            1: [{
                label: "2-1",
                src: rD
            }, {
                label: "2-2",
                src: jD
            }, {
                label: "2-3",
                src: nD
            }, {
                label: "2-4",
                src: GD
            }, {
                label: "2-5",
                src: DD
            }, {
                label: "2-6",
                src: qk
            }],
            2: [{
                label: "3-1",
                src: pD
            }, {
                label: "3-2",
                src: cD
            }, {
                label: "3-3",
                src: cD
            }, {
                label: "3-4",
                src: cD
            }, {
                label: "3-5",
                src: eD
            }, {
                label: "3-6",
                src: UD
            }],
            3: [{
                label: "4-1",
                src: PD
            }, {
                label: "4-2",
                src: fD
            }, {
                label: "4-3",
                src: JD
            }, {
                label: "4-4",
                src: oD
            }, {
                label: "4-5",
                src: ND
            }, {
                label: "4-6",
                src: eD
            }]
        }
          , iO = {
            0: [{
                label: "1-7",
                src: xD,
                isDisabled: !0
            }, {
                label: "1-8",
                src: aD,
                isDisabled: !0
            }, {
                label: "1-9",
                src: PD,
                isDisabled: !0
            }, {
                label: "1-10",
                src: Qk,
                isDisabled: !0
            }, {
                label: "1-11",
                src: ID,
                isDisabled: !0
            }, {
                label: "1-12",
                src: HD,
                isDisabled: !0
            }],
            1: [{
                label: "2-7",
                src: gD,
                isDisabled: !0
            }, {
                label: "2-8",
                src: YD,
                isDisabled: !0
            }, {
                label: "2-9",
                src: fD,
                isDisabled: !0
            }, {
                label: "2-10",
                src: ID,
                isDisabled: !0
            }, {
                label: "2-11",
                src: _D,
                isDisabled: !0
            }, {
                label: "2-12",
                src: HD,
                isDisabled: !0
            }],
            2: [{
                label: "3-7",
                src: AD
            }, {
                label: "3-8",
                src: QD
            }, {
                label: "3-9",
                src: UD
            }, {
                label: "3-10",
                src: uD
            }, {
                label: "3-11",
                src: cD
            }, {
                label: "3-12",
                src: HD
            }],
            3: [{
                label: "4-7",
                src: ZD
            }, {
                label: "4-8",
                src: dD
            }, {
                label: "4-9",
                src: kD
            }, {
                label: "4-10",
                src: Zk
            }, {
                label: "4-11",
                src: YD
            }, {
                label: "4-12",
                src: HD
            }]
        }
          , oO = {
            0: {
                1: "9S01",
                2: "7B03_1",
                3: "9C01",
                4: "7C02_1",
                5: "7B04_1",
                6: "9C02",
                7: "9C03",
                8: "M32",
                9: "9C04",
                10: "8G06_1",
                11: "9S02",
                12: "Presentation"
            },
            1: {
                1: "9S04",
                2: "7C02_new",
                3: "9C05",
                4: "8G03_1",
                5: "M36",
                6: "7B05_1",
                7: "M24",
                8: "8G05_1",
                9: "7C03_1",
                10: "7D04_1",
                11: "8G08_1",
                12: "Presentation"
            },
            2: {
                1: "7C05_1",
                2: "7A02_1",
                3: "9S05",
                4: "BOX",
                5: "BOX",
                6: "M03",
                7: "M33",
                8: "7B02_0",
                9: "M26",
                10: "7D04_2",
                11: "9CS03",
                12: "Presentation"
            },
            3: {
                1: "8G01_1",
                2: "BOX",
                3: "M10",
                4: "7D05_1",
                5: "9S03",
                6: "9S09",
                7: "M30",
                8: "M04",
                9: "9CS01_new",
                10: "9C06",
                11: "7C05_2",
                12: "Presentation"
            }
        }
          , aO = {
            0: {
                1: "8G03_2",
                2: "9C07",
                3: "7C03_2",
                4: "8G05_2",
                5: "7A01_1",
                6: "7A05_1",
                7: "7B04_2",
                8: "8G06_2",
                9: "7D01_2",
                10: "M08",
                11: "9S06",
                12: "Presentation"
            },
            1: {
                1: "7C01_1",
                2: "BOX",
                3: "7D02_2",
                4: "7B02_2",
                5: "7A03_1",
                6: "M34",
                7: "BOX",
                8: "M31",
                9: "7C02_2",
                10: "M12",
                11: "M13",
                12: "Presentation"
            },
            2: {
                1: "9C08",
                2: "8G08_2",
                3: "7A01_2",
                4: "9CS01",
                5: "7C01_2",
                6: "M06",
                7: "7A04_1",
                8: "7A02_2",
                9: "9S07",
                10: "7A05_2",
                11: "7B03_3",
                12: "Presentation"
            },
            3: {
                1: "9S08",
                2: "M15",
                3: "9C09",
                4: "7D05_2",
                5: "9CS02",
                6: "M22",
                7: "7B01_2",
                8: "8G07_2",
                9: "9C11_new",
                10: "7D03_2",
                11: "9CS11_number",
                12: "Presentation"
            }
        }
          , sO = {
            0: {
                1: "7C05_3",
                2: "M27",
                3: "9S11",
                4: "9CS12",
                5: "8G04_3",
                6: "M35",
                7: "7C04_0",
                8: "9C12",
                9: "8G03_3",
                10: "9CS08",
                11: "9CS10",
                12: "Presentation"
            },
            1: {
                1: "9CS11_shape",
                2: "M17",
                3: "7A03_2",
                4: "9CS05",
                5: "9C10",
                6: "9CS06",
                7: "7B02_3",
                8: "7C04_2",
                9: "M18",
                10: "7C03_3",
                11: "7B05_3",
                12: "Presentation"
            },
            2: {
                1: "M25",
                2: "BOX",
                3: "BOX",
                4: "BOX",
                5: "9CS09",
                6: "8G01_3",
                7: "7A01_3",
                8: "M23",
                9: "M29",
                10: "8G06_3",
                11: "BOX",
                12: "Presentation"
            },
            3: {
                1: "7A02_3",
                2: "M28",
                3: "7D03_3",
                4: "7C01_3",
                5: "7A04_3",
                6: "9CS07",
                7: "M37",
                8: "M38",
                9: "9CS04",
                10: "9S12",
                11: "7C04_3",
                12: "Presentation"
            }
        };
        function lO(e) {
            return (0,
            Bt.Ay)("MuiBottomNavigationAction", e)
        }
        const cO = (0,
        _t.A)("MuiBottomNavigationAction", ["root", "iconOnly", "selected", "label"])
          , uO = ["className", "icon", "label", "onChange", "onClick", "selected", "showLabel", "value"]
          , dO = (0,
        Mt.Ay)(FI, {
            name: "MuiBottomNavigationAction",
            slot: "Root",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.root, !n.showLabel && !n.selected && t.iconOnly]
            }
        })((e => {
            let {theme: t, ownerState: n} = e;
            return (0,
            rt.A)({
                transition: t.transitions.create(["color", "padding-top"], {
                    duration: t.transitions.duration.short
                }),
                padding: "0px 12px",
                minWidth: 80,
                maxWidth: 168,
                color: (t.vars || t).palette.text.secondary,
                flexDirection: "column",
                flex: "1"
            }, !n.showLabel && !n.selected && {
                paddingTop: 14
            }, !n.showLabel && !n.selected && !n.label && {
                paddingTop: 0
            }, {
                [`&.${cO.selected}`]: {
                    color: (t.vars || t).palette.primary.main
                }
            })
        }
        ))
          , hO = (0,
        Mt.Ay)("span", {
            name: "MuiBottomNavigationAction",
            slot: "Label",
            overridesResolver: (e, t) => t.label
        })((e => {
            let {theme: t, ownerState: n} = e;
            return (0,
            rt.A)({
                fontFamily: t.typography.fontFamily,
                fontSize: t.typography.pxToRem(12),
                opacity: 1,
                transition: "font-size 0.2s, opacity 0.2s",
                transitionDelay: "0.1s"
            }, !n.showLabel && !n.selected && {
                opacity: 0,
                transitionDelay: "0s"
            }, {
                [`&.${cO.selected}`]: {
                    fontSize: t.typography.pxToRem(14)
                }
            })
        }
        ))
          , pO = t.forwardRef((function(e, t) {
            const n = (0,
            Ct.b)({
                props: e,
                name: "MuiBottomNavigationAction"
            })
              , {className: r, icon: i, label: o, onChange: a, onClick: s, value: l} = n
              , c = (0,
            it.A)(n, uO)
              , u = n
              , d = (e => {
                const {classes: t, showLabel: n, selected: r} = e
                  , i = {
                    root: ["root", !n && !r && "iconOnly", r && "selected"],
                    label: ["label", !n && !r && "iconOnly", r && "selected"]
                };
                return (0,
                Et.A)(i, lO, t)
            }
            )(u);
            return (0,
            mt.jsxs)(dO, (0,
            rt.A)({
                ref: t,
                className: (0,
                wt.A)(d.root, r),
                focusRipple: !0,
                onClick: e => {
                    a && a(e, l),
                    s && s(e)
                }
                ,
                ownerState: u
            }, c, {
                children: [i, (0,
                mt.jsx)(hO, {
                    className: d.label,
                    ownerState: u,
                    children: o
                })]
            }))
        }
        ));
        function fO(e) {
            return (0,
            Bt.Ay)("MuiBottomNavigation", e)
        }
        (0,
        _t.A)("MuiBottomNavigation", ["root"]);
        const mO = ["children", "className", "component", "onChange", "showLabels", "value"]
          , gO = (0,
        Mt.Ay)("div", {
            name: "MuiBottomNavigation",
            slot: "Root",
            overridesResolver: (e, t) => t.root
        })((e => {
            let {theme: t} = e;
            return {
                display: "flex",
                justifyContent: "center",
                height: 56,
                backgroundColor: (t.vars || t).palette.background.paper
            }
        }
        ))
          , vO = t.forwardRef((function(e, n) {
            const r = (0,
            Ct.b)({
                props: e,
                name: "MuiBottomNavigation"
            })
              , {children: i, className: o, component: a="div", onChange: s, showLabels: l=!1, value: c} = r
              , u = (0,
            it.A)(r, mO)
              , d = (0,
            rt.A)({}, r, {
                component: a,
                showLabels: l
            })
              , h = (e => {
                const {classes: t} = e;
                return (0,
                Et.A)({
                    root: ["root"]
                }, fO, t)
            }
            )(d);
            return (0,
            mt.jsx)(gO, (0,
            rt.A)({
                as: a,
                className: (0,
                wt.A)(h.root, o),
                ref: n,
                ownerState: d
            }, u, {
                children: t.Children.map(i, ( (e, n) => {
                    if (!t.isValidElement(e))
                        return null;
                    const r = void 0 === e.props.value ? n : e.props.value;
                    return t.cloneElement(e, {
                        selected: r === c,
                        showLabel: void 0 !== e.props.showLabel ? e.props.showLabel : l,
                        value: r,
                        onChange: s
                    })
                }
                ))
            }))
        }
        ));
        var yO = __webpack_require__(3189);
        var bO = function() {
            return bO = Object.assign || function(e) {
                for (var t, n = 1, r = arguments.length; n < r; n++)
                    for (var i in t = arguments[n])
                        Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                return e
            }
            ,
            bO.apply(this, arguments)
        };
        Object.create;
        function _O(e, t, n) {
            if (n || 2 === arguments.length)
                for (var r, i = 0, o = t.length; i < o; i++)
                    !r && i in t || (r || (r = Array.prototype.slice.call(t, 0, i)),
                    r[i] = t[i]);
            return e.concat(r || Array.prototype.slice.call(t))
        }
        Object.create;
        "function" === typeof SuppressedError && SuppressedError;
        var AO = __webpack_require__(403)
          , xO = __webpack_require__.n(AO)
          , SO = "-ms-"
          , wO = "-moz-"
          , EO = "-webkit-"
          , MO = "comm"
          , CO = "rule"
          , TO = "decl"
          , RO = "@keyframes"
          , PO = Math.abs
          , BO = String.fromCharCode
          , IO = Object.assign;
        function LO(e) {
            return e.trim()
        }
        function kO(e, t) {
            return (e = t.exec(e)) ? e[0] : e
        }
        function DO(e, t, n) {
            return e.replace(t, n)
        }
        function OO(e, t, n) {
            return e.indexOf(t, n)
        }
        function NO(e, t) {
            return 0 | e.charCodeAt(t)
        }
        function FO(e, t, n) {
            return e.slice(t, n)
        }
        function UO(e) {
            return e.length
        }
        function zO(e) {
            return e.length
        }
        function GO(e, t) {
            return t.push(e),
            e
        }
        function HO(e, t) {
            return e.filter((function(e) {
                return !kO(e, t)
            }
            ))
        }
        var jO = 1
          , WO = 1
          , VO = 0
          , XO = 0
          , JO = 0
          , KO = "";
        function qO(e, t, n, r, i, o, a, s) {
            return {
                value: e,
                root: t,
                parent: n,
                type: r,
                props: i,
                children: o,
                line: jO,
                column: WO,
                length: a,
                return: "",
                siblings: s
            }
        }
        function YO(e, t) {
            return IO(qO("", null, null, "", null, null, 0, e.siblings), e, {
                length: -e.length
            }, t)
        }
        function QO(e) {
            for (; e.root; )
                e = YO(e.root, {
                    children: [e]
                });
            GO(e, e.siblings)
        }
        function ZO() {
            return JO = XO < VO ? NO(KO, XO++) : 0,
            WO++,
            10 === JO && (WO = 1,
            jO++),
            JO
        }
        function $O() {
            return NO(KO, XO)
        }
        function eN() {
            return XO
        }
        function tN(e, t) {
            return FO(KO, e, t)
        }
        function nN(e) {
            switch (e) {
            case 0:
            case 9:
            case 10:
            case 13:
            case 32:
                return 5;
            case 33:
            case 43:
            case 44:
            case 47:
            case 62:
            case 64:
            case 126:
            case 59:
            case 123:
            case 125:
                return 4;
            case 58:
                return 3;
            case 34:
            case 39:
            case 40:
            case 91:
                return 2;
            case 41:
            case 93:
                return 1
            }
            return 0
        }
        function rN(e) {
            return jO = WO = 1,
            VO = UO(KO = e),
            XO = 0,
            []
        }
        function iN(e) {
            return KO = "",
            e
        }
        function oN(e) {
            return LO(tN(XO - 1, lN(91 === e ? e + 2 : 40 === e ? e + 1 : e)))
        }
        function aN(e) {
            for (; (JO = $O()) && JO < 33; )
                ZO();
            return nN(e) > 2 || nN(JO) > 3 ? "" : " "
        }
        function sN(e, t) {
            for (; --t && ZO() && !(JO < 48 || JO > 102 || JO > 57 && JO < 65 || JO > 70 && JO < 97); )
                ;
            return tN(e, eN() + (t < 6 && 32 == $O() && 32 == ZO()))
        }
        function lN(e) {
            for (; ZO(); )
                switch (JO) {
                case e:
                    return XO;
                case 34:
                case 39:
                    34 !== e && 39 !== e && lN(JO);
                    break;
                case 40:
                    41 === e && lN(e);
                    break;
                case 92:
                    ZO()
                }
            return XO
        }
        function cN(e, t) {
            for (; ZO() && e + JO !== 57 && (e + JO !== 84 || 47 !== $O()); )
                ;
            return "/*" + tN(t, XO - 1) + "*" + BO(47 === e ? e : ZO())
        }
        function uN(e) {
            for (; !nN($O()); )
                ZO();
            return tN(e, XO)
        }
        function dN(e, t) {
            for (var n = "", r = 0; r < e.length; r++)
                n += t(e[r], r, e, t) || "";
            return n
        }
        function hN(e, t, n, r) {
            switch (e.type) {
            case "@layer":
                if (e.children.length)
                    break;
            case "@import":
            case TO:
                return e.return = e.return || e.value;
            case MO:
                return "";
            case RO:
                return e.return = e.value + "{" + dN(e.children, r) + "}";
            case CO:
                if (!UO(e.value = e.props.join(",")))
                    return ""
            }
            return UO(n = dN(e.children, r)) ? e.return = e.value + "{" + n + "}" : ""
        }
        function pN(e, t, n) {
            switch (function(e, t) {
                return 45 ^ NO(e, 0) ? (((t << 2 ^ NO(e, 0)) << 2 ^ NO(e, 1)) << 2 ^ NO(e, 2)) << 2 ^ NO(e, 3) : 0
            }(e, t)) {
            case 5103:
                return EO + "print-" + e + e;
            case 5737:
            case 4201:
            case 3177:
            case 3433:
            case 1641:
            case 4457:
            case 2921:
            case 5572:
            case 6356:
            case 5844:
            case 3191:
            case 6645:
            case 3005:
            case 6391:
            case 5879:
            case 5623:
            case 6135:
            case 4599:
            case 4855:
            case 4215:
            case 6389:
            case 5109:
            case 5365:
            case 5621:
            case 3829:
                return EO + e + e;
            case 4789:
                return wO + e + e;
            case 5349:
            case 4246:
            case 4810:
            case 6968:
            case 2756:
                return EO + e + wO + e + SO + e + e;
            case 5936:
                switch (NO(e, t + 11)) {
                case 114:
                    return EO + e + SO + DO(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
                case 108:
                    return EO + e + SO + DO(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
                case 45:
                    return EO + e + SO + DO(e, /[svh]\w+-[tblr]{2}/, "lr") + e
                }
            case 6828:
            case 4268:
            case 2903:
                return EO + e + SO + e + e;
            case 6165:
                return EO + e + SO + "flex-" + e + e;
            case 5187:
                return EO + e + DO(e, /(\w+).+(:[^]+)/, EO + "box-$1$2" + SO + "flex-$1$2") + e;
            case 5443:
                return EO + e + SO + "flex-item-" + DO(e, /flex-|-self/g, "") + (kO(e, /flex-|baseline/) ? "" : SO + "grid-row-" + DO(e, /flex-|-self/g, "")) + e;
            case 4675:
                return EO + e + SO + "flex-line-pack" + DO(e, /align-content|flex-|-self/g, "") + e;
            case 5548:
                return EO + e + SO + DO(e, "shrink", "negative") + e;
            case 5292:
                return EO + e + SO + DO(e, "basis", "preferred-size") + e;
            case 6060:
                return EO + "box-" + DO(e, "-grow", "") + EO + e + SO + DO(e, "grow", "positive") + e;
            case 4554:
                return EO + DO(e, /([^-])(transform)/g, "$1" + EO + "$2") + e;
            case 6187:
                return DO(DO(DO(e, /(zoom-|grab)/, EO + "$1"), /(image-set)/, EO + "$1"), e, "") + e;
            case 5495:
            case 3959:
                return DO(e, /(image-set\([^]*)/, EO + "$1$`$1");
            case 4968:
                return DO(DO(e, /(.+:)(flex-)?(.*)/, EO + "box-pack:$3" + SO + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + EO + e + e;
            case 4200:
                if (!kO(e, /flex-|baseline/))
                    return SO + "grid-column-align" + FO(e, t) + e;
                break;
            case 2592:
            case 3360:
                return SO + DO(e, "template-", "") + e;
            case 4384:
            case 3616:
                return n && n.some((function(e, n) {
                    return t = n,
                    kO(e.props, /grid-\w+-end/)
                }
                )) ? ~OO(e + (n = n[t].value), "span", 0) ? e : SO + DO(e, "-start", "") + e + SO + "grid-row-span:" + (~OO(n, "span", 0) ? kO(n, /\d+/) : +kO(n, /\d+/) - +kO(e, /\d+/)) + ";" : SO + DO(e, "-start", "") + e;
            case 4896:
            case 4128:
                return n && n.some((function(e) {
                    return kO(e.props, /grid-\w+-start/)
                }
                )) ? e : SO + DO(DO(e, "-end", "-span"), "span ", "") + e;
            case 4095:
            case 3583:
            case 4068:
            case 2532:
                return DO(e, /(.+)-inline(.+)/, EO + "$1$2") + e;
            case 8116:
            case 7059:
            case 5753:
            case 5535:
            case 5445:
            case 5701:
            case 4933:
            case 4677:
            case 5533:
            case 5789:
            case 5021:
            case 4765:
                if (UO(e) - 1 - t > 6)
                    switch (NO(e, t + 1)) {
                    case 109:
                        if (45 !== NO(e, t + 4))
                            break;
                    case 102:
                        return DO(e, /(.+:)(.+)-([^]+)/, "$1" + EO + "$2-$3$1" + wO + (108 == NO(e, t + 3) ? "$3" : "$2-$3")) + e;
                    case 115:
                        return ~OO(e, "stretch", 0) ? pN(DO(e, "stretch", "fill-available"), t, n) + e : e
                    }
                break;
            case 5152:
            case 5920:
                return DO(e, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, (function(t, n, r, i, o, a, s) {
                    return SO + n + ":" + r + s + (i ? SO + n + "-span:" + (o ? a : +a - +r) + s : "") + e
                }
                ));
            case 4949:
                if (121 === NO(e, t + 6))
                    return DO(e, ":", ":" + EO) + e;
                break;
            case 6444:
                switch (NO(e, 45 === NO(e, 14) ? 18 : 11)) {
                case 120:
                    return DO(e, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + EO + (45 === NO(e, 14) ? "inline-" : "") + "box$3$1" + EO + "$2$3$1" + SO + "$2box$3") + e;
                case 100:
                    return DO(e, ":", ":" + SO) + e
                }
                break;
            case 5719:
            case 2647:
            case 2135:
            case 3927:
            case 2391:
                return DO(e, "scroll-", "scroll-snap-") + e
            }
            return e
        }
        function fN(e, t, n, r) {
            if (e.length > -1 && !e.return)
                switch (e.type) {
                case TO:
                    return void (e.return = pN(e.value, e.length, n));
                case RO:
                    return dN([YO(e, {
                        value: DO(e.value, "@", "@" + EO)
                    })], r);
                case CO:
                    if (e.length)
                        return function(e, t) {
                            return e.map(t).join("")
                        }(n = e.props, (function(t) {
                            switch (kO(t, r = /(::plac\w+|:read-\w+)/)) {
                            case ":read-only":
                            case ":read-write":
                                QO(YO(e, {
                                    props: [DO(t, /:(read-\w+)/, ":-moz-$1")]
                                })),
                                QO(YO(e, {
                                    props: [t]
                                })),
                                IO(e, {
                                    props: HO(n, r)
                                });
                                break;
                            case "::placeholder":
                                QO(YO(e, {
                                    props: [DO(t, /:(plac\w+)/, ":" + EO + "input-$1")]
                                })),
                                QO(YO(e, {
                                    props: [DO(t, /:(plac\w+)/, ":-moz-$1")]
                                })),
                                QO(YO(e, {
                                    props: [DO(t, /:(plac\w+)/, SO + "input-$1")]
                                })),
                                QO(YO(e, {
                                    props: [t]
                                })),
                                IO(e, {
                                    props: HO(n, r)
                                })
                            }
                            return ""
                        }
                        ))
                }
        }
        function mN(e) {
            return iN(gN("", null, null, null, [""], e = rN(e), 0, [0], e))
        }
        function gN(e, t, n, r, i, o, a, s, l) {
            for (var c = 0, u = 0, d = a, h = 0, p = 0, f = 0, m = 1, g = 1, v = 1, y = 0, b = "", _ = i, A = o, x = r, S = b; g; )
                switch (f = y,
                y = ZO()) {
                case 40:
                    if (108 != f && 58 == NO(S, d - 1)) {
                        -1 != OO(S += DO(oN(y), "&", "&\f"), "&\f", PO(c ? s[c - 1] : 0)) && (v = -1);
                        break
                    }
                case 34:
                case 39:
                case 91:
                    S += oN(y);
                    break;
                case 9:
                case 10:
                case 13:
                case 32:
                    S += aN(f);
                    break;
                case 92:
                    S += sN(eN() - 1, 7);
                    continue;
                case 47:
                    switch ($O()) {
                    case 42:
                    case 47:
                        GO(yN(cN(ZO(), eN()), t, n, l), l);
                        break;
                    default:
                        S += "/"
                    }
                    break;
                case 123 * m:
                    s[c++] = UO(S) * v;
                case 125 * m:
                case 59:
                case 0:
                    switch (y) {
                    case 0:
                    case 125:
                        g = 0;
                    case 59 + u:
                        -1 == v && (S = DO(S, /\f/g, "")),
                        p > 0 && UO(S) - d && GO(p > 32 ? bN(S + ";", r, n, d - 1, l) : bN(DO(S, " ", "") + ";", r, n, d - 2, l), l);
                        break;
                    case 59:
                        S += ";";
                    default:
                        if (GO(x = vN(S, t, n, c, u, i, s, b, _ = [], A = [], d, o), o),
                        123 === y)
                            if (0 === u)
                                gN(S, t, x, x, _, o, d, s, A);
                            else
                                switch (99 === h && 110 === NO(S, 3) ? 100 : h) {
                                case 100:
                                case 108:
                                case 109:
                                case 115:
                                    gN(e, x, x, r && GO(vN(e, x, x, 0, 0, i, s, b, i, _ = [], d, A), A), i, A, d, s, r ? _ : A);
                                    break;
                                default:
                                    gN(S, x, x, x, [""], A, 0, s, A)
                                }
                    }
                    c = u = p = 0,
                    m = v = 1,
                    b = S = "",
                    d = a;
                    break;
                case 58:
                    d = 1 + UO(S),
                    p = f;
                default:
                    if (m < 1)
                        if (123 == y)
                            --m;
                        else if (125 == y && 0 == m++ && 125 == (JO = XO > 0 ? NO(KO, --XO) : 0,
                        WO--,
                        10 === JO && (WO = 1,
                        jO--),
                        JO))
                            continue;
                    switch (S += BO(y),
                    y * m) {
                    case 38:
                        v = u > 0 ? 1 : (S += "\f",
                        -1);
                        break;
                    case 44:
                        s[c++] = (UO(S) - 1) * v,
                        v = 1;
                        break;
                    case 64:
                        45 === $O() && (S += oN(ZO())),
                        h = $O(),
                        u = d = UO(b = S += uN(eN())),
                        y++;
                        break;
                    case 45:
                        45 === f && 2 == UO(S) && (m = 0)
                    }
                }
            return o
        }
        function vN(e, t, n, r, i, o, a, s, l, c, u, d) {
            for (var h = i - 1, p = 0 === i ? o : [""], f = zO(p), m = 0, g = 0, v = 0; m < r; ++m)
                for (var y = 0, b = FO(e, h + 1, h = PO(g = a[m])), _ = e; y < f; ++y)
                    (_ = LO(g > 0 ? p[y] + " " + b : DO(b, /&\f/g, p[y]))) && (l[v++] = _);
            return qO(e, t, n, 0 === i ? CO : s, l, c, u, d)
        }
        function yN(e, t, n, r) {
            return qO(e, t, n, MO, BO(JO), FO(e, 2, -2), 0, r)
        }
        function bN(e, t, n, r, i) {
            return qO(e, t, n, TO, FO(e, 0, r), FO(e, r + 1, -1), r, i)
        }
        var _N = {
            animationIterationCount: 1,
            aspectRatio: 1,
            borderImageOutset: 1,
            borderImageSlice: 1,
            borderImageWidth: 1,
            boxFlex: 1,
            boxFlexGroup: 1,
            boxOrdinalGroup: 1,
            columnCount: 1,
            columns: 1,
            flex: 1,
            flexGrow: 1,
            flexPositive: 1,
            flexShrink: 1,
            flexNegative: 1,
            flexOrder: 1,
            gridRow: 1,
            gridRowEnd: 1,
            gridRowSpan: 1,
            gridRowStart: 1,
            gridColumn: 1,
            gridColumnEnd: 1,
            gridColumnSpan: 1,
            gridColumnStart: 1,
            msGridRow: 1,
            msGridRowSpan: 1,
            msGridColumn: 1,
            msGridColumnSpan: 1,
            fontWeight: 1,
            lineHeight: 1,
            opacity: 1,
            order: 1,
            orphans: 1,
            tabSize: 1,
            widows: 1,
            zIndex: 1,
            zoom: 1,
            WebkitLineClamp: 1,
            fillOpacity: 1,
            floodOpacity: 1,
            stopOpacity: 1,
            strokeDasharray: 1,
            strokeDashoffset: 1,
            strokeMiterlimit: 1,
            strokeOpacity: 1,
            strokeWidth: 1
        }
          , AN = "undefined" != typeof process && void 0 !== {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_VERSION: "tw"
        } && ({
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_VERSION: "tw"
        }.REACT_APP_SC_ATTR || {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_VERSION: "tw"
        }.SC_ATTR) || "data-styled"
          , xN = "active"
          , SN = "data-styled-version"
          , wN = "6.1.13"
          , EN = "/*!sc*/\n"
          , MN = "undefined" != typeof window && "HTMLElement"in window
          , CN = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_VERSION: "tw"
        } && void 0 !== {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_VERSION: "tw"
        }.REACT_APP_SC_DISABLE_SPEEDY && "" !== {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_VERSION: "tw"
        }.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_VERSION: "tw"
        }.REACT_APP_SC_DISABLE_SPEEDY && {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_VERSION: "tw"
        }.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_VERSION: "tw"
        } && void 0 !== {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_VERSION: "tw"
        }.SC_DISABLE_SPEEDY && "" !== {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_VERSION: "tw"
        }.SC_DISABLE_SPEEDY && ("false" !== {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_VERSION: "tw"
        }.SC_DISABLE_SPEEDY && {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_VERSION: "tw"
        }.SC_DISABLE_SPEEDY))
          , TN = (new Set,
        Object.freeze([]))
          , RN = Object.freeze({});
        function PN(e, t, n) {
            return void 0 === n && (n = RN),
            e.theme !== n.theme && e.theme || t || n.theme
        }
        var BN = new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"])
          , IN = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g
          , LN = /(^-|-$)/g;
        function kN(e) {
            return e.replace(IN, "-").replace(LN, "")
        }
        var DN = /(a)(d)/gi
          , ON = function(e) {
            return String.fromCharCode(e + (e > 25 ? 39 : 97))
        };
        function NN(e) {
            var t, n = "";
            for (t = Math.abs(e); t > 52; t = t / 52 | 0)
                n = ON(t % 52) + n;
            return (ON(t % 52) + n).replace(DN, "$1-$2")
        }
        var FN, UN = function(e, t) {
            for (var n = t.length; n; )
                e = 33 * e ^ t.charCodeAt(--n);
            return e
        }, zN = function(e) {
            return UN(5381, e)
        };
        function GN(e) {
            return NN(zN(e) >>> 0)
        }
        function HN(e) {
            return e.displayName || e.name || "Component"
        }
        function jN(e) {
            return "string" == typeof e && !0
        }
        var WN = "function" == typeof Symbol && Symbol.for
          , VN = WN ? Symbol.for("react.memo") : 60115
          , XN = WN ? Symbol.for("react.forward_ref") : 60112
          , JN = {
            childContextTypes: !0,
            contextType: !0,
            contextTypes: !0,
            defaultProps: !0,
            displayName: !0,
            getDefaultProps: !0,
            getDerivedStateFromError: !0,
            getDerivedStateFromProps: !0,
            mixins: !0,
            propTypes: !0,
            type: !0
        }
          , KN = {
            name: !0,
            length: !0,
            prototype: !0,
            caller: !0,
            callee: !0,
            arguments: !0,
            arity: !0
        }
          , qN = {
            $$typeof: !0,
            compare: !0,
            defaultProps: !0,
            displayName: !0,
            propTypes: !0,
            type: !0
        }
          , YN = ((FN = {})[XN] = {
            $$typeof: !0,
            render: !0,
            defaultProps: !0,
            displayName: !0,
            propTypes: !0
        },
        FN[VN] = qN,
        FN);
        function QN(e) {
            return ("type"in (t = e) && t.type.$$typeof) === VN ? qN : "$$typeof"in e ? YN[e.$$typeof] : JN;
            var t
        }
        var ZN = Object.defineProperty
          , $N = Object.getOwnPropertyNames
          , eF = Object.getOwnPropertySymbols
          , tF = Object.getOwnPropertyDescriptor
          , nF = Object.getPrototypeOf
          , rF = Object.prototype;
        function iF(e, t, n) {
            if ("string" != typeof t) {
                if (rF) {
                    var r = nF(t);
                    r && r !== rF && iF(e, r, n)
                }
                var i = $N(t);
                eF && (i = i.concat(eF(t)));
                for (var o = QN(e), a = QN(t), s = 0; s < i.length; ++s) {
                    var l = i[s];
                    if (!(l in KN || n && n[l] || a && l in a || o && l in o)) {
                        var c = tF(t, l);
                        try {
                            ZN(e, l, c)
                        } catch (e) {}
                    }
                }
            }
            return e
        }
        function oF(e) {
            return "function" == typeof e
        }
        function aF(e) {
            return "object" == typeof e && "styledComponentId"in e
        }
        function sF(e, t) {
            return e && t ? "".concat(e, " ").concat(t) : e || t || ""
        }
        function lF(e, t) {
            if (0 === e.length)
                return "";
            for (var n = e[0], r = 1; r < e.length; r++)
                n += t ? t + e[r] : e[r];
            return n
        }
        function cF(e) {
            return null !== e && "object" == typeof e && e.constructor.name === Object.name && !("props"in e && e.$$typeof)
        }
        function uF(e, t, n) {
            if (void 0 === n && (n = !1),
            !n && !cF(e) && !Array.isArray(e))
                return t;
            if (Array.isArray(t))
                for (var r = 0; r < t.length; r++)
                    e[r] = uF(e[r], t[r]);
            else if (cF(t))
                for (var r in t)
                    e[r] = uF(e[r], t[r]);
            return e
        }
        function dF(e, t) {
            Object.defineProperty(e, "toString", {
                value: t
            })
        }
        function hF(e) {
            for (var t = [], n = 1; n < arguments.length; n++)
                t[n - 1] = arguments[n];
            return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(e, " for more information.").concat(t.length > 0 ? " Args: ".concat(t.join(", ")) : ""))
        }
        var pF = function() {
            function e(e) {
                this.groupSizes = new Uint32Array(512),
                this.length = 512,
                this.tag = e
            }
            return e.prototype.indexOfGroup = function(e) {
                for (var t = 0, n = 0; n < e; n++)
                    t += this.groupSizes[n];
                return t
            }
            ,
            e.prototype.insertRules = function(e, t) {
                if (e >= this.groupSizes.length) {
                    for (var n = this.groupSizes, r = n.length, i = r; e >= i; )
                        if ((i <<= 1) < 0)
                            throw hF(16, "".concat(e));
                    this.groupSizes = new Uint32Array(i),
                    this.groupSizes.set(n),
                    this.length = i;
                    for (var o = r; o < i; o++)
                        this.groupSizes[o] = 0
                }
                for (var a = this.indexOfGroup(e + 1), s = (o = 0,
                t.length); o < s; o++)
                    this.tag.insertRule(a, t[o]) && (this.groupSizes[e]++,
                    a++)
            }
            ,
            e.prototype.clearGroup = function(e) {
                if (e < this.length) {
                    var t = this.groupSizes[e]
                      , n = this.indexOfGroup(e)
                      , r = n + t;
                    this.groupSizes[e] = 0;
                    for (var i = n; i < r; i++)
                        this.tag.deleteRule(n)
                }
            }
            ,
            e.prototype.getGroup = function(e) {
                var t = "";
                if (e >= this.length || 0 === this.groupSizes[e])
                    return t;
                for (var n = this.groupSizes[e], r = this.indexOfGroup(e), i = r + n, o = r; o < i; o++)
                    t += "".concat(this.tag.getRule(o)).concat(EN);
                return t
            }
            ,
            e
        }()
          , fF = new Map
          , mF = new Map
          , gF = 1
          , vF = function(e) {
            if (fF.has(e))
                return fF.get(e);
            for (; mF.has(gF); )
                gF++;
            var t = gF++;
            return fF.set(e, t),
            mF.set(t, e),
            t
        }
          , yF = function(e, t) {
            gF = t + 1,
            fF.set(e, t),
            mF.set(t, e)
        }
          , bF = "style[".concat(AN, "][").concat(SN, '="').concat(wN, '"]')
          , _F = new RegExp("^".concat(AN, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'))
          , AF = function(e, t, n) {
            for (var r, i = n.split(","), o = 0, a = i.length; o < a; o++)
                (r = i[o]) && e.registerName(t, r)
        }
          , xF = function(e, t) {
            for (var n, r = (null !== (n = t.textContent) && void 0 !== n ? n : "").split(EN), i = [], o = 0, a = r.length; o < a; o++) {
                var s = r[o].trim();
                if (s) {
                    var l = s.match(_F);
                    if (l) {
                        var c = 0 | parseInt(l[1], 10)
                          , u = l[2];
                        0 !== c && (yF(u, c),
                        AF(e, u, l[3]),
                        e.getTag().insertRules(c, i)),
                        i.length = 0
                    } else
                        i.push(s)
                }
            }
        }
          , SF = function(e) {
            for (var t = document.querySelectorAll(bF), n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                i && i.getAttribute(AN) !== xN && (xF(e, i),
                i.parentNode && i.parentNode.removeChild(i))
            }
        };
        function wF() {
            return __webpack_require__.nc
        }
        var EF = function(e) {
            var t = document.head
              , n = e || t
              , r = document.createElement("style")
              , i = function(e) {
                var t = Array.from(e.querySelectorAll("style[".concat(AN, "]")));
                return t[t.length - 1]
            }(n)
              , o = void 0 !== i ? i.nextSibling : null;
            r.setAttribute(AN, xN),
            r.setAttribute(SN, wN);
            var a = wF();
            return a && r.setAttribute("nonce", a),
            n.insertBefore(r, o),
            r
        }
          , MF = function() {
            function e(e) {
                this.element = EF(e),
                this.element.appendChild(document.createTextNode("")),
                this.sheet = function(e) {
                    if (e.sheet)
                        return e.sheet;
                    for (var t = document.styleSheets, n = 0, r = t.length; n < r; n++) {
                        var i = t[n];
                        if (i.ownerNode === e)
                            return i
                    }
                    throw hF(17)
                }(this.element),
                this.length = 0
            }
            return e.prototype.insertRule = function(e, t) {
                try {
                    return this.sheet.insertRule(t, e),
                    this.length++,
                    !0
                } catch (e) {
                    return !1
                }
            }
            ,
            e.prototype.deleteRule = function(e) {
                this.sheet.deleteRule(e),
                this.length--
            }
            ,
            e.prototype.getRule = function(e) {
                var t = this.sheet.cssRules[e];
                return t && t.cssText ? t.cssText : ""
            }
            ,
            e
        }()
          , CF = function() {
            function e(e) {
                this.element = EF(e),
                this.nodes = this.element.childNodes,
                this.length = 0
            }
            return e.prototype.insertRule = function(e, t) {
                if (e <= this.length && e >= 0) {
                    var n = document.createTextNode(t);
                    return this.element.insertBefore(n, this.nodes[e] || null),
                    this.length++,
                    !0
                }
                return !1
            }
            ,
            e.prototype.deleteRule = function(e) {
                this.element.removeChild(this.nodes[e]),
                this.length--
            }
            ,
            e.prototype.getRule = function(e) {
                return e < this.length ? this.nodes[e].textContent : ""
            }
            ,
            e
        }()
          , TF = function() {
            function e(e) {
                this.rules = [],
                this.length = 0
            }
            return e.prototype.insertRule = function(e, t) {
                return e <= this.length && (this.rules.splice(e, 0, t),
                this.length++,
                !0)
            }
            ,
            e.prototype.deleteRule = function(e) {
                this.rules.splice(e, 1),
                this.length--
            }
            ,
            e.prototype.getRule = function(e) {
                return e < this.length ? this.rules[e] : ""
            }
            ,
            e
        }()
          , RF = MN
          , PF = {
            isServer: !MN,
            useCSSOMInjection: !CN
        }
          , BF = function() {
            function e(e, t, n) {
                void 0 === e && (e = RN),
                void 0 === t && (t = {});
                var r = this;
                this.options = bO(bO({}, PF), e),
                this.gs = t,
                this.names = new Map(n),
                this.server = !!e.isServer,
                !this.server && MN && RF && (RF = !1,
                SF(this)),
                dF(this, (function() {
                    return function(e) {
                        for (var t = e.getTag(), n = t.length, r = "", i = function(n) {
                            var i = function(e) {
                                return mF.get(e)
                            }(n);
                            if (void 0 === i)
                                return "continue";
                            var o = e.names.get(i)
                              , a = t.getGroup(n);
                            if (void 0 === o || !o.size || 0 === a.length)
                                return "continue";
                            var s = "".concat(AN, ".g").concat(n, '[id="').concat(i, '"]')
                              , l = "";
                            void 0 !== o && o.forEach((function(e) {
                                e.length > 0 && (l += "".concat(e, ","))
                            }
                            )),
                            r += "".concat(a).concat(s, '{content:"').concat(l, '"}').concat(EN)
                        }, o = 0; o < n; o++)
                            i(o);
                        return r
                    }(r)
                }
                ))
            }
            return e.registerId = function(e) {
                return vF(e)
            }
            ,
            e.prototype.rehydrate = function() {
                !this.server && MN && SF(this)
            }
            ,
            e.prototype.reconstructWithOptions = function(t, n) {
                return void 0 === n && (n = !0),
                new e(bO(bO({}, this.options), t),this.gs,n && this.names || void 0)
            }
            ,
            e.prototype.allocateGSInstance = function(e) {
                return this.gs[e] = (this.gs[e] || 0) + 1
            }
            ,
            e.prototype.getTag = function() {
                return this.tag || (this.tag = (e = function(e) {
                    var t = e.useCSSOMInjection
                      , n = e.target;
                    return e.isServer ? new TF(n) : t ? new MF(n) : new CF(n)
                }(this.options),
                new pF(e)));
                var e
            }
            ,
            e.prototype.hasNameForId = function(e, t) {
                return this.names.has(e) && this.names.get(e).has(t)
            }
            ,
            e.prototype.registerName = function(e, t) {
                if (vF(e),
                this.names.has(e))
                    this.names.get(e).add(t);
                else {
                    var n = new Set;
                    n.add(t),
                    this.names.set(e, n)
                }
            }
            ,
            e.prototype.insertRules = function(e, t, n) {
                this.registerName(e, t),
                this.getTag().insertRules(vF(e), n)
            }
            ,
            e.prototype.clearNames = function(e) {
                this.names.has(e) && this.names.get(e).clear()
            }
            ,
            e.prototype.clearRules = function(e) {
                this.getTag().clearGroup(vF(e)),
                this.clearNames(e)
            }
            ,
            e.prototype.clearTag = function() {
                this.tag = void 0
            }
            ,
            e
        }()
          , IF = /&/g
          , LF = /^\s*\/\/.*$/gm;
        function kF(e, t) {
            return e.map((function(e) {
                return "rule" === e.type && (e.value = "".concat(t, " ").concat(e.value),
                e.value = e.value.replaceAll(",", ",".concat(t, " ")),
                e.props = e.props.map((function(e) {
                    return "".concat(t, " ").concat(e)
                }
                ))),
                Array.isArray(e.children) && "@keyframes" !== e.type && (e.children = kF(e.children, t)),
                e
            }
            ))
        }
        function DF(e) {
            var t, n, r, i = void 0 === e ? RN : e, o = i.options, a = void 0 === o ? RN : o, s = i.plugins, l = void 0 === s ? TN : s, c = function(e, r, i) {
                return i.startsWith(n) && i.endsWith(n) && i.replaceAll(n, "").length > 0 ? ".".concat(t) : e
            }, u = l.slice();
            u.push((function(e) {
                e.type === CO && e.value.includes("&") && (e.props[0] = e.props[0].replace(IF, n).replace(r, c))
            }
            )),
            a.prefix && u.push(fN),
            u.push(hN);
            var d = function(e, i, o, s) {
                void 0 === i && (i = ""),
                void 0 === o && (o = ""),
                void 0 === s && (s = "&"),
                t = s,
                n = i,
                r = new RegExp("\\".concat(n, "\\b"),"g");
                var l = e.replace(LF, "")
                  , c = mN(o || i ? "".concat(o, " ").concat(i, " { ").concat(l, " }") : l);
                a.namespace && (c = kF(c, a.namespace));
                var d, h = [];
                return dN(c, function(e) {
                    var t = zO(e);
                    return function(n, r, i, o) {
                        for (var a = "", s = 0; s < t; s++)
                            a += e[s](n, r, i, o) || "";
                        return a
                    }
                }(u.concat((d = function(e) {
                    return h.push(e)
                }
                ,
                function(e) {
                    e.root || (e = e.return) && d(e)
                }
                )))),
                h
            };
            return d.hash = l.length ? l.reduce((function(e, t) {
                return t.name || hF(15),
                UN(e, t.name)
            }
            ), 5381).toString() : "",
            d
        }
        var OF = new BF
          , NF = DF()
          , FF = t.createContext({
            shouldForwardProp: void 0,
            styleSheet: OF,
            stylis: NF
        })
          , UF = (FF.Consumer,
        t.createContext(void 0));
        function zF() {
            return (0,
            t.useContext)(FF)
        }
        function GF(e) {
            var n = (0,
            t.useState)(e.stylisPlugins)
              , r = n[0]
              , i = n[1]
              , o = zF().styleSheet
              , a = (0,
            t.useMemo)((function() {
                var t = o;
                return e.sheet ? t = e.sheet : e.target && (t = t.reconstructWithOptions({
                    target: e.target
                }, !1)),
                e.disableCSSOMInjection && (t = t.reconstructWithOptions({
                    useCSSOMInjection: !1
                })),
                t
            }
            ), [e.disableCSSOMInjection, e.sheet, e.target, o])
              , s = (0,
            t.useMemo)((function() {
                return DF({
                    options: {
                        namespace: e.namespace,
                        prefix: e.enableVendorPrefixes
                    },
                    plugins: r
                })
            }
            ), [e.enableVendorPrefixes, e.namespace, r]);
            (0,
            t.useEffect)((function() {
                xO()(r, e.stylisPlugins) || i(e.stylisPlugins)
            }
            ), [e.stylisPlugins]);
            var l = (0,
            t.useMemo)((function() {
                return {
                    shouldForwardProp: e.shouldForwardProp,
                    styleSheet: a,
                    stylis: s
                }
            }
            ), [e.shouldForwardProp, a, s]);
            return t.createElement(FF.Provider, {
                value: l
            }, t.createElement(UF.Provider, {
                value: s
            }, e.children))
        }
        var HF = function() {
            function e(e, t) {
                var n = this;
                this.inject = function(e, t) {
                    void 0 === t && (t = NF);
                    var r = n.name + t.hash;
                    e.hasNameForId(n.id, r) || e.insertRules(n.id, r, t(n.rules, r, "@keyframes"))
                }
                ,
                this.name = e,
                this.id = "sc-keyframes-".concat(e),
                this.rules = t,
                dF(this, (function() {
                    throw hF(12, String(n.name))
                }
                ))
            }
            return e.prototype.getName = function(e) {
                return void 0 === e && (e = NF),
                this.name + e.hash
            }
            ,
            e
        }()
          , jF = function(e) {
            return e >= "A" && e <= "Z"
        };
        function WF(e) {
            for (var t = "", n = 0; n < e.length; n++) {
                var r = e[n];
                if (1 === n && "-" === r && "-" === e[0])
                    return e;
                jF(r) ? t += "-" + r.toLowerCase() : t += r
            }
            return t.startsWith("ms-") ? "-" + t : t
        }
        var VF = function(e) {
            return null == e || !1 === e || "" === e
        }
          , XF = function(e) {
            var t, n, r = [];
            for (var i in e) {
                var o = e[i];
                e.hasOwnProperty(i) && !VF(o) && (Array.isArray(o) && o.isCss || oF(o) ? r.push("".concat(WF(i), ":"), o, ";") : cF(o) ? r.push.apply(r, _O(_O(["".concat(i, " {")], XF(o), !1), ["}"], !1)) : r.push("".concat(WF(i), ": ").concat((t = i,
                null == (n = o) || "boolean" == typeof n || "" === n ? "" : "number" != typeof n || 0 === n || t in _N || t.startsWith("--") ? String(n).trim() : "".concat(n, "px")), ";")))
            }
            return r
        };
        function JF(e, t, n, r) {
            return VF(e) ? [] : aF(e) ? [".".concat(e.styledComponentId)] : oF(e) ? !oF(i = e) || i.prototype && i.prototype.isReactComponent || !t ? [e] : JF(e(t), t, n, r) : e instanceof HF ? n ? (e.inject(n, r),
            [e.getName(r)]) : [e] : cF(e) ? XF(e) : Array.isArray(e) ? Array.prototype.concat.apply(TN, e.map((function(e) {
                return JF(e, t, n, r)
            }
            ))) : [e.toString()];
            var i
        }
        function KF(e) {
            for (var t = 0; t < e.length; t += 1) {
                var n = e[t];
                if (oF(n) && !aF(n))
                    return !1
            }
            return !0
        }
        var qF = zN(wN)
          , YF = function() {
            function e(e, t, n) {
                this.rules = e,
                this.staticRulesId = "",
                this.isStatic = (void 0 === n || n.isStatic) && KF(e),
                this.componentId = t,
                this.baseHash = UN(qF, t),
                this.baseStyle = n,
                BF.registerId(t)
            }
            return e.prototype.generateAndInjectStyles = function(e, t, n) {
                var r = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e, t, n) : "";
                if (this.isStatic && !n.hash)
                    if (this.staticRulesId && t.hasNameForId(this.componentId, this.staticRulesId))
                        r = sF(r, this.staticRulesId);
                    else {
                        var i = lF(JF(this.rules, e, t, n))
                          , o = NN(UN(this.baseHash, i) >>> 0);
                        if (!t.hasNameForId(this.componentId, o)) {
                            var a = n(i, ".".concat(o), void 0, this.componentId);
                            t.insertRules(this.componentId, o, a)
                        }
                        r = sF(r, o),
                        this.staticRulesId = o
                    }
                else {
                    for (var s = UN(this.baseHash, n.hash), l = "", c = 0; c < this.rules.length; c++) {
                        var u = this.rules[c];
                        if ("string" == typeof u)
                            l += u;
                        else if (u) {
                            var d = lF(JF(u, e, t, n));
                            s = UN(s, d + c),
                            l += d
                        }
                    }
                    if (l) {
                        var h = NN(s >>> 0);
                        t.hasNameForId(this.componentId, h) || t.insertRules(this.componentId, h, n(l, ".".concat(h), void 0, this.componentId)),
                        r = sF(r, h)
                    }
                }
                return r
            }
            ,
            e
        }()
          , QF = t.createContext(void 0);
        QF.Consumer;
        var ZF = {};
        new Set;
        function $F(e, n, r) {
            var i = aF(e)
              , o = e
              , a = !jN(e)
              , s = n.attrs
              , l = void 0 === s ? TN : s
              , c = n.componentId
              , u = void 0 === c ? function(e, t) {
                var n = "string" != typeof e ? "sc" : kN(e);
                ZF[n] = (ZF[n] || 0) + 1;
                var r = "".concat(n, "-").concat(GN(wN + n + ZF[n]));
                return t ? "".concat(t, "-").concat(r) : r
            }(n.displayName, n.parentComponentId) : c
              , d = n.displayName
              , h = void 0 === d ? function(e) {
                return jN(e) ? "styled.".concat(e) : "Styled(".concat(HN(e), ")")
            }(e) : d
              , p = n.displayName && n.componentId ? "".concat(kN(n.displayName), "-").concat(n.componentId) : n.componentId || u
              , f = i && o.attrs ? o.attrs.concat(l).filter(Boolean) : l
              , m = n.shouldForwardProp;
            if (i && o.shouldForwardProp) {
                var g = o.shouldForwardProp;
                if (n.shouldForwardProp) {
                    var v = n.shouldForwardProp;
                    m = function(e, t) {
                        return g(e, t) && v(e, t)
                    }
                } else
                    m = g
            }
            var y = new YF(r,p,i ? o.componentStyle : void 0);
            function b(e, n) {
                return function(e, n, r) {
                    var i = e.attrs
                      , o = e.componentStyle
                      , a = e.defaultProps
                      , s = e.foldedComponentIds
                      , l = e.styledComponentId
                      , c = e.target
                      , u = t.useContext(QF)
                      , d = zF()
                      , h = e.shouldForwardProp || d.shouldForwardProp
                      , p = PN(n, u, a) || RN
                      , f = function(e, t, n) {
                        for (var r, i = bO(bO({}, t), {
                            className: void 0,
                            theme: n
                        }), o = 0; o < e.length; o += 1) {
                            var a = oF(r = e[o]) ? r(i) : r;
                            for (var s in a)
                                i[s] = "className" === s ? sF(i[s], a[s]) : "style" === s ? bO(bO({}, i[s]), a[s]) : a[s]
                        }
                        return t.className && (i.className = sF(i.className, t.className)),
                        i
                    }(i, n, p)
                      , m = f.as || c
                      , g = {};
                    for (var v in f)
                        void 0 === f[v] || "$" === v[0] || "as" === v || "theme" === v && f.theme === p || ("forwardedAs" === v ? g.as = f.forwardedAs : h && !h(v, m) || (g[v] = f[v]));
                    var y = function(e, t) {
                        var n = zF();
                        return e.generateAndInjectStyles(t, n.styleSheet, n.stylis)
                    }(o, f)
                      , b = sF(s, l);
                    return y && (b += " " + y),
                    f.className && (b += " " + f.className),
                    g[jN(m) && !BN.has(m) ? "class" : "className"] = b,
                    g.ref = r,
                    (0,
                    t.createElement)(m, g)
                }(_, e, n)
            }
            b.displayName = h;
            var _ = t.forwardRef(b);
            return _.attrs = f,
            _.componentStyle = y,
            _.displayName = h,
            _.shouldForwardProp = m,
            _.foldedComponentIds = i ? sF(o.foldedComponentIds, o.styledComponentId) : "",
            _.styledComponentId = p,
            _.target = i ? o.target : e,
            Object.defineProperty(_, "defaultProps", {
                get: function() {
                    return this._foldedDefaultProps
                },
                set: function(e) {
                    this._foldedDefaultProps = i ? function(e) {
                        for (var t = [], n = 1; n < arguments.length; n++)
                            t[n - 1] = arguments[n];
                        for (var r = 0, i = t; r < i.length; r++)
                            uF(e, i[r], !0);
                        return e
                    }({}, o.defaultProps, e) : e
                }
            }),
            dF(_, (function() {
                return ".".concat(_.styledComponentId)
            }
            )),
            a && iF(_, e, {
                attrs: !0,
                componentStyle: !0,
                displayName: !0,
                foldedComponentIds: !0,
                shouldForwardProp: !0,
                styledComponentId: !0,
                target: !0
            }),
            _
        }
        function eU(e, t) {
            for (var n = [e[0]], r = 0, i = t.length; r < i; r += 1)
                n.push(t[r], e[r + 1]);
            return n
        }
        var tU = function(e) {
            return Object.assign(e, {
                isCss: !0
            })
        };
        function nU(e) {
            for (var t = [], n = 1; n < arguments.length; n++)
                t[n - 1] = arguments[n];
            if (oF(e) || cF(e))
                return tU(JF(eU(TN, _O([e], t, !0))));
            var r = e;
            return 0 === t.length && 1 === r.length && "string" == typeof r[0] ? JF(r) : tU(JF(eU(r, t)))
        }
        function rU(e, t, n) {
            if (void 0 === n && (n = RN),
            !t)
                throw hF(1, t);
            var r = function(r) {
                for (var i = [], o = 1; o < arguments.length; o++)
                    i[o - 1] = arguments[o];
                return e(t, n, nU.apply(void 0, _O([r], i, !1)))
            };
            return r.attrs = function(r) {
                return rU(e, t, bO(bO({}, n), {
                    attrs: Array.prototype.concat(n.attrs, r).filter(Boolean)
                }))
            }
            ,
            r.withConfig = function(r) {
                return rU(e, t, bO(bO({}, n), r))
            }
            ,
            r
        }
        var iU = function(e) {
            return rU($F, e)
        }
          , oU = iU;
        BN.forEach((function(e) {
            oU[e] = iU(e)
        }
        ));
        !function() {
            function e(e, t) {
                this.rules = e,
                this.componentId = t,
                this.isStatic = KF(e),
                BF.registerId(this.componentId + 1)
            }
            e.prototype.createStyles = function(e, t, n, r) {
                var i = r(lF(JF(this.rules, t, n, r)), "")
                  , o = this.componentId + e;
                n.insertRules(o, o, i)
            }
            ,
            e.prototype.removeStyles = function(e, t) {
                t.clearRules(this.componentId + e)
            }
            ,
            e.prototype.renderStyles = function(e, t, n, r) {
                e > 2 && BF.registerId(this.componentId + e),
                this.removeStyles(e, n),
                this.createStyles(e, t, n, r)
            }
        }();
        (function() {
            function e() {
                var e = this;
                this._emitSheetCSS = function() {
                    var t = e.instance.toString();
                    if (!t)
                        return "";
                    var n = wF()
                      , r = lF([n && 'nonce="'.concat(n, '"'), "".concat(AN, '="true"'), "".concat(SN, '="').concat(wN, '"')].filter(Boolean), " ");
                    return "<style ".concat(r, ">").concat(t, "</style>")
                }
                ,
                this.getStyleTags = function() {
                    if (e.sealed)
                        throw hF(2);
                    return e._emitSheetCSS()
                }
                ,
                this.getStyleElement = function() {
                    var n;
                    if (e.sealed)
                        throw hF(2);
                    var r = e.instance.toString();
                    if (!r)
                        return [];
                    var i = ((n = {})[AN] = "",
                    n[SN] = wN,
                    n.dangerouslySetInnerHTML = {
                        __html: r
                    },
                    n)
                      , o = wF();
                    return o && (i.nonce = o),
                    [t.createElement("style", bO({}, i, {
                        key: "sc-0-0"
                    }))]
                }
                ,
                this.seal = function() {
                    e.sealed = !0
                }
                ,
                this.instance = new BF({
                    isServer: !0
                }),
                this.sealed = !1
            }
            e.prototype.collectStyles = function(e) {
                if (this.sealed)
                    throw hF(2);
                return t.createElement(GF, {
                    sheet: this.instance
                }, e)
            }
            ,
            e.prototype.interleaveWithNodeStream = function(e) {
                throw hF(3)
            }
        }
        )(),
        "__sc-".concat(AN, "__");
        const aU = oU(pO)({
            ".Mui-selected": {
                color: "#000"
            }
        });
        function sU(e) {
            let {menu: t, value: n, setValue: r, tabVal: i} = e;
            const o = OP();
            return (0,
            mt.jsx)(vO, {
                showLabels: !0,
                value: n,
                onChange: (e, t) => {
                    r(t),
                    o(t)
                }
                ,
                className: "bg-transparent mt-14",
                children: t.map(( (e, t) => (0,
                mt.jsx)(aU, {
                    label: e.label,
                    icon: (0,
                    mt.jsx)("img", {
                        src: e.src,
                        alt: e.alt,
                        style: {
                            maxWidth: "110%"
                        }
                    }),
                    className: "text-black"
                }, `b${t + 1}`)))
            })
        }
        function lU(e) {
            let {lessons: n, files: r, prefix: i=null, offset: o=0} = e;
            const a = m((e => e.app.isChangeStars))
              , s = LP()
              , l = kP()
              , c = ( () => {
                const e = C();
                return (0,
                t.useCallback)((t => e(qe(t))), [e])
            }
            )()
              , u = DP()
              , d = UP();
            return (0,
            mt.jsx)(St, {
                children: (0,
                mt.jsx)(vO, {
                    showLabels: !0,
                    onChange: (e, t) => {
                        const n = r[t + o + 1] || "7A03_1";
                        return "BOX" === n ? (l(!0),
                        void c("This lesson use Funny Box 3D card software")) : "Presentation" === n ? (l(!0),
                        void c("This lesson is a comprehensive review, please select the lesson plan and click on the required level")) : (u(`${n}.swf`),
                        s(!1),
                        void (a && d(!0)))
                    }
                    ,
                    className: "bg-transparent h-32",
                    children: n.map(( (e, t) => (0,
                    mt.jsx)(aU, {
                        value: t,
                        label: e.label,
                        icon: (0,
                        mt.jsx)("img", {
                            src: e.src,
                            alt: e.label,
                            style: {
                                maxWidth: "115%"
                            }
                        })
                    }, i + t)))
                })
            })
        }
        function cU(e) {
            let {menu: n, lessons: r, lessons2: i, files: o, tabVal: a} = e;
            const [s,l] = t.useState(0)
              , c = m((e => e.app.phase))
              , u = OP()
              , {t: d} = Pk();
            return (0,
            mt.jsx)(mt.Fragment, {
                children: (0,
                mt.jsxs)(St, {
                    sx: {
                        width: "100%",
                        height: 420
                    },
                    children: [null === c && (0,
                    mt.jsx)(sU, {
                        menu: n,
                        value: s,
                        setValue: l,
                        tabVal: a
                    }), null !== c && (0,
                    mt.jsxs)(mt.Fragment, {
                        children: [(0,
                        mt.jsx)("div", {
                            className: "my-4"
                        }), (0,
                        mt.jsx)(lU, {
                            lessons: r[c],
                            files: o[c],
                            prefix: "first-"
                        }), (0,
                        mt.jsx)("div", {
                            className: "mt-8"
                        }), (0,
                        mt.jsx)(lU, {
                            lessons: i[c],
                            files: o[c],
                            prefix: "second-",
                            offset: 6
                        }), (0,
                        mt.jsx)("div", {
                            className: "flex justify-center mt-8",
                            children: (0,
                            mt.jsx)(KI, {
                                size: "small",
                                variant: "contained",
                                className: "bg-primary capitalize",
                                startIcon: (0,
                                mt.jsx)(yO.A, {}),
                                onClick: () => {
                                    u(null)
                                }
                                ,
                                children: d("back")
                            })
                        })]
                    })]
                })
            })
        }
        const uU = __webpack_require__.p + "static/media/btn_cn_01@2x.df7d45fb0732388f60bd.png"
          , dU = __webpack_require__.p + "static/media/btn_cn_02@2x.ec63c8001b167b33badb.png"
          , hU = __webpack_require__.p + "static/media/btn_cn_03@2x.06c592fa13ceefc41ba6.png"
          , pU = __webpack_require__.p + "static/media/btn_cn_04@2x.d6960e2495dd2e569d67.png";
        __webpack_require__.p,
        __webpack_require__.p,
        __webpack_require__.p,
        __webpack_require__.p;
        function fU() {
            const e = ( () => {
                const e = C();
                return (0,
                t.useCallback)((t => e(Ze(t))), [e])
            }
            )()
              , n = NP()
              , r = [{
                label: 1,
                src: uU,
                alt: "Star1"
            }, {
                label: 2,
                src: dU,
                alt: "Star2"
            }, {
                label: 3,
                src: hU,
                alt: "Star3"
            }, {
                label: 4,
                src: pU,
                alt: "Star4"
            }];
            return (0,
            mt.jsx)(mt.Fragment, {
                children: (0,
                mt.jsx)(St, {
                    sx: {
                        width: "100%",
                        height: 420
                    },
                    children: (0,
                    mt.jsx)(vO, {
                        showLabels: !0,
                        value: "0",
                        onChange: (t, r) => {
                            n(r),
                            e(!1)
                        }
                        ,
                        className: "bg-transparent mt-14",
                        children: r.map(( (e, t) => (0,
                        mt.jsx)(pO, {
                            icon: (0,
                            mt.jsx)("img", {
                                src: e.src,
                                alt: e.alt,
                                style: {
                                    maxWidth: "115%"
                                }
                            }),
                            className: "text-black"
                        }, `s${t + 1}`)))
                    })
                })
            })
        }
        function mU(e) {
            return {
                id: `simple-tab-${e}`,
                "aria-controls": `simple-tabpanel-${e}`
            }
        }
        function gU(e) {
            const {children: t, value: n, index: r, ...i} = e;
            return (0,
            mt.jsx)("div", {
                role: "tabpanel",
                hidden: n !== r,
                id: `simple-tabpanel-${r}`,
                "aria-labelledby": `simple-tab-${r}`,
                ...i,
                children: n === r && (0,
                mt.jsx)(St, {
                    sx: {
                        p: 3
                    },
                    children: (0,
                    mt.jsx)(XP, {
                        children: t
                    })
                })
            })
        }
        const vU = e => {
            let {openDialog: n, setOpenDialog: r} = e;
            const i = m((e => e.app.stars))
              , o = m((e => e.app.showStars))
              , a = m((e => e.app.isBoxDialog))
              , s = m((e => e.app.boxMsg))
              , {i18n: l} = Pk()
              , {t: c} = Pk()
              , u = LP()
              , d = kP()
              , h = NP()
              , p = FP()
              , [f,g] = t.useState(!0)
              , [v,y] = t.useState(!0)
              , b = Ik
              , _ = Lk
              , [A,x] = t.useState(b)
              , [S,w] = t.useState(0)
              , E = m((e => e.app.phase))
              , M = OP()
              , C = () => {
                g(!1)
            }
            ;
            (0,
            t.useEffect)(( () => {
                const e = localStorage.getItem("noWelcome");
                !1 !== e && null !== e || (r(!0),
                u(!0))
            }
            ), []);
            const T = {
                menu: Xk(c),
                lessons: $D,
                lessons2: eO,
                files: oO,
                tabVal: i
            }
              , R = {
                menu: Jk(c),
                lessons: tO,
                lessons2: nO,
                files: aO,
                tabVal: i
            }
              , P = {
                menu: Kk(c),
                lessons: rO,
                lessons2: iO,
                files: sO,
                tabVal: i
            };
            return (0,
            mt.jsx)(mt.Fragment, {
                children: (0,
                mt.jsxs)(sI, {
                    fullScreen: !0,
                    open: n,
                    onClose: () => {}
                    ,
                    children: [(0,
                    mt.jsx)("div", {
                        className: "h-10 pl-1 bg-primary",
                        children: (0,
                        mt.jsx)(KI, {
                            onClick: e => {
                                const t = "tw" === l.language ? "cn" : "tw";
                                l.language !== t && (l.changeLanguage(t),
                                window.localStorage.setItem("language", l.language))
                            }
                            ,
                            value: l.language,
                            className: "text-[#CE0000]",
                            children: l.language
                        })
                    }), (0,
                    mt.jsx)($I, {
                        className: "border-4 border-primary",
                        children: (0,
                        mt.jsxs)(vL, {
                            maxWidth: "md",
                            component: "main",
                            className: "fixed top-2 left-1/2 -translate-x-1/2 z-9",
                            children: [(0,
                            mt.jsxs)(TL, {
                                container: !0,
                                spacing: 0,
                                alignItems: "flex-center",
                                justify: "center",
                                children: [(0,
                                mt.jsx)(TL, {
                                    item: !0,
                                    xs: 4,
                                    md: 4
                                }), (0,
                                mt.jsx)(TL, {
                                    item: !0,
                                    xs: 4,
                                    md: 4,
                                    children: (0,
                                    mt.jsx)("img", {
                                        src: Bk,
                                        alt: "title"
                                    })
                                }), (0,
                                mt.jsx)(TL, {
                                    item: !0,
                                    xs: 4,
                                    md: 4
                                })]
                            }), o && (0,
                            mt.jsx)(fU, {}), !1 === o && (0,
                            mt.jsxs)(mt.Fragment, {
                                children: [(0,
                                mt.jsx)(St, {
                                    sx: {
                                        borderBottom: 1,
                                        borderColor: "divider"
                                    },
                                    children: (0,
                                    mt.jsxs)(ck, {
                                        value: i,
                                        onChange: (e, t) => {
                                            i !== t && p(!0),
                                            h(t),
                                            M(null)
                                        }
                                        ,
                                        "aria-label": "basic tabs",
                                        textColor: "secondary",
                                        indicatorColor: "secondary",
                                        children: [(0,
                                        mt.jsx)(fk, {
                                            label: c("beginner") + (0 == i && null !== E ? `(${E + 1})` : "") + " \u2605",
                                            ...mU(0),
                                            className: "capitalize"
                                        }), (0,
                                        mt.jsx)(fk, {
                                            label: c("intermediate") + (1 == i && E ? `(${E + 1})` : "") + " \u2605\u2605",
                                            ...mU(1),
                                            className: "capitalize"
                                        }), (0,
                                        mt.jsx)(fk, {
                                            label: c("advanced") + (2 == i && E ? `(${E + 1})` : "") + " \u2605\u2605\u2605",
                                            ...mU(2),
                                            className: "capitalize"
                                        }), (0,
                                        mt.jsx)(fk, {
                                            label: c("master") + (3 == i && E ? `(${E + 1})` : "") + " \u265b",
                                            ...mU(3),
                                            className: "capitalize",
                                            disabled: !0
                                        })]
                                    })
                                }), (0,
                                mt.jsx)(gU, {
                                    value: i,
                                    index: 0,
                                    children: (0,
                                    mt.jsx)(cU, {
                                        ...T
                                    })
                                }), (0,
                                mt.jsx)(gU, {
                                    value: i,
                                    index: 1,
                                    children: (0,
                                    mt.jsx)(cU, {
                                        ...R
                                    })
                                }), (0,
                                mt.jsx)(gU, {
                                    value: i,
                                    index: 2,
                                    children: (0,
                                    mt.jsx)(cU, {
                                        ...P
                                    })
                                }), (0,
                                mt.jsx)(gU, {
                                    value: i,
                                    index: 3
                                })]
                            })]
                        })
                    }), (0,
                    mt.jsx)(sI, {
                        open: f,
                        onClose: C,
                        className: "z-999 scale-150",
                        children: (0,
                        mt.jsx)($I, {
                            children: (0,
                            mt.jsxs)("div", {
                                className: "relative",
                                children: [(0,
                                mt.jsx)("img", {
                                    src: A,
                                    alt: "class1",
                                    className: "w-full"
                                }), (0,
                                mt.jsx)("div", {
                                    className: "absolute bottom-2 right-0",
                                    children: v ? (0,
                                    mt.jsx)(KI, {
                                        onClick: () => (0 == S && x(_),
                                        0 == S && y(!1),
                                        void w(S + 1)),
                                        children: (0,
                                        mt.jsx)("img", {
                                            src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOAAAABGCAYAAADVaJgSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAF0WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDIgNzkuZjM1NGVmYzcwLCAyMDIzLzExLzA5LTEyOjA1OjUzICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjUuNCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjQtMDItMTlUMTc6MTE6MDkrMDg6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDI0LTAyLTE5VDE3OjEzOjI5KzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0LTAyLTE5VDE3OjEzOjI5KzA4OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDplZTg3NDBiNC1iY2Q5LTRhZGEtYjEwYy04ZGQ3NDhhOTBmMDAiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDphMzMxMDhkYS04OGI4LTUzNDAtYjhlNy1lY2M3OWM2NzljMTIiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpmNWZjNTQ1Mi0yM2ZiLTQwZGMtODMzNC04ODRjYmQ1ZDcyMTAiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmY1ZmM1NDUyLTIzZmItNDBkYy04MzM0LTg4NGNiZDVkNzIxMCIgc3RFdnQ6d2hlbj0iMjAyNC0wMi0xOVQxNzoxMTowOSswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjQgKE1hY2ludG9zaCkiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmVlODc0MGI0LWJjZDktNGFkYS1iMTBjLThkZDc0OGE5MGYwMCIgc3RFdnQ6d2hlbj0iMjAyNC0wMi0xOVQxNzoxMzoyOSswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjQgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+UL9+bAAAEOVJREFUeJztnXtQVFeex7+CoPTDaGbISK8RkEfPsJuECCauYIEzZQSG0s3aq0EyzEyRIljRSYj4zJSTMRVLfKwmWCXjypZOFokGM9EwgONWASOktASFqinWFlTU8j2TjNM0qAjsH92n+9xzz+0H9BPPp+rU7b59b/dtqj/8zjm/c8+ZMDIyAl+wrnjpBJ98kEAwRrZXHPONFAAmeEtABeFc3ScQ+ALej1+2z5tCelxARjzeY6WtQOBrRpgtb59EEE/L6DEBOeJNYB6zBZytQOAreKLxCu9Yj4k4ZgEVxKNLiMKWlREQIgq8Dxvt6DLMbNnHYB6PWcRRC+hEvBBOCWWek+PI+fRWIPAWbDSjpXNWuBFyLBKOSkBKPiXxQp0UVkQhoMBXsJGMFmyI2tKFfY0XGUclotsCcuRjo1wogIkOCishryoqEHgTttrJSveE2j5hntNSslHRbQndEpCRjxWPlixModACEglFW1DgC5TafnR0o0UbpLaDzHNHIrolocsCWuVjq5u0eESycE4JmxEdN21eRtZs3fOxyVOemTYrQq2dFRoaqnL1QgUCbzE0NNQ/YDZd6TM96Ll542rHN00N7Td6u7+DXbzHVCHP6ejIthNdltAlARn52KhHSzeJKeHLCt7JjPvhC4umPRv5qisXJBAEAn//7q9nLhv/0nDkYHkTgEewSPeIKkRIuorqtoROBVSQj0Q9WrzJVJlUULwuN/FHyT8LnzQp0o3vLRAEFIOPH9271NX52aGKsq8BPKQKLSKJlG5L6FBAqs1Ht/foqEeLFwFg8k+XFrw6LyOrNCx80nOj+cICQSAy+PjRvTOn/7T96y8OngUwYC20jKOSUFFATocLW+WkxVPNiI6LNLy5slD3fOxiZ1/GPGBGz/Vu9FzvRl9/n7PDBQKvoVFpED8zAfEzE6COUDs9/s7Na1998dm+Azd6u+9BLiItIUlXjLgtoEJvJ5GPRL0IACoAquQ56bGv5xVtiVCpY5U+6O7f7qDl/Gk0tNaj53q30y8qEPia+JkJyErLRvrs+fjB96YrHjfQb756/MiBD86f/fMVAP3WMgBplZSOhIpR0JGApJCUASufGoAq47UlL2Ytyd+p1KPZaexAzamjaDl/2oU/gUAQGKTPng/DwmV4SZ/MfX14eMh88kT1+40Nf+gEYIZdQjYSOqyKygTktPuIfKTaqbIWjSP5zANm7D38CRpa69386gJB4JCVlo1VK97lVk8tEn5e0tjwZSeAPsgjIekdVayKhrA7rPByfXSniyp5Tnqsknydxg68sdYg5BMEPQ2t9XhjrQGdxg7ZayEhoepFi9/YnTI3MxbWTkhY896wOEOP9uLeIysRUGGYGdvxEjEjOi7y9byiLTz5TrbW472y1aJzRTBu6Ovvw3tlq3GSE1BCQkLVS5YXbo2epY+ENQUH6agvdryz9HzOPl70o9t/kw1vrizkdbiUVW7Ftsqt7n9DgSAI2Fa5FWWc3/fkCNWspW8WF8EuYDjsuXKJgGwUtAmoEP1k1c+fLi14lZdqONlaL6qcgnFPQ2s9NxJO1818fcnywrmwV0OJhA6jIBsBlaKfbZjZvIysUvZNOo0dIvIFOFq1FkWGYvxm5RZkzlng78sJarZVbuW2CV9J+8lG2IdhKlZD6SgYwuxwKGBB8bpcdoSLecCMX5dv9Ny3E3iF3IzFyMvJR+acBXi/YK2/Lyfo+XX5RpgHzJJ9YeGTnvvlOxuXQDkCAkwUnEg9djbyJTzxR8k/Yy9k7+FPAqLDZWfpbqQkpXr1M9q72lC6s8SrnzEWfrf5ABJj9Lh9/xbW7CzB7fu3uMdp1VofX9n4o6+/D3sPf4L1hZsk++P1L/wCwFew3x1E375kywkSJkKK4t0OywreyWQHVncaOwKm3edt+Xz1GWMhMUYPAIiK1EEXqVMUELD8w1KivasN1XVVHr++8UZDaz2y0nMkyfqw8EnPrSgs+fHhyt11kEZAuho6sq546YTtFcdGeALyImBY3A9fWMReQM2po57/VgKf4OifSUpSakALmJWWjenfjwIAtFw47dehjTWnjspGy8QmJOUAOAXpDejcTpiJDtp/NgFnRMdNY+/nI2M7A4X9NRUuRShdpA5RkTrb8/auNpc/w51jgxlHkTMQoKOO4bVleK9std8kbDl/Gnf/dkcydvSZqc/Oi47TT7122dgP5elXRgB7FdRRJ8zEeRlZs3kfHEhU11W59F87LycfRYZi2/NAbtN5k/01FYqvBbqANOoINfasL/e7hEsX/odkX1pmzpxrl421cJKGYDthuDOb6Z6PTWZPDJS2n2B0BHIV0xlsp5+/JWxorZcJGDUj5mUA9eBHQBuO8oA2Cac8M20WfRC5n288kJeT7+9LELjJtsqPcflGj2QfkTB+ZoLPr6fnercsJaHRTEmA40moASinISQSRqi1EgHHi3wAUGQoRmbqAuz6/Q5c6jX6+3JcJi8n32Gbt8hQDFO/yfZcR7V7Ace9oIRA7Q0lYzP3rC9H3PPxtv3+jIQ917slnTERanUclOe+lbUBwbwomdWaHXQ9ngQELN33v9t8APtrKgLyB8cjLzvfYT6PpCSUcDWlEqh/j0CTkBUwJCRUDeW1UGzQnTDsQYphMxAS796gyFCMlKRU/HbfZpjMJucnwJ789iYmswn5G5ZLrqmv3/TUJ9QDSUIFJxzOb7uueOkEXgRkt+N6klyTWfpDTklKRdW2I/jtvs0upR28LR9gGbmSGK2XXM+H+zYrRjFdpA4ms0lWBc3NsI+hr20+gVtOejt9lXbRqDTISsuBRqUZ1fkdFy9IBAT83zHDoOgRKyB70rjn7S1vYc3P10p+zFq1FjtLdwdUlZSWCQAu9Rq5bdbcjMXINSyGyWxC6a4S2zEpSakSAZvONUoE06q1ttebzjX6NBWxKu9XWJSW7fH3VUeosSrvV3ivbLXH39tTOBLQZ8v0+pPb92+hdGcJ8nLyZe2qIkMxdJE67K+pUKySujoAYCwoycaSGKO35Ti1ai1SklJd7lh6v2Ct7S6JlKRUn+ZHvSFfsMAKqLRo4binuq4K7V1t+HDlFslIGRIVdh3aoXheIERJrVqLD1dukfwDcadXl+0l9SWtF1qQ9nK63z7fW7yavjDqbMupB3DgERFQaTXQp0ZAwPKDfXvLW/jNyi2SqBblxx+nK2jVWuxcs1tynWwV09n5dFvW1yNhtlV+DMPCZWN6D8Nry7gTJzW01I3pfcfC2ZZTDv+QvMHYvDXThtkTR9tYDgZMZhNKd5Zgzc/X2qJfbfMJP1+VMokxelnUvtRrRG3zCRwuOwJjrxHtXW3QO+gsotuGAJx2zniavv4+HDz+36M+f0PhJq58ZZVbfTZiS8EJpaWubUxkDqZPsq2bNjQ01E/nAv0x2sDX7Dq0A19bxQvUBH1uxmIUGYol1U7S+VJkKEaUdeC5ozvgE2P0yMuWjgYK5H84LBsKN3HbkL6UD5A7MTw8ZAZn6TLmMbcNyC5aODxgNl3RTJn6L0ofNl4JVPEA+aBywHK9pbtKYDKbHEYxk9mES9eM0Kq1WFOwViJwdV2VyzlQfxMo8gFyJwb6zT3gL2stgR0Lylsx9Emf6YFk4J06Qv3USBgstHe12eQDLFFsf02FrD1nMpuwv6YCGakLULXtiKTtd6nXiOp6/3couUKgycdWgc19pm5IF/+ULWkNyDthuMv23rxxtWP6P0X/G31iVlo29vo/wfnUUtt8ApmpC5AYo0d1XZXs9iKT2WTroSV3yCfG6KFVabEiJ1/WsURHz0BHKW/oD/kAiwssd25ea4d8Kgp5G3B7xbER6qZcVr4nAJ5809TQnjI3U3Ji+uz52Fv9qee+hcAtTGYT3t7yFvc1IlxUpM6WD3SUq2w614j//P2OoJAP4DeB/CUfYHGBpbWx7hz4C3cqtgF562YPARi80dv93d+/++uZqdO+P5cc/IPvTUf67PkBd2Pu0wSZapBEM3cHBNy+fwu7Du0Iujv9Oy5ekAx89rd87EpK/3jwbevVnv/7FtK15PkRkHnOCkiW3x28bPxLQ8rczLn0wYaFy4SAfiQ3Y7EsheAKTeca0dzWiKZzjV64Ku/TYbwAHLc87rnR7dffIC9/2dtzsRby2dAk1VCyUAsbASdAXgUdBDB45GB504uz//UePS/oS/pkZKVli7vjA5z2rjbLcLZrlpxgsFQ1lei4eAEdFy/4+zKQlZYtm5BpcPDx3f/5r13/C/sSZYpTEgJWAal2INsJQwR8DODRpa7Oz/45+ZU19BusWvEuWi6cDppblNq72lDbfAJRkbqgq3qx1DafkE0ydfv+Ldy6f8uWagjkVEowo1FpsGrFu7L9V7u7KmHxhV6ejJZPIqFtfUDOopz0gixqAFoA2o8/PXyUnR2709gR0CPOBQJPs2d9OTf6fbA6LxeACZZFO8lagZLFOul1Anl5QLIlEfAJrBEQwMMzp/+0nb2Yl/TJ2MDMECwQjFc2FG7irpx7/kzzR5AuU+00DWETkLKSHGjrBbWWRwAefv3FwbN3bl77in2jRWnZ3HyIQDCeyErL5uYg7925WXOsquIb8NeJl3W+EHjrA9LpCNIRY4uAAAa++GzfgYF+81X2xPWFm0QkFIxbNhRukq0FAQAPHw5c/rKqYh8sfpAqp9PoBzACMlGQ7Q0lEg7c6O2+d/zIgQ+sA04lLErLxp715eP6jgnB04VGpcGe9eXcyDc8PGT+47FDpVe6u+5BKqDT6AcorxHPywdKouD5s3++cvJE9fs8CV/SJ+PzHTWiSioIerLSsvH5jhpum294eMjcePKrlWdPn7oCe4eLYvWTh60XlIYamkZP0Esv1BkBQAVAtSDr319ctPiN3dZp2GR0GjtQc+qoSNgLgor02fNhWLiMKx5gl+/k8cOdAPphF/AR7J2XNgF50Q9QEBDgpiWIhGGwrhUPq4gpczNjlywv3Do5QjWL+2awL+bS0FofCLNUCQQy4mcmICstmzu8jObhw4HLfzx2qNQa+fphqRU+hDz62fJ/oxUQkE9VTyQkOcLJACKiZ+kjl75ZXDRdN/N1Z1+UTG3fc707aBL4gvGJRqVB/MwE7i1FPO7duVnzZVXFPmubbwDSdh/pfHFJPsCBgIBLEpIqKRFx8pLlhXNfSfvJRjZZLxAEM4ODj++eP9P8kTXVQCIeafPRo14kI18cyQc4ERBwKOFEayHrYZPF6ScDmPTLdzYuide/8AshoiCYGRx8fPdqd1flgU8/+gPsbTxSlBLuw4Bz+QAXBAQUJQyBXUI6IhIZwwGErygs+XFsQlLOM1OfnefidxYI/M4/Hnzb2ttzsdY6sJpkAEi0G6QKHfVcjnwElwQEZBIqRUMSEcOobRiAsOg4/dS0zJw5UTNiXtZopiREqNVxSj2nAoEvGR4eMg/0m3vMfabuOzevtbc21p2z3s9HJGOlo6ub5F4/t+UD3BAQ4EroSEQSGennpDdVccFCgcCH8KbhfMKUQeY5G/GcJtsd4ZaAgERCgL+cWSika8yHcgo5R3HZJoHAy7Cjvujxz3Rhox1veolRyQeMQkCCQjTkyUhveYvVA0JAge/hzQBPR7UhZqsoHjA6+YAxCAgoRkOejBM4W/ZcgcCXjDCP6UhIb3nSjVk8wpgEJCiISD/mFUCIJ/A/vEjIk82j4hE8IiCBI6IrW4HA37DTRShtPSYewaMCEhgRbZ/l5LlA4C9YCWRSeFo8glcEpFGQUSAIeLwlHY3XBXSGEFTgL3whmDP+Hx1tT7jwFNQDAAAAAElFTkSuQmCC",
                                            alt: "BtnNext",
                                            width: "112px"
                                        })
                                    }) : (0,
                                    mt.jsx)(KI, {
                                        onClick: () => C(),
                                        children: (0,
                                        mt.jsx)("img", {
                                            src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOAAAABGCAYAAADVaJgSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAF0WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDIgNzkuZjM1NGVmYzcwLCAyMDIzLzExLzA5LTEyOjA1OjUzICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjUuNCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjQtMDItMTlUMTc6MTE6MDkrMDg6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDI0LTAyLTE5VDE3OjEzOjQzKzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0LTAyLTE5VDE3OjEzOjQzKzA4OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDphYTE1YWVhYy1lZTU4LTQyN2ItOTQxYS1lY2U0MDlmNjliNjQiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo4YmYzYTM5ZS0zZjM2LTkxNDItYmE1NC1hNmFmZTVkZmVmMzUiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowYmVkYWY5Yy02OTU3LTQyMzktODgyOC1mZjlmNzM1MDAxZmYiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjBiZWRhZjljLTY5NTctNDIzOS04ODI4LWZmOWY3MzUwMDFmZiIgc3RFdnQ6d2hlbj0iMjAyNC0wMi0xOVQxNzoxMTowOSswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjQgKE1hY2ludG9zaCkiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmFhMTVhZWFjLWVlNTgtNDI3Yi05NDFhLWVjZTQwOWY2OWI2NCIgc3RFdnQ6d2hlbj0iMjAyNC0wMi0xOVQxNzoxMzo0MyswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjQgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+XzQAvwAAEj1JREFUeJztnXtQVFeex7+ConRzjSYhEcrwkEdn2M0EBSaWYAGz5QqMpeXKapCMkxksg5U40QQ1JimdIbXu+CqTkC0ZV2e0svgKZiJhAMetAkZJaSkGqqbYNKCCloiPJJNpGhQE94/uc/vc0+d23wb66flUnbrdt++177X6w++c3zn3nAmPHj2CJ9hUvGyCR75IIBgjO8tPekYKABPcJaCKcFr3CQSegPfjt9vnTiHHXUBGPN5rta1A4GkeMVvePoUg4y3juAnIEW8C85ot4GwFAk/BE41XeMeOm4hjFlBFPLoEqWxZGQEhosD9sNGOLiPMln0N5vWYRRy1gE7EC+KUYOY9OY6cT28FAnfBRjNaOmeFGyHHIuGoBKTkUxMv2ElhRRQCCjwFG8lowYapLV3Yz3iRcVQiuiwgRz42ygUDmOigsBLyqqICgTthq52sdA+p7UPmPS0lGxVdltAlARn5WPFoySapFFpAIqFoCwo8gVrbj45utGhD1HaIee9IRJck1CygVT62ukmLRyQL4ZRJM6Pjps/LzJkT+Vxs8tQnps8K1UuzgoODdVovVCBwF8PDw/0DZtPVPtMPnTdvXGv5qqGu+UZXx/ewiTdIFfKejo5sO1GzhJoEZORjox4t3WSmhCxf9XpW3PMvLJz+ZPhLWi5IIPAF/v79vfNXjH+rO36orAHAA1ike0AVIiRdRXVZQqcCqshHoh4t3hSqTF5VvGlR4o+Sfx4yeXK4C/ctEPgUQ4MP7rS3tX56uHzHlwDuU4UWkURKlyV0KCDV5qPbe3TUo8ULBTDlZ8tWvTQvM6dkUsjkZ0ZzwwKBLzI0+ODO+bN/2fnlZ4cuABiwFlrGUUmoKiAn4cJWOWnxdDOj48LzX1lbFPlc7GJnN2MeMKPzegc6r3egr7/P2eECgdsI04UhPioB8VEJ0IfqnR7fe7P7i88+3XfgRlfHHdiLSEtIuiseuSygSraTyEeiXigAHQBdclpG7NKCNaWhOn2s2hfd/rYX5y6fRV1TLTqvdzi9UYHA08RHJSAnPRcZc+bj2admqB430G++dur4gfcuX/jrVQD91jIAZZWUjoSqUdCRgKSQLgNWPj0AXea/LvlxzpLC3WoZzVZjCyrPnMC5y2c1/BcIBL5Bxpz5yF+wHC8akrmfj4wMm09XHX2rvu5PrQDMsEnIRkKHVVE7ATntPiIfqXbqrCXMkXzmATM+OfIR6ppqXbx1gcB3yEnPxRsr3+RWTy0SHttQX/d5K4A+2EdCkh1VrYoGsTus8Pr66KSLLjktI1ZNvlZjC17emC/kE/g9dU21eHljPlqNLXafBQUF6xcufnlvytysWFiTkLD2e8PiDD3ai/uMrEJAlWFmbOIldGZ0XPjSgjWlPPlON9Vi/Y51IrkiCBj6+vuwfsc6nOYElKCgYP2SFUXbo2cZwmHtgoNy1Bc73ll5PmcfL/rR7b8p+a+sLeIlXHYc3I7fHdzu+h0KBH7A7w5uxw7O73tKqG7WsleK18AmYAhsfeUKAdkoKAuoEv3sqp8/W7bqJV5Xw+mmWlHlFAQ8dU213Eg4IzJq6ZIVRXNhq4YSCR1GQTkJQ2U+6cTLZNgynhIA6T8+PnKM7WRvNbZg/Y5143SLvktEeCQiwyNVPzf1m9DeZXTrNUh6CYnRBtXPe+724NbdHsW+xBgDJJ2keo4nrjvQ+HBzmV2GdGjwwZ33fr1yKQATbEmZ+7AlZOy6JSYCTqOfPOplVfGmRax85gEz3i/bMv536CYkvYRta0uRkpTq9NiGi/X47b6tAIC3f7ERizKdjjHArbs9+M2+rW75QRfkFWJNfrHT46obq7Dn8C4A2q+7ue0SSnZvGPM1Pi68X7YFx3ZVKrKjk0ImP/PL17cs+eN//ecJWJwZhDICwrqVs6F0G9DZyJeQxB8l/5y9kE+OfORXCZdFmYs1yQcAWWnZSElKRWKMQdOPGLBEyYLcwrFcoipa5AMs9yjpJUSER2q+7pSkVGSlZY/l8h4r+vr78MmRj+z2xxteeBW2TCgvGaNgIvNe9WmH5atez2IHVrcaW/y63Wcym9DebR+pWEHp6pvaOZHhkYiwVk8lvXp1b7xo7zLC1G9S7KOvm1dNbW67ZLePPifCQfVaYE9dUy1yMvIUVdFJIZOfWVm04adHDu6tgVI+uh34aFPxsgk7y08+4gnIi4CT4p5/YSF7AZVnToz/XXkQSS9pjoa+xv7Kcrt9ju6lvcuIozUVdvslnYTEGPU2pSdJfn62/Lrlm69dPn/G0zMw4+kIAEDvvVvovdc7btemRuWZE3ZtwdiEpDwAZ6B8AJ2bhJnooP0nCzgzOm46+zwfGdv5uOEr0u4u2evS8YkxBpfP8TR7N30svz7dVOtSl1Z8VAI+3Fwmt8kOn/ojDp36w7hfI8u5y2dx+9texdjRJ6Y9OS86zjCt+4qxH+rTr9iSMLCfw1PxtPu8zJw5vC/2d27d7UEPkzEEHEcSLVVQwdhZmJ4LAJokZOXzNOcun8WyBf+u2JeelZfWfcVYDSfdEHQVVHVms8jnYpPZE/257TcWPNG+04Kz9hyL2h+OxGiDz9yTecCskEiLhGryeTIxWNdUaydgxMyY2QBqwY+AMo7agLKEU5+YPos+iDzP5+9EaIhabKIDcPxD9xS89pyj6+rrN+G3+7bCZFbez+6SvT5xPwCwfsc6O5kcSagm3+mmWo/mJzqvd9j98QgLm5oAx5NQA7CPgABHwlC9pBAwEOTTwtGaCrk/r7qxSnNK3xM4a8+Z+k2K7G1EeCSqymrcfVljovN6h2YJHcnnjeGQndc7FMmYUL0+Dupz39q1AcF8qJjVmh10HSgC7q8sR3PbJaQkpULSSSjIK5T3t3cZ5fZhQV4hjF1GZKaaIOklS0axtgIR4ZGyoFlp2T4jqMlsGdki6SWYzCafqWJqQYuEviYfYC9gUFCwHuprocjQSRj2INWw6U8d787Y/fZexQ+UtK12l+yFyWzC0doKuw5wsi8iPFIeLePpVD6vDQhAvmb6tdYOfF/BkYRhOgnJz8/2KfkAVScczm+7qXjZBF4EZLcBPUnurbs9kPQ2eUxmk+IHy7aZTGYTMlOz5bYjL7HhCbQOG6NH5bxWutpuiJwvtQFp1CRMn51hd6y35dOAqkesgOxJAU/Jng1YlLkYBbmFkPSSYjiWRU4JJbs3oCCv0FJVZY5JSUpFw8V6b1y604HZ5BgCqWoT1KKor6AmIY0fyOcQRwJ6bJleb2Iym3C0pgINF+vx+60H5B9se5cRiTEGJMYYsHLzCpTs3oA1+cVyO7G9y4iI8EikJKViTX6xVyLhW6s2ujR+k62KkoHmvkzn9Q58cuQjbC561+6z29/2+rV8gP0DuWqLFgYsWWnZ8lMGasmKlXmFKMgrVCRZmtsuoc/aRZGVlu3wMSV3Mdbkij8MHIiPSsAbK9/kfvbsUzPwDkdMX+GljAUR1peqHk3kHMBbMTRg2ba2lLufTqrwspskEhK80Y5yVPXljcxhB3A3XKz3yfYfQcsIF1dGzHiaC+fO2A+zouANxuatmTbCnhimCxuva/Q6t+72OPyhqv1Am9suob3LiKy0bE0d+u6gurEK1Y1VdvsL8gqRwsl8km4Xf0BNvqavz9llQX1BQhUn1Ja6lgliDqZPktdNGx4e7qdPio9KGOPl+g70UwWvla5G9q/m4zf7tiIx2oCUpFQcranAa6WrFcdn/2o+9hzehcQYA8J0Ehou1nstEUOzKHMxjuw47nfdDiyO+vneL9uC9TvWwTxgVny2MD3Xq9VR1omRkWEzOEuXMa+5bUB20cKRAbPpqqMv82foyEXacZHhkXL7ih1RQiIieVhX0kto7zZ6rTtC0kuyeG//YqPifnjR0dfR0slOsqO+JCHrxEC/uRP8Za0V8Kqg7IqhD/tMP3SGTZ32z+Qgfage8VEJATMihrBtbSm2rXV8TEpSKur/4P0nQSS9hDX5xchMzbZLxpAO+KM1FT4zOkcLroxwcWXYmrvhrSth7jN1QLn4p92S1oAtArKWKiS8eeNaC/ulOdYb9Xf8pU3EkhhtkKeeoGluu4TXSldzB2v7Oq4OL3MUCfMXLHfbdbLwXOi92d0M5bqB3AgYxEyXzcr3EMDDrxrqmtkTM+bMH49r9zrtXUbsObwLzW2X5ELDzjBmMpsUx+6vLEd1Y5XXs4lkUqX9leWIDI+0zISmoZvC0WxpnmY0w8vUJPRkopDnQlN9zUXwF+5UiEhXQXnrZg8DGLrR1fH937+/d37a9KfnkoOffWoGMubMD4gHc6sbq9DebURitEHRsU1ko0ebtHcb5ZExa/KL5Y54T9PcdglHaywDwqsbqyzXGWPA77ceUD3H1G/CtrWlkPSSfF++Mh0FiysjXLSMmHEXvJWU/vHDd03XOv/vOyjXktfcBqQFJMvvDl0x/q0uZW7WXPrg/AXLA0JAten+9leW240FJTibf8UT8OaFUePW3R5IOtswOt71e3tu0A07fy2/dnVOmM7rHVi97VXFnDCegFfV7er8phqW1ZHUIqA8LyivG4Ktgg4BGDp+qKxhaPDBHfqLXjQkB0xbkGXP4V0Os4hqP1aT2YSGS97pklCbeOnW3R7sObwLPXd7VP+gqD0x70lavvlaLqOh916vfL4nJmTKSc+1n5x3aPD2//z3nv+FbYkyth2oYCJgsdE6ORObhCECDgJ40N7W+uk/Jf/kbfofeGPlmzj39Vm/eUSJbucRiRou1svVzPZuIxou1ivafmSfpJfkHzjp1GarcOy548n+ynKkJKU6TBztryzH/spyeTZsdqbswndWcDOn1Y1VqnIK7AnThXGHyF3raDsIiy/08mS0fAoJeVPTk0U56QVZ6KnpTzyuU9MLBATu1PRDg7ffW1ewCJap6c2wrRWoWKyTTnw6GoxNIuBDWCMggPvnz/5lJ3sxLxqSfXpQrEAwnrxT9C535dzL5xs/gHKZaufdEOQFZSU5UM6CWssDAPe//OzQhd6b3V+w/9DC9NyAbQ8KBISc9Fy5s5/mTu/NypMV5V+Bv068XfKFwFsfkO6OIIkYOQICGPjs030HBvrN19gTNxe9KyKhIGB5p+hd7nOJ9+8PXPm8onwfLH6QKqfT6AcwAjJRkM2GEgkHbnR13Dl1/MB71gGnCham5+LDzWUB9cSE4PEmTBeGDzeXcSPfyMiw+c8nD5dc7Wi7A6WATqMfoL5GPK8/UBEFL1/469XTVUff4kn4oiEZx3ZViiqpwO/JSc/FsV2V3DbfyMiwuf70F2svnD1zFbaEi2r1k4ecBaWh1ougJ+iV1wmEZdFOHQBdds6//Xjh4pf3Wqdhs6PV2ILKMycCosNe8PiQMWc+8hcs54oH2OQ7fepIKywLcRIBH8CWvJQF5EU/QEVAgNstQSScBOta8bCKmDI3K3bJiqLtU0J1s7j/GGyLudQ11QbcUxSCwCA+KgE56bnc4WU09+8PXPnzycMl1shHVsElK+HS0U/u/xutgID9VPVEQtJHOAVAaPQsQ/iyV4rXzIiMWursRsnU9p3XO/ymA18QmITpwhAflcB9pIjHnd6blZ9XlO+ztvkGoGz3keSLJvkABwICmiQkVVIi4pQlK4rm/iT9X7awnfUCgT8zNDR4+/L5xg+sXQ0k4pE2Hz3qRTHyxZF8gBMBAYcSTrSWENhEJDJO/uXrW5bEG154VYgo8GeGhgZvX+toO3jg4w/+BFsbjxS1DvcRwLl8gAYBAVUJg2CTkI6IRMYQACErizb8NDYhKe+JaU/O03jPAoHX+ccP3zV1dX5TbR1YTXoASLQbogod9TRHPoImAQE7CdWiIYmIk6BcqH5SdJxhWnpWXlrEzJjZYWFTE0L1+ji1zKlA4ElGRobNA/3mTnOfqaP3ZndzU33NRevzfEQyVjq6ukme9XNZPsAFAQGuhI5EJJGRfk+yqaoLFgoEHoQ3DedDpgwx79mI57Sz3REuCQgoJAT4y5kFQ7nGfDCnkHNUl20SCNwMO+qLHv9MFzba8aaXGJV8wCgEJKhEQ56M9Ja3WD0gBBR4Ht4M8HRUG2a2quIBo5MPGIOAgGo05Mk4gbNlzxUIPAk7GRkdCektT7oxi0cYk4AEFRHp17wCCPEE3ocXCXmyjat4hHERkMARUctWIPA27HQRattxE48wrgISGBHl73LyXiDwFqwEdlKMt3gEtwhIoyKjQODzuEs6GrcL6AwhqMBbeEIwZ/w/HG1HhwhWk1EAAAAASUVORK5CYII=",
                                            alt: "BtnClose",
                                            width: "112px"
                                        })
                                    })
                                })]
                            })
                        })
                    }), (0,
                    mt.jsx)(sI, {
                        open: a,
                        onClose: () => {
                            d(!1)
                        }
                        ,
                        className: "z-1000 scale-150",
                        PaperProps: {
                            style: {
                                backgroundColor: "transparent",
                                boxShadow: "none"
                            }
                        },
                        children: (0,
                        mt.jsx)($I, {
                            className: "text-[#FFF]",
                            children: s
                        })
                    })]
                })
            })
        }
          , yU = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
        function bU(e) {
            return `scale(${e}, ${e ** 2})`
        }
        const _U = {
            entering: {
                opacity: 1,
                transform: bU(1)
            },
            entered: {
                opacity: 1,
                transform: "none"
            }
        }
          , AU = "undefined" !== typeof navigator && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent)
          , xU = t.forwardRef((function(e, n) {
            const {addEndListener: r, appear: i=!0, children: o, easing: a, in: s, onEnter: l, onEntered: c, onEntering: u, onExit: d, onExited: h, onExiting: p, style: f, timeout: m="auto", TransitionComponent: g=EB} = e
              , v = (0,
            it.A)(e, yU)
              , y = (0,
            bI.A)()
              , b = t.useRef()
              , _ = CB()
              , A = t.useRef(null)
              , x = (0,
            PB.A)(A, o.ref, n)
              , S = e => t => {
                if (e) {
                    const n = A.current;
                    void 0 === t ? e(n) : e(n, t)
                }
            }
              , w = S(u)
              , E = S(( (e, t) => {
                TB(e);
                const {duration: n, delay: r, easing: i} = RB({
                    style: f,
                    timeout: m,
                    easing: a
                }, {
                    mode: "enter"
                });
                let o;
                "auto" === m ? (o = _.transitions.getAutoHeightDuration(e.clientHeight),
                b.current = o) : o = n,
                e.style.transition = [_.transitions.create("opacity", {
                    duration: o,
                    delay: r
                }), _.transitions.create("transform", {
                    duration: AU ? o : .666 * o,
                    delay: r,
                    easing: i
                })].join(","),
                l && l(e, t)
            }
            ))
              , M = S(c)
              , C = S(p)
              , T = S((e => {
                const {duration: t, delay: n, easing: r} = RB({
                    style: f,
                    timeout: m,
                    easing: a
                }, {
                    mode: "exit"
                });
                let i;
                "auto" === m ? (i = _.transitions.getAutoHeightDuration(e.clientHeight),
                b.current = i) : i = t,
                e.style.transition = [_.transitions.create("opacity", {
                    duration: i,
                    delay: n
                }), _.transitions.create("transform", {
                    duration: AU ? i : .666 * i,
                    delay: AU ? n : n || .333 * i,
                    easing: r
                })].join(","),
                e.style.opacity = 0,
                e.style.transform = bU(.75),
                d && d(e)
            }
            ))
              , R = S(h);
            return (0,
            mt.jsx)(g, (0,
            rt.A)({
                appear: i,
                in: s,
                nodeRef: A,
                onEnter: E,
                onEntered: M,
                onEntering: w,
                onExit: T,
                onExited: R,
                onExiting: C,
                addEndListener: e => {
                    "auto" === m && y.start(b.current || 0, e),
                    r && r(A.current, e)
                }
                ,
                timeout: "auto" === m ? null : m
            }, v, {
                children: (e, n) => t.cloneElement(o, (0,
                rt.A)({
                    style: (0,
                    rt.A)({
                        opacity: 0,
                        transform: bU(.75),
                        visibility: "exited" !== e || s ? void 0 : "hidden"
                    }, _U[e], f, o.props.style),
                    ref: x
                }, n))
            }))
        }
        ));
        xU.muiSupportAuto = !0;
        const SU = xU;
        var wU = __webpack_require__(5329);
        function EU(e) {
            if (null == e)
                return window;
            if ("[object Window]" !== e.toString()) {
                var t = e.ownerDocument;
                return t && t.defaultView || window
            }
            return e
        }
        function MU(e) {
            return e instanceof EU(e).Element || e instanceof Element
        }
        function CU(e) {
            return e instanceof EU(e).HTMLElement || e instanceof HTMLElement
        }
        function TU(e) {
            return "undefined" !== typeof ShadowRoot && (e instanceof EU(e).ShadowRoot || e instanceof ShadowRoot)
        }
        var RU = Math.max
          , PU = Math.min
          , BU = Math.round;
        function IU() {
            var e = navigator.userAgentData;
            return null != e && e.brands && Array.isArray(e.brands) ? e.brands.map((function(e) {
                return e.brand + "/" + e.version
            }
            )).join(" ") : navigator.userAgent
        }
        function LU() {
            return !/^((?!chrome|android).)*safari/i.test(IU())
        }
        function kU(e, t, n) {
            void 0 === t && (t = !1),
            void 0 === n && (n = !1);
            var r = e.getBoundingClientRect()
              , i = 1
              , o = 1;
            t && CU(e) && (i = e.offsetWidth > 0 && BU(r.width) / e.offsetWidth || 1,
            o = e.offsetHeight > 0 && BU(r.height) / e.offsetHeight || 1);
            var a = (MU(e) ? EU(e) : window).visualViewport
              , s = !LU() && n
              , l = (r.left + (s && a ? a.offsetLeft : 0)) / i
              , c = (r.top + (s && a ? a.offsetTop : 0)) / o
              , u = r.width / i
              , d = r.height / o;
            return {
                width: u,
                height: d,
                top: c,
                right: l + u,
                bottom: c + d,
                left: l,
                x: l,
                y: c
            }
        }
        function DU(e) {
            var t = EU(e);
            return {
                scrollLeft: t.pageXOffset,
                scrollTop: t.pageYOffset
            }
        }
        function OU(e) {
            return e ? (e.nodeName || "").toLowerCase() : null
        }
        function NU(e) {
            return ((MU(e) ? e.ownerDocument : e.document) || window.document).documentElement
        }
        function FU(e) {
            return kU(NU(e)).left + DU(e).scrollLeft
        }
        function UU(e) {
            return EU(e).getComputedStyle(e)
        }
        function zU(e) {
            var t = UU(e)
              , n = t.overflow
              , r = t.overflowX
              , i = t.overflowY;
            return /auto|scroll|overlay|hidden/.test(n + i + r)
        }
        function GU(e, t, n) {
            void 0 === n && (n = !1);
            var r = CU(t)
              , i = CU(t) && function(e) {
                var t = e.getBoundingClientRect()
                  , n = BU(t.width) / e.offsetWidth || 1
                  , r = BU(t.height) / e.offsetHeight || 1;
                return 1 !== n || 1 !== r
            }(t)
              , o = NU(t)
              , a = kU(e, i, n)
              , s = {
                scrollLeft: 0,
                scrollTop: 0
            }
              , l = {
                x: 0,
                y: 0
            };
            return (r || !r && !n) && (("body" !== OU(t) || zU(o)) && (s = function(e) {
                return e !== EU(e) && CU(e) ? {
                    scrollLeft: (t = e).scrollLeft,
                    scrollTop: t.scrollTop
                } : DU(e);
                var t
            }(t)),
            CU(t) ? ((l = kU(t, !0)).x += t.clientLeft,
            l.y += t.clientTop) : o && (l.x = FU(o))),
            {
                x: a.left + s.scrollLeft - l.x,
                y: a.top + s.scrollTop - l.y,
                width: a.width,
                height: a.height
            }
        }
        function HU(e) {
            var t = kU(e)
              , n = e.offsetWidth
              , r = e.offsetHeight;
            return Math.abs(t.width - n) <= 1 && (n = t.width),
            Math.abs(t.height - r) <= 1 && (r = t.height),
            {
                x: e.offsetLeft,
                y: e.offsetTop,
                width: n,
                height: r
            }
        }
        function jU(e) {
            return "html" === OU(e) ? e : e.assignedSlot || e.parentNode || (TU(e) ? e.host : null) || NU(e)
        }
        function WU(e) {
            return ["html", "body", "#document"].indexOf(OU(e)) >= 0 ? e.ownerDocument.body : CU(e) && zU(e) ? e : WU(jU(e))
        }
        function VU(e, t) {
            var n;
            void 0 === t && (t = []);
            var r = WU(e)
              , i = r === (null == (n = e.ownerDocument) ? void 0 : n.body)
              , o = EU(r)
              , a = i ? [o].concat(o.visualViewport || [], zU(r) ? r : []) : r
              , s = t.concat(a);
            return i ? s : s.concat(VU(jU(a)))
        }
        function XU(e) {
            return ["table", "td", "th"].indexOf(OU(e)) >= 0
        }
        function JU(e) {
            return CU(e) && "fixed" !== UU(e).position ? e.offsetParent : null
        }
        function KU(e) {
            for (var t = EU(e), n = JU(e); n && XU(n) && "static" === UU(n).position; )
                n = JU(n);
            return n && ("html" === OU(n) || "body" === OU(n) && "static" === UU(n).position) ? t : n || function(e) {
                var t = /firefox/i.test(IU());
                if (/Trident/i.test(IU()) && CU(e) && "fixed" === UU(e).position)
                    return null;
                var n = jU(e);
                for (TU(n) && (n = n.host); CU(n) && ["html", "body"].indexOf(OU(n)) < 0; ) {
                    var r = UU(n);
                    if ("none" !== r.transform || "none" !== r.perspective || "paint" === r.contain || -1 !== ["transform", "perspective"].indexOf(r.willChange) || t && "filter" === r.willChange || t && r.filter && "none" !== r.filter)
                        return n;
                    n = n.parentNode
                }
                return null
            }(e) || t
        }
        var qU = "top"
          , YU = "bottom"
          , QU = "right"
          , ZU = "left"
          , $U = "auto"
          , ez = [qU, YU, QU, ZU]
          , tz = "start"
          , nz = "end"
          , rz = "viewport"
          , iz = "popper"
          , oz = ez.reduce((function(e, t) {
            return e.concat([t + "-" + tz, t + "-" + nz])
        }
        ), [])
          , az = [].concat(ez, [$U]).reduce((function(e, t) {
            return e.concat([t, t + "-" + tz, t + "-" + nz])
        }
        ), [])
          , sz = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];
        function lz(e) {
            var t = new Map
              , n = new Set
              , r = [];
            function i(e) {
                n.add(e.name),
                [].concat(e.requires || [], e.requiresIfExists || []).forEach((function(e) {
                    if (!n.has(e)) {
                        var r = t.get(e);
                        r && i(r)
                    }
                }
                )),
                r.push(e)
            }
            return e.forEach((function(e) {
                t.set(e.name, e)
            }
            )),
            e.forEach((function(e) {
                n.has(e.name) || i(e)
            }
            )),
            r
        }
        function cz(e) {
            var t;
            return function() {
                return t || (t = new Promise((function(n) {
                    Promise.resolve().then((function() {
                        t = void 0,
                        n(e())
                    }
                    ))
                }
                ))),
                t
            }
        }
        var uz = {
            placement: "bottom",
            modifiers: [],
            strategy: "absolute"
        };
        function dz() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                t[n] = arguments[n];
            return !t.some((function(e) {
                return !(e && "function" === typeof e.getBoundingClientRect)
            }
            ))
        }
        function hz(e) {
            void 0 === e && (e = {});
            var t = e
              , n = t.defaultModifiers
              , r = void 0 === n ? [] : n
              , i = t.defaultOptions
              , o = void 0 === i ? uz : i;
            return function(e, t, n) {
                void 0 === n && (n = o);
                var i = {
                    placement: "bottom",
                    orderedModifiers: [],
                    options: Object.assign({}, uz, o),
                    modifiersData: {},
                    elements: {
                        reference: e,
                        popper: t
                    },
                    attributes: {},
                    styles: {}
                }
                  , a = []
                  , s = !1
                  , l = {
                    state: i,
                    setOptions: function(n) {
                        var s = "function" === typeof n ? n(i.options) : n;
                        c(),
                        i.options = Object.assign({}, o, i.options, s),
                        i.scrollParents = {
                            reference: MU(e) ? VU(e) : e.contextElement ? VU(e.contextElement) : [],
                            popper: VU(t)
                        };
                        var u = function(e) {
                            var t = lz(e);
                            return sz.reduce((function(e, n) {
                                return e.concat(t.filter((function(e) {
                                    return e.phase === n
                                }
                                )))
                            }
                            ), [])
                        }(function(e) {
                            var t = e.reduce((function(e, t) {
                                var n = e[t.name];
                                return e[t.name] = n ? Object.assign({}, n, t, {
                                    options: Object.assign({}, n.options, t.options),
                                    data: Object.assign({}, n.data, t.data)
                                }) : t,
                                e
                            }
                            ), {});
                            return Object.keys(t).map((function(e) {
                                return t[e]
                            }
                            ))
                        }([].concat(r, i.options.modifiers)));
                        return i.orderedModifiers = u.filter((function(e) {
                            return e.enabled
                        }
                        )),
                        i.orderedModifiers.forEach((function(e) {
                            var t = e.name
                              , n = e.options
                              , r = void 0 === n ? {} : n
                              , o = e.effect;
                            if ("function" === typeof o) {
                                var s = o({
                                    state: i,
                                    name: t,
                                    instance: l,
                                    options: r
                                })
                                  , c = function() {};
                                a.push(s || c)
                            }
                        }
                        )),
                        l.update()
                    },
                    forceUpdate: function() {
                        if (!s) {
                            var e = i.elements
                              , t = e.reference
                              , n = e.popper;
                            if (dz(t, n)) {
                                i.rects = {
                                    reference: GU(t, KU(n), "fixed" === i.options.strategy),
                                    popper: HU(n)
                                },
                                i.reset = !1,
                                i.placement = i.options.placement,
                                i.orderedModifiers.forEach((function(e) {
                                    return i.modifiersData[e.name] = Object.assign({}, e.data)
                                }
                                ));
                                for (var r = 0; r < i.orderedModifiers.length; r++)
                                    if (!0 !== i.reset) {
                                        var o = i.orderedModifiers[r]
                                          , a = o.fn
                                          , c = o.options
                                          , u = void 0 === c ? {} : c
                                          , d = o.name;
                                        "function" === typeof a && (i = a({
                                            state: i,
                                            options: u,
                                            name: d,
                                            instance: l
                                        }) || i)
                                    } else
                                        i.reset = !1,
                                        r = -1
                            }
                        }
                    },
                    update: cz((function() {
                        return new Promise((function(e) {
                            l.forceUpdate(),
                            e(i)
                        }
                        ))
                    }
                    )),
                    destroy: function() {
                        c(),
                        s = !0
                    }
                };
                if (!dz(e, t))
                    return l;
                function c() {
                    a.forEach((function(e) {
                        return e()
                    }
                    )),
                    a = []
                }
                return l.setOptions(n).then((function(e) {
                    !s && n.onFirstUpdate && n.onFirstUpdate(e)
                }
                )),
                l
            }
        }
        var pz = {
            passive: !0
        };
        function fz(e) {
            return e.split("-")[0]
        }
        function mz(e) {
            return e.split("-")[1]
        }
        function gz(e) {
            return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
        }
        function vz(e) {
            var t, n = e.reference, r = e.element, i = e.placement, o = i ? fz(i) : null, a = i ? mz(i) : null, s = n.x + n.width / 2 - r.width / 2, l = n.y + n.height / 2 - r.height / 2;
            switch (o) {
            case qU:
                t = {
                    x: s,
                    y: n.y - r.height
                };
                break;
            case YU:
                t = {
                    x: s,
                    y: n.y + n.height
                };
                break;
            case QU:
                t = {
                    x: n.x + n.width,
                    y: l
                };
                break;
            case ZU:
                t = {
                    x: n.x - r.width,
                    y: l
                };
                break;
            default:
                t = {
                    x: n.x,
                    y: n.y
                }
            }
            var c = o ? gz(o) : null;
            if (null != c) {
                var u = "y" === c ? "height" : "width";
                switch (a) {
                case tz:
                    t[c] = t[c] - (n[u] / 2 - r[u] / 2);
                    break;
                case nz:
                    t[c] = t[c] + (n[u] / 2 - r[u] / 2)
                }
            }
            return t
        }
        var yz = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        };
        function bz(e) {
            var t, n = e.popper, r = e.popperRect, i = e.placement, o = e.variation, a = e.offsets, s = e.position, l = e.gpuAcceleration, c = e.adaptive, u = e.roundOffsets, d = e.isFixed, h = a.x, p = void 0 === h ? 0 : h, f = a.y, m = void 0 === f ? 0 : f, g = "function" === typeof u ? u({
                x: p,
                y: m
            }) : {
                x: p,
                y: m
            };
            p = g.x,
            m = g.y;
            var v = a.hasOwnProperty("x")
              , y = a.hasOwnProperty("y")
              , b = ZU
              , _ = qU
              , A = window;
            if (c) {
                var x = KU(n)
                  , S = "clientHeight"
                  , w = "clientWidth";
                if (x === EU(n) && "static" !== UU(x = NU(n)).position && "absolute" === s && (S = "scrollHeight",
                w = "scrollWidth"),
                i === qU || (i === ZU || i === QU) && o === nz)
                    _ = YU,
                    m -= (d && x === A && A.visualViewport ? A.visualViewport.height : x[S]) - r.height,
                    m *= l ? 1 : -1;
                if (i === ZU || (i === qU || i === YU) && o === nz)
                    b = QU,
                    p -= (d && x === A && A.visualViewport ? A.visualViewport.width : x[w]) - r.width,
                    p *= l ? 1 : -1
            }
            var E, M = Object.assign({
                position: s
            }, c && yz), C = !0 === u ? function(e, t) {
                var n = e.x
                  , r = e.y
                  , i = t.devicePixelRatio || 1;
                return {
                    x: BU(n * i) / i || 0,
                    y: BU(r * i) / i || 0
                }
            }({
                x: p,
                y: m
            }, EU(n)) : {
                x: p,
                y: m
            };
            return p = C.x,
            m = C.y,
            l ? Object.assign({}, M, ((E = {})[_] = y ? "0" : "",
            E[b] = v ? "0" : "",
            E.transform = (A.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + m + "px)" : "translate3d(" + p + "px, " + m + "px, 0)",
            E)) : Object.assign({}, M, ((t = {})[_] = y ? m + "px" : "",
            t[b] = v ? p + "px" : "",
            t.transform = "",
            t))
        }
        var _z = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        };
        function Az(e) {
            return e.replace(/left|right|bottom|top/g, (function(e) {
                return _z[e]
            }
            ))
        }
        var xz = {
            start: "end",
            end: "start"
        };
        function Sz(e) {
            return e.replace(/start|end/g, (function(e) {
                return xz[e]
            }
            ))
        }
        function wz(e, t) {
            var n = t.getRootNode && t.getRootNode();
            if (e.contains(t))
                return !0;
            if (n && TU(n)) {
                var r = t;
                do {
                    if (r && e.isSameNode(r))
                        return !0;
                    r = r.parentNode || r.host
                } while (r)
            }
            return !1
        }
        function Ez(e) {
            return Object.assign({}, e, {
                left: e.x,
                top: e.y,
                right: e.x + e.width,
                bottom: e.y + e.height
            })
        }
        function Mz(e, t, n) {
            return t === rz ? Ez(function(e, t) {
                var n = EU(e)
                  , r = NU(e)
                  , i = n.visualViewport
                  , o = r.clientWidth
                  , a = r.clientHeight
                  , s = 0
                  , l = 0;
                if (i) {
                    o = i.width,
                    a = i.height;
                    var c = LU();
                    (c || !c && "fixed" === t) && (s = i.offsetLeft,
                    l = i.offsetTop)
                }
                return {
                    width: o,
                    height: a,
                    x: s + FU(e),
                    y: l
                }
            }(e, n)) : MU(t) ? function(e, t) {
                var n = kU(e, !1, "fixed" === t);
                return n.top = n.top + e.clientTop,
                n.left = n.left + e.clientLeft,
                n.bottom = n.top + e.clientHeight,
                n.right = n.left + e.clientWidth,
                n.width = e.clientWidth,
                n.height = e.clientHeight,
                n.x = n.left,
                n.y = n.top,
                n
            }(t, n) : Ez(function(e) {
                var t, n = NU(e), r = DU(e), i = null == (t = e.ownerDocument) ? void 0 : t.body, o = RU(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), a = RU(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), s = -r.scrollLeft + FU(e), l = -r.scrollTop;
                return "rtl" === UU(i || n).direction && (s += RU(n.clientWidth, i ? i.clientWidth : 0) - o),
                {
                    width: o,
                    height: a,
                    x: s,
                    y: l
                }
            }(NU(e)))
        }
        function Cz(e, t, n, r) {
            var i = "clippingParents" === t ? function(e) {
                var t = VU(jU(e))
                  , n = ["absolute", "fixed"].indexOf(UU(e).position) >= 0 && CU(e) ? KU(e) : e;
                return MU(n) ? t.filter((function(e) {
                    return MU(e) && wz(e, n) && "body" !== OU(e)
                }
                )) : []
            }(e) : [].concat(t)
              , o = [].concat(i, [n])
              , a = o[0]
              , s = o.reduce((function(t, n) {
                var i = Mz(e, n, r);
                return t.top = RU(i.top, t.top),
                t.right = PU(i.right, t.right),
                t.bottom = PU(i.bottom, t.bottom),
                t.left = RU(i.left, t.left),
                t
            }
            ), Mz(e, a, r));
            return s.width = s.right - s.left,
            s.height = s.bottom - s.top,
            s.x = s.left,
            s.y = s.top,
            s
        }
        function Tz(e) {
            return Object.assign({}, {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            }, e)
        }
        function Rz(e, t) {
            return t.reduce((function(t, n) {
                return t[n] = e,
                t
            }
            ), {})
        }
        function Pz(e, t) {
            void 0 === t && (t = {});
            var n = t
              , r = n.placement
              , i = void 0 === r ? e.placement : r
              , o = n.strategy
              , a = void 0 === o ? e.strategy : o
              , s = n.boundary
              , l = void 0 === s ? "clippingParents" : s
              , c = n.rootBoundary
              , u = void 0 === c ? rz : c
              , d = n.elementContext
              , h = void 0 === d ? iz : d
              , p = n.altBoundary
              , f = void 0 !== p && p
              , m = n.padding
              , g = void 0 === m ? 0 : m
              , v = Tz("number" !== typeof g ? g : Rz(g, ez))
              , y = h === iz ? "reference" : iz
              , b = e.rects.popper
              , _ = e.elements[f ? y : h]
              , A = Cz(MU(_) ? _ : _.contextElement || NU(e.elements.popper), l, u, a)
              , x = kU(e.elements.reference)
              , S = vz({
                reference: x,
                element: b,
                strategy: "absolute",
                placement: i
            })
              , w = Ez(Object.assign({}, b, S))
              , E = h === iz ? w : x
              , M = {
                top: A.top - E.top + v.top,
                bottom: E.bottom - A.bottom + v.bottom,
                left: A.left - E.left + v.left,
                right: E.right - A.right + v.right
            }
              , C = e.modifiersData.offset;
            if (h === iz && C) {
                var T = C[i];
                Object.keys(M).forEach((function(e) {
                    var t = [QU, YU].indexOf(e) >= 0 ? 1 : -1
                      , n = [qU, YU].indexOf(e) >= 0 ? "y" : "x";
                    M[e] += T[n] * t
                }
                ))
            }
            return M
        }
        function Bz(e, t, n) {
            return RU(e, PU(t, n))
        }
        function Iz(e, t, n) {
            return void 0 === n && (n = {
                x: 0,
                y: 0
            }),
            {
                top: e.top - t.height - n.y,
                right: e.right - t.width + n.x,
                bottom: e.bottom - t.height + n.y,
                left: e.left - t.width - n.x
            }
        }
        function Lz(e) {
            return [qU, QU, YU, ZU].some((function(t) {
                return e[t] >= 0
            }
            ))
        }
        var kz = hz({
            defaultModifiers: [{
                name: "eventListeners",
                enabled: !0,
                phase: "write",
                fn: function() {},
                effect: function(e) {
                    var t = e.state
                      , n = e.instance
                      , r = e.options
                      , i = r.scroll
                      , o = void 0 === i || i
                      , a = r.resize
                      , s = void 0 === a || a
                      , l = EU(t.elements.popper)
                      , c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
                    return o && c.forEach((function(e) {
                        e.addEventListener("scroll", n.update, pz)
                    }
                    )),
                    s && l.addEventListener("resize", n.update, pz),
                    function() {
                        o && c.forEach((function(e) {
                            e.removeEventListener("scroll", n.update, pz)
                        }
                        )),
                        s && l.removeEventListener("resize", n.update, pz)
                    }
                },
                data: {}
            }, {
                name: "popperOffsets",
                enabled: !0,
                phase: "read",
                fn: function(e) {
                    var t = e.state
                      , n = e.name;
                    t.modifiersData[n] = vz({
                        reference: t.rects.reference,
                        element: t.rects.popper,
                        strategy: "absolute",
                        placement: t.placement
                    })
                },
                data: {}
            }, {
                name: "computeStyles",
                enabled: !0,
                phase: "beforeWrite",
                fn: function(e) {
                    var t = e.state
                      , n = e.options
                      , r = n.gpuAcceleration
                      , i = void 0 === r || r
                      , o = n.adaptive
                      , a = void 0 === o || o
                      , s = n.roundOffsets
                      , l = void 0 === s || s
                      , c = {
                        placement: fz(t.placement),
                        variation: mz(t.placement),
                        popper: t.elements.popper,
                        popperRect: t.rects.popper,
                        gpuAcceleration: i,
                        isFixed: "fixed" === t.options.strategy
                    };
                    null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, bz(Object.assign({}, c, {
                        offsets: t.modifiersData.popperOffsets,
                        position: t.options.strategy,
                        adaptive: a,
                        roundOffsets: l
                    })))),
                    null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, bz(Object.assign({}, c, {
                        offsets: t.modifiersData.arrow,
                        position: "absolute",
                        adaptive: !1,
                        roundOffsets: l
                    })))),
                    t.attributes.popper = Object.assign({}, t.attributes.popper, {
                        "data-popper-placement": t.placement
                    })
                },
                data: {}
            }, {
                name: "applyStyles",
                enabled: !0,
                phase: "write",
                fn: function(e) {
                    var t = e.state;
                    Object.keys(t.elements).forEach((function(e) {
                        var n = t.styles[e] || {}
                          , r = t.attributes[e] || {}
                          , i = t.elements[e];
                        CU(i) && OU(i) && (Object.assign(i.style, n),
                        Object.keys(r).forEach((function(e) {
                            var t = r[e];
                            !1 === t ? i.removeAttribute(e) : i.setAttribute(e, !0 === t ? "" : t)
                        }
                        )))
                    }
                    ))
                },
                effect: function(e) {
                    var t = e.state
                      , n = {
                        popper: {
                            position: t.options.strategy,
                            left: "0",
                            top: "0",
                            margin: "0"
                        },
                        arrow: {
                            position: "absolute"
                        },
                        reference: {}
                    };
                    return Object.assign(t.elements.popper.style, n.popper),
                    t.styles = n,
                    t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
                    function() {
                        Object.keys(t.elements).forEach((function(e) {
                            var r = t.elements[e]
                              , i = t.attributes[e] || {}
                              , o = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce((function(e, t) {
                                return e[t] = "",
                                e
                            }
                            ), {});
                            CU(r) && OU(r) && (Object.assign(r.style, o),
                            Object.keys(i).forEach((function(e) {
                                r.removeAttribute(e)
                            }
                            )))
                        }
                        ))
                    }
                },
                requires: ["computeStyles"]
            }, {
                name: "offset",
                enabled: !0,
                phase: "main",
                requires: ["popperOffsets"],
                fn: function(e) {
                    var t = e.state
                      , n = e.options
                      , r = e.name
                      , i = n.offset
                      , o = void 0 === i ? [0, 0] : i
                      , a = az.reduce((function(e, n) {
                        return e[n] = function(e, t, n) {
                            var r = fz(e)
                              , i = [ZU, qU].indexOf(r) >= 0 ? -1 : 1
                              , o = "function" === typeof n ? n(Object.assign({}, t, {
                                placement: e
                            })) : n
                              , a = o[0]
                              , s = o[1];
                            return a = a || 0,
                            s = (s || 0) * i,
                            [ZU, QU].indexOf(r) >= 0 ? {
                                x: s,
                                y: a
                            } : {
                                x: a,
                                y: s
                            }
                        }(n, t.rects, o),
                        e
                    }
                    ), {})
                      , s = a[t.placement]
                      , l = s.x
                      , c = s.y;
                    null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l,
                    t.modifiersData.popperOffsets.y += c),
                    t.modifiersData[r] = a
                }
            }, {
                name: "flip",
                enabled: !0,
                phase: "main",
                fn: function(e) {
                    var t = e.state
                      , n = e.options
                      , r = e.name;
                    if (!t.modifiersData[r]._skip) {
                        for (var i = n.mainAxis, o = void 0 === i || i, a = n.altAxis, s = void 0 === a || a, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, h = n.altBoundary, p = n.flipVariations, f = void 0 === p || p, m = n.allowedAutoPlacements, g = t.options.placement, v = fz(g), y = l || (v === g || !f ? [Az(g)] : function(e) {
                            if (fz(e) === $U)
                                return [];
                            var t = Az(e);
                            return [Sz(e), t, Sz(t)]
                        }(g)), b = [g].concat(y).reduce((function(e, n) {
                            return e.concat(fz(n) === $U ? function(e, t) {
                                void 0 === t && (t = {});
                                var n = t
                                  , r = n.placement
                                  , i = n.boundary
                                  , o = n.rootBoundary
                                  , a = n.padding
                                  , s = n.flipVariations
                                  , l = n.allowedAutoPlacements
                                  , c = void 0 === l ? az : l
                                  , u = mz(r)
                                  , d = u ? s ? oz : oz.filter((function(e) {
                                    return mz(e) === u
                                }
                                )) : ez
                                  , h = d.filter((function(e) {
                                    return c.indexOf(e) >= 0
                                }
                                ));
                                0 === h.length && (h = d);
                                var p = h.reduce((function(t, n) {
                                    return t[n] = Pz(e, {
                                        placement: n,
                                        boundary: i,
                                        rootBoundary: o,
                                        padding: a
                                    })[fz(n)],
                                    t
                                }
                                ), {});
                                return Object.keys(p).sort((function(e, t) {
                                    return p[e] - p[t]
                                }
                                ))
                            }(t, {
                                placement: n,
                                boundary: u,
                                rootBoundary: d,
                                padding: c,
                                flipVariations: f,
                                allowedAutoPlacements: m
                            }) : n)
                        }
                        ), []), _ = t.rects.reference, A = t.rects.popper, x = new Map, S = !0, w = b[0], E = 0; E < b.length; E++) {
                            var M = b[E]
                              , C = fz(M)
                              , T = mz(M) === tz
                              , R = [qU, YU].indexOf(C) >= 0
                              , P = R ? "width" : "height"
                              , B = Pz(t, {
                                placement: M,
                                boundary: u,
                                rootBoundary: d,
                                altBoundary: h,
                                padding: c
                            })
                              , I = R ? T ? QU : ZU : T ? YU : qU;
                            _[P] > A[P] && (I = Az(I));
                            var L = Az(I)
                              , k = [];
                            if (o && k.push(B[C] <= 0),
                            s && k.push(B[I] <= 0, B[L] <= 0),
                            k.every((function(e) {
                                return e
                            }
                            ))) {
                                w = M,
                                S = !1;
                                break
                            }
                            x.set(M, k)
                        }
                        if (S)
                            for (var D = function(e) {
                                var t = b.find((function(t) {
                                    var n = x.get(t);
                                    if (n)
                                        return n.slice(0, e).every((function(e) {
                                            return e
                                        }
                                        ))
                                }
                                ));
                                if (t)
                                    return w = t,
                                    "break"
                            }, O = f ? 3 : 1; O > 0; O--) {
                                if ("break" === D(O))
                                    break
                            }
                        t.placement !== w && (t.modifiersData[r]._skip = !0,
                        t.placement = w,
                        t.reset = !0)
                    }
                },
                requiresIfExists: ["offset"],
                data: {
                    _skip: !1
                }
            }, {
                name: "preventOverflow",
                enabled: !0,
                phase: "main",
                fn: function(e) {
                    var t = e.state
                      , n = e.options
                      , r = e.name
                      , i = n.mainAxis
                      , o = void 0 === i || i
                      , a = n.altAxis
                      , s = void 0 !== a && a
                      , l = n.boundary
                      , c = n.rootBoundary
                      , u = n.altBoundary
                      , d = n.padding
                      , h = n.tether
                      , p = void 0 === h || h
                      , f = n.tetherOffset
                      , m = void 0 === f ? 0 : f
                      , g = Pz(t, {
                        boundary: l,
                        rootBoundary: c,
                        padding: d,
                        altBoundary: u
                    })
                      , v = fz(t.placement)
                      , y = mz(t.placement)
                      , b = !y
                      , _ = gz(v)
                      , A = "x" === _ ? "y" : "x"
                      , x = t.modifiersData.popperOffsets
                      , S = t.rects.reference
                      , w = t.rects.popper
                      , E = "function" === typeof m ? m(Object.assign({}, t.rects, {
                        placement: t.placement
                    })) : m
                      , M = "number" === typeof E ? {
                        mainAxis: E,
                        altAxis: E
                    } : Object.assign({
                        mainAxis: 0,
                        altAxis: 0
                    }, E)
                      , C = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null
                      , T = {
                        x: 0,
                        y: 0
                    };
                    if (x) {
                        if (o) {
                            var R, P = "y" === _ ? qU : ZU, B = "y" === _ ? YU : QU, I = "y" === _ ? "height" : "width", L = x[_], k = L + g[P], D = L - g[B], O = p ? -w[I] / 2 : 0, N = y === tz ? S[I] : w[I], F = y === tz ? -w[I] : -S[I], U = t.elements.arrow, z = p && U ? HU(U) : {
                                width: 0,
                                height: 0
                            }, G = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 0
                            }, H = G[P], j = G[B], W = Bz(0, S[I], z[I]), V = b ? S[I] / 2 - O - W - H - M.mainAxis : N - W - H - M.mainAxis, X = b ? -S[I] / 2 + O + W + j + M.mainAxis : F + W + j + M.mainAxis, J = t.elements.arrow && KU(t.elements.arrow), K = J ? "y" === _ ? J.clientTop || 0 : J.clientLeft || 0 : 0, q = null != (R = null == C ? void 0 : C[_]) ? R : 0, Y = L + X - q, Q = Bz(p ? PU(k, L + V - q - K) : k, L, p ? RU(D, Y) : D);
                            x[_] = Q,
                            T[_] = Q - L
                        }
                        if (s) {
                            var Z, $ = "x" === _ ? qU : ZU, ee = "x" === _ ? YU : QU, te = x[A], ne = "y" === A ? "height" : "width", re = te + g[$], ie = te - g[ee], oe = -1 !== [qU, ZU].indexOf(v), ae = null != (Z = null == C ? void 0 : C[A]) ? Z : 0, se = oe ? re : te - S[ne] - w[ne] - ae + M.altAxis, le = oe ? te + S[ne] + w[ne] - ae - M.altAxis : ie, ce = p && oe ? function(e, t, n) {
                                var r = Bz(e, t, n);
                                return r > n ? n : r
                            }(se, te, le) : Bz(p ? se : re, te, p ? le : ie);
                            x[A] = ce,
                            T[A] = ce - te
                        }
                        t.modifiersData[r] = T
                    }
                },
                requiresIfExists: ["offset"]
            }, {
                name: "arrow",
                enabled: !0,
                phase: "main",
                fn: function(e) {
                    var t, n = e.state, r = e.name, i = e.options, o = n.elements.arrow, a = n.modifiersData.popperOffsets, s = fz(n.placement), l = gz(s), c = [ZU, QU].indexOf(s) >= 0 ? "height" : "width";
                    if (o && a) {
                        var u = function(e, t) {
                            return Tz("number" !== typeof (e = "function" === typeof e ? e(Object.assign({}, t.rects, {
                                placement: t.placement
                            })) : e) ? e : Rz(e, ez))
                        }(i.padding, n)
                          , d = HU(o)
                          , h = "y" === l ? qU : ZU
                          , p = "y" === l ? YU : QU
                          , f = n.rects.reference[c] + n.rects.reference[l] - a[l] - n.rects.popper[c]
                          , m = a[l] - n.rects.reference[l]
                          , g = KU(o)
                          , v = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0
                          , y = f / 2 - m / 2
                          , b = u[h]
                          , _ = v - d[c] - u[p]
                          , A = v / 2 - d[c] / 2 + y
                          , x = Bz(b, A, _)
                          , S = l;
                        n.modifiersData[r] = ((t = {})[S] = x,
                        t.centerOffset = x - A,
                        t)
                    }
                },
                effect: function(e) {
                    var t = e.state
                      , n = e.options.element
                      , r = void 0 === n ? "[data-popper-arrow]" : n;
                    null != r && ("string" !== typeof r || (r = t.elements.popper.querySelector(r))) && wz(t.elements.popper, r) && (t.elements.arrow = r)
                },
                requires: ["popperOffsets"],
                requiresIfExists: ["preventOverflow"]
            }, {
                name: "hide",
                enabled: !0,
                phase: "main",
                requiresIfExists: ["preventOverflow"],
                fn: function(e) {
                    var t = e.state
                      , n = e.name
                      , r = t.rects.reference
                      , i = t.rects.popper
                      , o = t.modifiersData.preventOverflow
                      , a = Pz(t, {
                        elementContext: "reference"
                    })
                      , s = Pz(t, {
                        altBoundary: !0
                    })
                      , l = Iz(a, r)
                      , c = Iz(s, i, o)
                      , u = Lz(l)
                      , d = Lz(c);
                    t.modifiersData[n] = {
                        referenceClippingOffsets: l,
                        popperEscapeOffsets: c,
                        isReferenceHidden: u,
                        hasPopperEscaped: d
                    },
                    t.attributes.popper = Object.assign({}, t.attributes.popper, {
                        "data-popper-reference-hidden": u,
                        "data-popper-escaped": d
                    })
                }
            }]
        });
        function Dz(e) {
            return (0,
            Bt.Ay)("MuiPopper", e)
        }
        (0,
        _t.A)("MuiPopper", ["root"]);
        const Oz = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"]
          , Nz = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
        function Fz(e) {
            return "function" === typeof e ? e() : e
        }
        function Uz(e) {
            return void 0 !== e.nodeType
        }
        const zz = {}
          , Gz = t.forwardRef((function(e, n) {
            var r;
            const {anchorEl: i, children: o, direction: a, disablePortal: s, modifiers: l, open: c, placement: u, popperOptions: d, popperRef: h, slotProps: p={}, slots: f={}, TransitionProps: m} = e
              , g = (0,
            it.A)(e, Oz)
              , v = t.useRef(null)
              , y = (0,
            KP.A)(v, n)
              , b = t.useRef(null)
              , _ = (0,
            KP.A)(b, h)
              , A = t.useRef(_);
            (0,
            dB.A)(( () => {
                A.current = _
            }
            ), [_]),
            t.useImperativeHandle(h, ( () => b.current), []);
            const x = function(e, t) {
                if ("ltr" === t)
                    return e;
                switch (e) {
                case "bottom-end":
                    return "bottom-start";
                case "bottom-start":
                    return "bottom-end";
                case "top-end":
                    return "top-start";
                case "top-start":
                    return "top-end";
                default:
                    return e
                }
            }(u, a)
              , [S,w] = t.useState(x)
              , [E,M] = t.useState(Fz(i));
            t.useEffect(( () => {
                b.current && b.current.forceUpdate()
            }
            )),
            t.useEffect(( () => {
                i && M(Fz(i))
            }
            ), [i]),
            (0,
            dB.A)(( () => {
                if (!E || !c)
                    return;
                let e = [{
                    name: "preventOverflow",
                    options: {
                        altBoundary: s
                    }
                }, {
                    name: "flip",
                    options: {
                        altBoundary: s
                    }
                }, {
                    name: "onUpdate",
                    enabled: !0,
                    phase: "afterWrite",
                    fn: e => {
                        let {state: t} = e;
                        w(t.placement)
                    }
                }];
                null != l && (e = e.concat(l)),
                d && null != d.modifiers && (e = e.concat(d.modifiers));
                const t = kz(E, v.current, (0,
                rt.A)({
                    placement: x
                }, d, {
                    modifiers: e
                }));
                return A.current(t),
                () => {
                    t.destroy(),
                    A.current(null)
                }
            }
            ), [E, s, l, c, d, x]);
            const C = {
                placement: S
            };
            null !== m && (C.TransitionProps = m);
            const T = (e => {
                const {classes: t} = e;
                return (0,
                Et.A)({
                    root: ["root"]
                }, Dz, t)
            }
            )(e)
              , R = null != (r = f.root) ? r : "div"
              , P = iB({
                elementType: R,
                externalSlotProps: p.root,
                externalForwardedProps: g,
                additionalProps: {
                    role: "tooltip",
                    ref: y
                },
                ownerState: e,
                className: T.root
            });
            return (0,
            mt.jsx)(R, (0,
            rt.A)({}, P, {
                children: "function" === typeof o ? o(C) : o
            }))
        }
        ))
          , Hz = t.forwardRef((function(e, n) {
            const {anchorEl: r, children: i, container: o, direction: a="ltr", disablePortal: s=!1, keepMounted: l=!1, modifiers: c, open: u, placement: d="bottom", popperOptions: h=zz, popperRef: p, style: f, transition: m=!1, slotProps: g={}, slots: v={}} = e
              , y = (0,
            it.A)(e, Nz)
              , [b,_] = t.useState(!0);
            if (!l && !u && (!m || b))
                return null;
            let A;
            if (o)
                A = o;
            else if (r) {
                const e = Fz(r);
                A = e && Uz(e) ? (0,
                oB.A)(e).body : (0,
                oB.A)(null).body
            }
            const x = u || !l || m && !b ? void 0 : "none"
              , S = m ? {
                in: u,
                onEnter: () => {
                    _(!1)
                }
                ,
                onExited: () => {
                    _(!0)
                }
            } : void 0;
            return (0,
            mt.jsx)(pB, {
                disablePortal: s,
                container: A,
                children: (0,
                mt.jsx)(Gz, (0,
                rt.A)({
                    anchorEl: r,
                    direction: a,
                    disablePortal: s,
                    modifiers: c,
                    ref: n,
                    open: m ? !b : u,
                    placement: d,
                    popperOptions: h,
                    popperRef: p,
                    slotProps: g,
                    slots: v
                }, y, {
                    style: (0,
                    rt.A)({
                        position: "fixed",
                        top: 0,
                        left: 0,
                        display: x
                    }, f),
                    TransitionProps: S,
                    children: i
                }))
            })
        }
        ))
          , jz = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"]
          , Wz = (0,
        Mt.Ay)(Hz, {
            name: "MuiPopper",
            slot: "Root",
            overridesResolver: (e, t) => t.root
        })({})
          , Vz = t.forwardRef((function(e, t) {
            var n;
            const r = (0,
            wU.A)()
              , i = (0,
            Ct.b)({
                props: e,
                name: "MuiPopper"
            })
              , {anchorEl: o, component: a, components: s, componentsProps: l, container: c, disablePortal: u, keepMounted: d, modifiers: h, open: p, placement: f, popperOptions: m, popperRef: g, transition: v, slots: y, slotProps: b} = i
              , _ = (0,
            it.A)(i, jz)
              , A = null != (n = null == y ? void 0 : y.root) ? n : null == s ? void 0 : s.Root
              , x = (0,
            rt.A)({
                anchorEl: o,
                container: c,
                disablePortal: u,
                keepMounted: d,
                modifiers: h,
                open: p,
                placement: f,
                popperOptions: m,
                popperRef: g,
                transition: v
            }, _);
            return (0,
            mt.jsx)(Wz, (0,
            rt.A)({
                as: a,
                direction: null == r ? void 0 : r.direction,
                slots: {
                    root: A
                },
                slotProps: null != b ? b : l
            }, x, {
                ref: t
            }))
        }
        ));
        var Xz = __webpack_require__(1014)
          , Jz = __webpack_require__(4570);
        function Kz(e) {
            return (0,
            Bt.Ay)("MuiTooltip", e)
        }
        const qz = (0,
        _t.A)("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"])
          , Yz = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];
        const Qz = (0,
        Mt.Ay)(Vz, {
            name: "MuiTooltip",
            slot: "Popper",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.popper, !n.disableInteractive && t.popperInteractive, n.arrow && t.popperArrow, !n.open && t.popperClose]
            }
        })((e => {
            let {theme: t, ownerState: n, open: r} = e;
            return (0,
            rt.A)({
                zIndex: (t.vars || t).zIndex.tooltip,
                pointerEvents: "none"
            }, !n.disableInteractive && {
                pointerEvents: "auto"
            }, !r && {
                pointerEvents: "none"
            }, n.arrow && {
                [`&[data-popper-placement*="bottom"] .${qz.arrow}`]: {
                    top: 0,
                    marginTop: "-0.71em",
                    "&::before": {
                        transformOrigin: "0 100%"
                    }
                },
                [`&[data-popper-placement*="top"] .${qz.arrow}`]: {
                    bottom: 0,
                    marginBottom: "-0.71em",
                    "&::before": {
                        transformOrigin: "100% 0"
                    }
                },
                [`&[data-popper-placement*="right"] .${qz.arrow}`]: (0,
                rt.A)({}, n.isRtl ? {
                    right: 0,
                    marginRight: "-0.71em"
                } : {
                    left: 0,
                    marginLeft: "-0.71em"
                }, {
                    height: "1em",
                    width: "0.71em",
                    "&::before": {
                        transformOrigin: "100% 100%"
                    }
                }),
                [`&[data-popper-placement*="left"] .${qz.arrow}`]: (0,
                rt.A)({}, n.isRtl ? {
                    left: 0,
                    marginLeft: "-0.71em"
                } : {
                    right: 0,
                    marginRight: "-0.71em"
                }, {
                    height: "1em",
                    width: "0.71em",
                    "&::before": {
                        transformOrigin: "0 0"
                    }
                })
            })
        }
        ))
          , Zz = (0,
        Mt.Ay)("div", {
            name: "MuiTooltip",
            slot: "Tooltip",
            overridesResolver: (e, t) => {
                const {ownerState: n} = e;
                return [t.tooltip, n.touch && t.touch, n.arrow && t.tooltipArrow, t[`tooltipPlacement${(0,
                Tt.A)(n.placement.split("-")[0])}`]]
            }
        })((e => {
            let {theme: t, ownerState: n} = e;
            return (0,
            rt.A)({
                backgroundColor: t.vars ? t.vars.palette.Tooltip.bg : (0,
                Rt.X4)(t.palette.grey[700], .92),
                borderRadius: (t.vars || t).shape.borderRadius,
                color: (t.vars || t).palette.common.white,
                fontFamily: t.typography.fontFamily,
                padding: "4px 8px",
                fontSize: t.typography.pxToRem(11),
                maxWidth: 300,
                margin: 2,
                wordWrap: "break-word",
                fontWeight: t.typography.fontWeightMedium
            }, n.arrow && {
                position: "relative",
                margin: 0
            }, n.touch && {
                padding: "8px 16px",
                fontSize: t.typography.pxToRem(14),
                lineHeight: (r = 16 / 14,
                Math.round(1e5 * r) / 1e5) + "em",
                fontWeight: t.typography.fontWeightRegular
            }, {
                [`.${qz.popper}[data-popper-placement*="left"] &`]: (0,
                rt.A)({
                    transformOrigin: "right center"
                }, n.isRtl ? (0,
                rt.A)({
                    marginLeft: "14px"
                }, n.touch && {
                    marginLeft: "24px"
                }) : (0,
                rt.A)({
                    marginRight: "14px"
                }, n.touch && {
                    marginRight: "24px"
                })),
                [`.${qz.popper}[data-popper-placement*="right"] &`]: (0,
                rt.A)({
                    transformOrigin: "left center"
                }, n.isRtl ? (0,
                rt.A)({
                    marginRight: "14px"
                }, n.touch && {
                    marginRight: "24px"
                }) : (0,
                rt.A)({
                    marginLeft: "14px"
                }, n.touch && {
                    marginLeft: "24px"
                })),
                [`.${qz.popper}[data-popper-placement*="top"] &`]: (0,
                rt.A)({
                    transformOrigin: "center bottom",
                    marginBottom: "14px"
                }, n.touch && {
                    marginBottom: "24px"
                }),
                [`.${qz.popper}[data-popper-placement*="bottom"] &`]: (0,
                rt.A)({
                    transformOrigin: "center top",
                    marginTop: "14px"
                }, n.touch && {
                    marginTop: "24px"
                })
            });
            var r
        }
        ))
          , $z = (0,
        Mt.Ay)("span", {
            name: "MuiTooltip",
            slot: "Arrow",
            overridesResolver: (e, t) => t.arrow
        })((e => {
            let {theme: t} = e;
            return {
                overflow: "hidden",
                position: "absolute",
                width: "1em",
                height: "0.71em",
                boxSizing: "border-box",
                color: t.vars ? t.vars.palette.Tooltip.bg : (0,
                Rt.X4)(t.palette.grey[700], .9),
                "&::before": {
                    content: '""',
                    margin: "auto",
                    display: "block",
                    width: "100%",
                    height: "100%",
                    backgroundColor: "currentColor",
                    transform: "rotate(45deg)"
                }
            }
        }
        ));
        let eG = !1;
        const tG = new bI.E;
        let nG = {
            x: 0,
            y: 0
        };
        function rG(e, t) {
            return function(n) {
                for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
                    i[o - 1] = arguments[o];
                t && t(n, ...i),
                e(n, ...i)
            }
        }
        const iG = t.forwardRef((function(e, n) {
            var r, i, o, a, s, l, c, u, d, h, p, f, m, g, v, y, b, _, A;
            const x = (0,
            Ct.b)({
                props: e,
                name: "MuiTooltip"
            })
              , {arrow: S=!1, children: w, components: E={}, componentsProps: M={}, describeChild: C=!1, disableFocusListener: T=!1, disableHoverListener: R=!1, disableInteractive: P=!1, disableTouchListener: B=!1, enterDelay: I=100, enterNextDelay: L=0, enterTouchDelay: k=700, followCursor: D=!1, id: O, leaveDelay: N=0, leaveTouchDelay: F=1500, onClose: U, onOpen: z, open: G, placement: H="bottom", PopperComponent: j, PopperProps: W={}, slotProps: V={}, slots: X={}, title: J, TransitionComponent: K=SU, TransitionProps: q} = x
              , Y = (0,
            it.A)(x, Yz)
              , Q = t.isValidElement(w) ? w : (0,
            mt.jsx)("span", {
                children: w
            })
              , Z = CB()
              , $ = BL()
              , [ee,te] = t.useState()
              , [ne,re] = t.useState(null)
              , ie = t.useRef(!1)
              , oe = P || D
              , ae = (0,
            bI.A)()
              , se = (0,
            bI.A)()
              , le = (0,
            bI.A)()
              , ce = (0,
            bI.A)()
              , [ue,de] = (0,
            Jz.A)({
                controlled: G,
                default: !1,
                name: "Tooltip",
                state: "open"
            });
            let he = ue;
            const pe = (0,
            Xz.A)(O)
              , fe = t.useRef()
              , me = (0,
            uI.A)(( () => {
                void 0 !== fe.current && (document.body.style.WebkitUserSelect = fe.current,
                fe.current = void 0),
                ce.clear()
            }
            ));
            t.useEffect(( () => me), [me]);
            const ge = e => {
                tG.clear(),
                eG = !0,
                de(!0),
                z && !he && z(e)
            }
              , ve = (0,
            uI.A)((e => {
                tG.start(800 + N, ( () => {
                    eG = !1
                }
                )),
                de(!1),
                U && he && U(e),
                ae.start(Z.transitions.duration.shortest, ( () => {
                    ie.current = !1
                }
                ))
            }
            ))
              , ye = e => {
                ie.current && "touchstart" !== e.type || (ee && ee.removeAttribute("title"),
                se.clear(),
                le.clear(),
                I || eG && L ? se.start(eG ? L : I, ( () => {
                    ge(e)
                }
                )) : ge(e))
            }
              , be = e => {
                se.clear(),
                le.start(N, ( () => {
                    ve(e)
                }
                ))
            }
              , {isFocusVisibleRef: _e, onBlur: Ae, onFocus: xe, ref: Se} = (0,
            dI.A)()
              , [,we] = t.useState(!1)
              , Ee = e => {
                Ae(e),
                !1 === _e.current && (we(!1),
                be(e))
            }
              , Me = e => {
                ee || te(e.currentTarget),
                xe(e),
                !0 === _e.current && (we(!0),
                ye(e))
            }
              , Ce = e => {
                ie.current = !0;
                const t = Q.props;
                t.onTouchStart && t.onTouchStart(e)
            }
              , Te = e => {
                Ce(e),
                le.clear(),
                ae.clear(),
                me(),
                fe.current = document.body.style.WebkitUserSelect,
                document.body.style.WebkitUserSelect = "none",
                ce.start(k, ( () => {
                    document.body.style.WebkitUserSelect = fe.current,
                    ye(e)
                }
                ))
            }
              , Re = e => {
                Q.props.onTouchEnd && Q.props.onTouchEnd(e),
                me(),
                le.start(F, ( () => {
                    ve(e)
                }
                ))
            }
            ;
            t.useEffect(( () => {
                if (he)
                    return document.addEventListener("keydown", e),
                    () => {
                        document.removeEventListener("keydown", e)
                    }
                    ;
                function e(e) {
                    "Escape" !== e.key && "Esc" !== e.key || ve(e)
                }
            }
            ), [ve, he]);
            const Pe = (0,
            PB.A)(Q.ref, Se, te, n);
            J || 0 === J || (he = !1);
            const Be = t.useRef()
              , Ie = {}
              , Le = "string" === typeof J;
            C ? (Ie.title = he || !Le || R ? null : J,
            Ie["aria-describedby"] = he ? pe : null) : (Ie["aria-label"] = Le ? J : null,
            Ie["aria-labelledby"] = he && !Le ? pe : null);
            const ke = (0,
            rt.A)({}, Ie, Y, Q.props, {
                className: (0,
                wt.A)(Y.className, Q.props.className),
                onTouchStart: Ce,
                ref: Pe
            }, D ? {
                onMouseMove: e => {
                    const t = Q.props;
                    t.onMouseMove && t.onMouseMove(e),
                    nG = {
                        x: e.clientX,
                        y: e.clientY
                    },
                    Be.current && Be.current.update()
                }
            } : {});
            const De = {};
            B || (ke.onTouchStart = Te,
            ke.onTouchEnd = Re),
            R || (ke.onMouseOver = rG(ye, ke.onMouseOver),
            ke.onMouseLeave = rG(be, ke.onMouseLeave),
            oe || (De.onMouseOver = ye,
            De.onMouseLeave = be)),
            T || (ke.onFocus = rG(Me, ke.onFocus),
            ke.onBlur = rG(Ee, ke.onBlur),
            oe || (De.onFocus = Me,
            De.onBlur = Ee));
            const Oe = t.useMemo(( () => {
                var e;
                let t = [{
                    name: "arrow",
                    enabled: Boolean(ne),
                    options: {
                        element: ne,
                        padding: 4
                    }
                }];
                return null != (e = W.popperOptions) && e.modifiers && (t = t.concat(W.popperOptions.modifiers)),
                (0,
                rt.A)({}, W.popperOptions, {
                    modifiers: t
                })
            }
            ), [ne, W])
              , Ne = (0,
            rt.A)({}, x, {
                isRtl: $,
                arrow: S,
                disableInteractive: oe,
                placement: H,
                PopperComponentProp: j,
                touch: ie.current
            })
              , Fe = (e => {
                const {classes: t, disableInteractive: n, arrow: r, touch: i, placement: o} = e
                  , a = {
                    popper: ["popper", !n && "popperInteractive", r && "popperArrow"],
                    tooltip: ["tooltip", r && "tooltipArrow", i && "touch", `tooltipPlacement${(0,
                    Tt.A)(o.split("-")[0])}`],
                    arrow: ["arrow"]
                };
                return (0,
                Et.A)(a, Kz, t)
            }
            )(Ne)
              , Ue = null != (r = null != (i = X.popper) ? i : E.Popper) ? r : Qz
              , ze = null != (o = null != (a = null != (s = X.transition) ? s : E.Transition) ? a : K) ? o : SU
              , Ge = null != (l = null != (c = X.tooltip) ? c : E.Tooltip) ? l : Zz
              , He = null != (u = null != (d = X.arrow) ? d : E.Arrow) ? u : $z
              , je = YP(Ue, (0,
            rt.A)({}, W, null != (h = V.popper) ? h : M.popper, {
                className: (0,
                wt.A)(Fe.popper, null == W ? void 0 : W.className, null == (p = null != (f = V.popper) ? f : M.popper) ? void 0 : p.className)
            }), Ne)
              , We = YP(ze, (0,
            rt.A)({}, q, null != (m = V.transition) ? m : M.transition), Ne)
              , Ve = YP(Ge, (0,
            rt.A)({}, null != (g = V.tooltip) ? g : M.tooltip, {
                className: (0,
                wt.A)(Fe.tooltip, null == (v = null != (y = V.tooltip) ? y : M.tooltip) ? void 0 : v.className)
            }), Ne)
              , Xe = YP(He, (0,
            rt.A)({}, null != (b = V.arrow) ? b : M.arrow, {
                className: (0,
                wt.A)(Fe.arrow, null == (_ = null != (A = V.arrow) ? A : M.arrow) ? void 0 : _.className)
            }), Ne);
            return (0,
            mt.jsxs)(t.Fragment, {
                children: [t.cloneElement(Q, ke), (0,
                mt.jsx)(Ue, (0,
                rt.A)({
                    as: null != j ? j : Vz,
                    placement: H,
                    anchorEl: D ? {
                        getBoundingClientRect: () => ({
                            top: nG.y,
                            left: nG.x,
                            right: nG.x,
                            bottom: nG.y,
                            width: 0,
                            height: 0
                        })
                    } : ee,
                    popperRef: Be,
                    open: !!ee && he,
                    id: pe,
                    transition: !0
                }, De, je, {
                    popperOptions: Oe,
                    children: e => {
                        let {TransitionProps: t} = e;
                        return (0,
                        mt.jsx)(ze, (0,
                        rt.A)({
                            timeout: Z.transitions.duration.shorter
                        }, t, We, {
                            children: (0,
                            mt.jsxs)(Ge, (0,
                            rt.A)({}, Ve, {
                                children: [J, S ? (0,
                                mt.jsx)(He, (0,
                                rt.A)({}, Xe, {
                                    ref: re
                                })) : null]
                            }))
                        }))
                    }
                }))]
            })
        }
        ))
          , oG = e => {
            let {setOpenDialog: t, setReloadKey: n, isDraggableBox: r, setIsDraggableBox: i} = e;
            const o = LP()
              , a = DP()
              , {t: s} = Pk();
            return (0,
            mt.jsxs)("div", {
                className: "absolute z-10 top-2 left-2/3 ",
                children: [(0,
                mt.jsx)(iG, {
                    title: s("tooltip_list"),
                    children: (0,
                    mt.jsx)(KI, {
                        onClick: () => {
                            o(!0),
                            a("null.swf")
                        }
                        ,
                        children: (0,
                        mt.jsx)("img", {
                            src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAAARzQklUCAgICHwIZIgAABXZSURBVHhe7V0JVBRXur7dzY7KIosoAipExAVUVHBFVFyIaOIaY9SoyeTMyaLZ3uTNm5hk5jwziUbzouM47oa4ABqMK6K4IggIyI7sNqDs+9rb+3/sbqqLbqjuKhSU/5x7Gqpu3eX/6ta9998uj/RwkslkttDEkZBeg+QMaQwkK0j9IfWT/1rIu1EFv3XyVA+/ZZBSIGVDysTE4/HwWo8lXk9rGQAwGNo0F9IcSL6Q7Dlu42Mo77o8hQNApRyXz6q4HgEIgDAcerER0nL5aGDVKS0fToX8QZCOADhCLZ/lPPsLAwRAMJEDgEDMhPTC2iLnqhR+r0E6DOl3AKeVc24zKPC5MwGAGATt2gLpz5BwHtCKpDJZcZNELGyWSZqaROKWZqm4uVrU0iTg8QX99fQNjPh6RsYCPSMDgcDEVKA3lM/jYX3aUiU88DOkvQBMhbYPs8n/3AABIHBi/hISjghG1CAWpT+sKS+9W16sd6+82CK+usyxXiIyZfSwPFM/gX69p6XtY2/LQVXTBg6WuJtbDTLV08cFAhNqhkwHIe0AYAqYPMA2T7cDAkCYQyP/Cen9rhrbIBEJw54W5J4tyjGLKCt0aZaItWJ+V+Ur7sMIaphnMzRr6RDnOj9bB2cTgZ4dg2d3Qp6vAZhGBnl1ztJtgAAQWPZmSNshDdTUQolM9uROeVHG9vTYQbHVpaN07gmLB2H0pP/FdVLZNCu7UXzCs+6kqCK4txVACWZRXaePdgsgAMYwqPUEJC9NtbfKpHnbM+KEu7Pip/IIT6+7OqhNuTIiE//PqCmxnzi7O+nx+J2NmqtQ7noA5qk25TPJyzkgAMYCqBiXkWon7BapJO/7zAfC/8tOmCqTkR4BBJ1Renye+EsXz5gtr4131OPxhmhgJG4wlwAoUUwYzTQPZ4AAEAL55+kLdZXD21d7MC81/i8pkdN7KhD0dusDMLvdZ0W/NXTkBLiHy3Q6ieHCfwEoPzFleFf5OAEEwDCDikIh+airMLmm8vayqPOjylubO/s+d9XWF3bfwWRAUehUf6GTyQBNn+AgAGUVFw1kDYh8XxEOjUEZkwqJZdKKt2PChOEljz24aOyLLmOVvUvS3vGzR8DeRt3q7ya0LwCAQVmazsQKELnI4xbU3kHeVCduTfK8fsqyrKWJa1mUzp3l4sHhpmZFd2avaDHmC1DcQ6dkuDCHjQBTZ0AADHeoHIV0HZa0MZUlV+ffCfXh8YgBF0zoaWUY8/Vaw2e+keg2wHKymrblyEHRaSOpEyAAhgtUGgMJN31UEn+dGhWxJyfJr6cxsTvas9t95r11jqO8oWw6HxGUqbpIkrUGBMDAT9B9SCgmV5KMkOoVUZeyIsqEk7qj8z21zJX2LvH/nuDrBu0zorUR9TDeAArqZRiTVoAAGLhKugcJFUVKapVK86fdDJLk1NeMYFzzS5RxkoVt7qXpSywEPJ5CUabo3R34ww9AQZkYI9IWkFgo1ZNaMkhfSzyunWgpbKp3YFTjS5ppvJl14bVZb1oAQ+krsBAAZAXTbjMGBEbHPij0A2rB8JmqmX4z+HF6beVYphW+zPl8bezTQrz8UZJMl0Cg/Gs3k74zAgTAeAMKO0srsDkg8kLq3YqiiUwqelXyrHN0TYHd/WjoL5W3uKOfAqDEd8WHLgGR6zGwIBXRwba0+xd/yU7076qCV/H+/gm+91fYu0yh9R0lxeMAFFR+aSQmgDzEgqglZNRWhk29GTz/VWQ2kz4jUzMXrE+3MjCiqxNOAiBrdAYERgfOGTh3KKlFKs5wuHh0kEgmoe9BmLT1lcljbWhckz7/HSnoV+grr5kACq6+1JLGESLX9KE9k8pO3PvG6ZTMuuoOcqtXhtNadNTfbljmr5P8UHVNpSQABKUcWgPSYVV14WnexXUxV/vmDS1AuTFrWby7mRWK76n0ZwBF5cujuKl2hMDowJ0n2ispSSST5dj+sd+W8HhoLdhHDDlga2RSn+b3Doj1VPYnaMnipG4XrwmQk/DAamqda+5fuXalpAAtCvtISw586zYl5iNnD7og8isA5Ht6UR0AgdHhCpnSqRmLmhpujQ0PnKVlOzRmN9M3IBvtR5J5A+3J6P70OU9zLWHlheRIYSaJqiph1JT5VvZkmd1wgr9MKbWuioRXFJLDUE+NiDtbuUL/jUITgf5QSjtQBewIoDRR26YOkN8gg8rSzO9OaERcVQna2bImBOOk+xytgKBXGvw0l3yeHt1pW3aCEHb5ILS10I0QmLceXucMFDCcSNjm5jWe1povAJAdGgGRW4vkUjNUtjRHjgg7BpYh3Jh6nh4/l3iZ2+jGJcpTCAgCo45WDBpOdozSaPDCuG4ciasTUeXDnkDMJHv6+nulhnw+WvMrqBQAof6vymQAZBvk/IZa/er7V+5cLSmYwb5JpG1UXPJcyEVRRNhUT6ZH/6G2rEjvAGJvxM3aY1HcZYKjhQv626jJ8VtdxtNXXKj2Pa8oX+WTBYDgvkMpQm+UihOHXDjkztXo2OI0lmwdxp0c0vEGmn6pEn4Sk6ajET03tCsvmezOR80sezIUCMRFizY1g06e+racAEDe7gAIgIGKJdQCKulgbvKlL1PuLWLflGclcA0Ifk7oE7y3hS055YGuJdwQl4Bgi65MXxI32XIQVYWBk7qlQmeiHCEACIqHP6F0Q+Tw2y5hfX8Tdcp8nXrbBwhoq2wcck55LaQr8tYCILiYap9DABCURirVsk/qam6MOrN/Ns/EiPCMDHUCgP5QHyDPOFKy+L0SfZ7K5H4GAGn7zraNELmIPYPKwK+iwq/uy0zwg5054VsM6AOEEw48K+T4pPnxr9s5USf3GgCkTVirAASdZ/ZS63T67ecMcITBTSLhapT0jZBnHA4YPCL3qOdc+lQwERVYCkDOQL43FYC0isUZ1r/ufA0y8NuuQS6+OYwSlMiwoD5AnjEP/FGkhf6b8M9n/H1GbZtEBSC40FbqN+4XPw6bf/WUigKKZ6BHeP3Y+c/0AdLO/ZwFG7ItDAyp1juXAZBFPJg/8GIW9cX/4l5Y2IFHDztoBPn9ARB93T0I+gBp57KaeaQMALFBQFC/cYEKiEfQvgf5jXUdjRdwgjcHtw8dP119gLRzedMwt/Qfx86gq3gHICCfQjb0n1NQi9mR72th+lDrOsDTExDeAN3EElwDok6s0dM3hgomTzC3rrw2801L2pQ8BQH5D1x8T3FDLJUmWR3foWLUQHuI8IwNIdEtJ+m5Ov6/CUTuX7twZzWkTnSCtRbM7tSOoOuGUnJ8l/WAHAJRPNdkwOcTEDbSi12HgKA7ATrut1FZQ91Fl+B9Xappef1MCM9AX6t2DjXuR+56BWj1jKbM0dWlZFUC+vl3JK4kylgyCjBRkNkdVAobRPBlpEp7/4GA4IZQqYiPfSo8Nu/KyfVMGqDLJL8NRggqp9hSZ1JYrj5bqKT6FkZId1Huwg3x5vqG1A3icQQEg7EoNVk3hbmHll4PaVskd0m4P8H5RIDuhcyJjfKoFrR432XHa9SFKFqBOpGvnSeQASD91YVCnuaRz9I59efs0Ixkv7U3hhiZzqbcuIyAYDQc5QR+MS/90Nu3zjMDBEtCUHB/ouVyGN9iP1CtuvVjpsKtFbeSaFAYhZTkMdbioSh+ue0w4gV1DdBjBkxafRW5CqpipmpiXcBWPHNv9soLrv0tXqeUEYuAoE+cctkUlJl8+P2oy4zDXygK02VOYdOZl+HZC9MCQqYOtKMqb/IRENAuttPBlLgjn8dFvKtLh7mSeelSd2985ujEeYEBQ4avpbS9AQFpgQvK8RyYnhj44f2r1Exa9RVXXjha+qhrDhyaOPf4G0NGrKPkbEFAyuGC0lz0Qm7GibW3/2C1kG/bPKKYRccdfdddeTly/O7lf2KWjT2V12UISD50z1HRxdvCvNMB14PZO8HzQcyCI0VPvewLJ/V5OKmbMrPZrpWI2ib1M1pO6ssUk7qA2Z4praGahD+nSf3ajKVBEyxsV1Jer1wEBDX4SuPp+JLiUN/LgUu5egdR24hzC5XYLHvReO3vDJe9f4NlL660dCEmtl+6lEt9JtZ39e8j+pmhM5SCEhGQSPhvquJKRkXZBa/zR6hLMbb1Ep4AjPJxaQy/XG0M1Rk4KBraWzaGSXPXXrY3MaXaRd1CQEKgI8sUnalqaowednoPeyszNTA6DLQikT6M/R87fRE6M2LrLaIT4aKNDyC6HVW4dwoB+V/o+VeK3kuk0uKBx3eo+KCzHiLyAja7jCPbxk3jqjjSm4WLyISKgD9VwL6a6n/zLQKyAe4doXLJ+tgP9SJZ+2aRKw5+OsqTbHXjLq5Abxa/mwr0a4X+G+nWI2sQEAwNgcEAlOQTeiQnsbqM8yAAXAPSGw3lFEz2tQYXam9/9MOh0gQEBJUkKqFQ/3ovPHrvowTO55E+QNp5v81tctQnzuNxMFDJRGHkkAdXnRR3YooK7vuFn6a79bL+cvUB0s7CmDmrHjibmlMn9DTQqY9WAHIIsioFiiKJpAzMgDiP/tYHyDNA0DWhYvH7dWB0TZ1D9gAgHykAQevrQOoQmByy//Gj+hpO45f0AQIclkrJZDPr7Cuzl6sE8IE7bwAgoQpAMCRqMRWQ3fGRt79JilSqdll/r6CAVxYQsZjIWiG6hkhEZBIp2eU1L+pd1w7zhzkAUkO1fke/wjbTUaTKhvrk4cH/4s6ZoxsAWXn7DxJd+eSZxhIFmpC8rYe8WHcE0GbIRMB8iaQttf2touAgRPjWJ/n9DQ2VczawJgbAaJuzqYD8A/7/K3UkeAT/qyC/oV4peGQ7SrgeIQhIVBka7bcTAhI0kxtDCixVrX8IqpCkmKREBonAW9/GfDGAoKpe6sAyMP/JjVj6Lt2uF0PN/kAHBPcd6EGlpMD0+Dsf3r/GiTsbFtorAXkUT3ZlgqEDvuUKAGhvvDYvauCMxdGvj1BxgMTShgIgbW8W3aUtAa4pQ7o2trQ8HnzyZ84mdq4BGXqmYzAEMwNDkrJYaw20Rp7uSoslP6XHacPzTvNWrP+8Ao7WoIpLbgIYSkMHOiB4nASeZKCkzddDH4QIH3Fi3Tba3IpcmcONcLGwoY54X1FZGCrbHLVgLbE31fpoErWMXHA9mKRWow6PPX3g7B7//fT5dKfP9wGQA4rS6YBgnPNCatVVjQ3pTkF7Xbly/AyetYR4WbGXXX4WF0GCCtRbFK50HEl2erJ3q48uLyYrbp1jjwSUgHsP4eqPhAOMjKlfHIzFaAeAVKsFBC+CKEVlk4jXVlw+lQDRqelO7zo1FD8pQTOXEDczjSdYdFluyONMsjU2otN8uyb5kuUOuhvkpdVUkJW3z5GaVjQ5YE9rnVwT9/gE0CN840ExKrHy1UVywBUAxp1VUnFtdaLb2f9wFi4cQdk0YiyZP2Q4Y2BqRS0kuqyYHMxO7rCy0sQuXHFtdh5L/AYzj+iAQIQV5ZJDOcmcgYHty1/1Ya65sYoDLXrfYmgNlWP81LpEwSg5Bpmp1hDkgxvnok8VZHIucGT/7vX8EraMnBD7jfdcut7hJwDjM3rrNQGCkasfUTO3iMXFjid2mzVLpezcqHo+/zhtobmeQWPOmo9FAj4fT5BQkNrRgTc1Og3CKPkF7n9IbV1oVsrNDZGXfDht8Ute2MW5K+Km2Q9TiXUMXcazrP6uruudAYLrRozugsecKmnG2YPpybWVL+SsqN6G3Sxr+6xz/mvwa0OlPABDYzCGTt1qYZSgRwk69LSPtdbWAqdTv1jA0UXcOK/3Ni4zbK+5QL8ua83HLfoCgcoLDY/jMUnqo+Z09slS1AugqOze8XpqaXHUtEuBdG0Xw6a+GtkeLtmU6mgxEAMqU+k6gNFpVL4uHc8BEJQAo9eKisHut9HXb+7KeODzarBXu17unOgTt2nsZPq8gQGUxwAgIJ7WTF0Cgo8CKGi3hfZbVGoNuBiYfrusWGPIU+268XLkXuEwMuOA7xLckVJ5iwLEWQCGxni9it4zAkQOyn74VTmtUyqV1s8IPSxM7Zvk2/g5y3Zo1rmFb+EulG7QrHFVRX8NGQMiBwVjwKuIUMQSSal70L7WopZG5pEmX47BoNKL8ZY2+REBG6yBofR9WluEBqZd1hYQNHxAxzsVm62m1tZ8z7MHBEXNDdSom0zb0OvzjbWwLroZsN4YxOp0v3M8b2U2ANLAtJNaASIfJch0rEgleCOMlJLJIQfqc5tqOTewY9qZF5EPztHNv7j4HSta2D5sCko6JqOeXJt2aQ2IHBRczt2FpOLcAXbBlXPPHytNqCpT6ua1aUxvyzvfzjHllN9KF2A6PcKbEPqC54V0uqJS11+dAJGDgsIyPFCSKqPBFVn9l5FhCQeykzhT/fZEoL7zmB77scdUdYbKqIrFFZWKxJxpH3QGRA4KLu9uQOpwsnLCE+GtReGnPZqkUhXAmDasp+YbqG9YF7FwrdDRciDdLhebjPHy8WBJZqG31XSSFSCUOQWjDdNlNqRZ1CpcHhZUdre8mK627Kn87rRdqx1d0/bM9B+sJxCo88NDg/VF2s4Z9ApZAyIHBdV/GAxYrTglqjD/1tu3fh9dKRLR5Tq9AhgHY9PKIN/lRa7Wtprs1M4CEEqnJzad4gQQOSi4GcJjrD9S1yA4Xq/qh5hbD7enRU+H0E+6R0Fj01stnzXg8SQ/TvBJXDfGE0Ue6kKzgiEWwVMOftSyaI3ZOQNEUYNczPIr/G+srta65qbsr2MiSg7nJMMqpGcCA572EjBZSvx4nJeDqbGxJqPznn3APZX5AAoObQwMrNEUFYDJBWCeHM5JweVhjxgx0G7xV2O8H27x8HYw0tfvzPr/KvRtPbT7KVcjQ1EO5yOEMlIw4iZqHFEzplF3Aqrhwos5aVnbk6Lsshpqnv/+BUw/Z9jYZ386ZkrFzKHDR4KqtTPHeTSR+hSACOYaiG4HhALMIPgbv7FdhuuoaWrIOJ2VWnIs++Hg1NqqDqs2LpkwzWpw7vrXxpUuGTHaCYLkYxu7IgyDiELCxq4ysrnfbSOE3ij4HKAZ0X9DYmS6iEYVcU+EOYHZSfqRJYXWjxvrbAifr5s5olRa52pmWeZj51S5epibYIyNnTMsXZmUhcYIRyH9E4AoYMNops8+N0AoIwalwmj+gmckahO4sUEEAZ6rm5tzypvrK1pkUn2RRKYnkUn0RDJp2xwE8dTFAp5ArC/giTFYsbVJvyFmhsbDQM6kbhPXGY/QdhQPJ0CvJq1kUUwZrynfcweEAgzu4PHgMbSMph+YxbZfujyPS1icrA9DOgdAiHQphO0zLwwQasPhc4Zv8GZIGO6cM38UhszBo2WDIB0FEFS8yBg+z2m2HgEIDRw0kcETWTChxTTXzqdo2oSiHjQORqMDFVNOTrmrQ2E9DhB6H2D04JyDKy5cEqMwE88rRxEMhiVUJEXgRjQkwJCFGNcVf1H8jSbymDCcesrznhO0xeT/AUgDKsMcJpvaAAAAAElFTkSuQmCC",
                            alt: "list",
                            className: "w-10 sm:w-12 md:w-14"
                        })
                    })
                }), (0,
                mt.jsx)(iG, {
                    title: s("tooltip_replay"),
                    children: (0,
                    mt.jsx)(KI, {
                        onClick: () => {
                            n((e => e + 1))
                        }
                        ,
                        children: (0,
                        mt.jsx)("img", {
                            src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAAARzQklUCAgICHwIZIgAABdHSURBVHhe7V0HeFTVtt5nJj1AGiEJJIRAEEiAQIykAIEAho6gFMGCgnLfu++KGr3e8u7zie8+r/oE9do+pFkQgaAiSEkgVEMSSEIgnfRMEkgnvUy7aw0z8845mXLOzJnJKK7v29+0ffZee/2zyyp7b4rYOCmVSl9g8QFIEyAFQ5oMyQvSUEhD1K8e6ma0wmsHpE71axO85kEqhVSMiaKoBltuMmVrzAEA/sDTAkjzIM2HNFJgHiVQXoo6nQWA7ghcvlnF2QQgAMJYaMUmSKvVPcGsRvF8uBDyH4G0C8BBsAaVBg0QAMEFWr5WDcTsQZXCvcqVkM5B2gvpOwCnbzB4sjogAAQOQVsh/R4SzgO8SKFU1vXIZZJepbynRyrr61bIetulfT1iSiR2tbN3cBHZOTmL7ZwcxGIXV7FdgIiicA7iS3fhgY8wATCNfB82J7/VAAEgcFJ+Td0jOPHcJZMW3mhravi5qc4utanOI+tuY2CnXOrK6WF1piFi+84IT5/qGE/f1lleI+Vh7sN9AThcJHClzyDjewBMOdcHzMlncUAACFwRvcsFiC65VJJ0p6r8u9oyt3ONNeOhJ/ASPldBQA/qih8RULJyVHDHQp/RwS5iOz8Oz34Ief4GwOAKzmJkMUAACCz7d5D+F5KnvhbIlcrbl5tqi94qvOZ79W7DJIu11EDBMz19C/888aHGmcP9JokI5W0g6234LQFAOWgpPi0CCIAxHhj+BtJD+hjvVyoq/lGUKdlRkh1DEcrOUg3kU66SKGX/NSny2kvBYWPsKJGhXoOT/9MATC2f8rnkFRwQAGM5VPwtJJ3DTZ9CXvF2cZbkg9LrMUolsQkg2IKyE1Gy18ZHXE14YHqgHUWN0iPIFvh+FYByiYugueYRDBAAQgyV4lyRoKty+Pe1767Iz34tL3WWrQLB5tsegPkwbE76hoAJ4fAbLtPZJIcv/hNAeYerwI3lEwQQAMMNKjoOSac+kdvWcmlV2vFJTf29hsZnY7wO2u+BLsNqj8YslQS5DIvSw8QP8P0TAEyPuUyaDYja1oSmiBA2MzKlonnD1SRJcn31NHMZtYXn1/uPv/nJ9LhxoNvoGo5TgcdlAArqMCaTWYCoTR4XoXa0PzGoQ9Z/MzzloGdjX8+A30zm1gYeHOfqVvtz3Jo+Z5EYzT1sKoIvYs1RJk0GBMB4ECpPhjRgSZvRUp8cf/noXIoiDjYgQ8FZcBbZ9afErsoJGeY5Q0fhlfDdfFMVSZMAATBweMIu6s5iSPa3/LRzH5fdjBdcCjZY4AdhsVeeCZwUDayx5VgN3z1kiqmfNyBq83gWVDiCLiOwzN1dk3ay5GyjRK/uYYMyNZuldf7js3eGz8M/qBOrMPTDzAJQ2vhUwgsQAANBSIcURK+kX6GojL5wWF7W2TaOT+W/lrwzPHzKT816xENMURpHmaZpKCscvrq5tpUvINlQ8HR64WB9rZ929kBfdU/naK6V/hrzhbt516TMedQDBMpegR0HQFZwbTNnQKB37IZCN7OGqbaYC4nVhe0tU7hW+GvOFzfCv+CHqKVoSWZbIP4EoKDSbJQ4AQJgrIeSDrBK612e+lP+5eZaXG39RmoJbAycmAfafSh8pMtWAZ9nAig4hBkko4AAGBhUkAnJkV7S6wUZJ/5ZmrPUWAX34++7wudlrPEfH8lqez18nmps5WUQEABDBIXkQ5pIL7yovSUp6kLiwvtR2FzajEItWbSxcLiDE9udgK5hjBvQS8YAeQGe/Cf96T6FrCjgxBe+/Uo5Wwfhwut9k2eEo3Nb0cKnFOBfYa+8UJO/rE8QegGB3oGGQHRbYuyTliLPH8or7riLw5hVKXSoB4l0G0FGOw8hIa73/gshQzyIm70DSWvF0YCQdrmUFHS2kivwOf3u4IdfLfMLKt7/UDy6rulUCIAMsPtpMhgCZMCq6tidihNPX0222ryBIKzxHUtW+wSpBM+H2qT9JL2tgZxulJAjdyr4PCpo3otzHssOcxuO5ns6vQSgoEt4AOkEBHoHLmNv0nNLlcoy72M7fQhFMXqMoNyrC4v28CEvB04m+CoESXo6yY7K3EEBxsfJpbMo/ikw6zH0k3Zo12hdWrw+QDBw7DG6MNZlnD6bVF+FEYUWI+wF2ydGkYXDLWMgRmBeKc7QDnEWawir4DdDIq9uDZ7GNkT+NwDyJpuHAYCol7m59Iy1PV0XQ8/sn2PJBiAICAbfockUnvbUFJP3ocfgsGYtql26SeIqtg+g1YdxyNhLGFEsugA5DBnX0BldcPnouczWeoy1tQht8p9Ato23rn6Z39FK1t1IsRooLwaHXd8WEsUwO4Ew0f37Fl2oDECgd6Daj1HiWmrp600NSvoSIkMGmJgFAWfHpCjVxD0YhD0EQUFwLE1gDVc2LHu+wVEkok+MzQDIcEOA/B1Ro2dYm3H6cnJ9lUVib7FXYO8YTLImKK9PmpGdMH46e8W1GkD5TiMDdg/B9eEYzY8QN5vj99OeMEv0DuwV2DtsgXCyX5x12uLDl5NYLKtbsrkXfPL0leoRAEQ7RWgBgeEqBoSDXkAt7SrPPfnHvCtLhBYa6heHwuabPIHX9HaSml6mi8HfyYX4O5m+Ikflcm0OxmpYlpJnPZI5w9M3glaLFN57aiZ3OiCfwA8Yka4hqf8370s6h7oIPsCfjlhMEBQ+hCDslhST5OZagv9oXRQAWny81yiy1m+sSovnSwmF6STxjmVjqheOGF12KGox25G3CQDZh/zSAUFbgzZu6nZH2/kJ3+2Mo1ycCOXEMPTybScj/8tjppCEIO7uk3aYeFGpw6UqH0KlcsfESF69JrmphmzOFTQQUSfLjcufr7enGJP7TwAIRnzeA0SX7vHntDPJnxZfj4eMYB4bxkcWevOijpEauYLzUIV2qYSidJNXQVhfAvwBuC4ccLW1KPOUIG01VMj+hxZmL/MbQ5/cO0HOqr0yGkBehPcf0AsJ/ObDolZpn8rsLlQv4dM7EAwc04VQ3rguIHBYjE47ZnFAVo4cV/5FxAL2VBCNDiwNIMiFqssg9ctkRcO/3v4A2K3QHwIvkNyhl+AbE4lP78BhKibjmCBgaNjdDMvrN4wonzsqclUavKUJ9qMo6paqvOEq+apJpSRqAMFZUuucz6irTno4+SDDAUU52BFqiOn7Z7gIRMMZ9gyNSV1I4bwPIVSrfRkBM9riheyRXHiuWPRMqYeDI27z1lAKALKAgvkDvVoF9EJevZKU9PmtGwM8gqKhAIi9aTsIuK6sLD2x6lJG0XeCc5W+1RsXAfPNo2MeaQdA3BCQlVAYRm9rKezwZ1kV3R0DjEuqCd4d5h6eQxcuR69EcYuEiUk/ZnHBID9R4OwaZmev8plYw3TCBmxzUEjh9imz2S5eHwTkT5D5bdoDfcP2vd1OKJHOrQOUnZhQw/gpYFyHK3QkvVyYxvfP9ovMH+7u3XIu9lF2XPRsBAQVkmc0rZIpFDc9v3pvqqFWUs6OhHJmR07qf2LPlFgSz8HH8RzoAEmgC9wP5CASETA2spv6HAJyBb7FgGEVNXZ1nBiX+JlRN61oCGwocrDnJDscrnCYMES4sgr9Gf1i9w81gYIIexnp1t93ERA8mEWryl+7I/ly/ulvN3IRC9dJXhK3wWhxlp7MjTIwCBkqFz+T7W7vSFcQDyAguJNUe8DLBUn5nhUpRxgho/p4VeknOJ+IcXuhbkITxuFpeIaMYbKWDmCMD2v+nh//5PlRTq5xtDqTEZBm+EI7uZyoKNyz/uJxToBgQSpQUD/RsxzmCsj9NH9oAEiPW/vTxKEey2iAZCEgXfCFdofpweLcvVvSTuHJPLyIgjmF0jGncAXEUsogr0ZYOfPJmSuOxHj50SMZqxAQPAVHS7vzMvclZJ571hTedNm8fgNEvyS/evDh/StGjX2SlqMTAcFjiLRRaPsLc/b/PiOZnokXNthLsLdo6DdA9Itv34MLvlo1atzTtBx9CAgeg4cHxKjoeHnRgScuHTO+LDIAk0p5RDMLTDBcAbGGc4jXP8sKmWEvyQHYU0KXdSMCUgl1B2rqvySpOLQsJXGdufxQIjCzQE8J9fAmaMcyRvfjKuvc7JWHwz188BA3DZUjIGhv1gZPZ9XXHY07tR/tW4IQehtrlhpfI9iiHhLlfm9fq6UCt6/Ne/yH8UPcVtEEnYOAYGADBjioqKi58acZx/fRl2JmA5Ox6Eni72r48Dh0RE0eZE1dE2EfA7oTPZwVrcDP518W3AiZt+DJU/4urvTh4yICwojjbe3pTg889LGg8Tl7oxeRhSN1+yHoaFtbF0FzTqSbN0EA4r38DbqWLfGHqV2yKQtOt6Nb1Q8iIBjK+BeNYOQKRZ3HV+8JejTr2sAJ5P0I45Golrb2otcS95jcA2CUUfsae2gQWldqXfG7ZtCrtQsqqG8bAvIMvFGFoGjI68t3O6VK5kYdc8at0TBcpcGwxYWE9ofgMITDD/YAvqFHlgTERWzfXrd0Ezt6ZAMCgpZetPhqKfbovrKcu42CHgKQPH8NCXVnhLHqxAfN7zh0CUFCxw3jHCdE0AW2Lc4btlBHL2XvpApHQNCOhfYsLf3lypn0T25dF3Qe4TpsIRNCDA1cI024Ao8rrTXXz3LNbjTfGyEz0l4Knq51e6gfcNEEOTBieq/WVmUsOHOIva3XaCWGMrg7OJK0hU+QYfBqjNr6+1SxtpJeNLOZRonTFxDNstW0EphPCa0nZc5flxXs6k6f0AvARR6qAWQPVK9VFqRyeaPX19sFP/3tlUkRJCGE29k0+XebyNqMU6RdBKY2O/6BFVy9lFzBEqLXaurCrQmty7d0QNA1fQ75GAB5QQPIE5B5P525iCM7q291tgl6fgmfXoK8ICgJWedJfjuMqKBgqqzJ4PrkQlxNNlzKEtSbqVDgUrs0KW41PQQI2cADNY9qAMEjUevozO3ITr30xs3UWC4M88nDp5dguW39vQDKBXK67t5OWjTJqFzH0Gso9MEYiIARah4x24ogkxFlv4wQqZQo5QryYdTDac9OHDB/uOMmUHqwNd4SoD2xobmrMzco8VPuUdE8UOG64qIXiYBsu5lKqrvwepD/J0oMPQY9lmjQhMQe3viEr+prwhslWdyDvdGbIQUA5HBgKSZ8z3BwEFK7/sXKoY6OY2j1XQUwVHM2HZABu6fCEj+tqujq1BoeecjcYNbJsPxNnL2C0wTPLgiBOVxVRDKabpO7MPnrIncnJxLlPYqsAYV0kY/57GMANiN2CyWswKQgSkgE/vUq4cvkGLhusO0Q/lN+YeWz7Lhe7WlBdEBQ78CABy19XZh9+T8yzlpkOxufZbC+Fkq62omkm9ljAlyGkgBXYaL1sd4aKD8qBU4WRzmj8BEEwzI3CMiB2cvTl41jbB3D0gKgh6hOyWZvabsO32mPdO3u66v2/fZDQSd2Ordvhs0im4MtMioK1ZlJYlUxeSkTTxYXhlo3vtoMV2vQzSUXAAxtoAMbELxOgnFK86aUo1lHJLcstmf5A7Bx4dBiq/QygHEYQBGC/j04LPudWQvZmz63ACC7NOWzAcFzzhmhg63dXYWBhz/Byd70vQhGWsN35SWEcLiWEXp8r965imsZ6nzKmsdfkAxzcqaPOL3wmx8Aoj18eYCQYVJiKIlY2OpTB6/D6dTsTe88+TGcHeeUbVNnmjTRC8oIrTDUg+JTEgUp/qkxE3M+mbuCfcI3XhTzR3oFugDBFUAZPVNd+92cid9/bvHjwnH1tePBOE5GSCGkVANLaEOOsz2lueT1Gz8LURWpXveHcndnxgZaPCc+EABhXKmkcxiCXvIlZKZHQ5At539MP1hVLKjBUV9LcQh7LniqRXvLjoJrZE9ZLon3G6PXV7Pm0o/kSiNDXzYJnJcnhF/bFr2AbTPaAWC8wi5QHyB4IcsteuY+mawu4MAHbr0KhenbqHg0B80sm8dNERSYdtBbEqtvkd2lNxgKpq4luFCrKw87h+7yDVulYpEIb5DQkM7egT/qnaihl+AtZX+gy/BoSd6Fp1NPzuUhV7OzIjD4L14ELmAubmBdFSaBMokKZfLtSr0TdIz3SC34aQ21ZHshnvtpPp1csCZzln8Q/aAALPR16B3/o6t0Q4BgVALuomd4lWK+312Y194yKHdFYQNQcKFuXjDPeGvH/2F2Dqp5J63p3vCCPQEnZPxc0NYs1CqJNzpzvf1Lji3dgKMNnSoADL2HMRhcykIvwR0ln9NL6+nvrwo8+JFHr0IunDrMu6m2/wAMVR1lG7b22YlEbDfpIwCI3r3XRnULAIWhvaMo8hrq0mJO7md7u2xfSlbksOCxLXn+Q93Zh4WqdtoaYoMLIKgU4m0IjDuYtqWnXNhelDXXim38xVT1UXT8tY0TprFXVXiJ2GQABK/e00tGAcEnoZfg+Yvs/Wb9y0/sL7zYWBf2i5GUFRhdNzakcFfsMrZlAw2IcwAMvef1aljjBIgalJ3wuoXeJoVC0Tnz6F5J/iBO8laQMecq5voElBxbvB4jAtk+Z72rKnbhnAFRgzLgugqZXN4w5fBn/bV93ZY5SpSzOAY3Y7iXT+X55Ru9QaBsPe0U9AzOZ47xBQQDH3AjOSNmC1ZelQ9+v0tc09tFP3VzcCVkxdqneo2ovbR8ozMcK87ed34N2IgDQDiHz/ACRN1LUOhYEeOUY6lM1hDx3e6Oip52QQPsrChXk6qa6eNfeXLxhuEgSPa+b7R0zEA/OZ+CeQOiBgXvx0CrG+NAfogLbpl3/MuG662NjNsU+DD0S8q7JGBc7sH5j+FJruxgMwl8F2lsRaWrrSYBogYFl3VnINFtNLgi63wtNen6ztKbFnH92gpgf58ee21rWJSuIDN0xeKKimEx58q3yYCoQUFX33lIA25Wzr4tubjkzKFp3QoFAzCujNlqPm97x45zi5+UBHp66brhAO9awUvA7l3XYAKZBYgaFJxT8DhPts2G9Er7JauSDjemNtWx3ZYmsDr4j2wInFjwcezSkXZisa67UzBgfQnfOYPdKrMBUYOCTnu8nFinOSWtpvLi4xd/CG2VSo2Hvw++3AdwMNrZtSVx3uraSd4++iIyvgcgGJcXmNoMQQBRg4LK0A5IeCvPAILr9VrfuXrxxj8K0mdB+CH/YF1TW2jGcw4UJd8ePjfn6ckRaPLQFSWO13f/BX77PzOqYTwqGCCaUtVmlq/hs7MuJjt6e0pfv3quHrx1kbYKDOy0l786KSJn69So0a7OzvqCztH1ipZbQQ/4EhwQdW/Brv0NJL1BVwBMOQBze09ZHgBD2UaPUSplf50cfeOladGjneztDUX/46XMGwGMO0L1DE05FgFEDQqGqaPHET1jen0n4BquOVFWUPLWzTS/W11t1tdfIAwxdoR/acLkyOY5AWMngKvV0GVnGCKVAEAIE4qiA02LAUIbwnzhPY6xRjcZtvV0FR0qya//ovTGyLz21gGrNiH/jbOGjyzf+MDUhpXjQsc4isXIozHaDhnQSMj5XltjBer63eKA0IDBMKK/QmJcFqOPaQyqyLwtKfu69KZ9akONN9y1662E07lMaqRC0THBzbMxzm9My/qgEPHkEX7BsHQ1vHH+XkUYjPAFpHcAiCpT6ub7jNUAoQGDVmEMf/k3SNwPbiSkC5wKha09PeUtfd2NPQqZA1xUZtfb328vVypUcxDEzMrsKbHMXkzJ8LBib5cho9wcnYNgp5Lea+r0CAzPf8GTvnFXEy9bFF8A2PmtDggNGNTgH4eEW+nYF2aZ2y5TnsclLE7WeyH9CEDgNRJWp0EDhN5SWCrjP/g5SI9CMn9DBz8x3oDseO/WFwCC+VFx/OoekNsmAGGBgyEyeEgjJjz+QejNpxjahKYe3GOAQQeMUE4z5Wn24zYHCLtF0HtwzsEVFy6J0ZiJ5m40waD/QZM0t7dgIAHu4MGz7PEVAwpwLwGmEkh51p4T+CL0L8AbX+ck632OAAAAAElFTkSuQmCC",
                            alt: "replay",
                            className: "w-10 sm:w-12 md:w-14"
                        })
                    })
                }), (0,
                mt.jsx)(iG, {
                    title: s("tooltip_ai"),
                    children: (0,
                    mt.jsx)(KI, {
                        onClick: () => {
                            i(!r)
                        }
                        ,
                        children: (0,
                        mt.jsx)("img", {
                            src: r ? "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAAARzQklUCAgICHwIZIgAAB4NSURBVHhe7V0HWFRX2j5DLyqiVKWIYsGGYu81aoIaTY8pxmRjNvsn7qZusqlussmmmGqKaaYYY0kxGjVYsMUGqKgoFjqCIgLS2zD873udmf/OZYC5U1yS/b/nOc/AzL2nvfc7Xz3nakQbp8bGxkB0sTdKL5SeKP1Q/FDao7TTf/rqh1GCz3KUCv3nJXweR0lDOYNyWqPRXGzLQ9a0tc4BgC7o0zUok1GmoHS1cx9zUN92QwFAF+xcv03VtQlAAEJ3jOJelJv03GDToFTefALXr0FZDnByVd5r98v/Y4AABC+M5maUBSjjUf5jfdHPqk7PNV/g8yeAU2v32bagwqs+CQAiGP36K8pfUCgHVJGusTG/ukGbW9PYUF1dr62t0mlryuprq501Ts7eLq5uXk4uHp7OLh5uzs5e3s4uoU4aTZCqBq5cfBnlbZQPAQzl0FWjqwYIgKBgfhKFS5NFVKmtTz1aeunib5fyXfZeyvc9dLkwvKKh3tuim/UXtXN2rRjaKTBndKegkrGduzREd/QLAnBUECyhGlz0GcqbACbbkhtsvcbhgACIzujkKygLW+tsZUN9btyF7Iwf8tJ94gvP9QQnqJr81uo3/A4OqpwWEHp2TtfI8umBYZFezi7k2tZoCS54EcBQg3MYOQwQAMG6/4TyKgpBMUsNjY3n91zKO/VKamJQwuWLUQ4baQsVj+kUlPpUn2GFY/yCo5yExr+FS/Px2yMAhUqAQ8ghgACMCPT2O5QRzfW6rlGX+eqppNy3zh4erREaF4eMTmWljaJR+1zUiMS/RUZ3c9E4tcQ121D1XY5Qme0OCMCYgc7yCTIrsGt1DZn/Pn0o9520I6MbG0WbAEKJm4uTRvtkz6EJj/YaHO6i0TRnBxXivusByn6VuLd4ud0AARDO+uXpCXMt4ukr+yzzxOEnU/aObatAKPvtCmDejZ5wYF5o7xj8RjVdSQ344imA8qa9QLELIADDBx1ahzLRXMeOlxbvnrt/Q9SlupqW1md7jcnu9YR7dchbNzo2N8Krw8hmKv8BoNCotZlsBgRgUM/fitJf2Rtto65oXkJc7paCnEE297QNVHB7SM9jHwye1AO2jTntbw+6GAtg6EuzmmwCRO/y2IXWQ5Q9KNfWHYvZvqpTYW11k9+s7m0buLGHt0/eb5NurvV0cqa7R0l0ZE4BKJQvVpHVgACMaLRIJ10TlfZgccGWaXvWTdRohJtVvWrjN3k6udRtHz83uW+HTsPNdDUT302y1pC0ChCAQTd4AkpHRYe0z57YH780/di0Nj6nduneO9Hj990THjUKlSnnMR3fjbbG1a8aEIDBJeggCt3kRmqE/+fm/ZvObivMHWaX0f5OKrk1pOfhZTGT+6K7Hooup+D/UWote1WAAAxqSftQIuWN1+l0WaN2rmlIryjt8TuZR7t2c7hvYMbmsdf7Oms0hkCZoX7aKJQp1ZY2qBaQJFQ8RF45vK8Fg7atrM2prgiztNE/4nUxPv7ntk+4wRcTqtTAVKnEFgMC7vgYE/mAYpkqHb1zbU5qWfGAP+Ikqx3TpICQkz+NjKUnWemBeAxc8pYl9VkECMC4HZWtVFRYM2vvLyf2FOWZcIwljf6Rr5kf3icF1j3j/vK51eL/cQDlQGtjbxUQfRzjKCpyl1f2/MmDG99LS45trYH/xt8/jZl88OaQnkrHagHmoi9AKW5pTiwBhGAMlFdyqqw4buTOtdP/GyfbkjFzUs/OmJ/q5+ahDCesBiC3WQ0IuONB3PyhvIJanfZU6MYvg+oaG5Q2iCV9VX2Nu5OzQIRP8BNajHR/vU4nqnVaUaXVCrhnVNd5NW4IcPcsPTX9Lh3iK0rNazxAoZvFLDXLIfpIHw0cOg6NNGLH6pTT5Zeb+K3sPUjEI0Swh7cY6xcsYoO6icEd/YW/u5eo0zWIrKoysa/ovNh8IVscK70kiutqBOygNkczgyNOrxg2jaFrOR0HICYrjvzHlgBpolWtv5C58e6ELQ6XGx7ghhGdgsRjvQaL8X7mwxEE4FJttVhz7qz4KjtVpFeWCkQf2xwouybceDjax4/uezk9BFA+MNdZs4CAO2h5Ml/JSPWNjen+65cFCo2G2YIOI1cnJzE9MFws7jtCwN0t4Fltsa2qBq3YeD5LvJ9+VBwHt7Q1SAI9vCpOTUNw0dQ+oWAPN2fFNwfIKtxwq3wmbj3467a4guypDkNCXzGXprcHjhMDfPyMMqO1Niu09WI1OOXNM4fF+ZrK1i6/6r//s++IhEWRg5SOyGcACJM/TKgJIOAOagYn5VflVVfu6rd1xQRHj6Sjq7v4V79R4oauPQQyQ1Q1d666QrwBQL7LPQ05Y17Q+7i6ie7ePiIIsgk5W0IHfrpcVyvyAGJWZZlAeFlVm2ouzou9N9fb2TVUdk8R/g5VulXMAUIDkIagkabuWRefVFLAXFuH0qzgCPEilipOWqv6uKInXKp+zs8QL59KEGkVpSa/umEZHA6ZNNk/RAzzDRQ92/kIgq+FzLlQUyVSy4vFzsJzAqlHIhPAOIL+Ghl9ZHHfkYMVdf8dgLwu/85k3PqAEzUrIxXX1uyNiPsKmSGq50jVuKjSvhs9Xszt0kNSc62h7KpyAfe/2HCeIYkr1A51kePuDOsjYrAcIsOxyUAIZhE0tfUA9POsk+JEGR9e+xLaaLw48/6L7k5OzOY3UCEACWgJkBfx4wvyC245+OueLQXZ4+zbvaa1BXl4ia+GTsOTDL3Bysa4VP3rVKL4OOO4tPxQW7s7PEr8pccAEebZvlUFoay+TnyflyYpCI7glOejhh9+tOdgpcY1B6D8bBiykkPIHcbQJPJmk4N/+Tza0dzBzgzxDRBLB00QUe07WQnHlds+TD8mlpw9Ij3x0wLDxHN9hgtE9ixWECiLPgSgn2Sk2N3o9HB21uZfd18NNEe5proKgBhFhBEQLFfUAhh4MtKnGcc3PZGy7zqbZsjCm6cEhIrX+o8RkVjfbaFvck6J104fktTfl/qOFNcFd5M4xVKiLUNZ8kzKPnGmgjnX9qUtY69PgjwbKquVsZIAgwosB+Rd/LBIdmF9yLdv51a09zIXzLdvL1HbVADybzsAsgKAIBFPTA4IEY9EDhYR3h1U95XL1aunkySj0940PSAsffXIa5WBvLsByDdsSw5IHv43hmXPl5fu6P3DskkaLw+h8TBx9KrqI7WZYViOqDnR6EMWCtwdRbCsL5uop4i6ifewZPVpr3T9qGoO8iNFkgFYr8WcLt0lH5haQta9eA91kNMcQYWz7i9w1ZgI93UAZK4RECxXffBPqrzxp/Zv3fLh6SPTcCHcY+qfMvqiZneJEHeE9hahXu0FtgVAqAoIW520vicUXxDfwmY4WVYsuTzot/pm2DRJllgr1FkP1V76uJbAuBzdOdiquhAFlRSDZ08eEPzb3rRi2PTDM4O7yYV7GeZZWqulsQOQ/8HHUnnD4d++e6qkvpZACbVcwqcSerdY0K0vHIKeguDIiUPkU3gS+j+F5y8XsuDBbRAfD54s0FHVRqGh7jwI5OcwiQWwLV7tP1oMhLVvDbF/y9CvZ07sc4h/bE6XHhlfDp2qFAXDAEqSAZAf0QeJZUh1Wu0pv2+W9ILfSppJOmI0HcElrfiVDPcjNUa8DIubNkBLRNd5DmyHxakJYhNAubFLpHi6z1ARDo6yhjajDtYV4tlOvNRvpNUaG9XnpViy/om6HEHYj6LLj72PVcufVMlINADC7cTG+MbB/Jy4a7asMglAadxchKZd6/tnKDOSptwmEJyxaCxcEg5dviiePL5X0moQbRPXBIRJ8kYN0QX/Olwnn2amiDGdu4hX+o8S/Ts0uy2lxaoLaqvEkjNHxCeoy1GUOeOeNF83d3n2ThwAmaHRJ71xD7eRHt8XF/fJmaNNIoJO7QGIa8s+pod6DJS4Qy1RM+K63atdR/FxzCRoR5a7Tyg7foBB92LqQZFfXSl6QzGg1T8S7hJr6FDJRfE8lr69iLk4iszIkSIA4kdAZqLRDfKGo9d8dCizqrxJ8oIk4DtiOWlh6dowepYY52eSQ2fRmBhoevDITsltcUdYb8nJSG5rjbjex1/MFa9ATeVEkui7+mzIFAS2Iiw2CA3tENy1UHcfObZHYEtda81b/ft9EX1TlwwYpwzxdiAgj6FW+f6G2g7L/10mNE5mtw5oXJyFpkPzIZGMGfNFJwuXK/loOBF3JMaJbQW5koVMnxblQACihFy+5JoXQUC/BWMh8YW5kt1BbU1Of+rWTyyCYkENz1KtjfXywXgd9W2EPHIkwa9WHD/+BqVbYhQB+RQNcy+gRFqd7linr99sNsTIazSe7ijmZUThzPtVr/+Gtl84eVB8nZMqSuASJ4XC//Rw5EDJaGzn4iY97Zy0uoYGkVNdDlf7GfFTfrqgD0pJ1O5o+cdCa7PEFmG9tJGWYdmkHUPBTk5zd3IR2FElVc9Yfg3atkccn3XD2ajs9j0EZDe+NToPCyvLN/ZY+1GrYVqndthQ5NZUi0oHh3S2gkPYs/fSjooP4IuiUJUTvb8DIKD9MMlUj3OqKiRAqBBwqhj94PfKEC5lyAswEIfA6FRymbx+1oPNRNJSRT8YHZPU1KgU0ENMx6cOiOWizQOwn8iNDITZGjK+BAMRJoHc+/sKAaFAZza7RIkXcr+a8ut385s8cma+MCfkrZUhrP7ts8mSYFcCwt/IHX5unqKzu4fwhWwhBxB42jjMQCmsrUGpkrjrUl21KIedw4megJj8w1i6GInkfZIc1I+FXFGhrUNwqlysA6cxNt8B10wLDBXYxiY5JZU2FMHaDpnFB4cyq8aGoFbWtfcchpyUG4hfExCe72HcVLMzN+Pz2du/l5Tk1kiyTyhPnP/PPQH3sngOT6Wl67ahDU7OM4hlfAtfVKlsCWJMvatHOymoNBEBJlrf1MQ6IPonJy4jXHKSLxeKXZfypcnKQOIDjFspNk9FgfdSUSC3YGkWpQDjBNw4P5/PkLJY6N55sPsAcVPXyFZjMlQ+/g4HJO+z1po/Me3OHV09vCfJxrGZgHC3j9Gk3ZiZ+vntuzZYBAgrkkChfaJXh+nM2zJ2jvQEqyHGxRckbRU7CvOMazSVA/q4bsQEzQgKE+0hRywhThBtGgrmX+FGYfIDn2RyFHZAiY5u7pJCQMCoJvPhwT5C8TiyXG4N6WWxDCQY9x7aJkUdraEDk275Bb47arkGSiQgPJnAaPGtOn38i4X7N1t8/IWhJg1kikYvUxiGpT2iZPeWOr0DLu8njv9mDL9y4m4J6Snui+hnsZGprJ9ck1BcIJZnnwQwOVjGmgp/3kOg74Ob56neQ4SHilg+gX8oeZdYCZ+cNbRpzOzvwbXyzaKZBMTEe/ZZStLyR5PiF1jTgMHn1RUC8Y0BY8QMpPO0lsbDdigzXkpNFD/CuOOTyyAVVda5CL2qiWU012eGdj+CbPoaMoL1y4myiRkun8VMsSoWsxXy5OYDm6yZLvH1kGtWzO7a/U7ZzeUEhDqmcS1YkZq84i8Ht8gvUtUYucQZFj0n9YleMVhqwlucVK779PrSmUfNhQGqJ3oNEdcj4UHN09paJw3uEIIiF8SURXch3k7vglq5Z3iYesdJoQzVtHzI1K/x0N0tu7GWgPD4IaPTZ0PGqZV37F4/T3XtshtoPDpD2EdBbZwX2kswGsglSO6f4qScLi+RXOUMBGViPefkPAKlYEF4X+lvayaopX7TkUmf2a8F2cbLyM2vg5uZrmoNcRxBv/DAIPWEvSQrsadEPteFBCQLVYUbqtudm7l65va1Jkly6puCoIcxRVvF16udGIoYR19wTAj+Rm6SwKk/Ihe2xNHSQilYRccgJ/+u8D7isZ4xIkyFda22b0nQvu5M3AJBfCWhjhy5cvgMSXOzhtj37r9+Zc2tIn7cnDUxvoG3yG7OICDcW21Mnj5UkL9u0uYVc6xqwcxNjDZStlAWULtxwycTpi9Dta2RrefIf0UIdzTAu2LEOYooiOnFfRoqK4UnI5TrRsVKyXPWEA3FGb8Zk0ZUVZE4+bafoM4bwx64OZmA7MUfow01nSoq/GX4huVyVUxVI+Yu1jjDF0XVGJ/miFrOc1HDJGOstRiKzZ1BBZdhmzxwOF7EFeTAvukoVo2YIS2p1tDLSDtiCqs1lDL1zs0hXt7Xyu7dRUC+xxc3Gr4sqa46EL56aXNneljTrvGe5nxgdCT+A4GpSEyOveVGcx2ma/1uLF1eWELfih6HGIw8y9OyYXK5it27Qcp8tIbyrrv3ENxCcq/6KgLChN+nDRU26HT5vl+/qd5/bmGPrnAL/GB6655r9wuwWxiUosPtahFd65LvLOOYpGXR3a+GuNy9Db8XPcPWuk9KZj9QhAdQHkVbTEDuQd3L5Z3p/NXrFfWN0iHFDiONu6vwat9eLOo5SHJXWBL7sGdnOKHZ2PhDw45POiOV/VREGOkF+AfkEG0cawicWZYfe68ye2QeAeGjwcMAjDR+3fJ0+IQcfgjAnG69xRPRo0V/X/+rtlTJx0l3Oj0EDyXvRFCtq6RUtObyIZCM3T974oC0k8taP9Ykf2yhHhXLfThyiiEgDJKYZBc/vW/rgQ/OHHGIHDG0HtG+o1g8ZIKYFd5LdVTPmifS3D2cXIk7Mk+Id9OSsVEoDLJsWLMqMD3J1NDoimFmiy0JQi/2Hb7/b5GDleuklyHJgeni3QydTsjLPjh16+pmz0u0dUKo1j4QNUQ8GT1K+MDhd7UEubl+8wlPg1H6Z2hdtImY8TId3oVpkGnd9VmPXJaoBKyHVziD+0ggf2wBg/1ImnLroUjvjnKBfhKhgX4GQD7HNUaHYn1DQ2Hnb5Y47PS3cfDc/nPoBDEEGzrbAjE6+GtBllh4KN5qAa1mHNyaUDJrYTn8fHIZshSAPGwA5A5UuEJe6dDvl+WcqSi1+/klQXBVPB49UtzfJ+Y/yhnKCaTlzmghzoW0+elvERyAP8LHPy1u0k0mB/jgnrkAZJ0BED6qPJPWSG8d3rv7xWN7eSa73Yie39mQGa+PmCIITFsiLkE4PVssOrpbipPYlbCfvrEOXub6etHYoBPvjrxm/4I+TeRHRwBSKk+2Zm6vlDpKKqqsOB6x9kO7HioTDF/WYwNGioVRyj0rdh2+1ZWRS95CGNmmBDlGM+oBAJIhBAv/VgicvNv/mtXe3b2brKMJAEOS2XJAXsb/z8hHE732w+zMygqj49HqkepvjO4cKN4YMVWMDLD3K0Fs7dmV+6kGM9jEQFlzG0elCznDzHrA9Y3cYIqnXpp8bYOUntQSIWkiY+ecBcq8XuNeQzkgtDv4JhojfZN6eM//HNxmt+1sE4LDxbJxsaILOKWt0qa8DPHEoZ3iHGwMaeKl+dV/cvIJgg0q1spxsw7M7BElNylYG3fjcjuIqVwFukfwnfFI16ra2pyg7961m2C/pmt38eXE2aK9IkGhLYETn58lnk6IF6mXHfOWipL5jxdh46ncXbITYBgTHUxMAADC10m8Jp+ge7evO/R97hm7nIk1uUs38cWEWaKTygSIqwnYVnDI3w/GizRFJqQ9+vBgZPTh18ZOVwrQhQCEyYoSKQHh4n5O3nhJVWVq+JoPKOxttt8oO5aOQTDIx7qsdHtMSkt10Ej8Keu0eOzAVlGM0LKdqfHcbQ/ndvDwlK84fD9JMAAxbmZsMsngEhMjkZ26afOqIzidWrnpXXV/e/p0Ei/SXRJmzMtTXYcjbyhH0GxZ6mHx8pE9VvuomuvfXd36JH8wcbbyhG++KMbkrHxzgFADMDk8IL/scnKfHz+x+bjwdpAdC3pFi2cHjxWeVh4O4ChAKFlTSy6JZ5N2iG159CTZl3JufSijo6fJBlqyIA+gMTkF2+wyBC5hkFieDSEW7vj5wKrs0zY7HGPgLlk8ZLwYD43L5jXQjnNWAe5YmZ4iXjq8R5Tqk73tVf0jvWMSF4+aqjzP+C2AwZ0HJtQcIFxTTDbx1Gq1+aEr3/Gp0emsCz7rmyVnzIXb/fGBI0UkcmfbAjHGv7/gnHg2cac4isQ6e5Kvi1tVxrxF9c5OTvIYsVnuYLvNPqTgkvfx+0Pyzq07m7Lz7r2bJtraYX9kk98e2R/+rMEiDFkflnIKhS6f3jx4Xy/B/V2Jp5oZ6O6IPrZHzm6Qp7cIgo1D0C2tk2AcLSoQrybvFTug8tqa0a6cm01Tb04aGxIhPyiAlzwP7njJ3Dy2BAh3XmagmGxlHf3jZ6kpZcU2vyvKD6BM6Roh5vXoD8u9S4sy5TxShnaezxaHCs+LdORylQGUauQC05omSNy/wX0c3q6uIgCg9IEWNzooVAzuHCQ6INPF3CApM1jP95mp4ru0FHGk6IJkqduTkBx+dn3sPKUGkwkwmj2MocUHCVzCHSWfyDtZXVeXHb7qfV/EkdVvXleMlk9yKGIOIwDIeLjk+3cKEIGYUJ7YU4T00tOXi8Ru5OQmXMwXBdjyXIQtBwSiJWJqKLnF39NLdEO8fiyAGY76+TcB48GZuTi+KbEwX2wHR6SWFAoCboPxbbY7WKrK0+ctqnVxclLuzeZrktY3N4ZWOVtpvbOilIv5+0dvWqEuK6CFWeRhZXySvaGFMdGBOzikk0eRUFcCEKpaAaG5qgkO6yVATEvl/+Qo5oNRxS1FtNDeS5ShLydvXJgS0r6j8rDQ7QCjxVP5LAGERiHPmDB5B9PiA9t3Ljl1yGZ5Ys8loq3U9f6oaYnzew9SalXMFeoPQFrc2tsqIBwkuIR5W8zfklPdrI0rUncV5vPFLv9P+hm4tXvf1E/Hz1R6NrgiTgAYzZ7Xa5hAiwDRg7IMnyZv69TpdBVj1n2Re8IOQv6PgOjEwNCz66+9PQJjUW7mb1arUo7bYkD0oDBn0sSFom1ouDhgzUd1ebVVf6h3Tal9QGI6B2btmDXfHxOqtNM2gzMsPnNMLSBMfOBLSkxytqB5ZQ358VPnczWV6vMx1Y68DV4/sHNA3u5Z8z2hjigt3UR0dxIAsfjsWlWA6LmEk86G5Nt5EanUXhz6w2flmdVlDk+wa0uYjAkMydp07Tw/TKQy6kZPx3DGydX0VzUgelD4fozfUEw2VSAvuHjyhq8uHikpNMbm1XTm93btdaE9jq+aciNf4KI8A4Q7m0e0plGZG69VgOhBoVrHF0qa5PFzE+mTe+OOLEs7ZrfQb1sE6uXB4xMXRY809wI0hmKpUZl4zC0dg9WA6EHhyf87UJpkvB0+n7vruq2rB1XpdNZtvLB0BFf5On9X9/L4a+/MDe/UWZmXy57wvHy+BMxqD6VNgMhkCl8w2STqVFNflzs3bk0h8p3aZt6PSjDnhfc5uXR8bBcXZ2dz+9+YsH6dWpmh7ILNgOhBYUyWRzyZdafsP5e167ZdP/Urqa+37sw9lRNn78vDPL2L106+KS/KP7C5PLUfAYRx05Mt7dsFED0oNIb4JrKHzXUIPqSS1xJ2HX315IGx2BGq7qR9W0Zow71uGk3DkpiJyXf3H0qXh7nDu3h6/9P47Q0bmjG51W6AGGrVu1m4cdvs2RrlNdVpzyfEF3yefnxEWwUG0ZSGx6OGJi8aODLM29OzuaTztv2CeznMAIWs/S1Ks6moACYDwJz/PD0FwGjaBsc0Nmr/0X/U0b8NGhXm4eraUvb/FoxtPjjjgr04w1CP3TlExincMMiIIyNjzcZOEBo+tzH95NlXju0PPlNZevXtF7jjxweEpD3af0TRhNDuvRFqbWnDOlOkHgUQa+0NhMMBkQHDkyi5xrZ6XEdpdeWp1WdPFHyZdrRLSlmJQ3OFxvp1yZjfa+DFOT36dUMI2JLTMpdgDHQSWnf0j4UIOoxDlO1jGWMa0T9Qbrakb0yqSDqfm/5N2jHXvRfP+eNdu/44P86qKKVGpyvv7dOpcFJwt+LbI/o69w8IjoTqasnhwExG+BLlNQCRbUm/bb3mqgEi4xh6hZn+8mcUyw73vXJzJYIKqSXV1RnFtVWFOEXODS8qc6mpq3NtaNRJMgihX62rxlnr6qzR8rBif692XX3cPSOwL8WcEdfS3DGx9x0U7mpS5Yv63QEiA4YWPN96ya10yhdm2Toua+6nCkth/QXKzwCi5eC9NS1YcM9V5xBzfcJyxieYJ6PegGK3/SgWjJ+X8NWya1C+BAgmu8gsvN+ul7UJQOQjAjhMkZmiL3wRmb03nzK1ia6eeH4qUzntOrtWVNbmAFGOAQBR5lDjokpMZybd3XTBMP5gKIaXjjCRgEcr8NhCfjKhgOfvsfDtLClXWyaoxeR/AQcJafN7Yw6HAAAAAElFTkSuQmCC" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAAARzQklUCAgICHwIZIgAAB1BSURBVHhe3V0JfBXVvT5nbgiQBBK2kLAFZIcIoq0KFcRiFWtfbe2r+qrWLlptrX1tfX2tS2trfVZbu7y+rk9rXWq1dqFqFVFEcQHrwiIhBIGwJAGSQCAJ2e+d0+87d8ncuXPvnZl7L0b/v9/8Asks55xvzvlv3/+MFANclFJj0cSZOGbgmI5jLo7ROIbhKIr8HBHpxhH8bMdxLPLzEH5uwbETx9s4tkspmwZyl+VAaxwAGIc2fQjHB3EswzE+y23ch/s9Fz0A0MEs3z+j2w0IQADCCejF53D8e2Q2ZNQpjxdvxfmP4vg9wKnzeG3WT3/HAAEIBejNJ3F8FscSHO9YWyKjakZmzb34uQLg9GR9tF3c8LgPAoAoR7v+E8eXcFAPeBOl9gsR3KtCwS4pgl3C7OsSwZ5OwBkQgcGDhTFoqJA4hFGIf1cIKcu8PUCffRTHT3H8CsBQDx03OW6AAAgq5v/GwaXJnZi920RnQ5Po2JVntu8eITrrKoTZW+ju4shZRv4xWVixTxRVHBGFU0OyYHyZMPJpILiRbpx0D467AMxeNxdkek7OAQEQo9DI23F8IW1jzZ460ba91jyyqVi0vz1dmEFvg5/2AeETpDGoQw2btUOWnNgui2dNA0CctenkxzjhuwCGFlzOJGeAAAje+0ocP8BBUJxFmQdER22Nuf+ZMtG5b3bOeprixrLwhG2i/OxmWTQFz5djUpyK5VJ8DaDQCMiJ5AQQgDEFrX0Yx2kpgNgtDj5bZx58fhHW/7yc9M7rTZUIynHnvC5Ll07GNEo1a1bj1pfnwmTOOiAAYzkayzfIWWGbod2icTWAeAFAqIEBRAJwgaAsX/aaHLu0AsZBMj+oGZddAFDWe8U91flZAwRABCLL0zeSrE1tqvnVDar+8TMGLhD2lgOYSRe+KkeecjL+QjPdLiH84lsA5a5sgZIVQABGMRr0dxxLHRvWdeBFc+fvZovQsVTrc7b6lPX7yEEjGuT0K+tE/qjTk9z8rwCFTm3GkjEgAIN2/rM4KhNao8zDas8Ddaq15qSMWzoAbiBHLHhLVlw0FYrfyfp7CU08H8AwluZbMgIkEvJYi6dPSASjt0Zt/WGRCh5L/Jvv5g6ACwePbjBmfaVHyHyGe+zCQOYygEL94kt8AwIw5uOJDNI5mrSq57BSb/9SilCnr4YN6IuMQb3G9Gs3iaFlpzq0czd+d5ZfR9IXIACDYfDXcJSkGjjVUSfUzt8KoYIDenz9Ns6YeOE6MerUhbjePo678LtFfkL9ngEBGFyC/omDYXKrKIeGCdVWI1TtfX77PPCvG7Fgg1Fx8Rw0dIitsVX4/0Kvnr0nQAAGraR1OKbFQxHaY9atyJcTPz5OSlq/NqRaNgq1708Df3B9thCxslo57eoRcCajibLoneijUKd0ub21V0DewI1PsQ13o7n1hz2i78gkMeIkISddhACrkQhK0wtC7X/abbvefecNnVBvzLwWgCRYYJ5MYteAYHb8BqN0tQ2MVrPmZ/tEd+OJ0d/LMR8Qcvy/OQ6oanhCqOZX3n2D7bLFctj0ajn184wk2yMQ12OW/MTNbVwBAjD+Azf7o+2G3ebOu7eKY7tsMwbvyLjlAvGgxFmiTKF2PyhE2zY3bXt3njPq1Cooe+b9rWNLq2YxQHk1XafSAhLJY2zGjQZbb6YOPPWkanzx/GQPkJMuFnLkgkRQzL6wkj9GQ+S9KUbFJf/E8m0PrDait3MASkuqXrsBhGDMi7tJ98FVWKrOTT2chpBTPyfksHj9z2tUqEeoHb8SWOrem4hgchiVN28TeYX2dMKfAMglvgHB7PgiLsbIWUQFa8y3binDqKb0QfQVRj5AuQpqbmLiTOlrAyhQS70pXxhMfCzHgfzwz6ixoBDTw0xD9hDoMhU+8ETmFbXKypvQOGm3vJYAFIZZHCXpDIlk+riuMHAYE3PbT6pET1Ni3CrZEwIFQs64VsjBiQ49vHkBb144evMc/EHFQhYhQlE8R8gCuD95oGHRyexpEaoDDnHrNqG6mGJnNIBu0MASWVK5XU6+jKlrq2wBIPErjuWvqQBJtKqOVj1p7vlDUr2RdDjyRwo5/RpwD4YnzhQnb97Iw6yaLMTYswAIYnmOAgCCHUIdgY9zGEEDgDsQZ4uccd0G5PEZvrfKlwEK3sREcQQEs4OeJ/lK1rmxy9x0I1mEZAt6lyFjAcqXhAzE2Qb6Pqq1GtbXH/AvzvCAkMNnwVI7D2YEZ1UaNYdlS1/f9KIQXQd4N+9ty+UVeUXHjMqb0Ik4/4TrdIWTF58MkEdwwcXWdqra+1ertm1nZ9R2vO1a0afy5rE0GRM+LsRQZFAdHEzH55swEhgNaFwjBHTTQBNZfh6yj2faA5E3ARCSP+IkARDMDloG1XFn9bWuNbf+4MysdDSVN0+nETNIliCQbAzy9rjeoxoQ1fImzTjnawOga2HW6aWT91eYTaEuofpatV7KZRDUmHdrHYwcq3WDNVZMtIdVnAChA0hHMCaht3+5RnbWkWubFUnlzVMviDxmS9Na5La2KKGOVgl1YBUG18Zt4zJYiPT4MASpCyfBwEBIjuBwiexrF6ob9N72nUK17wjrolxI6ZkbjXHn2R2zbwKQH1ofF9frSMIp3mMLdr5iVn1vEQbI6wil7FYyb16/tX4fBRNaNTwFncJAa0QMzLgR8+Ckvh9ZcVhq+t72rtBA6AwDehjOtNZF2RaljPm3N0FHUg9HpRmAlKYC5Lv44y1xs6P2vpdkW83ibDeP90vmzft+FpYqdeCZcLyM5jGttZGnIoxzhhD5dAfSvFOhblhtm3E9DIQczBRZdu4GWXaW3eL6GEB5LNpn+wzh7OhPTaq+Tebmm7Gg+31l0w1tcm8+3ZXJ/q6aX4YueV6bxHL4TCHLEVAYgrS/WwOBuoj3OIQsQ7adTjkoaMy/FfRUabVUHwEgMRURAwTLFa0AJp765eBzT5sHnyXPKneSwpv381B1+HUAgswylj45/nyAAgseM8W1MAAKXaL2/wOhHd+p8aSPM6Z/6Q3osfdZTmCupDRqAlsB+V/84SuWE/uCKxe2G2WL4dUl5jdcd9DNifTmZ33V0XF0c7n1HNXyhlAHVyOGNj0ccXaIEKS9JyMIuAedzqzLsFm7jKmfsXu7nwYgCINbFlXMkAb8vz8t27JhXfClyxfJEQhbDE/mLbtoLqwZCctGDwz9j75j4XAHLSGreVpSKYwKzFwHH8XFU2KnUH/QSdRGQwnSNIyBeRU6m01rAQo5HNkXY/7/NNqU+98BCJyvCCAAYxb+HZekMF+7bqN5YM0CASvFmIAKM69qBLNKFiPkNep9ePOhUBkgpFKlsqVF07E37DPQ5ORaDd/AOOGzcAhJ8/Jp0HG5OQiljhiXMeECxBSm+LwXTGgC2/Akrs++5y+nXLYBY2NV7m0ARMcMdc8ByLX48QvruxD8x6mHRKiDxZXCKIGvWJwYRk/67uCthGcq5CikBBgQTFjy0ElGarsaoTzRcYQ+OFt0+pcgelnzrY2Ag8dBBBcMjNyPAFw7D8Pt205A1kGPAJBsK3YOesmJtXLypXZe1/sByhtRQP6G8/SU0RJsrQk9uWgmPQKNGgd4PPxChziUUxflKJiaUKicXSmFne09AlP1aQ2KHDFfyDJEZxCM9CM6pgXHUOYjSjwOz0f8zJfQfMayp53MXIiRb8Jz1++65fbaSYwCwnLiWH5D1T60LrTldjiD/SILxqFyIiFbm9hc6Axj9n9hZrittQHsiPiaDY9j+YLfVHGJNlc96xIug7Cu1KH10FlT8EJwhripw3EYcXrvMJ216ZsjMU68ZSeiBdZlZxUAWS4jpDfWcMfEfOXKzeah9WQmxoksPV3Ioan50rJ0cfjt9CjaqqFDN2SMMJD+FYM5S1zqEuqOo3DoyGphXGpIqTAmfgJhEoRL/EgnXpD9K5FmrvVztatrHPTIYQAymoDgVRJPWO8SXHlGA5aSxLoI+AzGuKUply45DRnCpDmMFG2F5WXu+7MOW8iRMAS45Ol4UzrBek+/4QD43hhILYxdwWKTSGx5NtkJ7pFNQtWvCGclcyRyzOnb5PiP2VO8wwnI9Ximtb6hx3ys0kSzHEeDmT9ZFreaxTXZqPxOJDjosScRRopq364VqSxB/Gnch2F9oe5HGwUOswXOn2JQkMqX1ppF5OiF8ENQbZ3PldjlTKNFhRdDHUTUuNWWDvLYnbSnD53QYsz8sl1ZLiQgd+Ni1gKGpbe1KrhyUcoUrVECK7mY9N5EgY3tff2P3EZhmaCnHUvpIv6kl8Bh0CkcWKc8Ctf7Hb9OzM3DupMTPhqZJW58kUgGMuLHaB+Jz9MWX4SNyd8pzJpsWF64tx6rePkMAUEkTcSCh+roltWhtZekTERJvnGjT4HyTFSaRuW3PSj0+NZoy6YZ+X8Mcvy0gw+DlK6c9En4NImVcoo59h3IiDJ0bxVcY4xDLKsAjmmyWabPt6SDGQcz4SvhBZA0CnQun6lnnAOLUHTsQbgebBkmwjIEBtFfOIiG1RS8nYBQocded1X3+N9CG264MO2UwwkGlLywKXnfOoRdbgTdFH5JAiBsDAd06Hghp1wBUBKzyAqev9r3F4CCqmUCg8gtB1HTkMYsAUkCKlHnWfTNonMS58Ef6kWo5OiWcG4+MCScQh4Ji9IpKAnHVrW9rQOQqBoOg+dTjMpbNoi8oVYH8QECQk3YX1RT+/Bfgltuc1WeRf9EjMVaPbifESRJTCg/x9Jpt62FPqBTR+8dWbx+weDxbR0MH5XxKSaZ9EA56AWS8JhkAglPUcEzhE5GCvUeBhhlz2FDgUsR326G27uR+yAYx8BiwTN08gxZTVKYUgqMD02N5XU+vXlj7g3Pg1lzluU5KwkIQ5raI6eomt+uCG3/eb+TmG486TSOgVUUnSnovDEddC566F6EefE9fwwPaHQpwBstC2C60mEcDoPEpWOqBwiRWipm8AC0otZvMn0jgkNQCB4Bo5nMGUN9VfZBgIGkntt4GsAw9yLBal9iXfbbmP21f4jBY2nlRuV1AsKdCWJeXKj6Z4+pHXcjEORewNMDpAugU8KhCjJG5BioJQ9RYm261iNPE02/8m3F4MjRWBZdO5m2NhNYxswO/zMMDBiTjsI8Puo5dZTAUy4fsxrLpJ7VPsSY8cU/i4IKbsATld0EJC56Fqq64wm160Fn+nqah8YiwyS4Ibgni2lmuzA5aSkhTKGOvhWOcZEyBJM1THZwYyGlaRhTu7SeaMHx/lbRuqk8HGnmsuhRVNt2cJV/7/Gq8OnGCZc9KIZXXm65uJ2A8LXpXzCrf/pUcMc9cAD8iSycgLcaegpRWzkWSwCXmlSDCiXMN0x76bRcODPKlkWCjB6ZJ6maHA2HtEBxWxUxlTjy7XI8u+zi5bE/A/c1tyaYr64Gzzjh0vvF8BOvsJzcQ0BI0YjxPNXbv30qtO3nvgHRyDPsUYpILzi9cuTJUMQomeDbZ12bOSg9iPaSDspEEGk4HJyxS7F8IHmJf/saoFRDwUBm/ePh5SsqejbTX2EFgQ9BP8y3bvZxIcZp2pUPiaJpl1oubiYge/CLWNAntOuhp1XV7ZmnbZmYoq9SBFO1AHQkWkZ07mi9cNlA7lp0NVi4ufBumDuBleaKkOBrCHAR41SsUYkS6vCiGDClGUPzJbDizCodufUu06991CiceJHlwloCwtrqmGeu9j22OrTxxswYirEnQN0z20jPPoDlR5uc0AlMUtFPsMaK4GMYE2BwaCcusU7Re2+TXRHJdTQgZ05rjIHIqQhUOPCOXT0TjqJJFr8PMWZfv0IMHmO1aDcRENaY9QenGtesCb56XdZIcbqdzAZSr+Qn2UCOVg7YIdoZS5dD8dHxhEvIVtz7J10hjAGBcsUM8aHQeV9NOyKF1YcYc25YKfKLQWKOyVoCAvdWIFYdFmyD8WbohU+4SHx4bQFTunDsGAOzOXU6kFiONLEeFB+K1WtTeD5C6+aeh8I1LBM+Fs7BeBUuV6zD91l4hCTVm3i+dawfISAk/N4Qa0uw/UDwydN9ZnbS94ixKG2F5UdKE7B2y3IQEhCuyO1SZWsbHcNI7CxsZXnN4WDpY6iHlCOf4RPjpDvIW7UWznyPgHwGv4wzpEOPze/DXl5ZtDkTgZJF2J9yRCWcyA/BiQSz0FXuIz3g7s8IBwu1Y4c3HcX/njKMOgpAEkS6CrBkDZL5bSDN2QtmPkVAuDVEXK4yuGpZC/IL/hLb7kdEzwxjNqqrhvllh3h4mNOpzJ0zn4LEmByGUgmWc6cN+WBm0FRnDoamus84FuJy1cbUz7MOxyonExAOfBzlW62/ckeoab1zwiPDMYhezrpDY87XAQo2r86pVZWqwRGSNfLw5GHpKG8ZAqPJTGBspKOacS4J2eCX+QaDmrL8vPVg5nAyWKUgSnJgyHJy7C+7H94SfOu22GYAWcKg/zbw3I0plwpj5jXhjODxUuSOHWEg8hDSx9j6g0FIlt9RnxGcCOtRcVlCIJHseIbqwzojM74WTN43YeFZFXo1cupzo4D8Dk/o30+3u+VwcNXi5DuJZoiQHP1+zI7roUNyh7mnJnLp4jK0D4VjPhW0p+eBCQeFjiyctOqQXwCQ66KA0H1nkV9Mgk8vaUU+Ia4C19tDk5xNVsmMqzFDWK59nExcNw0nxVXTiLjZQmZvf8rHwQeSeSP2yPnf7V+Rwhd8HID8PQoIzVzuSRsT9ebXq0P1q+xKx03Xkp9Demn52SJw4o3+QxWZtSDF1VDWrAjm0pXt2pBuLHPgnJmdTP2244W8qsqY/VU7b6EEgLRa2e+MuJHjq0Ud3lgTevmy2P+zMg4MU8y4CrPjU1m5XdZvQuYL0wBQ8L4liCxkb6uQOBRrTQiGbQO3vHNW70XI30oaew1g6K04rIDchv/fZG0IHMRWEWzP2rJFnpQx70bHPVB8D0CWL1Rcurb9CLokxccRTLBPaHFh8CW+B6BZMgDA7EH2MdV1bOuQspa8c5+zuxSxWkMrIKw54JdoYhLc9L2tYu+jPuPSiSMlR58mAqdg53G/nNssD36y26kWEOU2fRuZZBLluI0Hq3qRfQwizUwASAXyKcb0q6uNOV+xqgIqLFbjshwkXqvCJ2GFSv+Wrp319cFnz83arqJy7GIReB84eWmdL5+9zeJlZt0TwtzwrSzekaMdEHkfXteC/ltnyAsAI0Z0iDNzAAg/J3GntRWhtRftU0e3IiaeucjSRZghWA40m3Dgi7njHmFW8zMi2RFZunBPYOE9k213+wIAIVlRix0Q8nnrrReoI1t2hl68xENxSPLGc/8sY8H3w3Scd4mYVXcIc5euNstY8pauaBDFM6ycaZLHygEIPyCTCAh/g1kS7yTid+aaj9TjgyoZL10EwpiDWkKYvu8WUbC8UE0Gvu8LGTUZtfJ1gSUP2/ep4odi4vbKT/DMHDcPOLS+OvjKlZn7JKDzGJM/KYxZ10Vy5hn1McsXww/pbUexj8OORaAPma9eA6eRWxX7k7yzVuwVw2dYTV2yAbkBTVypr6OrDFDux8mftj7afPEifPlmq9P22p5aiD2khDEXQcXRrMIeQJ466KdU5ALUU2O0tWo53D3V1yFCL8F/QnTYqxhjFtYai+6xj91PAAYrD+IkGSCM9MYV8cDTPBhcdTbiW6HM8iRkloAAbcz4AnTJZK99y835TFa1bABZ4Ue6GDWw6F7HOJvqahKhl/GeRutQ3LTGGBzMW/58Jyij1qnnODt4u6SvKGbJ/+HvX7Y+U1XduTm064GEyio37Yo7BzQhYyKIdIhnaRK025lCJqLeLAYhCOYi6JDxd2Qb0pRm9pGhcy8UIoKB2kSz5lc6tK7LEEANCpz5SLic2yaqY59AdUCEgpq+58bcb9YY0z5tj3h8B7Pj+05XpwKEcXHWdMXR+UJPL2kGJ9YnZ8bSBIAiSz8QBoa7l+pBTCKIA+k8xBGQojEgOhdBQrZ23FiayjoO0IvIbid3l8kmUopK4NNqprxTN3Ed7mNys5o6cLUYWrdGekFdCpzxADjLcXvD6AayHXqm2FmQtuYbRVObjGWP22+wG2AkXfpTLuKYJVfhGf8f95zOhrrg6vPG4k1KQw9P//ZoYhxonARE65Ri7E0SIdQp1mKAiKCaXwuXmHGbC3K5dJlBCiE4MB50LoMsylHIl48EWZvcsDzQkMg46QRznZvMNIFe2gadAMAdI7zQJ4HFf0T5Q2IBq3ngeWG+js8xJt2bq6A3b/maNpE3zM5P5WeSUOHqLGm1aoL3zqbvXbE5tImb0mRJODtY8cQ3XJOd0SzWYXAW9IJeGlee4OGZBAczBDuEhmeQzkyyDAE7NbCOhKz1ZAMaeQxfFGPh3eCNJ3KMk3rzyhB5Sx7cLkaeZKeyPAcw0hRDpelfZJcH0rvjvsEUXH/VNtG07h35zJ0HSLJyqgSBzzj5B4572jt584GZ11TLWdfZ3QQm4CsBSMrNuNLOEL1mKkXeFvlb/aJCvaHV5x9CYYzf7RKyMljH6ybG1MuxObJzbMvqzcuypXWB035JJ9o6tgwgngkwku7XG+2HK0AioIARZvtaZ6irI/jMuZ3IM2eu5I/XyGbwHGPO11CM1F8fG71V1JsXnQebAmf9lYFD+/qW1KqyN8c1IBFQNuBn/L6BPUeag88uH4IvsHn/0HAGg/NOXWqcfAcsQ4fyGRNUNmMQLQ57OflKzAzX1QReAeFM4EdK4vdr6qjfZ77wiRIzeCwx7vBOjVwOnxs4/Tdg6bva9RAVQvp7VLby4OSN8wRIZJYwQMYHxe/s0t3cHHr+ggDSlzkn2OVwrN3dGtZgMm/ecgNGOk5lntzdTcNneQYkAgqziKgLtn0UrK/tSGjNBUHV3fTe1ynw5vOWPdEHR9QplMTK5tPSWVROQPkCJAIK9l3VH5SMz7mHujvMdZ9vMFs2uf1muZcXaMCcG5hycY2c9x0nEghTsbSofH0gxTcgEVDo+GDrA5HAllc7H9xoVt81V6lg5h79gIEBDQkM6Q2ccmcdcjpO+x5ygxR+BMz3h1EyAsSiU7g5YSIXuGt/Q+jlKxCq2J/si8sDaajTtgVJpgOB039dgBS0ExOHhPUPe9UZ9odmDEgEFNJOucWTnTysn6d23LsxVPOLWaDIuNlvKe3AHO8TZF5hd2DezfVi4keTpbL/BiBiRU+ZtC8rgERAoTPEL5EhHeggwfaj6vVvNoQa12KbU3/GRCYd9XmtMsYt32MsuHUcApZO+xWSH3QDwABzIzuSNUCizYmEWcgKcJ4NbbW7zc3fDqrDm6apAQoMmqWwiVqdMe8bhaJ4bjLS+cD+wL31/QAopLWjgE8kp7e31+4JbQQwLZuQvBgYMwY1wyYcvr3GvG8NRzVwKvb/M+jbFZgZ8bumZWGSZH2GWGYKt4FjxpGZseQefFfTfrXjd01m/VMTVF+L970tMh4EvA1FUw7JSRc2GidcMh6ldalIY6RIfR1AYC/C3EjOALEAw52RucZelrYLrdt2qp0PdJvN68qx/1XO6lN0O4aObxHlZzfmTf/cKDFkdGJaMLGxP8avGCTM6ffIcw6IBRhSVFGHIKy73yTHqLv5AFKrTWr/s8MQ4i9BoqpICdOfT2OCjFtQ2m4Mn3kUS1IffIjx2IvFzf5RJCPch+NOALE37QuVhROOGyAWYJgrIP0F9WwJn7xO1SXwdHpqUH62G3XhLWawO98I9QwCPycPaV2EL0IS6XVsj22ETBkIGXmFQVUwqRT7eFVg4wKviTTu//IzHKxq8hSLyhST4w6IBRg6VyyjYimd/YNZmfbLz/U0Yams78XxGIDwT3H38/TINe8YINY2wypjupOZH+716HP3Y9+jwE/LPsqlCSDEVZH5vmMGFw4IQGzgkCKDWml9cM+VbEeOSW1iqIcblJB0kP2vtryXALH3BbOHOodxMkZWGcxkFJnmMZVy9Ih+b5ZEAu4xyyJy/iShADsz6wObOYqq460TvGLzLxLmmeTYC9TtAAAAAElFTkSuQmCC",
                            alt: "switch",
                            className: "w-10 sm:w-12 md:w-14"
                        })
                    })
                })]
            })
        }
        ;
        var aG = document.documentElement.clientWidth;
        const sG = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        function lG(e) {
            let {name: n, avatar_url: r, playing: i, blendData: o, rotation: a, faceBlendshapes: s} = e
              , l = oP(r)
              , c = null;
            l.scene.traverse((e => {
                "Mesh" === e.type && (e.castShadow = !0,
                e.receiveShadow = !0,
                e.frustumCulled = !1,
                e.name.includes("head_geo002") && (c = e.morphTargetDictionary))
            }
            ));
            const [u,d] = t.useState([])
              , h = (0,
            t.useMemo)(( () => new FM(l.scene)), []);
            return (0,
            t.useEffect)(( () => {
                if (null == o)
                    return;
                let e = [zP(o, c, "head_geo002")];
                d(e),
                e.map((e => {
                    let t = h.clipAction(e);
                    return t.setLoop(mf),
                    t.play(),
                    null
                }
                ))
            }
            ), [o]),
            zR(( (e, t) => {
                h.update(t)
            }
            )),
            zR(( () => {
                l.scene.traverse((e => {
                    if ("Mesh" === e.type && e.name.includes("head_geo002") && s && !i)
                        for (const t of s) {
                            const n = t.categoryName
                              , r = t.score
                              , i = e.morphTargetDictionary[n];
                            void 0 !== i && (e.morphTargetInfluences[i] = r)
                        }
                }
                ))
            }
            )),
            (0,
            mt.jsx)("group", {
                name: n,
                children: (0,
                mt.jsx)("primitive", {
                    rotation: a,
                    object: l.scene,
                    dispose: null
                })
            })
        }
        const cG = e => {
            let {playing: t, blendData: n, rotation: r, faceBlendshapes: i, draggableLeft: o, draggablBottom: a} = e;
            return (0,
            mt.jsx)(Ht(), {
                children: (0,
                mt.jsx)(St, {
                    style: {
                        flexDirection: "row",
                        display: "flex",
                        justifyContent: "space-between",
                        left: o + "px",
                        top: a + "px"
                    },
                    className: "absolute z-100 cursor-pointer",
                    children: (0,
                    mt.jsxs)(IP, {
                        style: {
                            width: sG ? 140 : 200,
                            height: sG ? 140 : 200
                        },
                        children: [(0,
                        mt.jsx)(sP, {
                            makeDefault: !0,
                            fov: 60,
                            aspect: 1,
                            position: [0, 0, 1],
                            near: .5,
                            far: 100
                        }), (0,
                        mt.jsx)("ambientLight", {}), (0,
                        mt.jsx)(lG, {
                            name: "host",
                            avatar_url: "raccoon_head.glb",
                            playing: t,
                            blendData: n,
                            rotation: [r[0], -r[1], -r[2]],
                            faceBlendshapes: i
                        }), (0,
                        mt.jsx)("pointLight", {
                            position: [1, 1, 1],
                            intensity: 3
                        })]
                    })
                })
            })
        }
        ;
        const uG = function() {
            const e = m((e => e.app.isMenuDialog))
              , n = m((e => e.app.isWelcomeVoice))
              , r = m((e => e.app.swfFile))
              , i = UP()
              , o = FP()
              , [a,s] = t.useState(!1)
              , [l,c] = t.useState(null)
              , [u,d] = t.useState(null)
              , h = (0,
            t.useRef)()
              , [p,f] = t.useState(!1)
              , [g,v] = t.useState(!1)
              , [y,b] = t.useState(null)
              , [_,A] = t.useState([0, 0, 0])
              , [x,S] = t.useState(null)
              , [w,E] = t.useState(null)
              , M = (0,
            t.useRef)()
              , [C,T] = t.useState("")
              , [R,P] = t.useState(0)
              , [B,I] = t.useState(0)
              , [L,k] = t.useState(100)
              , [D,O] = t.useState(10)
              , [N,F] = t.useState(!0);
            (0,
            t.useEffect)(( () => {
                const e = JSON.parse(localStorage.getItem("isAssistant"));
                null !== e && F(e)
            }
            ), []),
            (0,
            t.useEffect)(( () => {
                localStorage.setItem("isAssistant", JSON.stringify(N))
            }
            ), [N]),
            (0,
            t.useEffect)(( () => {
                let e;
                console.log("width " + aG);
                let t = !1;
                window.RufflePlayer = window.RufflePlayer || {};
                const n = document.getElementById("container")
                  , i = n.querySelector("ruffle-player");
                if (i) {
                    const n = "https://file.numiner.io/swf_tc/";
                    i.addEventListener("loadeddata", ( () => {
                        t = !0,
                        clearTimeout(e)
                    }
                    )),
                    window.displayRight01 = e => {
                        G()
                    }
                    ,
                    window.displayWrong01 = () => {
                        U()
                    }
                    ,
                    e = setTimeout(( () => {
                        t || alert("Couldn't read file " + r)
                    }
                    ), 5e3),
                    i.load(n + r)
                } else {
                    window.RufflePlayer.config = {
                        splashScreen: !1,
                        preferredRenderer: "canvas",
                        backgroundColor: "#6F78A3",
                        contextMenu: "off",
                        allowScriptAccess: !0
                    };
                    const e = window.RufflePlayer.local().createPlayer();
                    let t, i;
                    if (aG > 1400 ? (t = Math.ceil(9 * window.innerWidth / 12),
                    i = Math.ceil(t / 1.66583541)) : aG > 669 ? (t = window.innerWidth > 1024 ? 960 : Math.ceil(4 * window.innerWidth / 5),
                    i = Math.ceil(t / 1.66583541)) : (t = Math.ceil(8 * window.innerWidth / 12),
                    i = Math.ceil(aG / 1.66583541)),
                    e.style.width = t + "px",
                    e.style.height = i + "px",
                    !n.querySelector("ruffle-player")) {
                        n.appendChild(e);
                        const t = n.getBoundingClientRect()
                          , i = t.height;
                        k(t.left - 60);
                        O(i / 2 + (aG < 576 ? 0 : 30)),
                        e.load("swf/" + r).then(( () => {}
                        )).catch((e => {
                            console.error("ruffle-player Failed to load SWF file", e)
                        }
                        ))
                    }
                }
            }
            ), [r, B]),
            (0,
            t.useEffect)(( () => {
                Ic.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm").then((e => {
                    od.createFromOptions(e, {
                        baseOptions: {
                            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
                            delegate: "GPU"
                        },
                        outputFaceBlendshapes: !0,
                        outputFacialTransformationMatrixes: !0,
                        runningMode: "VIDEO",
                        numFaces: 1
                    }).then((e => {
                        c(e)
                    }
                    )),
                    Fd.createFromOptions(e, {
                        baseOptions: {
                            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/object_detector/efficientdet_lite0/float16/1/efficientdet_lite0.tflite",
                            delegate: "GPU"
                        },
                        scoreThreshold: .5,
                        runningMode: "VIDEO"
                    }).then((e => {
                        d(e)
                    }
                    ))
                }
                )).catch((e => {
                    console.log("err " + e)
                }
                ))
            }
            ), []),
            (0,
            t.useEffect)(( () => {
                if (!u || !p)
                    return;
                const e = () => {
                    const t = h.current;
                    if (!t)
                        return;
                    const n = t.videoHeight / t.videoWidth;
                    t.style.width = "1px",
                    t.style.height = 1 * n + "px";
                    let r = performance.now();
                    0 === u.detectForVideo(t, r).detections.length ? (P((e => e + 1)),
                    R > 100 && (console.log("zeroCount " + R),
                    T("0"))) : P(0),
                    requestAnimationFrame(e)
                }
                ;
                return e(),
                () => {}
            }
            ), [u, p, R]),
            (0,
            t.useEffect)(( () => {
                if (!l || !p)
                    return;
                const e = new xv
                  , t = () => {
                    const n = h.current;
                    if (!n)
                        return;
                    const r = n.videoHeight / n.videoWidth;
                    n.style.width = "1px",
                    n.style.height = 1 * r + "px";
                    let i = performance.now();
                    var o = l.detectForVideo(n, i);
                    if (o.facialTransformationMatrixes.length > 0) {
                        const t = o.facialTransformationMatrixes[0].data;
                        e.matrix.fromArray(t),
                        e.matrix.decompose(e.position, e.quaternion, e.scale),
                        A([e.rotation.x, e.rotation.y, e.rotation.z])
                    }
                    if (o.faceBlendshapes.length > 0) {
                        const e = o.faceBlendshapes[0].categories;
                        S(e),
                        T("1")
                    }
                    requestAnimationFrame(t)
                }
                ;
                return t(),
                () => {}
            }
            ), [l, p]);
            const U = () => {
                var e = 1 + Math.floor(12 * Math.random());
                fetch("voice/zh/greet0" + e + ".json").then((e => e.json())).then((e => {
                    b(e.blendData),
                    E("voice" + e.filename)
                }
                ))
            }
              , z = () => {
                var e = 2 + Math.floor(4 * Math.random());
                fetch("voice/zh/leave0" + e + ".json").then((e => e.json())).then((e => {
                    b(e.blendData),
                    E("voice" + e.filename)
                }
                ))
            }
              , G = () => {
                var e = 1 + Math.floor(9 * Math.random());
                fetch("voice/zh/great0" + e + ".json").then((e => e.json())).then((e => {
                    b(e.blendData),
                    E("voice" + e.filename)
                }
                ))
            }
            ;
            return (0,
            t.useEffect)(( () => {
                ("0" == C && 0 == e || "0" == C && 0 == a) && z()
            }
            ), [C, a, e]),
            (0,
            t.useEffect)(( () => {
                !0 === n && ( () => {
                    var e = 1 + Math.floor(3 * Math.random());
                    fetch("voice/zh/welcome0" + e + ".json").then((e => e.json())).then((e => {
                        b(e.blendData),
                        E("voice" + e.filename),
                        i(!1),
                        o(!1)
                    }
                    ))
                }
                )()
            }
            ), [n]),
            (0,
            t.useEffect)(( () => {
                ( () => {
                    const e = h.current;
                    navigator.mediaDevices && navigator.mediaDevices.getUserMedia && navigator.mediaDevices.getUserMedia({
                        video: !0
                    }).then((t => {
                        e.srcObject = t,
                        e.addEventListener("loadeddata", ( () => {
                            f(!0)
                        }
                        ))
                    }
                    ))
                }
                )()
            }
            ), []),
            (0,
            t.useEffect)(( () => {
                if (w && N) {
                    var e = M.current.audioEl.current.play();
                    void 0 !== e && e.then((e => {}
                    )).catch((e => {}
                    ))
                }
            }
            ), [w, N]),
            (0,
            mt.jsxs)(t.Fragment, {
                children: [(0,
                mt.jsxs)(St, {
                    style: {
                        width: "100%",
                        height: document.documentElement.clientHeight,
                        backgroundColor: "#ffffff",
                        backgroundRepeat: "no-repeat",
                        backgroundSize: "100% 100%",
                        flexDirection: "column",
                        display: "flex"
                    },
                    children: [(0,
                    mt.jsx)(zt, {
                        elevation: 0,
                        className: "flex items-center w-full h-6 bg-[#6F78A3] justify-between"
                    }), (0,
                    mt.jsxs)(St, {
                        style: {
                            position: "fixed",
                            width: "100%",
                            top: 24,
                            height: document.documentElement.clientHeight - 24,
                            background: "#6F78A3",
                            backgroundRepeat: "no-repeat",
                            backgroundSize: "100% 100%",
                            overflow: "auto"
                        },
                        children: [(0,
                        mt.jsx)(St, {
                            className: "flex flex-col",
                            children: (0,
                            mt.jsx)(St, {
                                className: "self-center",
                                id: "container"
                            })
                        }), (0,
                        mt.jsx)(oG, {
                            setOpenDialog: s,
                            setReloadKey: I,
                            isDraggableBox: N,
                            setIsDraggableBox: F
                        }), N && (0,
                        mt.jsx)(cG, {
                            playing: g,
                            blendData: y,
                            rotation: _,
                            faceBlendshapes: x,
                            draggableLeft: L,
                            draggablBottom: D
                        }), (0,
                        mt.jsx)("video", {
                            width: 1,
                            ref: h,
                            autoPlay: !0,
                            playsInline: !0
                        }), N && (0,
                        mt.jsx)(Wt(), {
                            src: w,
                            ref: M,
                            onEnded: () => {
                                E(null),
                                v(!1)
                            }
                            ,
                            onCanPlayThrough: () => {
                                v(!0)
                            }
                        }), (0,
                        mt.jsx)(St, {
                            style: {
                                height: 10
                            }
                        })]
                    })]
                }), (0,
                mt.jsx)(vU, {
                    openDialog: e,
                    setOpenDialog: s
                })]
            })
        }
          , dG = e => "string" === typeof e
          , hG = () => {
            let e, t;
            const n = new Promise(( (n, r) => {
                e = n,
                t = r
            }
            ));
            return n.resolve = e,
            n.reject = t,
            n
        }
          , pG = e => null == e ? "" : "" + e
          , fG = /###/g
          , mG = e => e && e.indexOf("###") > -1 ? e.replace(fG, ".") : e
          , gG = e => !e || dG(e)
          , vG = (e, t, n) => {
            const r = dG(t) ? t.split(".") : t;
            let i = 0;
            for (; i < r.length - 1; ) {
                if (gG(e))
                    return {};
                const t = mG(r[i]);
                !e[t] && n && (e[t] = new n),
                e = Object.prototype.hasOwnProperty.call(e, t) ? e[t] : {},
                ++i
            }
            return gG(e) ? {} : {
                obj: e,
                k: mG(r[i])
            }
        }
          , yG = (e, t, n) => {
            const {obj: r, k: i} = vG(e, t, Object);
            if (void 0 !== r || 1 === t.length)
                return void (r[i] = n);
            let o = t[t.length - 1]
              , a = t.slice(0, t.length - 1)
              , s = vG(e, a, Object);
            for (; void 0 === s.obj && a.length; )
                o = `${a[a.length - 1]}.${o}`,
                a = a.slice(0, a.length - 1),
                s = vG(e, a, Object),
                s && s.obj && "undefined" !== typeof s.obj[`${s.k}.${o}`] && (s.obj = void 0);
            s.obj[`${s.k}.${o}`] = n
        }
          , bG = (e, t) => {
            const {obj: n, k: r} = vG(e, t);
            if (n)
                return n[r]
        }
          , _G = (e, t, n) => {
            for (const r in t)
                "__proto__" !== r && "constructor" !== r && (r in e ? dG(e[r]) || e[r]instanceof String || dG(t[r]) || t[r]instanceof String ? n && (e[r] = t[r]) : _G(e[r], t[r], n) : e[r] = t[r]);
            return e
        }
          , AG = e => e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        var xG = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;",
            "/": "&#x2F;"
        };
        const SG = e => dG(e) ? e.replace(/[&<>"'\/]/g, (e => xG[e])) : e;
        const wG = [" ", ",", "?", "!", ";"]
          , EG = new class {
            constructor(e) {
                this.capacity = e,
                this.regExpMap = new Map,
                this.regExpQueue = []
            }
            getRegExp(e) {
                const t = this.regExpMap.get(e);
                if (void 0 !== t)
                    return t;
                const n = new RegExp(e);
                return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()),
                this.regExpMap.set(e, n),
                this.regExpQueue.push(e),
                n
            }
        }
        (20)
          , MG = function(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ".";
            if (!e)
                return;
            if (e[t])
                return e[t];
            const r = t.split(n);
            let i = e;
            for (let o = 0; o < r.length; ) {
                if (!i || "object" !== typeof i)
                    return;
                let e, t = "";
                for (let a = o; a < r.length; ++a)
                    if (a !== o && (t += n),
                    t += r[a],
                    e = i[t],
                    void 0 !== e) {
                        if (["string", "number", "boolean"].indexOf(typeof e) > -1 && a < r.length - 1)
                            continue;
                        o += a - o + 1;
                        break
                    }
                i = e
            }
            return i
        }
          , CG = e => e && e.replace("_", "-")
          , TG = {
            type: "logger",
            log(e) {
                this.output("log", e)
            },
            warn(e) {
                this.output("warn", e)
            },
            error(e) {
                this.output("error", e)
            },
            output(e, t) {
                console && console[e] && console[e].apply(console, t)
            }
        };
        class RG {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                this.init(e, t)
            }
            init(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                this.prefix = t.prefix || "i18next:",
                this.logger = e || TG,
                this.options = t,
                this.debug = t.debug
            }
            log() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                return this.forward(t, "log", "", !0)
            }
            warn() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                return this.forward(t, "warn", "", !0)
            }
            error() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                return this.forward(t, "error", "")
            }
            deprecate() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                return this.forward(t, "warn", "WARNING DEPRECATED: ", !0)
            }
            forward(e, t, n, r) {
                return r && !this.debug ? null : (dG(e[0]) && (e[0] = `${n}${this.prefix} ${e[0]}`),
                this.logger[t](e))
            }
            create(e) {
                return new RG(this.logger,{
                    prefix: `${this.prefix}:${e}:`,
                    ...this.options
                })
            }
            clone(e) {
                return (e = e || this.options).prefix = e.prefix || this.prefix,
                new RG(this.logger,e)
            }
        }
        var PG = new RG;
        class BG {
            constructor() {
                this.observers = {}
            }
            on(e, t) {
                return e.split(" ").forEach((e => {
                    this.observers[e] || (this.observers[e] = new Map);
                    const n = this.observers[e].get(t) || 0;
                    this.observers[e].set(t, n + 1)
                }
                )),
                this
            }
            off(e, t) {
                this.observers[e] && (t ? this.observers[e].delete(t) : delete this.observers[e])
            }
            emit(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
                    n[r - 1] = arguments[r];
                if (this.observers[e]) {
                    Array.from(this.observers[e].entries()).forEach((e => {
                        let[t,r] = e;
                        for (let i = 0; i < r; i++)
                            t(...n)
                    }
                    ))
                }
                if (this.observers["*"]) {
                    Array.from(this.observers["*"].entries()).forEach((t => {
                        let[r,i] = t;
                        for (let o = 0; o < i; o++)
                            r.apply(r, [e, ...n])
                    }
                    ))
                }
            }
        }
        class IG extends BG {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                    ns: ["translation"],
                    defaultNS: "translation"
                };
                super(),
                this.data = e || {},
                this.options = t,
                void 0 === this.options.keySeparator && (this.options.keySeparator = "."),
                void 0 === this.options.ignoreJSONStructure && (this.options.ignoreJSONStructure = !0)
            }
            addNamespaces(e) {
                this.options.ns.indexOf(e) < 0 && this.options.ns.push(e)
            }
            removeNamespaces(e) {
                const t = this.options.ns.indexOf(e);
                t > -1 && this.options.ns.splice(t, 1)
            }
            getResource(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                const i = void 0 !== r.keySeparator ? r.keySeparator : this.options.keySeparator
                  , o = void 0 !== r.ignoreJSONStructure ? r.ignoreJSONStructure : this.options.ignoreJSONStructure;
                let a;
                e.indexOf(".") > -1 ? a = e.split(".") : (a = [e, t],
                n && (Array.isArray(n) ? a.push(...n) : dG(n) && i ? a.push(...n.split(i)) : a.push(n)));
                const s = bG(this.data, a);
                return !s && !t && !n && e.indexOf(".") > -1 && (e = a[0],
                t = a[1],
                n = a.slice(2).join(".")),
                !s && o && dG(n) ? MG(this.data && this.data[e] && this.data[e][t], n, i) : s
            }
            addResource(e, t, n, r) {
                let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {
                    silent: !1
                };
                const o = void 0 !== i.keySeparator ? i.keySeparator : this.options.keySeparator;
                let a = [e, t];
                n && (a = a.concat(o ? n.split(o) : n)),
                e.indexOf(".") > -1 && (a = e.split("."),
                r = t,
                t = a[1]),
                this.addNamespaces(t),
                yG(this.data, a, r),
                i.silent || this.emit("added", e, t, n, r)
            }
            addResources(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {
                    silent: !1
                };
                for (const i in n)
                    (dG(n[i]) || Array.isArray(n[i])) && this.addResource(e, t, i, n[i], {
                        silent: !0
                    });
                r.silent || this.emit("added", e, t, n)
            }
            addResourceBundle(e, t, n, r, i) {
                let o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {
                    silent: !1,
                    skipCopy: !1
                }
                  , a = [e, t];
                e.indexOf(".") > -1 && (a = e.split("."),
                r = n,
                n = t,
                t = a[1]),
                this.addNamespaces(t);
                let s = bG(this.data, a) || {};
                o.skipCopy || (n = JSON.parse(JSON.stringify(n))),
                r ? _G(s, n, i) : s = {
                    ...s,
                    ...n
                },
                yG(this.data, a, s),
                o.silent || this.emit("added", e, t, n)
            }
            removeResourceBundle(e, t) {
                this.hasResourceBundle(e, t) && delete this.data[e][t],
                this.removeNamespaces(t),
                this.emit("removed", e, t)
            }
            hasResourceBundle(e, t) {
                return void 0 !== this.getResource(e, t)
            }
            getResourceBundle(e, t) {
                return t || (t = this.options.defaultNS),
                "v1" === this.options.compatibilityAPI ? {
                    ...this.getResource(e, t)
                } : this.getResource(e, t)
            }
            getDataByLanguage(e) {
                return this.data[e]
            }
            hasLanguageSomeTranslations(e) {
                const t = this.getDataByLanguage(e);
                return !!(t && Object.keys(t) || []).find((e => t[e] && Object.keys(t[e]).length > 0))
            }
            toJSON() {
                return this.data
            }
        }
        var LG = {
            processors: {},
            addPostProcessor(e) {
                this.processors[e.name] = e
            },
            handle(e, t, n, r, i) {
                return e.forEach((e => {
                    this.processors[e] && (t = this.processors[e].process(t, n, r, i))
                }
                )),
                t
            }
        };
        const kG = {};
        class DG extends BG {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                super(),
                ( (e, t, n) => {
                    e.forEach((e => {
                        t[e] && (n[e] = t[e])
                    }
                    ))
                }
                )(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e, this),
                this.options = t,
                void 0 === this.options.keySeparator && (this.options.keySeparator = "."),
                this.logger = PG.create("translator")
            }
            changeLanguage(e) {
                e && (this.language = e)
            }
            exists(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                    interpolation: {}
                };
                if (void 0 === e || null === e)
                    return !1;
                const n = this.resolve(e, t);
                return n && void 0 !== n.res
            }
            extractFromKey(e, t) {
                let n = void 0 !== t.nsSeparator ? t.nsSeparator : this.options.nsSeparator;
                void 0 === n && (n = ":");
                const r = void 0 !== t.keySeparator ? t.keySeparator : this.options.keySeparator;
                let i = t.ns || this.options.defaultNS || [];
                const o = n && e.indexOf(n) > -1
                  , a = !this.options.userDefinedKeySeparator && !t.keySeparator && !this.options.userDefinedNsSeparator && !t.nsSeparator && !( (e, t, n) => {
                    t = t || "",
                    n = n || "";
                    const r = wG.filter((e => t.indexOf(e) < 0 && n.indexOf(e) < 0));
                    if (0 === r.length)
                        return !0;
                    const i = EG.getRegExp(`(${r.map((e => "?" === e ? "\\?" : e)).join("|")})`);
                    let o = !i.test(e);
                    if (!o) {
                        const t = e.indexOf(n);
                        t > 0 && !i.test(e.substring(0, t)) && (o = !0)
                    }
                    return o
                }
                )(e, n, r);
                if (o && !a) {
                    const t = e.match(this.interpolator.nestingRegexp);
                    if (t && t.length > 0)
                        return {
                            key: e,
                            namespaces: dG(i) ? [i] : i
                        };
                    const o = e.split(n);
                    (n !== r || n === r && this.options.ns.indexOf(o[0]) > -1) && (i = o.shift()),
                    e = o.join(r)
                }
                return {
                    key: e,
                    namespaces: dG(i) ? [i] : i
                }
            }
            translate(e, t, n) {
                if ("object" !== typeof t && this.options.overloadTranslationOptionHandler && (t = this.options.overloadTranslationOptionHandler(arguments)),
                "object" === typeof t && (t = {
                    ...t
                }),
                t || (t = {}),
                void 0 === e || null === e)
                    return "";
                Array.isArray(e) || (e = [String(e)]);
                const r = void 0 !== t.returnDetails ? t.returnDetails : this.options.returnDetails
                  , i = void 0 !== t.keySeparator ? t.keySeparator : this.options.keySeparator
                  , {key: o, namespaces: a} = this.extractFromKey(e[e.length - 1], t)
                  , s = a[a.length - 1]
                  , l = t.lng || this.language
                  , c = t.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
                if (l && "cimode" === l.toLowerCase()) {
                    if (c) {
                        const e = t.nsSeparator || this.options.nsSeparator;
                        return r ? {
                            res: `${s}${e}${o}`,
                            usedKey: o,
                            exactUsedKey: o,
                            usedLng: l,
                            usedNS: s,
                            usedParams: this.getUsedParamsDetails(t)
                        } : `${s}${e}${o}`
                    }
                    return r ? {
                        res: o,
                        usedKey: o,
                        exactUsedKey: o,
                        usedLng: l,
                        usedNS: s,
                        usedParams: this.getUsedParamsDetails(t)
                    } : o
                }
                const u = this.resolve(e, t);
                let d = u && u.res;
                const h = u && u.usedKey || o
                  , p = u && u.exactUsedKey || o
                  , f = Object.prototype.toString.apply(d)
                  , m = void 0 !== t.joinArrays ? t.joinArrays : this.options.joinArrays
                  , g = !this.i18nFormat || this.i18nFormat.handleAsObject
                  , v = !dG(d) && "boolean" !== typeof d && "number" !== typeof d;
                if (!(g && d && v && ["[object Number]", "[object Function]", "[object RegExp]"].indexOf(f) < 0) || dG(m) && Array.isArray(d))
                    if (g && dG(m) && Array.isArray(d))
                        d = d.join(m),
                        d && (d = this.extendTranslation(d, e, t, n));
                    else {
                        let r = !1
                          , a = !1;
                        const c = void 0 !== t.count && !dG(t.count)
                          , h = DG.hasDefaultValue(t)
                          , p = c ? this.pluralResolver.getSuffix(l, t.count, t) : ""
                          , f = t.ordinal && c ? this.pluralResolver.getSuffix(l, t.count, {
                            ordinal: !1
                        }) : ""
                          , m = c && !t.ordinal && 0 === t.count && this.pluralResolver.shouldUseIntlApi()
                          , g = m && t[`defaultValue${this.options.pluralSeparator}zero`] || t[`defaultValue${p}`] || t[`defaultValue${f}`] || t.defaultValue;
                        !this.isValidLookup(d) && h && (r = !0,
                        d = g),
                        this.isValidLookup(d) || (a = !0,
                        d = o);
                        const v = (t.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && a ? void 0 : d
                          , y = h && g !== d && this.options.updateMissing;
                        if (a || r || y) {
                            if (this.logger.log(y ? "updateKey" : "missingKey", l, s, o, y ? g : d),
                            i) {
                                const e = this.resolve(o, {
                                    ...t,
                                    keySeparator: !1
                                });
                                e && e.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
                            }
                            let e = [];
                            const n = this.languageUtils.getFallbackCodes(this.options.fallbackLng, t.lng || this.language);
                            if ("fallback" === this.options.saveMissingTo && n && n[0])
                                for (let t = 0; t < n.length; t++)
                                    e.push(n[t]);
                            else
                                "all" === this.options.saveMissingTo ? e = this.languageUtils.toResolveHierarchy(t.lng || this.language) : e.push(t.lng || this.language);
                            const r = (e, n, r) => {
                                const i = h && r !== d ? r : v;
                                this.options.missingKeyHandler ? this.options.missingKeyHandler(e, s, n, i, y, t) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(e, s, n, i, y, t),
                                this.emit("missingKey", e, s, n, d)
                            }
                            ;
                            this.options.saveMissing && (this.options.saveMissingPlurals && c ? e.forEach((e => {
                                const n = this.pluralResolver.getSuffixes(e, t);
                                m && t[`defaultValue${this.options.pluralSeparator}zero`] && n.indexOf(`${this.options.pluralSeparator}zero`) < 0 && n.push(`${this.options.pluralSeparator}zero`),
                                n.forEach((n => {
                                    r([e], o + n, t[`defaultValue${n}`] || g)
                                }
                                ))
                            }
                            )) : r(e, o, g))
                        }
                        d = this.extendTranslation(d, e, t, u, n),
                        a && d === o && this.options.appendNamespaceToMissingKey && (d = `${s}:${o}`),
                        (a || r) && this.options.parseMissingKeyHandler && (d = "v1" !== this.options.compatibilityAPI ? this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${s}:${o}` : o, r ? d : void 0) : this.options.parseMissingKeyHandler(d))
                    }
                else {
                    if (!t.returnObjects && !this.options.returnObjects) {
                        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
                        const e = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(h, d, {
                            ...t,
                            ns: a
                        }) : `key '${o} (${this.language})' returned an object instead of string.`;
                        return r ? (u.res = e,
                        u.usedParams = this.getUsedParamsDetails(t),
                        u) : e
                    }
                    if (i) {
                        const e = Array.isArray(d)
                          , n = e ? [] : {}
                          , r = e ? p : h;
                        for (const o in d)
                            if (Object.prototype.hasOwnProperty.call(d, o)) {
                                const e = `${r}${i}${o}`;
                                n[o] = this.translate(e, {
                                    ...t,
                                    joinArrays: !1,
                                    ns: a
                                }),
                                n[o] === e && (n[o] = d[o])
                            }
                        d = n
                    }
                }
                return r ? (u.res = d,
                u.usedParams = this.getUsedParamsDetails(t),
                u) : d
            }
            extendTranslation(e, t, n, r, i) {
                var o = this;
                if (this.i18nFormat && this.i18nFormat.parse)
                    e = this.i18nFormat.parse(e, {
                        ...this.options.interpolation.defaultVariables,
                        ...n
                    }, n.lng || this.language || r.usedLng, r.usedNS, r.usedKey, {
                        resolved: r
                    });
                else if (!n.skipInterpolation) {
                    n.interpolation && this.interpolator.init({
                        ...n,
                        interpolation: {
                            ...this.options.interpolation,
                            ...n.interpolation
                        }
                    });
                    const a = dG(e) && (n && n.interpolation && void 0 !== n.interpolation.skipOnVariables ? n.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
                    let s;
                    if (a) {
                        const t = e.match(this.interpolator.nestingRegexp);
                        s = t && t.length
                    }
                    let l = n.replace && !dG(n.replace) ? n.replace : n;
                    if (this.options.interpolation.defaultVariables && (l = {
                        ...this.options.interpolation.defaultVariables,
                        ...l
                    }),
                    e = this.interpolator.interpolate(e, l, n.lng || this.language || r.usedLng, n),
                    a) {
                        const t = e.match(this.interpolator.nestingRegexp);
                        s < (t && t.length) && (n.nest = !1)
                    }
                    !n.lng && "v1" !== this.options.compatibilityAPI && r && r.res && (n.lng = this.language || r.usedLng),
                    !1 !== n.nest && (e = this.interpolator.nest(e, (function() {
                        for (var e = arguments.length, r = new Array(e), a = 0; a < e; a++)
                            r[a] = arguments[a];
                        return i && i[0] === r[0] && !n.context ? (o.logger.warn(`It seems you are nesting recursively key: ${r[0]} in key: ${t[0]}`),
                        null) : o.translate(...r, t)
                    }
                    ), n)),
                    n.interpolation && this.interpolator.reset()
                }
                const a = n.postProcess || this.options.postProcess
                  , s = dG(a) ? [a] : a;
                return void 0 !== e && null !== e && s && s.length && !1 !== n.applyPostProcessor && (e = LG.handle(s, e, t, this.options && this.options.postProcessPassResolved ? {
                    i18nResolved: {
                        ...r,
                        usedParams: this.getUsedParamsDetails(n)
                    },
                    ...n
                } : n, this)),
                e
            }
            resolve(e) {
                let t, n, r, i, o, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return dG(e) && (e = [e]),
                e.forEach((e => {
                    if (this.isValidLookup(t))
                        return;
                    const s = this.extractFromKey(e, a)
                      , l = s.key;
                    n = l;
                    let c = s.namespaces;
                    this.options.fallbackNS && (c = c.concat(this.options.fallbackNS));
                    const u = void 0 !== a.count && !dG(a.count)
                      , d = u && !a.ordinal && 0 === a.count && this.pluralResolver.shouldUseIntlApi()
                      , h = void 0 !== a.context && (dG(a.context) || "number" === typeof a.context) && "" !== a.context
                      , p = a.lngs ? a.lngs : this.languageUtils.toResolveHierarchy(a.lng || this.language, a.fallbackLng);
                    c.forEach((e => {
                        this.isValidLookup(t) || (o = e,
                        !kG[`${p[0]}-${e}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(o) && (kG[`${p[0]}-${e}`] = !0,
                        this.logger.warn(`key "${n}" for languages "${p.join(", ")}" won't get resolved as namespace "${o}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),
                        p.forEach((n => {
                            if (this.isValidLookup(t))
                                return;
                            i = n;
                            const o = [l];
                            if (this.i18nFormat && this.i18nFormat.addLookupKeys)
                                this.i18nFormat.addLookupKeys(o, l, n, e, a);
                            else {
                                let e;
                                u && (e = this.pluralResolver.getSuffix(n, a.count, a));
                                const t = `${this.options.pluralSeparator}zero`
                                  , r = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                                if (u && (o.push(l + e),
                                a.ordinal && 0 === e.indexOf(r) && o.push(l + e.replace(r, this.options.pluralSeparator)),
                                d && o.push(l + t)),
                                h) {
                                    const n = `${l}${this.options.contextSeparator}${a.context}`;
                                    o.push(n),
                                    u && (o.push(n + e),
                                    a.ordinal && 0 === e.indexOf(r) && o.push(n + e.replace(r, this.options.pluralSeparator)),
                                    d && o.push(n + t))
                                }
                            }
                            let s;
                            for (; s = o.pop(); )
                                this.isValidLookup(t) || (r = s,
                                t = this.getResource(n, e, s, a))
                        }
                        )))
                    }
                    ))
                }
                )),
                {
                    res: t,
                    usedKey: n,
                    exactUsedKey: r,
                    usedLng: i,
                    usedNS: o
                }
            }
            isValidLookup(e) {
                return void 0 !== e && !(!this.options.returnNull && null === e) && !(!this.options.returnEmptyString && "" === e)
            }
            getResource(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(e, t, n, r) : this.resourceStore.getResource(e, t, n, r)
            }
            getUsedParamsDetails() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const t = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"]
                  , n = e.replace && !dG(e.replace);
                let r = n ? e.replace : e;
                if (n && "undefined" !== typeof e.count && (r.count = e.count),
                this.options.interpolation.defaultVariables && (r = {
                    ...this.options.interpolation.defaultVariables,
                    ...r
                }),
                !n) {
                    r = {
                        ...r
                    };
                    for (const e of t)
                        delete r[e]
                }
                return r
            }
            static hasDefaultValue(e) {
                const t = "defaultValue";
                for (const n in e)
                    if (Object.prototype.hasOwnProperty.call(e, n) && t === n.substring(0, 12) && void 0 !== e[n])
                        return !0;
                return !1
            }
        }
        const OG = e => e.charAt(0).toUpperCase() + e.slice(1);
        class NG {
            constructor(e) {
                this.options = e,
                this.supportedLngs = this.options.supportedLngs || !1,
                this.logger = PG.create("languageUtils")
            }
            getScriptPartFromCode(e) {
                if (!(e = CG(e)) || e.indexOf("-") < 0)
                    return null;
                const t = e.split("-");
                return 2 === t.length ? null : (t.pop(),
                "x" === t[t.length - 1].toLowerCase() ? null : this.formatLanguageCode(t.join("-")))
            }
            getLanguagePartFromCode(e) {
                if (!(e = CG(e)) || e.indexOf("-") < 0)
                    return e;
                const t = e.split("-");
                return this.formatLanguageCode(t[0])
            }
            formatLanguageCode(e) {
                if (dG(e) && e.indexOf("-") > -1) {
                    if ("undefined" !== typeof Intl && "undefined" !== typeof Intl.getCanonicalLocales)
                        try {
                            let t = Intl.getCanonicalLocales(e)[0];
                            if (t && this.options.lowerCaseLng && (t = t.toLowerCase()),
                            t)
                                return t
                        } catch (t) {}
                    const n = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
                    let r = e.split("-");
                    return this.options.lowerCaseLng ? r = r.map((e => e.toLowerCase())) : 2 === r.length ? (r[0] = r[0].toLowerCase(),
                    r[1] = r[1].toUpperCase(),
                    n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = OG(r[1].toLowerCase()))) : 3 === r.length && (r[0] = r[0].toLowerCase(),
                    2 === r[1].length && (r[1] = r[1].toUpperCase()),
                    "sgn" !== r[0] && 2 === r[2].length && (r[2] = r[2].toUpperCase()),
                    n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = OG(r[1].toLowerCase())),
                    n.indexOf(r[2].toLowerCase()) > -1 && (r[2] = OG(r[2].toLowerCase()))),
                    r.join("-")
                }
                return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e
            }
            isSupportedCode(e) {
                return ("languageOnly" === this.options.load || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)),
                !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1
            }
            getBestMatchFromCodes(e) {
                if (!e)
                    return null;
                let t;
                return e.forEach((e => {
                    if (t)
                        return;
                    const n = this.formatLanguageCode(e);
                    this.options.supportedLngs && !this.isSupportedCode(n) || (t = n)
                }
                )),
                !t && this.options.supportedLngs && e.forEach((e => {
                    if (t)
                        return;
                    const n = this.getLanguagePartFromCode(e);
                    if (this.isSupportedCode(n))
                        return t = n;
                    t = this.options.supportedLngs.find((e => e === n ? e : e.indexOf("-") < 0 && n.indexOf("-") < 0 ? void 0 : e.indexOf("-") > 0 && n.indexOf("-") < 0 && e.substring(0, e.indexOf("-")) === n || 0 === e.indexOf(n) && n.length > 1 ? e : void 0))
                }
                )),
                t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]),
                t
            }
            getFallbackCodes(e, t) {
                if (!e)
                    return [];
                if ("function" === typeof e && (e = e(t)),
                dG(e) && (e = [e]),
                Array.isArray(e))
                    return e;
                if (!t)
                    return e.default || [];
                let n = e[t];
                return n || (n = e[this.getScriptPartFromCode(t)]),
                n || (n = e[this.formatLanguageCode(t)]),
                n || (n = e[this.getLanguagePartFromCode(t)]),
                n || (n = e.default),
                n || []
            }
            toResolveHierarchy(e, t) {
                const n = this.getFallbackCodes(t || this.options.fallbackLng || [], e)
                  , r = []
                  , i = e => {
                    e && (this.isSupportedCode(e) ? r.push(e) : this.logger.warn(`rejecting language code not found in supportedLngs: ${e}`))
                }
                ;
                return dG(e) && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? ("languageOnly" !== this.options.load && i(this.formatLanguageCode(e)),
                "languageOnly" !== this.options.load && "currentOnly" !== this.options.load && i(this.getScriptPartFromCode(e)),
                "currentOnly" !== this.options.load && i(this.getLanguagePartFromCode(e))) : dG(e) && i(this.formatLanguageCode(e)),
                n.forEach((e => {
                    r.indexOf(e) < 0 && i(this.formatLanguageCode(e))
                }
                )),
                r
            }
        }
        let FG = [{
            lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
            nr: [1, 2],
            fc: 1
        }, {
            lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
            nr: [1, 2],
            fc: 2
        }, {
            lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
            nr: [1],
            fc: 3
        }, {
            lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
            nr: [1, 2, 5],
            fc: 4
        }, {
            lngs: ["ar"],
            nr: [0, 1, 2, 3, 11, 100],
            fc: 5
        }, {
            lngs: ["cs", "sk"],
            nr: [1, 2, 5],
            fc: 6
        }, {
            lngs: ["csb", "pl"],
            nr: [1, 2, 5],
            fc: 7
        }, {
            lngs: ["cy"],
            nr: [1, 2, 3, 8],
            fc: 8
        }, {
            lngs: ["fr"],
            nr: [1, 2],
            fc: 9
        }, {
            lngs: ["ga"],
            nr: [1, 2, 3, 7, 11],
            fc: 10
        }, {
            lngs: ["gd"],
            nr: [1, 2, 3, 20],
            fc: 11
        }, {
            lngs: ["is"],
            nr: [1, 2],
            fc: 12
        }, {
            lngs: ["jv"],
            nr: [0, 1],
            fc: 13
        }, {
            lngs: ["kw"],
            nr: [1, 2, 3, 4],
            fc: 14
        }, {
            lngs: ["lt"],
            nr: [1, 2, 10],
            fc: 15
        }, {
            lngs: ["lv"],
            nr: [1, 2, 0],
            fc: 16
        }, {
            lngs: ["mk"],
            nr: [1, 2],
            fc: 17
        }, {
            lngs: ["mnk"],
            nr: [0, 1, 2],
            fc: 18
        }, {
            lngs: ["mt"],
            nr: [1, 2, 11, 20],
            fc: 19
        }, {
            lngs: ["or"],
            nr: [2, 1],
            fc: 2
        }, {
            lngs: ["ro"],
            nr: [1, 2, 20],
            fc: 20
        }, {
            lngs: ["sl"],
            nr: [5, 1, 2, 3],
            fc: 21
        }, {
            lngs: ["he", "iw"],
            nr: [1, 2, 20, 21],
            fc: 22
        }]
          , UG = {
            1: e => Number(e > 1),
            2: e => Number(1 != e),
            3: e => 0,
            4: e => Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2),
            5: e => Number(0 == e ? 0 : 1 == e ? 1 : 2 == e ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5),
            6: e => Number(1 == e ? 0 : e >= 2 && e <= 4 ? 1 : 2),
            7: e => Number(1 == e ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2),
            8: e => Number(1 == e ? 0 : 2 == e ? 1 : 8 != e && 11 != e ? 2 : 3),
            9: e => Number(e >= 2),
            10: e => Number(1 == e ? 0 : 2 == e ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4),
            11: e => Number(1 == e || 11 == e ? 0 : 2 == e || 12 == e ? 1 : e > 2 && e < 20 ? 2 : 3),
            12: e => Number(e % 10 != 1 || e % 100 == 11),
            13: e => Number(0 !== e),
            14: e => Number(1 == e ? 0 : 2 == e ? 1 : 3 == e ? 2 : 3),
            15: e => Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2),
            16: e => Number(e % 10 == 1 && e % 100 != 11 ? 0 : 0 !== e ? 1 : 2),
            17: e => Number(1 == e || e % 10 == 1 && e % 100 != 11 ? 0 : 1),
            18: e => Number(0 == e ? 0 : 1 == e ? 1 : 2),
            19: e => Number(1 == e ? 0 : 0 == e || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3),
            20: e => Number(1 == e ? 0 : 0 == e || e % 100 > 0 && e % 100 < 20 ? 1 : 2),
            21: e => Number(e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0),
            22: e => Number(1 == e ? 0 : 2 == e ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3)
        };
        const zG = ["v1", "v2", "v3"]
          , GG = ["v4"]
          , HG = {
            zero: 0,
            one: 1,
            two: 2,
            few: 3,
            many: 4,
            other: 5
        };
        class jG {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                this.languageUtils = e,
                this.options = t,
                this.logger = PG.create("pluralResolver"),
                this.options.compatibilityJSON && !GG.includes(this.options.compatibilityJSON) || "undefined" !== typeof Intl && Intl.PluralRules || (this.options.compatibilityJSON = "v3",
                this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")),
                this.rules = ( () => {
                    const e = {};
                    return FG.forEach((t => {
                        t.lngs.forEach((n => {
                            e[n] = {
                                numbers: t.nr,
                                plurals: UG[t.fc]
                            }
                        }
                        ))
                    }
                    )),
                    e
                }
                )(),
                this.pluralRulesCache = {}
            }
            addRule(e, t) {
                this.rules[e] = t
            }
            clearCache() {
                this.pluralRulesCache = {}
            }
            getRule(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (this.shouldUseIntlApi()) {
                    const r = CG("dev" === e ? "en" : e)
                      , i = t.ordinal ? "ordinal" : "cardinal"
                      , o = JSON.stringify({
                        cleanedCode: r,
                        type: i
                    });
                    if (o in this.pluralRulesCache)
                        return this.pluralRulesCache[o];
                    let a;
                    try {
                        a = new Intl.PluralRules(r,{
                            type: i
                        })
                    } catch (n) {
                        if (!e.match(/-|_/))
                            return;
                        const r = this.languageUtils.getLanguagePartFromCode(e);
                        a = this.getRule(r, t)
                    }
                    return this.pluralRulesCache[o] = a,
                    a
                }
                return this.rules[e] || this.rules[this.languageUtils.getLanguagePartFromCode(e)]
            }
            needsPlural(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                const n = this.getRule(e, t);
                return this.shouldUseIntlApi() ? n && n.resolvedOptions().pluralCategories.length > 1 : n && n.numbers.length > 1
            }
            getPluralFormsOfKey(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                return this.getSuffixes(e, n).map((e => `${t}${e}`))
            }
            getSuffixes(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                const n = this.getRule(e, t);
                return n ? this.shouldUseIntlApi() ? n.resolvedOptions().pluralCategories.sort(( (e, t) => HG[e] - HG[t])).map((e => `${this.options.prepend}${t.ordinal ? `ordinal${this.options.prepend}` : ""}${e}`)) : n.numbers.map((n => this.getSuffix(e, n, t))) : []
            }
            getSuffix(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                const r = this.getRule(e, n);
                return r ? this.shouldUseIntlApi() ? `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${r.select(t)}` : this.getSuffixRetroCompatible(r, t) : (this.logger.warn(`no plural rule found for: ${e}`),
                "")
            }
            getSuffixRetroCompatible(e, t) {
                const n = e.noAbs ? e.plurals(t) : e.plurals(Math.abs(t));
                let r = e.numbers[n];
                this.options.simplifyPluralSuffix && 2 === e.numbers.length && 1 === e.numbers[0] && (2 === r ? r = "plural" : 1 === r && (r = ""));
                const i = () => this.options.prepend && r.toString() ? this.options.prepend + r.toString() : r.toString();
                return "v1" === this.options.compatibilityJSON ? 1 === r ? "" : "number" === typeof r ? `_plural_${r.toString()}` : i() : "v2" === this.options.compatibilityJSON || this.options.simplifyPluralSuffix && 2 === e.numbers.length && 1 === e.numbers[0] ? i() : this.options.prepend && n.toString() ? this.options.prepend + n.toString() : n.toString()
            }
            shouldUseIntlApi() {
                return !zG.includes(this.options.compatibilityJSON)
            }
        }
        const WG = function(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "."
              , i = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]
              , o = ( (e, t, n) => {
                const r = bG(e, n);
                return void 0 !== r ? r : bG(t, n)
            }
            )(e, t, n);
            return !o && i && dG(n) && (o = MG(e, n, r),
            void 0 === o && (o = MG(t, n, r))),
            o
        }
          , VG = e => e.replace(/\$/g, "$$$$");
        class XG {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                this.logger = PG.create("interpolator"),
                this.options = e,
                this.format = e.interpolation && e.interpolation.format || (e => e),
                this.init(e)
            }
            init() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                e.interpolation || (e.interpolation = {
                    escapeValue: !0
                });
                const {escape: t, escapeValue: n, useRawValueToEscape: r, prefix: i, prefixEscaped: o, suffix: a, suffixEscaped: s, formatSeparator: l, unescapeSuffix: c, unescapePrefix: u, nestingPrefix: d, nestingPrefixEscaped: h, nestingSuffix: p, nestingSuffixEscaped: f, nestingOptionsSeparator: m, maxReplaces: g, alwaysFormat: v} = e.interpolation;
                this.escape = void 0 !== t ? t : SG,
                this.escapeValue = void 0 === n || n,
                this.useRawValueToEscape = void 0 !== r && r,
                this.prefix = i ? AG(i) : o || "{{",
                this.suffix = a ? AG(a) : s || "}}",
                this.formatSeparator = l || ",",
                this.unescapePrefix = c ? "" : u || "-",
                this.unescapeSuffix = this.unescapePrefix ? "" : c || "",
                this.nestingPrefix = d ? AG(d) : h || AG("$t("),
                this.nestingSuffix = p ? AG(p) : f || AG(")"),
                this.nestingOptionsSeparator = m || ",",
                this.maxReplaces = g || 1e3,
                this.alwaysFormat = void 0 !== v && v,
                this.resetRegExp()
            }
            reset() {
                this.options && this.init(this.options)
            }
            resetRegExp() {
                const e = (e, t) => e && e.source === t ? (e.lastIndex = 0,
                e) : new RegExp(t,"g");
                this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`),
                this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`),
                this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`)
            }
            interpolate(e, t, n, r) {
                let i, o, a;
                const s = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}
                  , l = e => {
                    if (e.indexOf(this.formatSeparator) < 0) {
                        const i = WG(t, s, e, this.options.keySeparator, this.options.ignoreJSONStructure);
                        return this.alwaysFormat ? this.format(i, void 0, n, {
                            ...r,
                            ...t,
                            interpolationkey: e
                        }) : i
                    }
                    const i = e.split(this.formatSeparator)
                      , o = i.shift().trim()
                      , a = i.join(this.formatSeparator).trim();
                    return this.format(WG(t, s, o, this.options.keySeparator, this.options.ignoreJSONStructure), a, n, {
                        ...r,
                        ...t,
                        interpolationkey: o
                    })
                }
                ;
                this.resetRegExp();
                const c = r && r.missingInterpolationHandler || this.options.missingInterpolationHandler
                  , u = r && r.interpolation && void 0 !== r.interpolation.skipOnVariables ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
                return [{
                    regex: this.regexpUnescape,
                    safeValue: e => VG(e)
                }, {
                    regex: this.regexp,
                    safeValue: e => this.escapeValue ? VG(this.escape(e)) : VG(e)
                }].forEach((t => {
                    for (a = 0; i = t.regex.exec(e); ) {
                        const n = i[1].trim();
                        if (o = l(n),
                        void 0 === o)
                            if ("function" === typeof c) {
                                const t = c(e, i, r);
                                o = dG(t) ? t : ""
                            } else if (r && Object.prototype.hasOwnProperty.call(r, n))
                                o = "";
                            else {
                                if (u) {
                                    o = i[0];
                                    continue
                                }
                                this.logger.warn(`missed to pass in variable ${n} for interpolating ${e}`),
                                o = ""
                            }
                        else
                            dG(o) || this.useRawValueToEscape || (o = pG(o));
                        const s = t.safeValue(o);
                        if (e = e.replace(i[0], s),
                        u ? (t.regex.lastIndex += o.length,
                        t.regex.lastIndex -= i[0].length) : t.regex.lastIndex = 0,
                        a++,
                        a >= this.maxReplaces)
                            break
                    }
                }
                )),
                e
            }
            nest(e, t) {
                let n, r, i, o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                const a = (e, t) => {
                    const n = this.nestingOptionsSeparator;
                    if (e.indexOf(n) < 0)
                        return e;
                    const r = e.split(new RegExp(`${n}[ ]*{`));
                    let o = `{${r[1]}`;
                    e = r[0],
                    o = this.interpolate(o, i);
                    const a = o.match(/'/g)
                      , s = o.match(/"/g);
                    (a && a.length % 2 === 0 && !s || s.length % 2 !== 0) && (o = o.replace(/'/g, '"'));
                    try {
                        i = JSON.parse(o),
                        t && (i = {
                            ...t,
                            ...i
                        })
                    } catch (l) {
                        return this.logger.warn(`failed parsing options string in nesting for key ${e}`, l),
                        `${e}${n}${o}`
                    }
                    return i.defaultValue && i.defaultValue.indexOf(this.prefix) > -1 && delete i.defaultValue,
                    e
                }
                ;
                for (; n = this.nestingRegexp.exec(e); ) {
                    let s = [];
                    i = {
                        ...o
                    },
                    i = i.replace && !dG(i.replace) ? i.replace : i,
                    i.applyPostProcessor = !1,
                    delete i.defaultValue;
                    let l = !1;
                    if (-1 !== n[0].indexOf(this.formatSeparator) && !/{.*}/.test(n[1])) {
                        const e = n[1].split(this.formatSeparator).map((e => e.trim()));
                        n[1] = e.shift(),
                        s = e,
                        l = !0
                    }
                    if (r = t(a.call(this, n[1].trim(), i), i),
                    r && n[0] === e && !dG(r))
                        return r;
                    dG(r) || (r = pG(r)),
                    r || (this.logger.warn(`missed to resolve ${n[1]} for nesting ${e}`),
                    r = ""),
                    l && (r = s.reduce(( (e, t) => this.format(e, t, o.lng, {
                        ...o,
                        interpolationkey: n[1].trim()
                    })), r.trim())),
                    e = e.replace(n[0], r),
                    this.regexp.lastIndex = 0
                }
                return e
            }
        }
        const JG = e => {
            const t = {};
            return (n, r, i) => {
                let o = i;
                i && i.interpolationkey && i.formatParams && i.formatParams[i.interpolationkey] && i[i.interpolationkey] && (o = {
                    ...o,
                    [i.interpolationkey]: void 0
                });
                const a = r + JSON.stringify(o);
                let s = t[a];
                return s || (s = e(CG(r), i),
                t[a] = s),
                s(n)
            }
        }
        ;
        class KG {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                this.logger = PG.create("formatter"),
                this.options = e,
                this.formats = {
                    number: JG(( (e, t) => {
                        const n = new Intl.NumberFormat(e,{
                            ...t
                        });
                        return e => n.format(e)
                    }
                    )),
                    currency: JG(( (e, t) => {
                        const n = new Intl.NumberFormat(e,{
                            ...t,
                            style: "currency"
                        });
                        return e => n.format(e)
                    }
                    )),
                    datetime: JG(( (e, t) => {
                        const n = new Intl.DateTimeFormat(e,{
                            ...t
                        });
                        return e => n.format(e)
                    }
                    )),
                    relativetime: JG(( (e, t) => {
                        const n = new Intl.RelativeTimeFormat(e,{
                            ...t
                        });
                        return e => n.format(e, t.range || "day")
                    }
                    )),
                    list: JG(( (e, t) => {
                        const n = new Intl.ListFormat(e,{
                            ...t
                        });
                        return e => n.format(e)
                    }
                    ))
                },
                this.init(e)
            }
            init(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                    interpolation: {}
                };
                this.formatSeparator = t.interpolation.formatSeparator || ","
            }
            add(e, t) {
                this.formats[e.toLowerCase().trim()] = t
            }
            addCached(e, t) {
                this.formats[e.toLowerCase().trim()] = JG(t)
            }
            format(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                const i = t.split(this.formatSeparator);
                if (i.length > 1 && i[0].indexOf("(") > 1 && i[0].indexOf(")") < 0 && i.find((e => e.indexOf(")") > -1))) {
                    const e = i.findIndex((e => e.indexOf(")") > -1));
                    i[0] = [i[0], ...i.splice(1, e)].join(this.formatSeparator)
                }
                return i.reduce(( (e, t) => {
                    const {formatName: i, formatOptions: o} = (e => {
                        let t = e.toLowerCase().trim();
                        const n = {};
                        if (e.indexOf("(") > -1) {
                            const r = e.split("(");
                            t = r[0].toLowerCase().trim();
                            const i = r[1].substring(0, r[1].length - 1);
                            "currency" === t && i.indexOf(":") < 0 ? n.currency || (n.currency = i.trim()) : "relativetime" === t && i.indexOf(":") < 0 ? n.range || (n.range = i.trim()) : i.split(";").forEach((e => {
                                if (e) {
                                    const [t,...r] = e.split(":")
                                      , i = r.join(":").trim().replace(/^'+|'+$/g, "")
                                      , o = t.trim();
                                    n[o] || (n[o] = i),
                                    "false" === i && (n[o] = !1),
                                    "true" === i && (n[o] = !0),
                                    isNaN(i) || (n[o] = parseInt(i, 10))
                                }
                            }
                            ))
                        }
                        return {
                            formatName: t,
                            formatOptions: n
                        }
                    }
                    )(t);
                    if (this.formats[i]) {
                        let t = e;
                        try {
                            const a = r && r.formatParams && r.formatParams[r.interpolationkey] || {}
                              , s = a.locale || a.lng || r.locale || r.lng || n;
                            t = this.formats[i](e, s, {
                                ...o,
                                ...r,
                                ...a
                            })
                        } catch (a) {
                            this.logger.warn(a)
                        }
                        return t
                    }
                    return this.logger.warn(`there was no format function for ${i}`),
                    e
                }
                ), e)
            }
        }
        class qG extends BG {
            constructor(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                super(),
                this.backend = e,
                this.store = t,
                this.services = n,
                this.languageUtils = n.languageUtils,
                this.options = r,
                this.logger = PG.create("backendConnector"),
                this.waitingReads = [],
                this.maxParallelReads = r.maxParallelReads || 10,
                this.readingCalls = 0,
                this.maxRetries = r.maxRetries >= 0 ? r.maxRetries : 5,
                this.retryTimeout = r.retryTimeout >= 1 ? r.retryTimeout : 350,
                this.state = {},
                this.queue = [],
                this.backend && this.backend.init && this.backend.init(n, r.backend, r)
            }
            queueLoad(e, t, n, r) {
                const i = {}
                  , o = {}
                  , a = {}
                  , s = {};
                return e.forEach((e => {
                    let r = !0;
                    t.forEach((t => {
                        const a = `${e}|${t}`;
                        !n.reload && this.store.hasResourceBundle(e, t) ? this.state[a] = 2 : this.state[a] < 0 || (1 === this.state[a] ? void 0 === o[a] && (o[a] = !0) : (this.state[a] = 1,
                        r = !1,
                        void 0 === o[a] && (o[a] = !0),
                        void 0 === i[a] && (i[a] = !0),
                        void 0 === s[t] && (s[t] = !0)))
                    }
                    )),
                    r || (a[e] = !0)
                }
                )),
                (Object.keys(i).length || Object.keys(o).length) && this.queue.push({
                    pending: o,
                    pendingCount: Object.keys(o).length,
                    loaded: {},
                    errors: [],
                    callback: r
                }),
                {
                    toLoad: Object.keys(i),
                    pending: Object.keys(o),
                    toLoadLanguages: Object.keys(a),
                    toLoadNamespaces: Object.keys(s)
                }
            }
            loaded(e, t, n) {
                const r = e.split("|")
                  , i = r[0]
                  , o = r[1];
                t && this.emit("failedLoading", i, o, t),
                !t && n && this.store.addResourceBundle(i, o, n, void 0, void 0, {
                    skipCopy: !0
                }),
                this.state[e] = t ? -1 : 2,
                t && n && (this.state[e] = 0);
                const a = {};
                this.queue.forEach((n => {
                    ( (e, t, n) => {
                        const {obj: r, k: i} = vG(e, t, Object);
                        r[i] = r[i] || [],
                        r[i].push(n)
                    }
                    )(n.loaded, [i], o),
                    ( (e, t) => {
                        void 0 !== e.pending[t] && (delete e.pending[t],
                        e.pendingCount--)
                    }
                    )(n, e),
                    t && n.errors.push(t),
                    0 !== n.pendingCount || n.done || (Object.keys(n.loaded).forEach((e => {
                        a[e] || (a[e] = {});
                        const t = n.loaded[e];
                        t.length && t.forEach((t => {
                            void 0 === a[e][t] && (a[e][t] = !0)
                        }
                        ))
                    }
                    )),
                    n.done = !0,
                    n.errors.length ? n.callback(n.errors) : n.callback())
                }
                )),
                this.emit("loaded", a),
                this.queue = this.queue.filter((e => !e.done))
            }
            read(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.retryTimeout
                  , o = arguments.length > 5 ? arguments[5] : void 0;
                if (!e.length)
                    return o(null, {});
                if (this.readingCalls >= this.maxParallelReads)
                    return void this.waitingReads.push({
                        lng: e,
                        ns: t,
                        fcName: n,
                        tried: r,
                        wait: i,
                        callback: o
                    });
                this.readingCalls++;
                const a = (a, s) => {
                    if (this.readingCalls--,
                    this.waitingReads.length > 0) {
                        const e = this.waitingReads.shift();
                        this.read(e.lng, e.ns, e.fcName, e.tried, e.wait, e.callback)
                    }
                    a && s && r < this.maxRetries ? setTimeout(( () => {
                        this.read.call(this, e, t, n, r + 1, 2 * i, o)
                    }
                    ), i) : o(a, s)
                }
                  , s = this.backend[n].bind(this.backend);
                if (2 !== s.length)
                    return s(e, t, a);
                try {
                    const n = s(e, t);
                    n && "function" === typeof n.then ? n.then((e => a(null, e))).catch(a) : a(null, n)
                } catch (l) {
                    a(l)
                }
            }
            prepareLoading(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                  , r = arguments.length > 3 ? arguments[3] : void 0;
                if (!this.backend)
                    return this.logger.warn("No backend was added via i18next.use. Will not load resources."),
                    r && r();
                dG(e) && (e = this.languageUtils.toResolveHierarchy(e)),
                dG(t) && (t = [t]);
                const i = this.queueLoad(e, t, n, r);
                if (!i.toLoad.length)
                    return i.pending.length || r(),
                    null;
                i.toLoad.forEach((e => {
                    this.loadOne(e)
                }
                ))
            }
            load(e, t, n) {
                this.prepareLoading(e, t, {}, n)
            }
            reload(e, t, n) {
                this.prepareLoading(e, t, {
                    reload: !0
                }, n)
            }
            loadOne(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                const n = e.split("|")
                  , r = n[0]
                  , i = n[1];
                this.read(r, i, "read", void 0, void 0, ( (n, o) => {
                    n && this.logger.warn(`${t}loading namespace ${i} for language ${r} failed`, n),
                    !n && o && this.logger.log(`${t}loaded namespace ${i} for language ${r}`, o),
                    this.loaded(e, n, o)
                }
                ))
            }
            saveMissing(e, t, n, r, i) {
                let o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {}
                  , a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : () => {}
                ;
                if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(t))
                    this.logger.warn(`did not save key "${n}" as the namespace "${t}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
                else if (void 0 !== n && null !== n && "" !== n) {
                    if (this.backend && this.backend.create) {
                        const l = {
                            ...o,
                            isUpdate: i
                        }
                          , c = this.backend.create.bind(this.backend);
                        if (c.length < 6)
                            try {
                                let i;
                                i = 5 === c.length ? c(e, t, n, r, l) : c(e, t, n, r),
                                i && "function" === typeof i.then ? i.then((e => a(null, e))).catch(a) : a(null, i)
                            } catch (s) {
                                a(s)
                            }
                        else
                            c(e, t, n, r, a, l)
                    }
                    e && e[0] && this.store.addResource(e[0], t, n, r)
                }
            }
        }
        const YG = () => ({
            debug: !1,
            initImmediate: !0,
            ns: ["translation"],
            defaultNS: ["translation"],
            fallbackLng: ["dev"],
            fallbackNS: !1,
            supportedLngs: !1,
            nonExplicitSupportedLngs: !1,
            load: "all",
            preload: !1,
            simplifyPluralSuffix: !0,
            keySeparator: ".",
            nsSeparator: ":",
            pluralSeparator: "_",
            contextSeparator: "_",
            partialBundledLanguages: !1,
            saveMissing: !1,
            updateMissing: !1,
            saveMissingTo: "fallback",
            saveMissingPlurals: !0,
            missingKeyHandler: !1,
            missingInterpolationHandler: !1,
            postProcess: !1,
            postProcessPassResolved: !1,
            returnNull: !1,
            returnEmptyString: !0,
            returnObjects: !1,
            joinArrays: !1,
            returnedObjectHandler: !1,
            parseMissingKeyHandler: !1,
            appendNamespaceToMissingKey: !1,
            appendNamespaceToCIMode: !1,
            overloadTranslationOptionHandler: e => {
                let t = {};
                if ("object" === typeof e[1] && (t = e[1]),
                dG(e[1]) && (t.defaultValue = e[1]),
                dG(e[2]) && (t.tDescription = e[2]),
                "object" === typeof e[2] || "object" === typeof e[3]) {
                    const n = e[3] || e[2];
                    Object.keys(n).forEach((e => {
                        t[e] = n[e]
                    }
                    ))
                }
                return t
            }
            ,
            interpolation: {
                escapeValue: !0,
                format: e => e,
                prefix: "{{",
                suffix: "}}",
                formatSeparator: ",",
                unescapePrefix: "-",
                nestingPrefix: "$t(",
                nestingSuffix: ")",
                nestingOptionsSeparator: ",",
                maxReplaces: 1e3,
                skipOnVariables: !0
            }
        })
          , QG = e => (dG(e.ns) && (e.ns = [e.ns]),
        dG(e.fallbackLng) && (e.fallbackLng = [e.fallbackLng]),
        dG(e.fallbackNS) && (e.fallbackNS = [e.fallbackNS]),
        e.supportedLngs && e.supportedLngs.indexOf("cimode") < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])),
        e)
          , ZG = () => {}
        ;
        class $G extends BG {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , t = arguments.length > 1 ? arguments[1] : void 0;
                var n;
                if (super(),
                this.options = QG(e),
                this.services = {},
                this.logger = PG,
                this.modules = {
                    external: []
                },
                n = this,
                Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach((e => {
                    "function" === typeof n[e] && (n[e] = n[e].bind(n))
                }
                )),
                t && !this.isInitialized && !e.isClone) {
                    if (!this.options.initImmediate)
                        return this.init(e, t),
                        this;
                    setTimeout(( () => {
                        this.init(e, t)
                    }
                    ), 0)
                }
            }
            init() {
                var e = this;
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , n = arguments.length > 1 ? arguments[1] : void 0;
                this.isInitializing = !0,
                "function" === typeof t && (n = t,
                t = {}),
                !t.defaultNS && !1 !== t.defaultNS && t.ns && (dG(t.ns) ? t.defaultNS = t.ns : t.ns.indexOf("translation") < 0 && (t.defaultNS = t.ns[0]));
                const r = YG();
                this.options = {
                    ...r,
                    ...this.options,
                    ...QG(t)
                },
                "v1" !== this.options.compatibilityAPI && (this.options.interpolation = {
                    ...r.interpolation,
                    ...this.options.interpolation
                }),
                void 0 !== t.keySeparator && (this.options.userDefinedKeySeparator = t.keySeparator),
                void 0 !== t.nsSeparator && (this.options.userDefinedNsSeparator = t.nsSeparator);
                const i = e => e ? "function" === typeof e ? new e : e : null;
                if (!this.options.isClone) {
                    let t;
                    this.modules.logger ? PG.init(i(this.modules.logger), this.options) : PG.init(null, this.options),
                    this.modules.formatter ? t = this.modules.formatter : "undefined" !== typeof Intl && (t = KG);
                    const n = new NG(this.options);
                    this.store = new IG(this.options.resources,this.options);
                    const o = this.services;
                    o.logger = PG,
                    o.resourceStore = this.store,
                    o.languageUtils = n,
                    o.pluralResolver = new jG(n,{
                        prepend: this.options.pluralSeparator,
                        compatibilityJSON: this.options.compatibilityJSON,
                        simplifyPluralSuffix: this.options.simplifyPluralSuffix
                    }),
                    !t || this.options.interpolation.format && this.options.interpolation.format !== r.interpolation.format || (o.formatter = i(t),
                    o.formatter.init(o, this.options),
                    this.options.interpolation.format = o.formatter.format.bind(o.formatter)),
                    o.interpolator = new XG(this.options),
                    o.utils = {
                        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
                    },
                    o.backendConnector = new qG(i(this.modules.backend),o.resourceStore,o,this.options),
                    o.backendConnector.on("*", (function(t) {
                        for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
                            r[i - 1] = arguments[i];
                        e.emit(t, ...r)
                    }
                    )),
                    this.modules.languageDetector && (o.languageDetector = i(this.modules.languageDetector),
                    o.languageDetector.init && o.languageDetector.init(o, this.options.detection, this.options)),
                    this.modules.i18nFormat && (o.i18nFormat = i(this.modules.i18nFormat),
                    o.i18nFormat.init && o.i18nFormat.init(this)),
                    this.translator = new DG(this.services,this.options),
                    this.translator.on("*", (function(t) {
                        for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
                            r[i - 1] = arguments[i];
                        e.emit(t, ...r)
                    }
                    )),
                    this.modules.external.forEach((e => {
                        e.init && e.init(this)
                    }
                    ))
                }
                if (this.format = this.options.interpolation.format,
                n || (n = ZG),
                this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
                    const e = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                    e.length > 0 && "dev" !== e[0] && (this.options.lng = e[0])
                }
                this.services.languageDetector || this.options.lng || this.logger.warn("init: no languageDetector is used and no lng is defined");
                ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((t => {
                    this[t] = function() {
                        return e.store[t](...arguments)
                    }
                }
                ));
                ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((t => {
                    this[t] = function() {
                        return e.store[t](...arguments),
                        e
                    }
                }
                ));
                const o = hG()
                  , a = () => {
                    const e = (e, t) => {
                        this.isInitializing = !1,
                        this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"),
                        this.isInitialized = !0,
                        this.options.isClone || this.logger.log("initialized", this.options),
                        this.emit("initialized", this.options),
                        o.resolve(t),
                        n(e, t)
                    }
                    ;
                    if (this.languages && "v1" !== this.options.compatibilityAPI && !this.isInitialized)
                        return e(null, this.t.bind(this));
                    this.changeLanguage(this.options.lng, e)
                }
                ;
                return this.options.resources || !this.options.initImmediate ? a() : setTimeout(a, 0),
                o
            }
            loadResources(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ZG;
                const n = dG(e) ? e : this.language;
                if ("function" === typeof e && (t = e),
                !this.options.resources || this.options.partialBundledLanguages) {
                    if (n && "cimode" === n.toLowerCase() && (!this.options.preload || 0 === this.options.preload.length))
                        return t();
                    const e = []
                      , r = t => {
                        if (!t)
                            return;
                        if ("cimode" === t)
                            return;
                        this.services.languageUtils.toResolveHierarchy(t).forEach((t => {
                            "cimode" !== t && e.indexOf(t) < 0 && e.push(t)
                        }
                        ))
                    }
                    ;
                    if (n)
                        r(n);
                    else {
                        this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((e => r(e)))
                    }
                    this.options.preload && this.options.preload.forEach((e => r(e))),
                    this.services.backendConnector.load(e, this.options.ns, (e => {
                        e || this.resolvedLanguage || !this.language || this.setResolvedLanguage(this.language),
                        t(e)
                    }
                    ))
                } else
                    t(null)
            }
            reloadResources(e, t, n) {
                const r = hG();
                return "function" === typeof e && (n = e,
                e = void 0),
                "function" === typeof t && (n = t,
                t = void 0),
                e || (e = this.languages),
                t || (t = this.options.ns),
                n || (n = ZG),
                this.services.backendConnector.reload(e, t, (e => {
                    r.resolve(),
                    n(e)
                }
                )),
                r
            }
            use(e) {
                if (!e)
                    throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
                if (!e.type)
                    throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
                return "backend" === e.type && (this.modules.backend = e),
                ("logger" === e.type || e.log && e.warn && e.error) && (this.modules.logger = e),
                "languageDetector" === e.type && (this.modules.languageDetector = e),
                "i18nFormat" === e.type && (this.modules.i18nFormat = e),
                "postProcessor" === e.type && LG.addPostProcessor(e),
                "formatter" === e.type && (this.modules.formatter = e),
                "3rdParty" === e.type && this.modules.external.push(e),
                this
            }
            setResolvedLanguage(e) {
                if (e && this.languages && !(["cimode", "dev"].indexOf(e) > -1))
                    for (let t = 0; t < this.languages.length; t++) {
                        const e = this.languages[t];
                        if (!(["cimode", "dev"].indexOf(e) > -1) && this.store.hasLanguageSomeTranslations(e)) {
                            this.resolvedLanguage = e;
                            break
                        }
                    }
            }
            changeLanguage(e, t) {
                var n = this;
                this.isLanguageChangingTo = e;
                const r = hG();
                this.emit("languageChanging", e);
                const i = e => {
                    this.language = e,
                    this.languages = this.services.languageUtils.toResolveHierarchy(e),
                    this.resolvedLanguage = void 0,
                    this.setResolvedLanguage(e)
                }
                  , o = (e, o) => {
                    o ? (i(o),
                    this.translator.changeLanguage(o),
                    this.isLanguageChangingTo = void 0,
                    this.emit("languageChanged", o),
                    this.logger.log("languageChanged", o)) : this.isLanguageChangingTo = void 0,
                    r.resolve((function() {
                        return n.t(...arguments)
                    }
                    )),
                    t && t(e, (function() {
                        return n.t(...arguments)
                    }
                    ))
                }
                  , a = t => {
                    e || t || !this.services.languageDetector || (t = []);
                    const n = dG(t) ? t : this.services.languageUtils.getBestMatchFromCodes(t);
                    n && (this.language || i(n),
                    this.translator.language || this.translator.changeLanguage(n),
                    this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(n)),
                    this.loadResources(n, (e => {
                        o(e, n)
                    }
                    ))
                }
                ;
                return e || !this.services.languageDetector || this.services.languageDetector.async ? !e && this.services.languageDetector && this.services.languageDetector.async ? 0 === this.services.languageDetector.detect.length ? this.services.languageDetector.detect().then(a) : this.services.languageDetector.detect(a) : a(e) : a(this.services.languageDetector.detect()),
                r
            }
            getFixedT(e, t, n) {
                var r = this;
                const i = function(e, t) {
                    let o;
                    if ("object" !== typeof t) {
                        for (var a = arguments.length, s = new Array(a > 2 ? a - 2 : 0), l = 2; l < a; l++)
                            s[l - 2] = arguments[l];
                        o = r.options.overloadTranslationOptionHandler([e, t].concat(s))
                    } else
                        o = {
                            ...t
                        };
                    o.lng = o.lng || i.lng,
                    o.lngs = o.lngs || i.lngs,
                    o.ns = o.ns || i.ns,
                    "" !== o.keyPrefix && (o.keyPrefix = o.keyPrefix || n || i.keyPrefix);
                    const c = r.options.keySeparator || ".";
                    let u;
                    return u = o.keyPrefix && Array.isArray(e) ? e.map((e => `${o.keyPrefix}${c}${e}`)) : o.keyPrefix ? `${o.keyPrefix}${c}${e}` : e,
                    r.t(u, o)
                };
                return dG(e) ? i.lng = e : i.lngs = e,
                i.ns = t,
                i.keyPrefix = n,
                i
            }
            t() {
                return this.translator && this.translator.translate(...arguments)
            }
            exists() {
                return this.translator && this.translator.exists(...arguments)
            }
            setDefaultNamespace(e) {
                this.options.defaultNS = e
            }
            hasLoadedNamespace(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (!this.isInitialized)
                    return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages),
                    !1;
                if (!this.languages || !this.languages.length)
                    return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages),
                    !1;
                const n = t.lng || this.resolvedLanguage || this.languages[0]
                  , r = !!this.options && this.options.fallbackLng
                  , i = this.languages[this.languages.length - 1];
                if ("cimode" === n.toLowerCase())
                    return !0;
                const o = (e, t) => {
                    const n = this.services.backendConnector.state[`${e}|${t}`];
                    return -1 === n || 0 === n || 2 === n
                }
                ;
                if (t.precheck) {
                    const e = t.precheck(this, o);
                    if (void 0 !== e)
                        return e
                }
                return !!this.hasResourceBundle(n, e) || (!(this.services.backendConnector.backend && (!this.options.resources || this.options.partialBundledLanguages)) || !(!o(n, e) || r && !o(i, e)))
            }
            loadNamespaces(e, t) {
                const n = hG();
                return this.options.ns ? (dG(e) && (e = [e]),
                e.forEach((e => {
                    this.options.ns.indexOf(e) < 0 && this.options.ns.push(e)
                }
                )),
                this.loadResources((e => {
                    n.resolve(),
                    t && t(e)
                }
                )),
                n) : (t && t(),
                Promise.resolve())
            }
            loadLanguages(e, t) {
                const n = hG();
                dG(e) && (e = [e]);
                const r = this.options.preload || []
                  , i = e.filter((e => r.indexOf(e) < 0 && this.services.languageUtils.isSupportedCode(e)));
                return i.length ? (this.options.preload = r.concat(i),
                this.loadResources((e => {
                    n.resolve(),
                    t && t(e)
                }
                )),
                n) : (t && t(),
                Promise.resolve())
            }
            dir(e) {
                if (e || (e = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)),
                !e)
                    return "rtl";
                const t = this.services && this.services.languageUtils || new NG(YG());
                return ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"].indexOf(t.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr"
            }
            static createInstance() {
                return new $G(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},arguments.length > 1 ? arguments[1] : void 0)
            }
            cloneInstance() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ZG;
                const n = e.forkResourceStore;
                n && delete e.forkResourceStore;
                const r = {
                    ...this.options,
                    ...e,
                    isClone: !0
                }
                  , i = new $G(r);
                void 0 === e.debug && void 0 === e.prefix || (i.logger = i.logger.clone(e));
                return ["store", "services", "language"].forEach((e => {
                    i[e] = this[e]
                }
                )),
                i.services = {
                    ...this.services
                },
                i.services.utils = {
                    hasLoadedNamespace: i.hasLoadedNamespace.bind(i)
                },
                n && (i.store = new IG(this.store.data,r),
                i.services.resourceStore = i.store),
                i.translator = new DG(i.services,r),
                i.translator.on("*", (function(e) {
                    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
                        n[r - 1] = arguments[r];
                    i.emit(e, ...n)
                }
                )),
                i.init(r, t),
                i.translator.options = r,
                i.translator.backendConnector.services.utils = {
                    hasLoadedNamespace: i.hasLoadedNamespace.bind(i)
                },
                i
            }
            toJSON() {
                return {
                    options: this.options,
                    store: this.store,
                    language: this.language,
                    languages: this.languages,
                    resolvedLanguage: this.resolvedLanguage
                }
            }
        }
        const eH = $G.createInstance();
        eH.createInstance = $G.createInstance;
        eH.createInstance,
        eH.dir,
        eH.init,
        eH.loadResources,
        eH.reloadResources,
        eH.use,
        eH.changeLanguage,
        eH.getFixedT,
        eH.t,
        eH.exists,
        eH.setDefaultNamespace,
        eH.hasLoadedNamespace,
        eH.loadNamespaces,
        eH.loadLanguages;
        const tH = {
            en: {
                translation: JSON.parse('{"back":"Back","tooltip_list":"Back to menu","tooltip_replay":"Try it again","tooltip_ai":"Turn on/off AI","beginner":"beginner","intermediate":"intermediate","advanced":"advanced","master":"master","first":"I","second":"II","third":"III","fourth":"IV"}')
            },
            cn: {
                translation: JSON.parse('{"back":"\u8fd4\u56de","tooltip_list":"\u8fd4\u56de\u83dc\u5355","tooltip_replay":"\u91cd\u73a9","tooltip_ai":"\u6253\u5f00/\u5173\u95ed AI","beginner":"\u521d\u7ea7","intermediate":"\u4e2d\u7ea7","advanced":"\u9ad8\u7ea7","master":"\u5927\u5e08","first":"\u7b2c\u4e00\u671f","second":"\u7b2c\u4e8c\u671f","third":"\u7b2c\u4e09\u671f","fourth":"\u7b2c\u56db\u671f"}')
            },
            tw: {
                translation: JSON.parse('{"back":"\u8fd4\u56de","tooltip_list":"\u8fd4\u56de\u9078\u55ae","tooltip_replay":"\u91cd\u73a9","tooltip_ai":"\u6253\u958b/\u95dc\u9589 AI","beginner":"\u521d\u968e","intermediate":"\u9032\u968e","advanced":"\u9ad8\u968e","master":"\u5927\u5e2b","first":"\u7b2c\u4e00\u671f","second":"\u7b2c\u4e8c\u671f","third":"\u7b2c\u4e09\u671f","fourth":"\u7b2c\u56db\u671f"}')
            }
        };
        eH.use(Mk).init({
            resources: tH,
            lng: "tw",
            fallbackLng: "tw",
            interpolation: {
                escapeValue: !1
            }
        });
        const nH = e => {
            e && e instanceof Function && __webpack_require__.e(206).then(__webpack_require__.bind(__webpack_require__, 8206)).then((t => {
                let {getCLS: n, getFID: r, getFCP: i, getLCP: o, getTTFB: a} = t;
                n(e),
                r(e),
                i(e),
                o(e),
                a(e)
            }
            ))
        }
        ;
        const rH = t.createContext(null);
        function iH() {
            return t.useContext(rH)
        }
        const oH = "function" === typeof Symbol && Symbol.for ? Symbol.for("mui.nested") : "__THEME_NESTED__";
        const aH = function(e) {
            const {children: n, theme: r} = e
              , i = iH()
              , o = t.useMemo(( () => {
                const e = null === i ? r : function(e, t) {
                    if ("function" === typeof t)
                        return t(e);
                    return (0,
                    rt.A)({}, e, t)
                }(i, r);
                return null != e && (e[oH] = null !== i),
                e
            }
            ), [r, i]);
            return (0,
            mt.jsx)(rH.Provider, {
                value: o,
                children: n
            })
        };
        var sH = __webpack_require__(6171);
        const lH = {};
        function cH(e, n, r) {
            let i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            return t.useMemo(( () => {
                const t = e && n[e] || n;
                if ("function" === typeof r) {
                    const o = r(t)
                      , a = e ? (0,
                    rt.A)({}, n, {
                        [e]: o
                    }) : o;
                    return i ? () => a : a
                }
                return e ? (0,
                rt.A)({}, n, {
                    [e]: r
                }) : (0,
                rt.A)({}, n, r)
            }
            ), [e, n, r, i])
        }
        const uH = function(e) {
            const {children: t, theme: n, themeId: r} = e
              , i = ht(lH)
              , o = iH() || lH
              , a = cH(r, i, n)
              , s = cH(r, o, n, !0)
              , l = "rtl" === a.direction;
            return (0,
            mt.jsx)(aH, {
                theme: s,
                children: (0,
                mt.jsx)(dt.T.Provider, {
                    value: a,
                    children: (0,
                    mt.jsx)(IL, {
                        value: l,
                        children: (0,
                        mt.jsx)(sH.A, {
                            value: null == a ? void 0 : a.components,
                            children: t
                        })
                    })
                })
            })
        }
          , dH = ["theme"];
        function hH(e) {
            let {theme: t} = e
              , n = (0,
            it.A)(e, dH);
            const r = t[bt.A];
            return (0,
            mt.jsx)(uH, (0,
            rt.A)({}, n, {
                themeId: r ? bt.A : void 0,
                theme: r || t
            }))
        }
        const pH = Boolean("localhost" === window.location.hostname || "[::1]" === window.location.hostname || window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));
        function fH(e, t) {
            navigator.serviceWorker.register(e).then((e => {
                e.onupdatefound = () => {
                    const n = e.installing;
                    null != n && (n.onstatechange = () => {
                        "installed" === n.state && (navigator.serviceWorker.controller ? (console.log("New content is available and will be used when all tabs for this page are closed. See https://cra.link/PWA."),
                        t && t.onUpdate && t.onUpdate(e)) : (console.log("Content is cached for offline use."),
                        t && t.onSuccess && t.onSuccess(e)))
                    }
                    )
                }
            }
            )).catch((e => {
                console.error("Error during service worker registration:", e)
            }
            ))
        }
        const mH = (0,
        yt.A)({
            palette: {
                secondary: {
                    light: "#ff7961",
                    main: "#C73131",
                    dark: "#ba000d",
                    contrastText: "#000"
                }
            }
        });
        n.createRoot(document.getElementById("root")).render((0,
        mt.jsx)(hH, {
            theme: mH,
            children: (0,
            mt.jsx)(x, {
                store: nt,
                children: (0,
                mt.jsx)(uG, {})
            })
        })),
        nH(),
        function(e) {
            if (console.log("register service worker", e),
            "serviceWorker"in navigator) {
                if (new URL("",window.location.href).origin !== window.location.origin)
                    return;
                window.addEventListener("load", ( () => {
                    const t = "/service-worker.js";
                    pH ? (!function(e, t) {
                        fetch(e, {
                            headers: {
                                "Service-Worker": "script"
                            }
                        }).then((n => {
                            const r = n.headers.get("content-type");
                            404 === n.status || null != r && -1 === r.indexOf("javascript") ? navigator.serviceWorker.ready.then((e => {
                                e.unregister().then(( () => {
                                    window.location.reload()
                                }
                                ))
                            }
                            )) : fH(e, t)
                        }
                        )).catch(( () => {
                            console.log("No internet connection found. App is running in offline mode.")
                        }
                        ))
                    }(t, e),
                    navigator.serviceWorker.ready.then(( () => {
                        console.log("This web app is being served cache-first by a service worker. To learn more, visit https://cra.link/PWA")
                    }
                    ))) : fH(t, e)
                }
                ))
            }
        }()
    }
    )()
}
)();
